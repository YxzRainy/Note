---
title: C 冒泡排序
date: 2022-04-17 6:00:00
updated: 2022-04-17 6:00:00
categories:
        - 编程语言
tags:
        - C
        - 算法
        - 学习笔记

---

# 冒泡排序

冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢"浮"到数列的顶端。

## 步骤

比较相邻的元素。如果第一个比第二个大，就交换它们两个。

对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，会产生一个最大或者最小的数（这取决于你是升序还是降序）。升序是产生最小的数，降序是产生最大的数。

## C 代码实现

```C
# include <stdio.h>
// 定义冒泡排序函数，将数组中的元素按从小到大的顺序排列
// 形参是数组中第一个元素的地址和数组的长度
// 以 sort(a,6); 来举例
void sort(int * a, int len){
    int i,j,t;
    // 定义总共需要几次循环才能对数组中每个元素都进行比较
    // 首次循环 ：i = 5，所以想要将这个数组进行排序，总共需要进行 5 次比较。
    for (i = 0; i < len-1;i ++){
        // 每一次整体比较结束后，需要进行比较的元素就要少一个，
        // 因为每一次比较后，都会产生一个最小的元素，而这个最小的元素，将不再参加后续的比较，
        // 因此，每次整体比较后，都会少一个元素参加后续的比较
        // 当 i = 0 时：数组中会进行 5 次依次比较
        // 当 i = 1 时：数组中会进行 4 次依次比较
        // 当 i = 2 时：数组中会进行 3 次依次比较
        // 当 i = 3 时：数组中会进行 2 次依次比较
        // 当 i = 4 时：数组中会进行 1 次依次比较
        for(j = 0;j < len - 1- i;j++){
            // 开始进行元素的交换，> 表示升序，< 表示降序
            // 如果数组中第一个元素（a[0]）大于第二个元素（a[1]）
            // 注意，此时是第一个元素在前，第二个元素在后
            // 每次依次比较后，j 都会 + 1，也就是最小的元素将不再参与比较
            if (a[j] > a[j+1]){
                // 将较大的元素赋给 t
                t = a[j];
                // 将较小的元素赋给 a[0]，
                // 也就是互换它们的位置，将较小的元素放到较大的元素的前面
                a[j] = a [j+1];
                // 在将 t（a[0]）,也就是较大的元素放到较小的元素的后面，
                // 最终，成功交换这两个元素的位置。
                a[j + 1] = t;
            }
        }
    }
}
int main(void)
{
    int a[] = {10,2,8,-8,11,0};

    // // 将数组中第一个元素的地址和数组长度作为实参
    sort(a,6);
    // 输出最终的冒泡排序的结果
    for(int i = 0; i < 6;i++){
        printf("%d ",a[i]);
    }
    printf("\n");
}

```

## JAVA 代码实现

```JAVA
public static void main(String[] args) {
        //定义数组
        int[] arr = {6, 4, 8, 2, 9};
        System.out.println("排序前：");
        //打印排序前的数组元素
        printArray(arr);
        //数组排序的方法
        bubbleSort(arr);
        System.out.println("排序后：");
        //打印排序后的数组元素
        printArray(arr);
    }
    //定义打印数组中所有元素的方法
    public static void printArray(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            //返回当前数组中所有的元素
            System.out.print(arr[i] + "");
        }
        System.out.println("\n");
        // 返回后换行
    }
    //定义冒泡排序的方法
    public static void bubbleSort(int[] arr) {
        //  arr.length - 1，即 5 - 1 = 4，
        // 这里的循环控制的是总共进行 n 轮排序，这里只进行四轮排序
        // 为什么只进行四轮，因为通过推算，进行 4 轮排序后就可以得出最终结果。
        for (int i = 0; i < arr.length - 1; i++) {
            /*
            第一轮排序开始，外层变量 i = 0，再 5 - 0 - 1 = 4，意味着要从左往右对调 4 次。
            6 4 8 2 9
            6 4        第 1 次对调,j = 0
              8 4      第 2 次对调,j = 1
                4 2    第 3 次对调,j = 2
                  9 2  第 4 次对调,j = 3
            6 8 4 9 2, 第一轮对调完毕,对调了四次。
            此时的 j = 4,不满足循环条件,循环结束,退出循环,开始进行第 2 轮排序.

            第二轮排序开始,外层变量 i = 1，再 5 - 1 - 1 = 3 意味着要从左往右对调 3 次。
            将 j 重新赋值为 0 (j 原为 4),开始内层循环,这次依旧是循环四次
            6 8 4 9 2
            8 6        对调 1 次，j = 0
              6 4      对调 2 次，j = 1
                9 4    对调 3 此，j = 2
                    2  剩下的数 2 已经确定了
            8 6 9 4 2,第二轮对调完毕,此时的 j = 4,不满足循环条件,循环结束,退出循环,开始进行第 2 轮排序。

            第三轮排序开始，外层变量 i = 2，再 5 - 2 - 1 = 2，意味着要从左往右对调 2 次。
            8 6 9 4 2
            8 6 对调 1 次
              9 6 对调 2 次
                  4 2，剩下的数 4、2 已经确定了
            8 9 6 4 2，第三轮对调完毕,只对调了两次

            第四轮排序开始，外层变量 i = 3，再 5 - 3 - 1 = 1，意味着要从左往右对调 1 次。
            8 9 6 4 2
            9 8，对调 1 次
                6 4 2 剩下的数 6、4、2 已经确定了。
            9 8 6 4 2，第四轮对调完毕，只对调了一次。
            */

            for (int j = 0; j < arr.length - i - 1; j++) {
                //两个数比较，如果前者小于后者，则元素从大到小进行排序，
                // 反之前者大于后者，则元素从小到大进行排序
                if (arr[j] > arr[j + 1]) {
                    //定义一个临时变量 temp，用于后面对调数组中两个数的位置
                    // 将前者赋给 temp
                    int temp = arr[j];
                    //将后者赋给前者
                    arr[j] = arr[j + 1];
                    //再将临时变量(前者)赋给后者,最终实现了前者与后者的位置互换,此时的 temp 的值是前者.
                    arr[j + 1] = temp;
                }
            }
            //外层循环每执行完毕一次，代表着一轮的排序结束，用于计算排序进行了多少次
            System.out.print("第" + (i + 1) + "轮排序后:");
            //返回最总的排序结果
            printArray(arr);
        }
    }
```

