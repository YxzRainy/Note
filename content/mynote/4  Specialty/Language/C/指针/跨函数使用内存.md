---
title: C 跨函数使用内存
date: 2022-04-13 6:00:00
updated: 2022-04-13 6:00:00
categories:
        - 编程语言
tags:
        - C
        - 指针
        - 学习笔记
---

# 跨函数使用变量

## 静态内存不能跨函数使用

当静态函数终止之后，这个静态函数中的数据就不能被其他函数访问，因为这个静态函数的内存空间已经被释放了。就算可以使用，也是非法访问，这样是不对的。

```c
#include <iostream>
#include <malloc.h>
// q 是指针变量，无论 q 是什么类型的指针变量，都只占 4 个字节
// 将实参 *p 传入 fun 函数的形参，则**q = *p, 则*q = p，q 存放的是 p 的地址，
void fun(int **q){
    int i = 5;
    // ** q =  i
    // *q = p
    //q = p 的地址
    // **q = *p
    // 因为 *q = p，所以这里相当于 p = &1，
    *q = &i;
}
int main(void)
{
  int *p;
  // 取 p（*p） 的地址，传入函数 fun，实际传入的是 *p，则 **q = *p
  fun(&p);
  // 下面代码语法没问题，但是逻辑上有问题。
  // 这是因为当 fun 函数执行完毕后，fun 函数中的 i 变量已经被释放，
  // 因此，p 虽然可以存放 i 的地址， 但是却不能访问 i 。
  // 就算能够访问 i ，这也是非法的访问，没 error 是因为编译器的问题。
  printf("%d\n",*p);
}
```

## 动态内存可以跨函数使用

因为当一个函数执行完毕，动态内存分配的变量不会随着`fun()`的自动释放而释放，所以，当`fun()`被系统自动释放后，我们依旧可以访问变量`*p`

```c
#include <iostream>
#include <malloc.h>
// **q = *p 的地址
// *q = p
// q = p 的地址
void fun(int **q)
{
    // * q 变量的空间是动态分配的
    // 因为 *q = p，则 p = (int *)malloc(sizeof(int));
    // 所以 *p 的内存是动态分配的
    *q = (int *)malloc(sizeof(int));
    // 因为 **q = *p 的地址，则*p = 5，
    // 所以这里是将 5 放入动态分配的 * p 中
    **q = 5;
}

int main(void)
{
    int *p;
    fun(&p);
    // 返回 *p，这次不会造成非法访问，这是因为 *p 的内存是动态分配的
    // 动态分配的内存不会被系统自动释放，所以就算 f 函数被系统自动释放了，
    // 但我们依旧可以访问 *p （动态变量）中的数据，
    // 这个动态变量只能由我们使用free() 函数来手动释放
    printf("%d\n",*p);
}

```

