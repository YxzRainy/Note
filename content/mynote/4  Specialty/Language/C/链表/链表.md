---
title: C 链表
date: 2022-04-18 6:00:00
updated: 2022-04-18 6:00:00
categories:
        - 编程语言
tags:
        - C
        - 链表
        - 学习笔记
---

# 链表

链表主要是便于管理长度或数量不确定的数据，相对于数组，链表处理这种数据时比较节省内存。

链表靠节点的指针域中存放的指针地址来寻找下一个元素。

确定一个链表，只需要知道头指针即可。

## 优点

存取数据效率高。

不需要一个太大的内存。

## 缺点 

查找某个位置的元素时，效率很低。

## 节点

链表由一个个的节点所组成，每个节点左侧是数据域，右侧是指针域，数据域用来存放当前节点的有效数据，指针域用来存放下一个节点的指针地址。

链表中一个个的元素，被称之为节点，每个节点都有数据域和指针域。

## 首节点

链表中存放第一个有效数据的节点。

## 尾节点

链表中存放最后一个有效数据的节点，尾节的指针域为 Null。

## 头结点

头结点的数据类型和首节点的类型一模一样。

头结点是首节点前面的那个节点。

头结点的数据域并不存放任何有效数据，但头结点的指针域存放的是首节点的地址。

设置头结点的目的是为了方便对链表的操作。

## 头指针

用于存放头结点地址。

## 链表实例

```C
# include <stdio.h>
# include <malloc.h>
# include <stdlib.h>

// 定义一个链表
struct Node
{
    // 定义链表中节点的数据域
    int data;
    // 定义链表中节点的指针域。
    // 指针域是一个 struct Node *类型的 pNext，其中 pNext 中存放的是 struct Node 变量的地址
    struct Node * pNext;
};

// 函数声明
struct Node * CreateList(void);
void TraverseList(struct Node *);

int main(void)
{
    // 定义头指针pHead，用来存放链表头结点的地址
    struct Node *pHead = NULL;
    // 调用 CreateList() 函数来创建一个链表 ，
    // 然后因为 CreateList() reture 了该链表的头指针，
    // 所以最终会将这个链表的头指针（头结点的地址）保存到 pHead 中。
    // 此行无法运行，因为未定义 CreateList() 函数
    pHead = CreateList();
    // 遍历链表中的节点
    // 此行无法运行，因为未定义 TraverseList() 函数
    TraverseList(pHead);
    return 0;
}

struct Node *CreateList(void)
{
    // 用于存放有效节点的个数
    int len;
    //
    int i;
    // 用于临时存放用户输入的节点的值
    int val;
    // 动态分配了一个不存放有效数据的头结点
    struct Node * pHead = (struct Node * )malloc(sizeof(struct Node));
    if(NULL == pHead)
    {
        printf("分配失败，程序终止！\n");
        exit(-1);
    }
    struct Node * pTail = pHead;
    pTail->pNext = NULL;

    printf("请输入需要生成的链表节点的个数：");
    scanf("%d",&len);

    for(i = 0; i<len; i++)
    {
        printf("请输入地%d个节点的值：",i+1);
        scanf("%d",&val);

        struct Node *pNew = (struct Node *)malloc(sizeof(struct Node));
        if(NULL == pNew)
        {
            printf("分配失败，程序终止！\n");
            exit(-1);
        }
        pNew ->data = val;
        pTail ->pNext = pNew;
        pNew ->pNext = NULL;
        pTail = pNew;
    }
    return pHead;
};

bool empty_list (struct Node * pHead)
{
    if(pHead ->pNext == NULL)
    {
        return true;
    }
    else
    {
        return false;
    }
}

void TraverseList(struct Node * pHead)
{
    if (empty_list(pHead))
    {
        printf("链表为空！\n");
    }
    else
    {
        struct Node * p = pHead->pNext;
        while(NULL != p)
        {
            printf("链表中有：%d\n",p ->data);
            p = p ->pNext;
        }

    }
    return;
}

```

