---
title: JavaScript 作用域
date: 2021-10-21 6:00:00
updated: 2021-10-23 22:29:00
categories:
        - 编程技术
tags:
        - 学习笔记
        - JavaScript
---

# 作用域

作用域（scope）定义了代码在运行时的某些特定的变量、函数、对象的可调用范围。

每个函数都会创建 scope（作用域对象），scope 中储存是一个个的全局作用域与局部作用域），即 scope 中存储的是作用域的集合（作用域链）。

### 父函数不能调用子函数的变量

当调用一个变量时，调用者会去作用域链（scope）的顶端依次向下寻找这个变量；又因为子函数的 AO 中含有父函数 AO 的引用地址，所以子函数可以调用父函数的变量；反之，因为父函数的 AO 不能含有子函数 AO 的引用，所以父函数不能调用子函数的变量。

### 作用域都是独立的

声明多个同级函数时，这些函数的作用域链都是独立的，即每个同级函数中的局部变量不可以公用，但它们都可以使用全局中的变量；这些作用域链会随着对应函数的执行完毕而依次释放。

## 全局作用域

在全局作用域（GO 对象）中的变量为全局变量，全局变量的的作用域为整个脚本，这类变量在脚本中的任何地方（包括函数内部）能被调用。

它们通常指在全局中定义的变量或没有使用 var 声明的暗示全局变量。

### 这些变量都在全局作用域中：

- 函数外声明的变量。
- 函数中没有使用 var 声明的变量。

## 局部作用域

局部作用域（AO 对象）中的变量为局部变量，局部变量的作用域仅限于某个特定的函数，这类变量可以在特定的函数中调用。

每个函数内部都会创建一个局部作用域，当一个函数（父函数）中包含另一个函数（子函数），则父函数不能调用子函数的变量，但子函数可以调用父函数的变量；并且两个独立且同级的函数中的局部变量不能公用，只能各用各的局部变量。

### 这些变量都在局部作用域中：

- 它们通常指在函数中定义的变量或函数的形式参数。
- 函数中使用 var 声明的变量。
- 函数中的形式参数。

### 累加器

```JavaScript
function One() {
	var b = 0;
	function Two() {
		b++;
		console.log(b);
	}
	a = Two;
	// 变量 a 是一个暗示全局变量，用变量 a 接收函数 Two
}
One();
//调用函数 One，使暗示全局变量 a 可以执行
a();
// 执行变量 a，相当于执行函数 Two，每执行一次变量 a，就会使 b 在原来的的结果上自增一次。
a();
a();
```

### 作用域链

```JavaScript
function One() {
	// 声明函数 One 时，系统会隐式创建 One.[[scope]]，这是一个隐式的属性，我们并不能调用。
	b = 20;
	// 全局变量 b。
	var a = 30;
	// 变量 a，它是局部变量，函数中局部变量优先于全局变量。
	Two();
	// 调用函数 One，返回 70。
	console.log(c);
	// 返回 30 。
	console.log(typeof d);
	// 变量 d 为函数 Two 中的局部变量，通常情况，在全局中调用该变量会报错，
	// 但使用 typeof 操作符则不会报错，并且还会返回 undefined。
	function Two() {
		var e = 50;
		console.log(b + e);
		// 返回全局变量 b 与局部变量 e 的和 70。
		c = '30';
		// 全局变量 c。
		var d = 40;
		// 局部变量 d。
	}
	Two();
	// 在次调用函数 Two
}
One();

// 声明函数 One------创建函数 One 的scope------在 scope 的作用域链里第零位创建一个 GO，
// 也就是全局的环境栈
// 0：GO
// 执行函数 One------将函数 One 创建的 AO 放在作用域链的第零位，
// 全局创建的 GO 移动到了作用域链的第一位，
// 这是函数 One 的环境栈
// 0：One 的 AO
// 1：GO
// 声明函数 Two------创建函数 Two 的 scope------ 它可以使用函数 One 的环境栈
// 0：One 的 AO
// 1：GO
// 执行函数 One------创建函数 Two 的 scope------将函数 Two 创建的 AO 放在作用域链的第零位，
// 并将函数 One 的 AO 移动到作用域链的第一位，再将全局的 GO 移动到作用域链的第二位，
// 这是函数 Two 的环境栈
// 0：Two 的 AO
// 1：One 的 AO
// 2：GO
// 函数 Two 执行完毕后------销毁函数 Two 创建的 AO，并再次调用函数 Two，
// 0：new Two 的 AO（原函数 Two 已被销毁，这是一个新的函数 Two 的 new Two ）
// 1：One 的 AO
// 2：GO
// 新的函数 Two 执行完毕后------销毁新的函数 Two 创建的 new AO，
// 函数 One 执行完毕后------销毁函数 One 创建的 AO
// 全局执行完后------销毁全局创建的 GO

```
