---
title: Webpack 优化代码性能 
date: 2022-06-15
categories:
        - 编程技术
tags:
        - NodeJs
        - 打包工具
---

# 优化代码性能

## Code Split

代码分割（Code Split）主要做了两件事：

1. 分割文件：将打包生成的文件进行分割，生成多个 js 文件。
2. 按需加载：需要哪个文件就加载哪个文件。

### 为什么使用

打包代码时会将所有 js 文件打包到一个文件中，体积太大了。我们如果只要渲染首页，就应该只加载首页的 js 文件，其他文件不应该加载。

所以我们需要将打包生成的文件进行代码分割，生成多个 js 文件，渲染哪个页面就只加载某个 js 文件，这样加载的资源就少，速度就更快。

### 多入口文件使用

定义多个入口文件 **main.js**、**app.js**、**main.js**

配置 **webpack.prod.js**

```js
// webpack.prod.js
const path = require('path');
const os = require('os');

const ESLintWebpackPlugin = require('eslint-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');
const threads = os.cpus().length;
const getStyleLoaders = (preProcessor) => {
	return [
		MiniCssExtractPlugin.loader,
		'css-loader',
		{
			loader: 'postcss-loader',
			options: {
				postcssOptions: {
					plugins: [
						'postcss-preset-env', 
					],
				},
			},
		},
		preProcessor,
	].filter(Boolean);
};
module.exports = {
	// 单文件入口
	// entry: './src/main.js',
	// 多文件入口
	entry: {
		main: './src/main.js',
		app: './src/app.js',
	},
	output: {
		path: path.resolve(__dirname, '../dist'),
		// [name]是 webpack 命名规则，使用 chunk 的 name 作为输出的文件名。
		// 什么是 chunk？打包的资源就是 chunk，输出出去叫 bundle。
		// chunk 的 name 是啥呢？ 比如： entry 中xxx: "./src/xxx.js", name 就是 xxx。注意是前面的 xxx，和文件名无关。
		// 为什么需要这样命名呢？如果还是之前写法 main.js，那么打包生成两个js文件都会叫做 main.js 会发生覆盖。(实际上会直接报错的)
		filename: 'js/[name].js',
		clean: true,
	},
	module: {
		rules: [
			{
				test: /\.css$/i,
				use: getStyleLoaders(),
			},
			{
				test: /\.less$/i,
				use: getStyleLoaders('less-loader'),
			},
			{
				test: /\.(png|jpe?g|gif|webp)$/,
				type: 'asset',
			},
			{
				test: /\.txt|jpeg|png|gif/,
				type: 'asset',
				parser: {
					dataUrlCondition: {
						maxSize: 10 * 1024,
					},
				},
				generator: {
					filename: 'static/images/[hash:5][ext][query]',
				},
			},
			{
				test: /\.(ttf|woff2?|mp4)$/,
				type: 'asset/resource',
				generator: {
					filename: 'static/media/[hash:8][ext][query]',
				},
			},
			{
				test: /\.m?js$/,
				exclude: /(node_modules|bower_components)/,

				use: [
					{
						loader: 'thread-loader', 
						options: {
							workers: threads, 
						},
					},
					{
						loader: 'babel-loader',
						options: {
						
							cacheDirectory: true,
							
							cacheCompression: false,
							plugins: ['@babel/plugin-transform-runtime'], 
						},
					},
				],
			},
		],
	},
	plugins: [
		new ESLintWebpackPlugin({
			context: path.resolve(__dirname, '../src'),
			cache: true,
			cacheLocation: path.resolve(__dirname, '../node_modules/.cache/.eslintcache'),
			threads,
		}),
		new HtmlWebpackPlugin({
			template: path.resolve(__dirname, '../public/index.html'),
		}),
		new MiniCssExtractPlugin({
			filename: 'static/css/main.css',
		}),
		new CssMinimizerPlugin(),
	],

	mode: 'production',
	devtool: 'source-map',
};

```

### 提取代码复用

将多个文件中重复的部分代码提取到单独的一个文件中。

配置 **webpack.prod.js**

```js
optimization: {
		// 代码分割配置
		splitChunks: {
			chunks: 'all', // 对所有模块都进行分割
			// 以下是默认值
			// minSize: 20000, // 分割代码最小的大小
			// minRemainingSize: 0, // 类似于minSize，最后确保提取的文件大小不能为0
			// minChunks: 1, // 至少被引用的次数，满足条件才会代码分割
			// maxAsyncRequests: 30, // 按需加载时并行加载的文件的最大数量
			// maxInitialRequests: 30, // 入口js文件最大并行请求数量
			// enforceSizeThreshold: 50000, // 超过50kb一定会单独打包（此时会忽略minRemainingSize、maxAsyncRequests、maxInitialRequests）
			// cacheGroups: { // 组，哪些模块要打包到一个组
			//   defaultVendors: { // 组名
			//     test: /[\\/]node_modules[\\/]/, // 需要打包到一起的模块
			//     priority: -10, // 权重（越大越高）
			//     reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块
			//   },
			//   default: { // 其他没有写的配置会使用上面的默认值
			//     minChunks: 2, // 这里的minChunks权重更大
			//     priority: -20,
			//     reuseExistingChunk: true,
			//   },
			// },
			// 修改配置
			cacheGroups: {
				// 组，哪些模块要打包到一个组
				// defaultVendors: { // 组名
				//   test: /[\\/]node_modules[\\/]/, // 需要打包到一起的模块
				//   priority: -10, // 权重（越大越高）
				//   reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块
				// },
				default: {
					// 其他没有写的配置会使用上面的默认值
					minSize: 0, // 我们定义的文件体积太小了，所以要改打包的最小文件体积
					minChunks: 2,
					priority: -20,
					reuseExistingChunk: true,
				},
			},
		},
	},
```

### 动态 import，按需加载

动态导入，实现按需加载，即使只被引用了一次，也会代码分割

```js
let btn = document.getElementById('btn');

btn.onclick = function () {
	import('./js/test')
		.then((result) => {
			console.log('模块加载成功', result.default(9, 5));
		})
		.catch((err) => {
			console.log('模块加载失败', err);
		});
};
```

此时，test.js 只会当 btn 被点击的时候加载。

### 单页面入口使用

```js
// 单入口
entry: "./src/main.js",
// 代码分割配置
  splitChunks: {
      // 对所有模块都进行分割
    chunks: "all", 
    // 其他内容用默认配置即可
},
```

### 自定义动态导入的模块名

**动态导入的模块的配置**

```js
btn.onclick = function () {
	// webpackChunkName: "math"：这是 webpack 动态导入模块命名的方式
	// "math"将来就会作为 chunkFilename 中的 [name] 的值显示
	import(/* webpackChunkName: "math" */ './js/test')
		.then((result) => {
			console.log('模块加载成功', result.default(9, 5));
		})
		.catch((err) => {
			console.log('模块加载失败', err);
		});
};

```

配置 **webpack.config.js**

```js
output: {
    // 动态导入的模块的输出资源命名
    chunkFilename: 'static/js/[name].[contenthash:8].chunk.js',
     // 图片、字体等资源命名方式（注意用 hash）
     assetModuleFilename: "static/media/[name].[hash][ext]", 
},
```



## Preload / Prefetch

使浏览器在空闲的时间，加载后续需要使用的资源。

### 为什么用

我们前面已经做了代码分割，同时会使用 import 动态导入语法来进行代码按需加载（我们也叫懒加载，比如路由懒加载就是这样实现的）。

但是加载速度还不够好，比如：是用户点击按钮时才加载这个资源的，如果资源体积很大，那么用户会感觉到明显卡顿效果。

`Preload`：告诉浏览器立即加载资源（优先级较高，兼容性较好）。

`Prefetch`：告诉浏览器在空闲时才开始加载资源（优先级较低，兼容性较差）。

**共同点**

都只会加载资源，但并不会执行，且都有缓存。

**区别**

`Preload`只能加载当前页面需要使用的资源，`Prefetch`可以加载当前页面资源，也可以加载下一个页面需要使用的资源。

**分别在什么情况下使用**

当前页面优先级高的资源用 `Preload` 加载。

下一个页面需要使用的资源用 `Prefetch` 加载。

### 基本使用

**安装模块**

```js
npm i @vue/preload-webpack-plugin -D
```

配置 **webpack.config.js**

```js
const PreloadWebpackPlugin = require("@vue/preload-webpack-plugin");

plugins: [
		new PreloadWebpackPlugin({
			rel: 'preload',
			as: 'script',
			// rel: 'prefetch'
		}),
]

```

## Network Cache

将文件名变为一个唯一的 hash 值，确保更新前后文件名不一样，这样就可以做缓存了。

#### fullhash

webpack 4 是 hash，每次修改任何一个文件，所有文件名的 hash 至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效。

#### chunkhash

根据不同的入口文件（Entry）—— 进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。我们 js 和 css 是同一个引入，会共享一个 hash 值。

#### contenthash

根据文件内容生成 hash 值，只有文件内容变化了，hash 值才会变化。所有文件 hash 值是独享且不同的。

### 为什么用

将来开发时我们对静态资源会使用缓存来优化，这样浏览器第二次请求资源就能读取缓存了，速度很快。

但是这样的话就会有一个问题, 因为前后输出的文件名是一样的，都叫 main.js，一旦将来发布新版本，因为文件名没有变化导致浏览器会直接读取缓存，不会加载新资源，项目也就没法更新了。本使用

配置 **webpack.config.js**

```js
output: {
    filename: 'static/js/[name].[contenthash:8].js',
},

plugins: [
    // 使 css 生成的文件名带有 hash 值
	new MiniCssExtractPlugin({
		// 定义输出文件名和目录
		filename: 'static/css/[name].[contenthash:8].css',
		chunkFilename: 'static/css/[name].[contenthash:8].chunk.css',
	}),
];

```

**build 后间接导致 main.js 文件名被改变的问题**

1. 当我们修改 math.js 文件再重新打包的时候，因为 contenthash 原因，math.js 文件 hash 值会发生变化（这是正常的）。
2. 但是 main.js 文件的 hash 值也发生了变化，这会导致 main.js 的缓存失效。明明我们只修改 math.js, 为什么 main.js 也会变身变化呢？

**产生的原因**

- 更新前：math.js 打包后实际为 **math.xxx.js,** main.js 引用的也是 **math.xxx.js**。
- 更新后：math.js 打包后变成了 **math.yyy.js** main.js 引用的也变成了 **math.yyy.js**，即每次打包 math.js 后所生成的文件名都不一样，间接导致了 main.js 也发生了变化

**解决**

将 hash 值单独保管在一个 runtime 文件中。

我们最终输出三个文件：main、math、runtime。当 math 文件发送变化，变化的是 math 和 runtime 文件，main 不变。

**runtime 文件只保存文件的 hash 值和它们与文件关系，整个文件体积就比较小，所以变化重新请求的代价也小。**
