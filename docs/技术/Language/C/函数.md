---
title: C 函数
date: 2022-02-23
categories:
        - Note
tags:
        - C
        - 函数
---

# 函数

每个 C 程序都至少有一个函数，即主函数 **main()** ，主函数被操作系统调用

函数就是功能，用函数可以实现模块化设计。

```c
#include <iostream>

// void 表示这个 max 函数没有返回值（但可以有 reture，但不能 reture 表达式）
void max(int i,int j)
{
    if(i > j)
    {
        printf("%d\n",i);
    }
    else
    {
        printf("%d\n",j);
    }
}

// int 表示 main 函数返回一个整型的值
// 程序从 main 函数进入 void 表示该函数不能接收参数。
int main(void)
{
    int a = 1;
    int b = 5;
    max(a,b);
}

```

## 优点

- 避免了重复性的操作。
- 有利于程序的模块化。

## 特点

能够接受参数，（但也可以不接收）

能够对接收的参数进行处理

有返回值（但也可以没有返回值）

## 函数的返回值以函数名前面的关键字为准

```c
// 函数名 fun 前面的 int 是该函数的类型，也是该函数返回值的类型
// 就算该函数 return 其他类型的值（比如 char 类型的 A），、
// 但最终这个 char A 也会以 int 类型返回（int 类型的 65，因为 A 的 ASCII 码是65）。
int fun(void)
{
    // 该函数最终的返回值不是 char A ，而是一个整形的 65
    return 'A';
}
int main(void)
{
    int c;
    c = fun();
    printf("%d\n",c);
}
```

## return 

reture 是用来终止函数的，如果有 **reture 表达式**，还会返回这个表达式的值；如果 **return 空**，则不会返回某个值，只终止被调函数。

## 函数的分类

- 有参函数和无参函数
- 有返回值和无返回值
- 库函数和用户自定义函数
- 值传递函数和地址传递函数
- 普通函数和主函数（main）

一个程序必须且只能有一个主函数
主函数可以调用普通函数，但普通函数不能调用主函数，普通函数可以相互调用
主函数是程序的入口，也是程序的出口

## 函数的调用和定义

### 函数声明

如果先调用函数，后定义函数，则必须在调用该函数之前，加一个该函数的**函数声明**。

1. main() 函数前声明（外部声明）
2. main() 内声明，但要在函数调用前。

作用是告诉编译器即将出现一个这样的函数，将函数名、类型、以及形参类型、个数、顺序通知编译系统，以便在调用时系统按此进行对照检查。防止程序在函数未定义之前使用了函数而导致程序报错

函数声明的形参名可省略或不与函数声明时的形参名一样，而只写形参的类型，以及确保参数个数与函数定义时相同。

对库函数的声明是通过**# include <库 函数所在的文件的名字. h>**来实现的

```c
#include <iostream>
void fun(void);// 如果不在main 函数之前声明函数 fun，那么当在main 中调用 fun 时，会 error

int main(void){
    fun();
    return 0;
}

void fun(void){
    printf("哈哈哈哈\n");
}

```

### 函数调用的过程

1. 定义函数时指定的形参，在未出现函数调用时，并不占用存储单元，在函数被调用时，形参才被分配存储单元。
2. 将实参值传给对于形参
3. 执行函数体。
4. 通过 return 将函数值返回到**主调函数**
5. 函数调用结束，形参存储单元被释放，而实参单元仍保留并维持原值。

### 函数嵌套调用

函数无法嵌套定义，但可以嵌套调用。需注意在调用函数前进行函数声明。

## 形参和实参

C 语言中，实参值传给形参，是值传递

- 值传递的特点是单向传递，即主调函数调用时给形参分配存储单元，把实参的值传递给形参，在调用结束后，形参的存储单元被释放，而形参值的任何变化都不会影响到实参的值，实参的存储单元仍保留并维持数值不变

定义函数时指定的函数类型应该与该函数 return 语句中的表达式类型一致即，函数类型决定函数返回值的类型

## 递归

函数自身调用自身

**递归的基本思想就是把规模大的问题转化为规模小的相似的子问题来解决**

### 递归三要素

- 明确递归终止条件；
- 给出递归终止时的处理办法；
- 提取重复的逻辑，缩小问题规模。

单从算法设计上看，递归和循环并无优劣之别。然而，在实际开发中，因为函数调用的开销，递归常常会带来性能问题，特别是在求解规模不确定的情况下；而循环因为没有函数调用开销，所以效率会比递归高。递归求解方式和循环求解方式往往可以互换，也就是说，如果用到递归的地方可以很方便使用循环替换，而不影响程序的阅读，那么替换成循环往往是好的。

## 数组作函数参数

数组元素不能做形参，只能作实参，作实参时，传递的是元素的值。

一维数组名可以作形参和实参，作实参时，传递的是数组首元素的地址。

当将一个数组定义当作形参时，此时指定这个数组的长度是没有作用的，但需要跟一个 `[]`，因为编译系统并不会检查形参数组大小。

多维数组和一维数组一样，不同的是可以省略一维数组的大小指定。

## 全局变量和局部变量

### 局部变量

函数内部定义的变量，只在当前函数中有效，主函数中的变量也是局部变量。函数可以使用本函数的局部变量，也可使用全局中的全局变量。

复合语句 `{}` 内定义的变量，只在当前变量所在的 `{}` 内有效；若是复合语句嵌套，则先在子层复合语句寻找变量，若字层没有知道该变量的定义，则到父层复合语句中寻找变量，

函数的形参，只在当前函数中有效。

在子层可以访问父层的变量，但在父层无法访问子层的变量

### 全局变量

函数外定义的变量，即主函数外部定义到变量，与 # include 同级。

C 语言中，全局变量首字母通常大写。

## 静态和动态变量

### 静态变量

静态变量在全局数据区（静态数据区）中分配。不存储在堆内存，也不存储在栈内存中。它由程序自动分配，也由程序自动释放。在函数运行的过程中，无法被使用者手动释放，必须等函数执行完毕。

### 动态变量

动态变量是存储在栈或堆中的变量，它们在运行时根据需要分配和释放内存，因此它们的生命周期是不确定的。由使用者手动分配，也由使用者手动释放。在函数的运行的过程中，可以被使用者手动释放，不需要等待函数执行完毕。

1. 函数形参
2. 函数中没用 static 声明的变量（自动变量）
3. 函数调用时的现场保护和返回地址

## 跨函数使用变量

### 静态内存不能跨函数使用

当静态函数终止之后，这个静态函数中的数据就不能被其他函数访问，因为这个静态函数的内存空间已经被释放了。就算可以使用，也是非法访问，这样是不对的。

```c
#include <iostream>
#include <malloc.h>
// q 是指针变量，无论 q 是什么类型的指针变量，都只占 4 个字节
// 将实参 *p 传入 fun 函数的形参，则**q = *p, 则*q = p，q 存放的是 p 的地址，
void fun(int **q){
    int i = 5;
    // ** q =  i
    // *q = p
    //q = p 的地址
    // **q = *p
    // 因为 *q = p，所以这里相当于 p = &1，
    *q = &i;
}
int main(void)
{
  int *p;
  // 取 p（*p） 的地址，传入函数 fun，实际传入的是 *p，则 **q = *p
  fun(&p);
  // 下面代码语法没问题，但是逻辑上有问题。
  // 这是因为当 fun 函数执行完毕后，fun 函数中的 i 变量已经被释放，
  // 因此，p 虽然可以存放 i 的地址， 但是却不能访问 i 。
  // 就算能够访问 i ，这也是非法的访问，没 error 是因为编译器的问题。
  printf("%d\n",*p);
}
```

### 动态内存可以跨函数使用

因为当一个函数执行完毕，动态内存分配的变量不会随着`fun()`的自动释放而释放，所以，当`fun()`被系统自动释放后，我们依旧可以访问变量`*p`

```c
#include <iostream>
#include <malloc.h>
// **q = *p 的地址
// *q = p
// q = p 的地址
void fun(int **q)
{
    // * q 变量的空间是动态分配的
    // 因为 *q = p，则 p = (int *)malloc(sizeof(int));
    // 所以 *p 的内存是动态分配的
    *q = (int *)malloc(sizeof(int));
    // 因为 **q = *p 的地址，则*p = 5，
    // 所以这里是将 5 放入动态分配的 * p 中
    **q = 5;
}

int main(void)
{
    int *p;
    fun(&p);
    // 返回 *p，这次不会造成非法访问，这是因为 *p 的内存是动态分配的
    // 动态分配的内存不会被系统自动释放，所以就算 f 函数被系统自动释放了，
    // 但我们依旧可以访问 *p （动态变量）中的数据，
    // 这个动态变量只能由我们使用free() 函数来手动释放
    printf("%d\n",*p);
}

```

## 局部存储类别

### 自动 auto

动态局部变量，存储在动态存储区，调用结束后就会释放存储单元。其中 auto 关键字可省略，若不指定存储类别，则默认为 auto 类型。

### 静态 static

静态局部变量，存储在静态存储区，使变量调用结束后不消失而继续保留原值，即继续占用存储单元不释放。

若静态局部变量不赋初值，则系统自动赋初值 0

需保留上一次调用结束后该变量的值时，则使用静态变量。

### 寄存器 register

寄存器变量 ，将局部变量存放在**寄存器**中的变量，不必存储到内存中。由于寄存器的存取速度远高于内存的存取速度，因此这样做可以提高代码的执行效率

## 全局存储类别

### 一个文件内的外部变量作用域

外部变量通常的作用域是从定义点到文件结束处。在变量定义之前是无法引用该变量对，**如果需要在定义前引用该变量，则需要用 extern 对该变量进行声明**，可将该外部变量的作用域扩展到此为止。

尽量将外部变量放在引用它的所有函数前，这样可以避免使用 extern。

### 将外部变量作用域扩展到其他文件

若两个不同文件需要用同一个外部变量 public，则需在任何一个文件中定义外部变量 public，而在另一个文件中用 extern 对 public 作外部变量声明。**在编译链接时，系统会将 public 的作用域扩展到当前具有 extern public 的文件中**。

事实上，系统在编译时遇到 extern 时，会先在本文件中找外部变量的定义，若找到，则只扩展到本文件，若找不到，则在连接时从其他文件中找外部变量的定义。

例如，若有五个源文件模块，若在一个文件红定义到了外部变量 A ，若其他 4 个文件想引用这个 A ，则需要在这 4 个文件中都加上一个 extern A 的声明。

### 将外部变量的作用域限制在本文件中

限制外部变量只能在当前文件中被引用，可在定义外部变量时，加一个 `static`。

## 内部和外部函数

内部函数，用 static 定义的函数，它只能被当前文件中的其他函数所调用。

外部函数，用 extern 定义的函数叫外部函数，在需要调用此函数的其他文件中，对此函数作 extern 声明，表示将此函数可供其他文件调用。

**利用 extern，可以在当前文件中调用或引用其他文件以及定义好的函数或变量。**

在当前文件中调用其他文件中的函数，还有一种方法是将其他文件用 #include 包含进来。
