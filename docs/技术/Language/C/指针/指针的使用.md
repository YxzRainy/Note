---
title: C 指针的使用
date: 2022-03-24
categories:
        - Note
tags:
        - C
        - 指针
---

# 指针的使用

## 数组指针

```c
int (*p)[5]
```

一维数组的名字是一个**指针常量**，它存放的是数组一个元素的地址。而指针是一个指针变量。

因此，形参可以用数组名，也可以用指针变量名

### 下标和指针的关系

**如果 p 是一个数组指针，则 p[n] 永远等价于 \*（p + n）或 * (a + n)**，其中 a 是数组名，p 是指向数组元素的指针变量，其 `p = a`，前者是后者的简写。

```c
void DeterminesArray(int *arr, int lenght)
{
    for(int i = 0; i < lenght; i++)
    {
        printf("%d\n",*(arr + i));
        // *(arr + i) 等价于 arr[i]
        printf("%d\n",arr[i]);
    }
}
```

### 数组指针的下一个元素

可以通过改变指针元素来指向不同的数组元素，比如 `p++`。

```c
#include <stdio.h>

int main() {
	int arr[3] = { 2,3,5 };
	int* p = &arr;
	printf("%d\n", &p[0]);
	// 指针变量 + 1，不是单纯的 + 1 而是基于上一个数组元素的地址字节数 + 4
	printf("%d\n", ++p);

	return 0;
}

```

注意，若在上述代码中引用 `arr[3]`，虽然数组 arr 中不存在这个元素，但系统会将其按 *`(arr + 3)` 来处理，返回一个内存地址。

### 数组名作参数

当给一个函数定义了一个数组形参时，系统会将其当作一个指针变量来处理。

若 `arrary[]` 是实参，`arr` 是形参，则 `arr` 就指向 `arrary[0]`，`arr+1` 就是 `arrary[1]`

且 `arrary[0]` 等于 `*(arr+1)`。

## 多维数组指针

### 多维数组的元素的指针地址

二维数组 `arr[3][4]` 的首元素不是一个简单的整型元素，而是右若干个整型元素所组成的一维数组，因此，现在的首元素代表的是首行下标为 0 的元素，**则 `arr + 1` 应该是第二行下标为 0 的元素，而非首行中下标为 1 的元素。**

二维数组`arr[0][1] `的值应该用 `*arr[0] + 1` 或 `arr[0] + 1`来表示，即 `*(arr[i]+j)` 或 `* (*(arr + i) +j)` 都是  `arr[i][j]` 的值。

若二维数组 `arr[3][4]` 的首行地址为 2000，则 a + 1 的值应该是 2016，因为第 0 行有 4 个整型数据 则 $4 * 4 = 16、2000 + 16 = 2016$，即 a + 1 指向 a[1]，即 `&a[1][0]`。

## 字符指针

通过数组名和下标引用字符串，因为字符串也是数组，因此字符数组可以用指针引用。

### 字符指针作函数参数

若想将一个字符串从一个函数传递到另一个函数，**则可以用字符数组名作参数，也可以用字符指针变量做参数。**

### 字符数组和字符指针的区别

1. 字符数组由若干个元素组成，每个元素存储一个字符；而数组指针存储的是地址（字符串第一个字符的地址）
2. 可对字符指针赋值，但不能对字符数组赋值。
3. 编译时，字符数组会被分配若干存储单元，用于存放各元素的值；而字符指针则只分配一个存储单元，用于存放字符串首字符的地址。
4. 指针变量可改变，字符数组名是固定的值，无法被改变。
5. 字符数组中的元素可以被重新赋值，而字符指针所指向的**字符串常量无法被重新赋值**。
6. **若指针变量没有指向字符串常量**，则无法用下标法或地址法引用数组中的元素。
7. 指针变量还可以**替代格式字符串**，如 `printf()`。

## 函数指针

函数都有一个入口地址，而函数名代代表着函数的入口地址，因此我们可以用一个指针变量来指向该入口地址，冉海来调用这个函数。

定义一个函数指针变量，其中 `*p` 必须用圆括号括起来。

```c
int(*p)(int,int)
```

### 用指针变量调用函数

除了通过函数名，还可用函数指针变量来调用该函数。

1. 指针变量并不能指向任意函数，只能指向在定义时指定类型的函数。
2. 指针调用函数前，必须先用指针变量指向该函数 `p =max`
3. 用指针变量调用函数时，以 ***指针变量(形参)** 的形式将函数值赋给一个变量即可。
4. 函数指针变量，无法进行运算，因为无意义。
5. 函数名调用函数，只能调用所指定的函数，而函数指针变量则可以根据不同情况先后调用不同的函数

### 函数指针作函数参数

将一个函数的入口地址作为参数传递给其他动函数。

将函数的入口地址传递给形参，这样就能在被调用函数中使用实参函数。

### 作用

可以实现数据的双向传递，即被调函数可以通过形参指针修改主调函数中实参指针指向的数据。
可以传递一组数据，只需要传递数组或结构体的首地址，而不需要拷贝整个数据。
可以提高运行效率，因为传递指针只需要传递4字节的地址，而不需要拷贝大量的数据。
可以实现回调函数，即将一个函数的地址作为参数传递给另一个函数，让另一个函数在特定条件下调用该函数。

## 返回指针值的函数

return 一个指针型的数据，即地址。

```c
int * a(int x,int y);
```

注意和函数指针变量区分

```c
int(* p)(int,int)
```

## 指针数组

一个数组的元素都是指针型数据的数组。

```c
int *p[4];
```

数组中的每一个指针变量都指向一个整型变量。

指针数组比较适合用来指向若干个字符串，使字符串处理起来更加灵活，也就无需使用二维数组。

### 多级指针

其实就是指针的指针`int**`，或指针的指针的指针`int***`。

```c
#include <iostream>
#include <malloc.h>

int main()
{
    // i 存放的是 int 类型
    int i = 10;
    // p 存放 i 的地址，且这个地址只能是 int 类型的地址，因为 p 是 int 类型的指针变量。
    int * p = &i;
    // q 存放 p 的地址，且这个地址只能是 int * 类型的地址，不能存放 int 类型的地址，因为 q 是 int* 类型的指针变量。
    int ** q = &p;
    // r 存放 q 的地址,且这个地址只能int**的地址，不能存放 int * 类型的地址，因为 r 是 int **类型的指针变量。
    int *** r = &q;
    printf("%d",***r);
}


```

```c
#include <iostream>
#include <malloc.h>
void f(int **q)
{
    // *q = p
}
int main()
{
    int i = 10;
    // p 是 int * 类型，&p 是 int ** 类型。
    int * p = &i;
    f(&p);
}
```

### 指针数组作 main 函数的形参

指针数组的一个重要作用就是作 main 函数的形参

main 函数的形参

1. 第一个形参必须是 int 型，用于接收形参的个数。
2. 第二个参数必须是字符指针数组，用于接收从操作系统命令行传来的字符串中第一个首字符的地址。

因为 main 函数由操作系统调用，因此 main 函数的形参由**操作系统的命令行**传递。

## 动态内存分配

动态分配是一种在程序执行的过程中根据需要动态地分配或者回收存储空间的方法。

可以使程序更灵活地使用内存，不需要提前确定数组或结构的大小，也可以创建和销毁对象。

一般是通过调用动态内存分配函数（如 malloc、calloc、new 等）在堆中申请内存空间，并返回所分配的空间地址。程序可以通过指针或引用来访问和操作这些内存空间。

需要手动管理内存，使用完毕后要调用相应的函数（如 free、delete等）来释放内存，否则会造成内存泄漏或其他问题。

### malloc(size)

动态分配一个长度为 size 的连续空间，其类型是无符号整型。

该函数是一个指针函数，返回的指针（地址）指向所分配区域的第一个字节，若该函数未成功执行，则返回一个空指针。

### calloc(n,size)

动态分配 n 个长度 为 size 的连续空间，这个空间一般足够存储一个数组。

一般用该函数为一个一维数组开辟动态存储空间，也就是动态数组。

### realloc(*p,size)

将 p 所指向的动态存储空间的大小修改为 size。重新分配不成功，返回 NULL

### free( *p)

释放 *p 所指向的动态空间。使这些空间能被其他变量使用。无返回值

### 传统数组的缺点

传统数组也叫静态数组，也属于静态内存

1. 数组长度必须事先指定，且只能是长整数，不能是变量。

2. 传统形式定义的数组，该数组的内存无法被我们手动释放。因为系统为该数组分配的储存空间就会一直存在，除非数组所在的函数运行完毕，数组的空间才会被系统释放。

   ```C
   #include <stdio.h>
   void fun(void){
       // 这 20 个字节（4 个 int ）的储存空间无法被我们手动的释放，
       // 只能在本函数（fun 函数）运行完毕后由系统自动释放
       int a[5] = {1,2,3,4,5};
   }
   int main ()
   {
   
   }
   ```

3. 数组的长度一旦定义，其长度就不能再被更改。也就是数组的长度不能在函数运行的过程中动态的扩充或缩小。

4. Ａ 函数中定义的数组，在 Ａ 函数运行期间可以被其他函数使用，但 A 函数运行完毕之后，A 函数中的数组将无法在被其他函数使用（A 函数在运行完毕后，就会被系统释放）。

### 动态数组

是一种在声明时没有确定数组大小的数组，它可以根据程序的需要动态地分配和释放内存空间。

C语言提供了一些内存管理函数，如 malloc, calloc, realloc 和 free，来帮助我们构建和操作动态数组。

动态数组的优点是可以灵活地调整数组的长度，节省内存资源，提高程序的效率。

动态数组的缺点是需要手动申请和释放内存空间，否则可能会导致内存泄漏或数据丢失

动态数组的构建方法有两种：一种是使用 C99 标准提供的变长数组，另一种是使用内存管理函数和指针。

```c
#include <iostream>
#include <malloc.h>

int main()
{
    int a = 5; // a 是一个 int 变量，它是静态分配的
    int * p = (int *)malloc(4); // 动态分配
    *p = 5;// *p 也是一个 int 变量，但它是动态分配的
    free(p); // 手动释放动态分配的内存
    printf("%d\n",*p);
    printf("%d\n",p);
}
```

1. 使用 malloc 函数，需要添加头文件 malloc.h
2. malloc 函数只有一个形参，并且形参是整型。
3. `malloc(4)`表示请求系统为我们分配 4 个字节
4. malloc 函数只能返回第一个字节的地址，**即 p 只保存了第一个字节的整型地址**
5. `int *` 是为了让系统知道我们分配这个 4 个字节的地址是整型地址。
6. `int * p = (int *)malloc(4)`这行代码总共分配了 8 个字节，`int * p`分配了 4 个字节，`(int *)malloc(4)`分配了 84 个字节一共 8 个字节。
7. p（`int * p`）本身所占的内存是静态分配的，但 p 所指向的内存`(int *)malloc(4)`是动态分配的。
8. `free(p)`表示**将 p 所指向的内存给释放掉**，使得 p 指向的内存无法被读写。但是，p 本身的内存是静态的，不能被我们用`free()`函数手动释放，p 本身的内存只能在 p 变量所在的函数运行结束后，被系统自动释放。
9. `*p = 5`和`int a = 5`的区别在于前者的内存分配方式是动态分配的，后者的内存分配方式是静态分配的。
10. `*p = 5` 中，其中`*p`指的是用`(int *)malloc(4)`动态分配了 4 个字节的内存空间，而`*p = 5`，则是将 5 这个 int 数值放入这动态分配的 4 个字节的内存中。而 p 则只保存了其中第 1 个字节的地址。

## void* 型指针

它不指向任何类型的数据。

任何类型的指针都可以转为 void *，void * 也可以接受任何类型的指针。

对于某些通用型接口，你不知道用户的数据类型是什么，但是你必须能够处理用户的各种类型数据，因而会使用void。void 能包容地接受各种类型的指针。也就是说，如果你期望接口能够接受任何类型的参数，你可以使用 void 类型的指针。但是在具体使用的时候，你必须转换为具体的指针类型。例如，你传入接口的是 int \*，那么你在使用的时候就应该按照 int* 使用。

## 通过被调函数修改主调函数普通变量的值

函数的实参必须为该普通变量的地址。

形参必须是指针变量。

在被调函数中，通过**\*形参名 = n**的方式，就可以修改主调函数中，对应变量的值。因为此时的\*\*\*形参名\*\*的等同于主调函数中的普通变量

## 确定一个一维数组需要哪些参数

当一个函数要处理一个或多个一维数组时，我们需要接收该数组的那些信息。也就是如何让一个函数知道我们将要处理的是一个数组，而不是其他数据类型。

1. **数组首个元素的地址**

2. **数组的长度**

      ```c
      #include <stdio.h>
      
      void DeterminesArray(int *arr, int lenght)
      {
          for(int i = 0; i < lenght; i++)
          {
              printf("%d",*(arr + i));
              printf("\n");
          }
      }
      int main ()
      {
          int a[5] = {1,20,300,4000,50000};
          // a[3] ，因为数组名 a 是第一个元素的地址，
          // 所以a[3] 的意思是从数组第一个元素的地址开始 + 1，
          // 第二个元素就是*（a + 1），地址 + 4（因为 int 类型占 4 个字节）
          // 第三个元素是*（a + 2）
          printf("数组 a 中第一个元素的地址：%d\n",a);
          // a + 1，这个 1 在内存中占了四个字节，所以地址会向后数 4 个字节，
          // 最后的才会返回数组中第二个元素的地址
          printf("数组 a 中第二个元素的地址：%d\n",a + 1);
          printf("数组 a 中第三个元素的地址：%d\n",a + 2);
          printf("数组 a 中第四个元素的地址：%d\n",a + 3);
          printf("数组 a 中第五个元素的地址：%d\n",a + 4);
          printf("数组 a 中第三个元素是：%d\n",a[3]);
          printf("for 循环输出数组：\n");
          DeterminesArray(a,5);
      }
      
      ```

## 指针实例

### 互换两个数字

```C
#include <stdio.h>
//*p = 1 *q = 5
void interchange(int * p,int * q)
{
//  将 t 作为两个值的互换媒介。
    int t;
//  t = 1
    t = *p;
//  *p = 5
    *p = *q;
//  *q = 1
    *q = t;
}
// 因为 *p 和 *q 分别指向于 a 和 b，所以，修改 *p 和 *q，就相当于修改 a 和 b，
// 尽管 *p 和 *q 在函数指向完毕后已经被释放，但程序依旧通过 *p 和 *q，分别修改了 a 和b。
// 而 p 和 q，两者和 a 、b，并不一样，因为 p、q 中，存放的是指向 a、b 的地址。
// 由此可得出一个结论，函数的形参和实参， 永远不是一个
int main ()
{
    int a = 1;
    int b = 5;
//  取 a、b 的地址
    interchange(&a,&b);
    printf("a = %d,b = %d",a,b);
}
```
