<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git 管理修改 | Rainy · Note</title><meta name=keywords content="Git,Github,Note"><meta name=description content="管理修改 你也许很疑惑为什么 Git 比其他版本控制系统设计得优秀，那是因为 Git 跟踪并管理的是修改，而非文件。
第二次修改为什么没有被提交 现在假设我我们对一个文件 ReadMe.txt 进行了以下操作：
修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本
git add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3.0 版本
git commit ReadMe.txt 接着你会发现被提交的版本为什么不是ReadMe.txt 3.0？
这是因为 Git 管理的是修改，而非文件，因此，当你使用git add命令将 2.0 版本放入暂存区后，准备提交，但是，之后得到的版本 3.0 并没有被放入暂存区，所以，最后的git commit只负责把暂存区的修改提交了。
 也就是将 2.0 版本提交了，因为版本 2.0 被添加到了暂存区 但版本 3.0 却并没有被提交，因为版本 3.0 没有被添加到暂存区  如何提交第二次修改 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了。
修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本
git add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3."><meta name=author content="Me"><link rel=canonical href=https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E7%AE%A1%E7%90%86%E4%BF%AE%E6%94%B9/><link crossorigin=anonymous href=/assets/css/stylesheet.min.edd18a27851ae8379d90ba603c54f14188c8c2035d0b8b598c33130c14f2b4db.css integrity="sha256-7dGKJ4Ua6DedkLpgPFTxQYjIwgNdC4tZjDMTDBTytNs=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://gallery.yxzi.xyz/galleries/2022/06/12/Note.ico><link rel=icon type=image/png sizes=16x16 href=https://note.yxzi.xyz/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://note.yxzi.xyz/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://note.yxzi.xyz/apple-touch-icon.png><link rel=mask-icon href=https://note.yxzi.xyz/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Git 管理修改"><meta property="og:description" content="管理修改 你也许很疑惑为什么 Git 比其他版本控制系统设计得优秀，那是因为 Git 跟踪并管理的是修改，而非文件。
第二次修改为什么没有被提交 现在假设我我们对一个文件 ReadMe.txt 进行了以下操作：
修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本
git add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3.0 版本
git commit ReadMe.txt 接着你会发现被提交的版本为什么不是ReadMe.txt 3.0？
这是因为 Git 管理的是修改，而非文件，因此，当你使用git add命令将 2.0 版本放入暂存区后，准备提交，但是，之后得到的版本 3.0 并没有被放入暂存区，所以，最后的git commit只负责把暂存区的修改提交了。
 也就是将 2.0 版本提交了，因为版本 2.0 被添加到了暂存区 但版本 3.0 却并没有被提交，因为版本 3.0 没有被添加到暂存区  如何提交第二次修改 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了。
修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本
git add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3."><meta property="og:type" content="article"><meta property="og:url" content="https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E7%AE%A1%E7%90%86%E4%BF%AE%E6%94%B9/"><meta property="og:image" content="https://note.yxzi.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="note"><meta property="article:published_time" content="2021-10-21T00:00:00+00:00"><meta property="article:modified_time" content="2021-10-21T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://note.yxzi.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Git 管理修改"><meta name=twitter:description content="管理修改 你也许很疑惑为什么 Git 比其他版本控制系统设计得优秀，那是因为 Git 跟踪并管理的是修改，而非文件。
第二次修改为什么没有被提交 现在假设我我们对一个文件 ReadMe.txt 进行了以下操作：
修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本
git add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3.0 版本
git commit ReadMe.txt 接着你会发现被提交的版本为什么不是ReadMe.txt 3.0？
这是因为 Git 管理的是修改，而非文件，因此，当你使用git add命令将 2.0 版本放入暂存区后，准备提交，但是，之后得到的版本 3.0 并没有被放入暂存区，所以，最后的git commit只负责把暂存区的修改提交了。
 也就是将 2.0 版本提交了，因为版本 2.0 被添加到了暂存区 但版本 3.0 却并没有被提交，因为版本 3.0 没有被添加到暂存区  如何提交第二次修改 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了。
修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本
git add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Notes","item":"https://note.yxzi.xyz/note/"},{"@type":"ListItem","position":3,"name":"Git 管理修改","item":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E7%AE%A1%E7%90%86%E4%BF%AE%E6%94%B9/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git 管理修改","name":"Git 管理修改","description":"管理修改 你也许很疑惑为什么 Git 比其他版本控制系统设计得优秀，那是因为 Git 跟踪并管理的是修改，而非文件。\n第二次修改为什么没有被提交 现在假设我我们对一个文件 ReadMe.txt 进行了以下操作：\n修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本\ngit add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3.0 版本\ngit commit ReadMe.txt 接着你会发现被提交的版本为什么不是ReadMe.txt 3.0？\n这是因为 Git 管理的是修改，而非文件，因此，当你使用git add命令将 2.0 版本放入暂存区后，准备提交，但是，之后得到的版本 3.0 并没有被放入暂存区，所以，最后的git commit只负责把暂存区的修改提交了。\n 也就是将 2.0 版本提交了，因为版本 2.0 被添加到了暂存区 但版本 3.0 却并没有被提交，因为版本 3.0 没有被添加到暂存区  如何提交第二次修改 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了。\n修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本\ngit add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3.","keywords":["Git","Github","Note"],"articleBody":"管理修改 你也许很疑惑为什么 Git 比其他版本控制系统设计得优秀，那是因为 Git 跟踪并管理的是修改，而非文件。\n第二次修改为什么没有被提交 现在假设我我们对一个文件 ReadMe.txt 进行了以下操作：\n修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本\ngit add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3.0 版本\ngit commit ReadMe.txt 接着你会发现被提交的版本为什么不是ReadMe.txt 3.0？\n这是因为 Git 管理的是修改，而非文件，因此，当你使用git add命令将 2.0 版本放入暂存区后，准备提交，但是，之后得到的版本 3.0 并没有被放入暂存区，所以，最后的git commit只负责把暂存区的修改提交了。\n 也就是将 2.0 版本提交了，因为版本 2.0 被添加到了暂存区 但版本 3.0 却并没有被提交，因为版本 3.0 没有被添加到暂存区  如何提交第二次修改 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了。\n修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本\ngit add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3.0 版本\ngit add ReadMe.txt\rgit commit ReadMe.txt ","wordCount":"76","inLanguage":"en","datePublished":"2021-10-21T00:00:00Z","dateModified":"2021-10-21T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E7%AE%A1%E7%90%86%E4%BF%AE%E6%94%B9/"},"publisher":{"@type":"Organization","name":"Rainy · Note","logo":{"@type":"ImageObject","url":"https://gallery.yxzi.xyz/galleries/2022/06/12/Note.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://note.yxzi.xyz accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://note.yxzi.xyz/categories/ title=Category><span>Category</span></a></li><li><a href=https://note.yxzi.xyz/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://note.yxzi.xyz/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://note.yxzi.xyz/tags/ title=Tag><span>Tag</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Git 管理修改</h1><div class=post-meta><span title="2021-10-21 00:00:00 +0000 UTC">October 21 2021</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#第二次修改为什么没有被提交>第二次修改为什么没有被提交</a></li><li><a href=#如何提交第二次修改>如何提交第二次修改</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=管理修改>管理修改<a hidden class=anchor aria-hidden=true href=#管理修改>#</a></h1><p>你也许很疑惑为什么 Git 比其他版本控制系统设计得优秀，那是因为 <strong>Git 跟踪并管理的是修改，而非文件</strong>。</p><h3 id=第二次修改为什么没有被提交>第二次修改为什么没有被提交<a hidden class=anchor aria-hidden=true href=#第二次修改为什么没有被提交>#</a></h3><p>现在假设我我们对一个文件 ReadMe.txt 进行了以下操作：</p><p>修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>git add ReadMe.txt
</span></span></code></pre></div><p>修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3.0 版本</p><pre tabindex=0><code>git commit ReadMe.txt
</code></pre><p>接着你会发现被提交的版本为什么不是<strong>ReadMe.txt 3.0</strong>？</p><p>这是因为 Git 管理的是修改，而非文件，因此，当你使用<code>git add</code>命令将 2.0 版本放入暂存区后，准备提交，但是，之后得到的版本 3.0 并没有被放入暂存区，所以，最后的<code>git commit</code>只负责把暂存区的修改提交了。</p><ul><li>也就是将 2.0 版本提交了，因为版本 2.0 被添加到了暂存区</li><li>但版本 3.0 却并没有被提交，因为版本 3.0 没有被添加到暂存区</li></ul><h3 id=如何提交第二次修改>如何提交第二次修改<a hidden class=anchor aria-hidden=true href=#如何提交第二次修改>#</a></h3><p>那怎么提交第二次修改呢？你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了。</p><p>修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本</p><pre tabindex=0><code>git add ReadMe.txt
</code></pre><p>修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3.0 版本</p><pre tabindex=0><code>git add ReadMe.txt
git commit ReadMe.txt
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://note.yxzi.xyz/tags/git/>Git</a></li><li><a href=https://note.yxzi.xyz/tags/github/>Github</a></li><li><a href=https://note.yxzi.xyz/tags/note/>Note</a></li></ul><nav class=paginav><a class=prev href=https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/><span class=title>« Prev</span><br><span>Git 版本回退</span></a>
<a class=next href=https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%85%8D%E7%BD%AE%E5%88%AB%E5%90%8D/><span class=title>Next »</span><br><span>Git 配置别名</span></a></nav></footer></article></main><footer class=footer><div id=Record><a class="RecordNumber TransitionOne" href=https://beian.miit.gov.cn/ target=_blank>黔ICP备2021007565号</a>
<a class="PublicSecurityRecord TransitionOne" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=52010202002678" target=_blank>贵公网安备 52010202002678号</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="copy";function s(){e.innerHTML="copied!",setTimeout(()=>{e.innerHTML="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>