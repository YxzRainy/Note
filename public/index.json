[{"content":"递推 从初值出发反复进行某一运算得到所需的结果。\n从已知到未知，从小到大（比如每年长高 9cm，20则长高年 180 cm，30年后则长高 270 cm）\nfunction Recursion(n) { \tlet start = 0; \tlet fn = 1; \tfor (let i = 0; i \u0026lt; n; i++) { \tlet t = fn; \tconsole.log(t); \tfn = fn + start; \tstart = t; \t} \treturn fn; }  console.log(Recursion(5)); ","permalink":"https://yxzi.xyz/blog/technology/datastructure/algorithm/%E9%80%92%E6%8E%A8/","summary":"递推 从初值出发反复进行某一运算得到所需的结果。\n从已知到未知，从小到大（比如每年长高 9cm，20则长高年 180 cm，30年后则长高 270 cm）\nfunction Recursion(n) { \tlet start = 0; \tlet fn = 1; \tfor (let i = 0; i \u0026lt; n; i++) { \tlet t = fn; \tconsole.log(t); \tfn = fn + start; \tstart = t; \t} \treturn fn; }  console.log(Recursion(5)); ","title":"递推"},{"content":"App Recommend 推荐一些 PC 端好用的软件。\nAdvanced Renamer 批量重命名工具。\nPhotoshop 处理图片。\nAudition 剪辑音频。\nPremiere 剪辑视频。\nAfter Effects 制作视频特效。\nGit 管理项目的版本。\nNodejs Javascript 的运行环境，能够使得 javascript 脱离浏览器运行。\nPython Python 的运行环境。\nVsCode 全能代码编辑器。\n360 Zip 简洁无广告的解压工具。\nEverything 快速的文件搜索工具。\nOulu 好用的词典。\nTypora markdown 编辑器。\nPotPlayer 功能强大的视频解码器。\nXiaoYaoEmulator Android 模拟器。\nVMware 虚拟机。安装完成后会弹出一个对话框让你输入密钥\n密钥 ZF3R0-FHED2-M80TY-8QYGC-NPKYF\nYF390-0HF8P-M81RQ-2DXQE-M2UT6\nZF71R-DMX85-08DQY-8YMNC-PPHV8\nIntelliJ IDEA Java\nPyCharm Python\nCodeBlock 免费的 C/C++ 和 Fortran IDE\nWin SCP 服务器文件管理器\nXshell 服务器终端，登录 Linux 虚拟服务器\nNotepad++ 轻量、快速的文本编辑器\nNavicat Premium 链接数据库\nBaidu Translate 快速的翻译软件\nXmind 画思维导图。\n","permalink":"https://yxzi.xyz/blog/essay/app-recommend/","summary":"App Recommend 推荐一些 PC 端好用的软件。\nAdvanced Renamer 批量重命名工具。\nPhotoshop 处理图片。\nAudition 剪辑音频。\nPremiere 剪辑视频。\nAfter Effects 制作视频特效。\nGit 管理项目的版本。\nNodejs Javascript 的运行环境，能够使得 javascript 脱离浏览器运行。\nPython Python 的运行环境。\nVsCode 全能代码编辑器。\n360 Zip 简洁无广告的解压工具。\nEverything 快速的文件搜索工具。\nOulu 好用的词典。\nTypora markdown 编辑器。\nPotPlayer 功能强大的视频解码器。\nXiaoYaoEmulator Android 模拟器。\nVMware 虚拟机。安装完成后会弹出一个对话框让你输入密钥\n密钥 ZF3R0-FHED2-M80TY-8QYGC-NPKYF\nYF390-0HF8P-M81RQ-2DXQE-M2UT6\nZF71R-DMX85-08DQY-8YMNC-PPHV8\nIntelliJ IDEA Java\nPyCharm Python\nCodeBlock 免费的 C/C++ 和 Fortran IDE\nWin SCP 服务器文件管理器\nXshell 服务器终端，登录 Linux 虚拟服务器\nNotepad++ 轻量、快速的文本编辑器","title":"App Recommend"},{"content":"笔记和博客的区别 笔记 笔记是给自己看的，是自己知识的沉积，更是自己思考的结果。\n笔记是工具，而非目的，不应该追求美观完善，而是要简洁、清晰、成体系。方便自己查找和复习。\n记笔记时，更不应该局限于某个软件，或局限于某些方式。比如有的人只喜欢用纯文本记笔记。\n从而忽略了其他方式所带来的优势，比如思维导图。\n博客 博客是给其他人看的，是自己知识的升华，更是思想的交汇之所。\n博客说白了就是个人网站、或者个人的网络笔记本，别人也可以去看，但需要别人很主动的去看。\n因此，博客不能写的太随意，要把来龙去脉说清楚，尽可能让别人理解你想表达的东西。毕竟，要把一件事情讲明白，讲道理挺难的。\n对自己来说，博客不适合构建知识体系，因为博客的结构是松散的，不适合快速查找知识。\n但是，博客可以是一个表达自己、展示自己的平台。\n","permalink":"https://yxzi.xyz/blog/essay/%E7%AC%94%E8%AE%B0%E5%92%8C%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"笔记和博客的区别 笔记 笔记是给自己看的，是自己知识的沉积，更是自己思考的结果。\n笔记是工具，而非目的，不应该追求美观完善，而是要简洁、清晰、成体系。方便自己查找和复习。\n记笔记时，更不应该局限于某个软件，或局限于某些方式。比如有的人只喜欢用纯文本记笔记。\n从而忽略了其他方式所带来的优势，比如思维导图。\n博客 博客是给其他人看的，是自己知识的升华，更是思想的交汇之所。\n博客说白了就是个人网站、或者个人的网络笔记本，别人也可以去看，但需要别人很主动的去看。\n因此，博客不能写的太随意，要把来龙去脉说清楚，尽可能让别人理解你想表达的东西。毕竟，要把一件事情讲明白，讲道理挺难的。\n对自己来说，博客不适合构建知识体系，因为博客的结构是松散的，不适合快速查找知识。\n但是，博客可以是一个表达自己、展示自己的平台。","title":"笔记和博客的区别"},{"content":"哈夫曼树 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;queue\u0026gt;using namespace std;  typedef struct node{ \tint data; \tstruct node *lchild, *rchild; } n;  //创建一个节点 node * get_a_node(int data){ \tnode *c = (node *)malloc(sizeof(node)); \tc-\u0026gt;data = data; \tc-\u0026gt;lchild = 0; \tc-\u0026gt;rchild = 0; \treturn c; }   int main(){ \tqueue\u0026lt;node *\u0026gt;q; \t//构建一棵树 \tnode *t = get_a_node(1); \tt-\u0026gt;lchild = get_a_node(2); \tt-\u0026gt;rchild = get_a_node(3); \tt-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5); \tt-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7); \tt-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);  \tq.push(t); \t//在这里测试你所完成的函数 \twhile (q.size() \u0026gt; 0){ \tnode *c = q.front(); \tif(c-\u0026gt;lchild) \tq.push(c-\u0026gt;lchild); \tif(c-\u0026gt;rchild) \tq.push(c-\u0026gt;rchild); \tprintf(\u0026#34;%d \u0026#34;,c-\u0026gt;data); \tq.pop(); \t} } ","permalink":"https://yxzi.xyz/blog/technology/datastructure/algorithm/tree/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/","summary":"哈夫曼树 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;queue\u0026gt;using namespace std;  typedef struct node{ \tint data; \tstruct node *lchild, *rchild; } n;  //创建一个节点 node * get_a_node(int data){ \tnode *c = (node *)malloc(sizeof(node)); \tc-\u0026gt;data = data; \tc-\u0026gt;lchild = 0; \tc-\u0026gt;rchild = 0; \treturn c; }   int main(){ \tqueue\u0026lt;node *\u0026gt;q; \t//构建一棵树 \tnode *t = get_a_node(1); \tt-\u0026gt;lchild = get_a_node(2); \tt-\u0026gt;rchild = get_a_node(3); \tt-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5); \tt-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7); \tt-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);  \tq.","title":"哈夫曼树"},{"content":"二叉树的最大深度 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }  //二叉树的最大深度 int max_depth(node *p) {  int left = 0;  int right = 0;  if (p-\u0026gt;lchild)  {  left = max_depth(p-\u0026gt;lchild);  }  if (p-\u0026gt;rchild)  {  right = max_depth(p-\u0026gt;rchild);  }  if (left \u0026gt; right)  return left + 1;  else  return right + 1; }  int main(void) {  // 构建树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);   // 二叉树的最大深度  int depth = max_depth(t);  printf(\u0026#34;二叉树的深度为：%d\\n\u0026#34;,depth);  return 0; } ","permalink":"https://yxzi.xyz/blog/technology/datastructure/algorithm/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","summary":"二叉树的最大深度 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }  //二叉树的最大深度 int max_depth(node *p) {  int left = 0;  int right = 0;  if (p-\u0026gt;lchild)  {  left = max_depth(p-\u0026gt;lchild);  }  if (p-\u0026gt;rchild)  {  right = max_depth(p-\u0026gt;rchild);  }  if (left \u0026gt; right)  return left + 1;  else  return right + 1; }  int main(void) {  // 构建树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);   // 二叉树的最大深度  int depth = max_depth(t);  printf(\u0026#34;二叉树的深度为：%d\\n\u0026#34;,depth);  return 0; } ","title":"二叉树的最大深度"},{"content":"判断是否为完全二叉树 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct node {  int data;  struct node *lchild, *rchild; } n;  //创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }  /* //5 判断一棵树是否是完全二叉树，如果是返回1，如果否返回0 int is_complete(node *p){ //请完善这里 } */ int main(void) {  //构建一棵树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);   return 0; } ","permalink":"https://yxzi.xyz/blog/technology/datastructure/algorithm/tree/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"判断是否为完全二叉树 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct node {  int data;  struct node *lchild, *rchild; } n;  //创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }  /* //5 判断一棵树是否是完全二叉树，如果是返回1，如果否返回0 int is_complete(node *p){ //请完善这里 } */ int main(void) {  //构建一棵树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);   return 0; } ","title":"判断是否为完全二叉树"},{"content":"判断是否为对称二叉树 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }  bool isSymHeper(node* left,node* right); //3 判断是否是对称的二叉树，如果是返回1，如果否返回0 bool isSym(node* p) {  if(p == NULL)  return true;  return isSymHeper(p-\u0026gt;lchild,p-\u0026gt;rchild); } bool isSymHeper(node* left,node* right) {  if(left == NULL \u0026amp;\u0026amp; right == NULL)  return true;  if(left == NULL || right == NULL || left-\u0026gt;data != right-\u0026gt;data)  return false;  return isSymHeper(left-\u0026gt;lchild,right-\u0026gt;rchild) \u0026amp;\u0026amp; isSymHeper(left-\u0026gt;rchild,right-\u0026gt;lchild); }   int main(void) {  //构建一棵树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);   // 判断是否为对称二叉树  int re = isSym(t);  if(re == 0)  printf(\u0026#34;不对称二叉树：%d\\n\u0026#34;,re);  else  printf(\u0026#34;是对称二叉树：%d\\n\u0026#34;,re);  return 0; } ","permalink":"https://yxzi.xyz/blog/technology/datastructure/algorithm/tree/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"判断是否为对称二叉树 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }  bool isSymHeper(node* left,node* right); //3 判断是否是对称的二叉树，如果是返回1，如果否返回0 bool isSym(node* p) {  if(p == NULL)  return true;  return isSymHeper(p-\u0026gt;lchild,p-\u0026gt;rchild); } bool isSymHeper(node* left,node* right) {  if(left == NULL \u0026amp;\u0026amp; right == NULL)  return true;  if(left == NULL || right == NULL || left-\u0026gt;data !","title":"判断是否为对称二叉树"},{"content":"翻转二叉树 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt;  typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }  //4 翻转二叉树，返回树根 node *node_reverse(node* p) {  if (p == NULL)  return NULL;  node_reverse(p-\u0026gt;lchild);  node_reverse(p-\u0026gt;rchild);  node * t = p-\u0026gt;lchild;  p-\u0026gt;lchild = p-\u0026gt;rchild;  p-\u0026gt;rchild = t;   return p; }  int main(void) {  //构建一棵树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);    // 翻转二叉树  node* newt = node_reverse(t);  printf(\u0026#34;翻转后的二叉树根节点：%d\\n\u0026#34;,newt-\u0026gt;lchild-\u0026gt;lchild-\u0026gt;rchild-\u0026gt;data );    return 0; } ","permalink":"https://yxzi.xyz/blog/technology/datastructure/algorithm/tree/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"翻转二叉树 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt;  typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }  //4 翻转二叉树，返回树根 node *node_reverse(node* p) {  if (p == NULL)  return NULL;  node_reverse(p-\u0026gt;lchild);  node_reverse(p-\u0026gt;rchild);  node * t = p-\u0026gt;lchild;  p-\u0026gt;lchild = p-\u0026gt;rchild;  p-\u0026gt;rchild = t;   return p; }  int main(void) {  //构建一棵树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);    // 翻转二叉树  node* newt = node_reverse(t);  printf(\u0026#34;翻转后的二叉树根节点：%d\\n\u0026#34;,newt-\u0026gt;lchild-\u0026gt;lchild-\u0026gt;rchild-\u0026gt;data );    return 0; } ","title":"翻转二叉树"},{"content":"二叉树的节点数量 递归法  判断根节点是否有左右子节点，有则递归调用NodeNum()，则子节点 + 1。 左右子节点数量加上根节点数量。  ·include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 定义节点 typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }   // *p：根节点 int NodeNum(node *p) {  // 节点总数  int nums;   // 左节点数量  int left = 0;   // 右节点数量  int right = 0;   // 有左节点  if (p-\u0026gt;lchild)  {  // 左节点 + 1  left = NodeNum(p-\u0026gt;lchild);  }  // 有右节点  if (p-\u0026gt;rchild)  {  // 右节点 + 1  right = NodeNum(p-\u0026gt;rchild);  }  // 左右节点数量加上根节点数量  // 这个 + 1 很重要，因为每次调用 NodeNum()，就说明有节点，则 nums + 1。  nums = left + right + 1;  return nums; }   int main(void) {  // 构建二叉树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);   int num = NodeNum(t);  printf(\u0026#34;二叉树的结点个数为：%d\\n\u0026#34;,num);  return 0; } ","permalink":"https://yxzi.xyz/blog/technology/datastructure/algorithm/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E9%87%8F/","summary":"二叉树的节点数量 递归法  判断根节点是否有左右子节点，有则递归调用NodeNum()，则子节点 + 1。 左右子节点数量加上根节点数量。  ·include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 定义节点 typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }   // *p：根节点 int NodeNum(node *p) {  // 节点总数  int nums;   // 左节点数量  int left = 0;   // 右节点数量  int right = 0;   // 有左节点  if (p-\u0026gt;lchild)  {  // 左节点 + 1  left = NodeNum(p-\u0026gt;lchild);  }  // 有右节点  if (p-\u0026gt;rchild)  {  // 右节点 + 1  right = NodeNum(p-\u0026gt;rchild);  }  // 左右节点数量加上根节点数量  // 这个 + 1 很重要，因为每次调用 NodeNum()，就说明有节点，则 nums + 1。  nums = left + right + 1;  return nums; }   int main(void) {  // 构建二叉树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);   int num = NodeNum(t);  printf(\u0026#34;二叉树的结点个数为：%d\\n\u0026#34;,num);  return 0; } ","title":"二叉树的节点数量"},{"content":"数据结构 数据结构是指计算机存储和组织数据的一种的结构。\n将现实中大量而复杂的问题以特定的数据类型和特定的存储结构存储到内存中，以此来实现某个功能（删除、查找、排序）而执行相应的操作，这个相应的操作也叫算法。\n数据结构定义数据将以什么样的形式存储到内存中，而算法定义的是我们如何对内存中的数据结构进行操作。\n程序 = 数据的存储（数据结构） + 数据的操作（算法） + 可以被程序执行的语言（变成语言）\n","permalink":"https://yxzi.xyz/blog/technology/datastructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","summary":"数据结构 数据结构是指计算机存储和组织数据的一种的结构。\n将现实中大量而复杂的问题以特定的数据类型和特定的存储结构存储到内存中，以此来实现某个功能（删除、查找、排序）而执行相应的操作，这个相应的操作也叫算法。\n数据结构定义数据将以什么样的形式存储到内存中，而算法定义的是我们如何对内存中的数据结构进行操作。\n程序 = 数据的存储（数据结构） + 数据的操作（算法） + 可以被程序执行的语言（变成语言）","title":"数据结构"},{"content":"算法 算法是为了解决一个问题而设计的一种操作。\n算法目的就是为了解决问题，它是一系列解题步骤，一个计算过程。因此，我们描述算法，通常可以使用伪代码。\n定义 通俗定义 解题的方法和步骤。\n狭义定义 对存储数据的操作。\n对不同的数据结构，要完成某一个功能所执行的操作是不一样的。\n比如，输出数组所有的元素和输出链表中所有的元素的操作是不一样的。这说明，算法是依附于数据结构，不同的数据结构，所执行的算法是不一样的。\n广义定义 广义的算法也叫泛型。无论数据是如何存储的，对该数据的操作都是一样的。\n我们至少可以通过两种结构来存储数据：\n 数组 链表  衡量算法的标准 时间复杂度 程序执行的大概次数，而非执行时间。\n为什么不是执行呢？\n 这是因为在不同的机器上，同一个程序的执行时间是不同的（机器的性能不一样）。  空间复杂度 算法的执行过程中，大概所占用的最大内存。\n可读性 算法是否容易让人理解。\n健壮性 一个算法对不合理数据输入的反应能力和处理能力，也称为算法容错性。\n","permalink":"https://yxzi.xyz/blog/technology/datastructure/algorithm/%E7%AE%97%E6%B3%95/","summary":"算法 算法是为了解决一个问题而设计的一种操作。\n算法目的就是为了解决问题，它是一系列解题步骤，一个计算过程。因此，我们描述算法，通常可以使用伪代码。\n定义 通俗定义 解题的方法和步骤。\n狭义定义 对存储数据的操作。\n对不同的数据结构，要完成某一个功能所执行的操作是不一样的。\n比如，输出数组所有的元素和输出链表中所有的元素的操作是不一样的。这说明，算法是依附于数据结构，不同的数据结构，所执行的算法是不一样的。\n广义定义 广义的算法也叫泛型。无论数据是如何存储的，对该数据的操作都是一样的。\n我们至少可以通过两种结构来存储数据：\n 数组 链表  衡量算法的标准 时间复杂度 程序执行的大概次数，而非执行时间。\n为什么不是执行呢？\n 这是因为在不同的机器上，同一个程序的执行时间是不同的（机器的性能不一样）。  空间复杂度 算法的执行过程中，大概所占用的最大内存。\n可读性 算法是否容易让人理解。\n健壮性 一个算法对不合理数据输入的反应能力和处理能力，也称为算法容错性。","title":"算法"},{"content":"补码 在计算机中，数值一律用补码来表示和存储。\n补码是现代计算机使用的编码格式，同时解决了原码和反码的瑕疵。\n已知十进制求二进制的补码 求正整数的二进制补码 除 2 取余，直至商为 0，余数倒序即可\n求负整数的二进制补码 先求与该负数的相反数的二进制数，然后将所有位取反，末尾位加 1，不够位数，左侧补 1。\n（-3）—\u0026gt; 011 —\u0026gt; 100 —\u0026gt; 101 — 11111111,11111111,11111111,11111101 — \u0026gt; FFFFFFFD\n求零的二进制补码 全是 0。\n已知二进制补码求十进制 如果二进制补码首位是 0，则表示这个数是正整数。\n直接转十进制即可。\n如果二进制补码首位是 1，则表示这个数是负整数。\n将所有位取反，末位加 1，所得数字就是该负数的绝对值加 1。\n1001010 —\u0026gt; 0110101 —\u0026gt; 0110110 —\u0026gt; 57 —\u0026gt; -54\n如果二进制补码全是零，则表示这个数字是 0。\n原码 原码不能直接参加运算\n首位是 0 表示这个数是正整数，首位是 1 表示这个数是负整数，\n其余二进制位是该数字的绝对值的二进制位。\n（+35）00100011，就是 35 的二进制，不足位补零，0 表示负；\n（-35）10100011，最高位放符号位，1 表示负。\n反码 在计算机中不常用。\n（+35）—\u0026gt; 00100011，和原码补码都相同\n（-35）—\u0026gt; 11011100，+ 35 的原码全部取反即可求出 -35 的反码。或者 35 的补码最低位减去 1 获得。\n移码 移码表示数值平移动 N 位，N 称为 移码量。\n移码主要用于浮点数的阶码的存储。\n（+35）10100011，补码符号位取反\n（-35）01011101，补码符号位取反\n","permalink":"https://yxzi.xyz/blog/technology/computer/%E8%A1%A5%E7%A0%81/","summary":"补码 在计算机中，数值一律用补码来表示和存储。\n补码是现代计算机使用的编码格式，同时解决了原码和反码的瑕疵。\n已知十进制求二进制的补码 求正整数的二进制补码 除 2 取余，直至商为 0，余数倒序即可\n求负整数的二进制补码 先求与该负数的相反数的二进制数，然后将所有位取反，末尾位加 1，不够位数，左侧补 1。\n（-3）—\u0026gt; 011 —\u0026gt; 100 —\u0026gt; 101 — 11111111,11111111,11111111,11111101 — \u0026gt; FFFFFFFD\n求零的二进制补码 全是 0。\n已知二进制补码求十进制 如果二进制补码首位是 0，则表示这个数是正整数。\n直接转十进制即可。\n如果二进制补码首位是 1，则表示这个数是负整数。\n将所有位取反，末位加 1，所得数字就是该负数的绝对值加 1。\n1001010 —\u0026gt; 0110101 —\u0026gt; 0110110 —\u0026gt; 57 —\u0026gt; -54\n如果二进制补码全是零，则表示这个数字是 0。\n原码 原码不能直接参加运算\n首位是 0 表示这个数是正整数，首位是 1 表示这个数是负整数，\n其余二进制位是该数字的绝对值的二进制位。\n（+35）00100011，就是 35 的二进制，不足位补零，0 表示负；\n（-35）10100011，最高位放符号位，1 表示负。\n反码 在计算机中不常用。\n（+35）—\u0026gt; 00100011，和原码补码都相同\n（-35）—\u0026gt; 11011100，+ 35 的原码全部取反即可求出 -35 的反码。或者 35 的补码最低位减去 1 获得。","title":"补码"},{"content":"冒泡排序 流程   比较相邻的两个元素，升序则交换两个数的位置，降序则位置不变。\n  对每一对相邻元素作同样的操作，从开始第一对到结尾的最后一对。直到产生一个最大或者最小的数（这取决于你是升序还是降序）。升序是产生最大的数，降序是产生最小的数。\n  重新开始下一轮遍历，但无需遍历上轮遍历时所产生的最大数。\n  实现升序 # include \u0026lt;stdio.h\u0026gt;  // *arr 数组 // len 数组长度 void BubbleSort(int * arr, int len){   // 整体比较轮数  int i;   // 元素与元素的比较次数  int j;   // 媒介变量，用于交换两个元素的位置  int t;   // 整体比较轮数  // 需要b len-1 轮，每轮整体比较都需要进行元素与元素的比较。  for (i = 0; i \u0026lt; len-1;i ++){   // 元素与元素的比较次数  // 每进行一轮比较，都会在数组末尾产生一个最大元素。  // 下次比较时，这个最大元素将不再参与和其他元素的比较，因此，元素与元素的比较次数为 j \u0026lt; len - 1 - i。  for(j = 0;j \u0026lt; len - 1- i;j++){   // 元素与元素的比较 \t// 从第一个元素 a[j] 与第二个元素 a[j+1] 开始依次比较。  if (arr[j] \u0026gt; arr[j+1]){   // 交换两个元素的位置。  t = arr[j];  arr[j] = arr[j+1];  arr[j + 1] = t;  }  }  } }  int main(void) {  int arr[] = {10,2,8,-8,11,0};  BubbleSort(arr,6);  for(int i = 0; i \u0026lt; 6;i++){  printf(\u0026#34;%d \u0026#34;,arr[i]);  }  printf(\u0026#34;\\n\u0026#34;); ","permalink":"https://yxzi.xyz/blog/technology/datastructure/algorithm/sort/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","summary":"冒泡排序 流程   比较相邻的两个元素，升序则交换两个数的位置，降序则位置不变。\n  对每一对相邻元素作同样的操作，从开始第一对到结尾的最后一对。直到产生一个最大或者最小的数（这取决于你是升序还是降序）。升序是产生最大的数，降序是产生最小的数。\n  重新开始下一轮遍历，但无需遍历上轮遍历时所产生的最大数。\n  实现升序 # include \u0026lt;stdio.h\u0026gt;  // *arr 数组 // len 数组长度 void BubbleSort(int * arr, int len){   // 整体比较轮数  int i;   // 元素与元素的比较次数  int j;   // 媒介变量，用于交换两个元素的位置  int t;   // 整体比较轮数  // 需要b len-1 轮，每轮整体比较都需要进行元素与元素的比较。  for (i = 0; i \u0026lt; len-1;i ++){   // 元素与元素的比较次数  // 每进行一轮比较，都会在数组末尾产生一个最大元素。  // 下次比较时，这个最大元素将不再参与和其他元素的比较，因此，元素与元素的比较次数为 j \u0026lt; len - 1 - i。  for(j = 0;j \u0026lt; len - 1- i;j++){   // 元素与元素的比较 \t// 从第一个元素 a[j] 与第二个元素 a[j+1] 开始依次比较。  if (arr[j] \u0026gt; arr[j+1]){   // 交换两个元素的位置。  t = arr[j];  arr[j] = arr[j+1];  arr[j + 1] = t;  }  }  } }  int main(void) {  int arr[] = {10,2,8,-8,11,0};  BubbleSort(arr,6);  for(int i = 0; i \u0026lt; 6;i++){  printf(\u0026#34;%d \u0026#34;,arr[i]);  }  printf(\u0026#34;\\n\u0026#34;); ","title":"冒泡排序"},{"content":"选择排序 流程  在未排序的元素中找到最小（或最大）元素，将其存放到该数组的起始位置， 跳过已排序数，从剩余未排序的元素中继续寻找最小（或最大）元素，放到已排序数组的末尾。 以此类推，直到所有元素均排序完毕。  实现升序 #include \u0026lt;stdio.h\u0026gt; void SelectionSort(int *arr,int len) {   // 已排序元素的末尾位置  int i;   // 未排序元素的起始位置  int j;   int k;   // 媒介变量，用于交换两个元素的位置  int t;   // 整体比较轮数  // 需要比较 len 轮  for(i = 0; i \u0026lt; len; i++)  {   // 跳过已排序的数  int k = i;   // 忽略已排序的数，直接从未排序的数开始比较，找出未排序数中的最小数  for(j = i; j \u0026lt; len; j++)  {  printf(\u0026#34;%d\\n\u0026#34;,i);  if(arr[j] \u0026lt; arr[k])  {  // 将一对数中较小的数的索引赋给 k  k = j;  }  }   // 将最小的那个数移到数组最前面  t = arr[k];  arr[k] = arr[i];  arr[i] = t;  } }  int main() {  int arr[] = {5,7,1,3,8,12,2,9};  SelectionSort(arr,8);  for(int j = 0; j \u0026lt; 8; j++)  {  printf(\u0026#34;%d \u0026#34;,arr[j]);  } } ","permalink":"https://yxzi.xyz/blog/technology/datastructure/algorithm/sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","summary":"选择排序 流程  在未排序的元素中找到最小（或最大）元素，将其存放到该数组的起始位置， 跳过已排序数，从剩余未排序的元素中继续寻找最小（或最大）元素，放到已排序数组的末尾。 以此类推，直到所有元素均排序完毕。  实现升序 #include \u0026lt;stdio.h\u0026gt; void SelectionSort(int *arr,int len) {   // 已排序元素的末尾位置  int i;   // 未排序元素的起始位置  int j;   int k;   // 媒介变量，用于交换两个元素的位置  int t;   // 整体比较轮数  // 需要比较 len 轮  for(i = 0; i \u0026lt; len; i++)  {   // 跳过已排序的数  int k = i;   // 忽略已排序的数，直接从未排序的数开始比较，找出未排序数中的最小数  for(j = i; j \u0026lt; len; j++)  {  printf(\u0026#34;%d\\n\u0026#34;,i);  if(arr[j] \u0026lt; arr[k])  {  // 将一对数中较小的数的索引赋给 k  k = j;  }  }   // 将最小的那个数移到数组最前面  t = arr[k];  arr[k] = arr[i];  arr[i] = t;  } }  int main() {  int arr[] = {5,7,1,3,8,12,2,9};  SelectionSort(arr,8);  for(int j = 0; j \u0026lt; 8; j++)  {  printf(\u0026#34;%d \u0026#34;,arr[j]);  } } ","title":"冒泡排序"},{"content":"进制 进制也是进位计数制，是人为定义的带进位的计数方法。\n十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，N 进制就是逢 N 进位。\n用不同的进制表示同一个数，虽然使用的进制不一样，但内部依旧表示的同一个数，只是外部所表现形式不一样而已。\n进制的表示  B 表示二进制 O 表示八进制 D 表示十进制 H 表示十六进制  二进制的规律  1 = 1 10 = 21 100 = 22 1000 = 23 10000 = 24  ","permalink":"https://yxzi.xyz/blog/technology/computer/%E8%BF%9B%E5%88%B6/%E8%BF%9B%E5%88%B6/","summary":"进制 进制也是进位计数制，是人为定义的带进位的计数方法。\n十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，N 进制就是逢 N 进位。\n用不同的进制表示同一个数，虽然使用的进制不一样，但内部依旧表示的同一个数，只是外部所表现形式不一样而已。\n进制的表示  B 表示二进制 O 表示八进制 D 表示十进制 H 表示十六进制  二进制的规律  1 = 1 10 = 21 100 = 22 1000 = 23 10000 = 24  ","title":"进制"},{"content":"进制转换 二进制与八进制的转换 二进制转八进制 从右向左，三位一段，分别转换，不够三位补零。\n0101110 —\u0026gt; 000, 101, 110，三位一段。\n（000 = 0）（101 = 5）（110 = 6），则最后得到八进制数56。\n八进制转二进制 将每一个八进制位转换为 3 个二进制位。\n27 —\u0026gt; （010）（111），最后得到二进制数10111。\n二进制与十六进制的转换 二进制转十六进制 从右向左，四位一段，分别转换，不够四位补零。\n因为一个十六进制位有 16 种状态，所以需要 4 个二进制位的排列组合来表示，即每个 16 进制位，都需要用 4 个二进制位来表示，所以，我们可以将一串二进制位划分为好几段，四位为一段，不够四位的在前方补零，最后再一段一段的进行转换。\n0101110 —\u0026gt; 0010, 1110，四位一段。\n（0010 = 2）（1110 = 14 = E），则最后得到十六进制数2E\n十六进制转二进制 将每一个十六进制位转换为 4 个二进制位。\n2E —\u0026gt; （0010）（1110），一段四位则最后得到二进制数101110\n十进制转 N 进制 **除 N 取余，直至商 0 ，余数倒序。**十六进制需要将余数转换\n十进制转二进制 除以二取余，并将余数倒过来，即可得出结果。\n比如 185：\n 18 / 2 = 92， 余 1\n92 / 2 = 46，余 0\n46 / 2 = 23，余 0\n23 / 2 = 11， 余 1\n11 / 2 = 5 ， 余 1\n5 / 2 = 2， 余 1\n2 / 2 = 1， 余 0\n1 / 2 = 1， 余 1\n 最后将余数倒过来，即可得到 185 的二进制数：10111001。\n十进制转八进制 除以八取余，并将余数倒过来，即可得出结果。\n比如 185：\n 185 / 8 = 23， 余 1\n23 / 8 = 2， 余 7\n2 / 8 = 0， 余 2\n 最后将余数倒过来，即可得到 185 的八进制数：271。\n十进制转十六进制 除以十六取余，并将余数倒过来，即可得出结果。\n比如 185：\n 185 / 16 = 11，余 9\n11 / 16 = 0， 余 11 —\u0026gt; B\n 然后因为 11 在十六进制中是 B，所以需要将 11 变为 B，\n最后将余数倒过来，即可得到 185 的十六进制数：B9。\nN 进制转十进制 给定一个 N 进制的数 25，转换为十进制为：5 + 2 * N。比如 5 进制的 32 转为十进制为：2 + 3 * 5 = 17。\n不存在十六进制与八进制的直接相互转化，都是以二进制为中间进制来进行转化。\n十进制转十进制 1234 —\u0026gt; 4 * 10º + 3 * 10¹ + 2 * 10² + 1 * 10³ = 1234\n二进制转十进制 10101 —\u0026gt; 1 * 2º + 0 * 2 ¹ + 1 * 2² + 0 *2³ + 1 * 2⁴ = 21\n八进制转十进制 371 —\u0026gt; 1 * 8º + 7 * 8¹ + 3 * 8² = 249\n十六进制转十进制 E01A —\u0026gt; 10 * 16º + 1 * 16¹ + 0 * 16² + 14 * 16³ = 4106\n","permalink":"https://yxzi.xyz/blog/technology/computer/%E8%BF%9B%E5%88%B6/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/","summary":"进制转换 二进制与八进制的转换 二进制转八进制 从右向左，三位一段，分别转换，不够三位补零。\n0101110 —\u0026gt; 000, 101, 110，三位一段。\n（000 = 0）（101 = 5）（110 = 6），则最后得到八进制数56。\n八进制转二进制 将每一个八进制位转换为 3 个二进制位。\n27 —\u0026gt; （010）（111），最后得到二进制数10111。\n二进制与十六进制的转换 二进制转十六进制 从右向左，四位一段，分别转换，不够四位补零。\n因为一个十六进制位有 16 种状态，所以需要 4 个二进制位的排列组合来表示，即每个 16 进制位，都需要用 4 个二进制位来表示，所以，我们可以将一串二进制位划分为好几段，四位为一段，不够四位的在前方补零，最后再一段一段的进行转换。\n0101110 —\u0026gt; 0010, 1110，四位一段。\n（0010 = 2）（1110 = 14 = E），则最后得到十六进制数2E\n十六进制转二进制 将每一个十六进制位转换为 4 个二进制位。\n2E —\u0026gt; （0010）（1110），一段四位则最后得到二进制数101110\n十进制转 N 进制 **除 N 取余，直至商 0 ，余数倒序。**十六进制需要将余数转换\n十进制转二进制 除以二取余，并将余数倒过来，即可得出结果。\n比如 185：\n 18 / 2 = 92， 余 1","title":"进制转换"},{"content":"冻疮的康复之路 今年冬天也不知道是为什么，刚从贵州到重庆没几天，手上居然还是长冻疮了\u0026hellip;\n白萝卜叶治疗法   找一些的白萝卜（圆的和长的白萝卜都可以）叶子，用清水洗干净；\n  在锅中放入适量清水，烧开即可；\n  向锅中放入刚洗好的白萝卜叶子，沸水煮 10 分钟左右即可；\n  等水温降到合适的温度后，将双手或双脚放入水中浸泡即可。\n  我当时是早晚各一次，三天左右基本就好的差不多了。\n  预防冻疮  接触冷水时（比如洗碗）佩戴加绒的橡胶手套。 不要让易长冻疮的地方忽冷忽热（刚接触热水，立马又接触冷水）。 耳罩、手套。 厚袜子，保护手、耳朵以及脚。 晚上睡觉时穿袜子入睡。  ","permalink":"https://yxzi.xyz/blog/essay/%E5%86%BB%E7%96%AE%E7%9A%84%E5%BA%B7%E5%A4%8D%E4%B9%8B%E8%B7%AF/","summary":"冻疮的康复之路 今年冬天也不知道是为什么，刚从贵州到重庆没几天，手上居然还是长冻疮了\u0026hellip;\n白萝卜叶治疗法   找一些的白萝卜（圆的和长的白萝卜都可以）叶子，用清水洗干净；\n  在锅中放入适量清水，烧开即可；\n  向锅中放入刚洗好的白萝卜叶子，沸水煮 10 分钟左右即可；\n  等水温降到合适的温度后，将双手或双脚放入水中浸泡即可。\n  我当时是早晚各一次，三天左右基本就好的差不多了。\n  预防冻疮  接触冷水时（比如洗碗）佩戴加绒的橡胶手套。 不要让易长冻疮的地方忽冷忽热（刚接触热水，立马又接触冷水）。 耳罩、手套。 厚袜子，保护手、耳朵以及脚。 晚上睡觉时穿袜子入睡。  ","title":"冻疮的康复之路"},{"content":"贵州哪些地方值得一玩 贵阳区域  花溪 青岩 天河潭  老城区  黔灵山公园 甲秀楼  市郊  乌当偏坡 渔洞峡 情人谷 阿栗杨梅园 香纸沟水上乐园 白云欢乐世界 金阳喀斯特公园 贵安新区森哒星生态度假公园 云漫湖 瑞士小镇 多彩贵州城 1958 多彩贵州海洋世界  贵阳三县一市 贵阳三县一市分别是修文县息烽县，开阳县，清镇市，距离贵阳市较近，非常适合自驾。\n修文县  贵阳野生动物园 阳明洞 苏格兰牧场 桃源河峡谷生态旅游区 珍珠岛度假休闲中心  息烽县  息烽温泉 息烽集中营 乌江峡  开阳县  南江大峡谷 白马峪温泉 云山茶海 十里画廊 白果生态农业观光园  清镇市  时光贵州 红枫湖  安顺区域  黄果树风景区 龙宫风景区  探秘历史 天龙\n 云峰屯堡（保留 600 年明朝军屯历史原样，老汉人） 紫云格凸河（悬棺、蜘蛛人） 关岭红崖天书 关岭海百合化石群 普定穿洞遗址  青山秀水  平坝农场（赏樱花） 普定秀水（农家乐） 小河湾（摘果） 黄果树石头寨（烧烤）  有句话是：“玩在贵阳，吃在安顺”。很多贵阳的朋友都会周末到安顺去吃小吃再返程，因此就算是边逛边吃也可以玩一天。\n推荐地段：安顺民主路、安顺老街（儒林路，《致青春》取景地）、安顺好吃街。\n黔南州区域 惠水  好花红乡 九龙寺  都匀  斗篷山  龙里  龙里大草原 龙架山森林公园 榕御温泉  贵定  金海雪山 音寨  荔波  荔波漳江风景区 茂兰喀斯特森林 大七孔  平塘  掌布瀑布  三都  水族 产蛋崖  ","permalink":"https://yxzi.xyz/blog/essay/%E8%B4%B5%E5%B7%9E%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E5%80%BC%E5%BE%97%E4%B8%80%E7%8E%A9/","summary":"贵州哪些地方值得一玩 贵阳区域  花溪 青岩 天河潭  老城区  黔灵山公园 甲秀楼  市郊  乌当偏坡 渔洞峡 情人谷 阿栗杨梅园 香纸沟水上乐园 白云欢乐世界 金阳喀斯特公园 贵安新区森哒星生态度假公园 云漫湖 瑞士小镇 多彩贵州城 1958 多彩贵州海洋世界  贵阳三县一市 贵阳三县一市分别是修文县息烽县，开阳县，清镇市，距离贵阳市较近，非常适合自驾。\n修文县  贵阳野生动物园 阳明洞 苏格兰牧场 桃源河峡谷生态旅游区 珍珠岛度假休闲中心  息烽县  息烽温泉 息烽集中营 乌江峡  开阳县  南江大峡谷 白马峪温泉 云山茶海 十里画廊 白果生态农业观光园  清镇市  时光贵州 红枫湖  安顺区域  黄果树风景区 龙宫风景区  探秘历史 天龙\n 云峰屯堡（保留 600 年明朝军屯历史原样，老汉人） 紫云格凸河（悬棺、蜘蛛人） 关岭红崖天书 关岭海百合化石群 普定穿洞遗址  青山秀水  平坝农场（赏樱花） 普定秀水（农家乐） 小河湾（摘果） 黄果树石头寨（烧烤）  有句话是：“玩在贵阳，吃在安顺”。很多贵阳的朋友都会周末到安顺去吃小吃再返程，因此就算是边逛边吃也可以玩一天。","title":"贵阳哪些地方值得一玩"},{"content":"进厂后 每天做着重复且机械的工作，好不容易熬到下班，\n换上了自己喜欢的衣服，吃完饭便回到宿舍，\n推开门，扑面而来的是一股浓浓的烟味，让你不得不捂住鼻子，\n你望着昏暗腐朽的宿舍，想开灯，但却怕打扰舍友休息。\n角落里的两个室友，一个对着手机痴迷的笑着，跟着魔了似的，\n另一个正在睡觉，睡得像死猪一般。\n你想跟那个玩手机的舍友打个招呼，但却不知什么原因止住了。\n你太累了，躺在床上，\n望着脏兮兮的天花板，不禁开始怀念曾经在学校的生活\u0026hellip;\n","permalink":"https://yxzi.xyz/blog/essay/%E8%BF%9B%E5%8E%82%E5%90%8E/","summary":"进厂后 每天做着重复且机械的工作，好不容易熬到下班，\n换上了自己喜欢的衣服，吃完饭便回到宿舍，\n推开门，扑面而来的是一股浓浓的烟味，让你不得不捂住鼻子，\n你望着昏暗腐朽的宿舍，想开灯，但却怕打扰舍友休息。\n角落里的两个室友，一个对着手机痴迷的笑着，跟着魔了似的，\n另一个正在睡觉，睡得像死猪一般。\n你想跟那个玩手机的舍友打个招呼，但却不知什么原因止住了。\n你太累了，躺在床上，\n望着脏兮兮的天花板，不禁开始怀念曾经在学校的生活\u0026hellip;","title":"进厂后"},{"content":"为什么会写博客 技术总结 码代码嘛，肯定是会遇到各种 bug 的，之后肯定得通过某些渠道来解决这些 bug，比如 Google、各种论坛\u0026hellip;\n最终，你花了大半天的时间找到了解决办法，但你并没有记录解决这个问题的过程。\n过了一段时间，当你再遇到同样的问题，你还得再花上大半天的时间去 Google。\n这时候你就会想，要是当时自己记录了这个问题的解决过程就好了。\n换句话说，第一次接触某个新知识或新问题，你通过各种方式进行学习+实践+总结。\n完成过后，再把这些过程都记录下来，如果未来需要用到，看你自己的笔记就行了，哪还需要去搜索引擎中大海捞针？\n将笔记公开，成为博客，能帮助到需要的人。\n生活感悟 每个人不免会在生活中产生一些对人生的一些感触和觉悟。\n我也一样，很多时候，我可能会因一篇文章、一本书、一部电影、一个人、或生活中的某个细节，而触动我。\n我珍惜这些东西，想把这些东西用文字表述出来。并愿意分享。\n最后用在其他博客上看到的一句话来总结一下：\n 对任何渴望进步的人来说，写博客/文章/回答，对自己的成长帮助都是巨大的。频率和数量不必过分强求，有话要说就写写，没事就歇歇，随意点。因为在开始写作的那一刻起，你就已经开始受益。”\n ","permalink":"https://yxzi.xyz/blog/essay/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%86%99%E5%8D%9A%E5%AE%A2/","summary":"为什么会写博客 技术总结 码代码嘛，肯定是会遇到各种 bug 的，之后肯定得通过某些渠道来解决这些 bug，比如 Google、各种论坛\u0026hellip;\n最终，你花了大半天的时间找到了解决办法，但你并没有记录解决这个问题的过程。\n过了一段时间，当你再遇到同样的问题，你还得再花上大半天的时间去 Google。\n这时候你就会想，要是当时自己记录了这个问题的解决过程就好了。\n换句话说，第一次接触某个新知识或新问题，你通过各种方式进行学习+实践+总结。\n完成过后，再把这些过程都记录下来，如果未来需要用到，看你自己的笔记就行了，哪还需要去搜索引擎中大海捞针？\n将笔记公开，成为博客，能帮助到需要的人。\n生活感悟 每个人不免会在生活中产生一些对人生的一些感触和觉悟。\n我也一样，很多时候，我可能会因一篇文章、一本书、一部电影、一个人、或生活中的某个细节，而触动我。\n我珍惜这些东西，想把这些东西用文字表述出来。并愿意分享。\n最后用在其他博客上看到的一句话来总结一下：\n 对任何渴望进步的人来说，写博客/文章/回答，对自己的成长帮助都是巨大的。频率和数量不必过分强求，有话要说就写写，没事就歇歇，随意点。因为在开始写作的那一刻起，你就已经开始受益。”\n ","title":"为什么会写博客"},{"content":"递归 简单地说，就是如果在函数中存在着调用函数本身的情况，这种现象就叫递归。\n从所需结果出发不断回溯前一运算直到回到初值再递推得到所需结果。从未知到已知，从大到小，再从小到大。\n用计算阶乘函数举例，factorial()中存在着factorial(n - 1)的调用，所以此函数就是递归函数。\nvar n = 5; function factorial(n) { \tif (n == 1) { \treturn 1; \t} \treturn (n = n * factorial(n - 1));  } console.log(factorial(n)); 使用递归的思路   找规律（符合人的思维过程）。\n  找出口（用已知的条件当做终止条件，用实际性的数去返回结果），避免无限递归（即无限循环），导致浏览器崩溃。\n  递归的一般格式为 return + 有规律公式。\n   递归优缺点 优点\n 使代码更加简洁。  缺点\n 影响程序的效率与性能，因此，复杂的程序一定不要使用递归。  ","permalink":"https://yxzi.xyz/blog/technology/datastructure/algorithm/%E9%80%92%E5%BD%92/","summary":"递归 简单地说，就是如果在函数中存在着调用函数本身的情况，这种现象就叫递归。\n从所需结果出发不断回溯前一运算直到回到初值再递推得到所需结果。从未知到已知，从大到小，再从小到大。\n用计算阶乘函数举例，factorial()中存在着factorial(n - 1)的调用，所以此函数就是递归函数。\nvar n = 5; function factorial(n) { \tif (n == 1) { \treturn 1; \t} \treturn (n = n * factorial(n - 1));  } console.log(factorial(n)); 使用递归的思路   找规律（符合人的思维过程）。\n  找出口（用已知的条件当做终止条件，用实际性的数去返回结果），避免无限递归（即无限循环），导致浏览器崩溃。\n  递归的一般格式为 return + 有规律公式。\n   递归优缺点 优点\n 使代码更加简洁。  缺点\n 影响程序的效率与性能，因此，复杂的程序一定不要使用递归。  ","title":"递归"},{"content":"Hello World 2021 年 10 月 1 日，\n我的站点正式发布。\n愿你被世界温柔以待。\n","permalink":"https://yxzi.xyz/blog/essay/hello-world/","summary":"Hello World 2021 年 10 月 1 日，\n我的站点正式发布。\n愿你被世界温柔以待。","title":"Hello World"}]