[{"content":"Linux 命令 sudo sudo -s 切换到 root 用户，获取管理员权限\n","permalink":"https://note.yxzi.xyz/note/technology/windows-server/linux-%E5%91%BD%E4%BB%A4/","summary":"Linux 命令 sudo sudo -s 切换到 root 用户，获取管理员权限","title":"Linux 命令"},{"content":"Server 2012 FTP 安装 FTP 新建用户 新建站点  ","permalink":"https://note.yxzi.xyz/note/technology/windows-server/server-2012-ftp/","summary":"Server 2012 FTP 安装 FTP 新建用户 新建站点  ","title":"Server 2012 FTP"},{"content":"Listening 顺序原则 **题目的顺序和对话的先后顺序是绝对一致的，**绝对是第一题的关键句子出现之后，第二题的才可能出来。所以你做题的时候要是听到了第二题的答案但是第一题还没选，那赶紧瞎蒙一个，根本不影响后面的做题。\n视听一致 权威统计，四级的听力有 90%的答案都是原文\n耳朵听到的信息与眼睛所看到的信息越一致，则越容易称为正确答案。\n 关键词与音频内容完全相符的选项。 关键词在音频中出现的次数最多的选项。  选取关键词 纵向：排除相同概念。\n横向：划实不划虚，划组合概念。\n  听音频的同时，眼睛来回扫视画出来的关键词。\n  听见与选项对应的关键词，听到几次则标记几次。\n  同转 关键词与音频内容不完全符合，但都表达用一个意思。\n 同根词 词词替换 短语概念替换 泛指到特指  错误选项的特点  直接被否定。 反义表述。 选项部分信息音频中并未提及。  短篇新闻  划关键字并猜测发音。 使用视听一致 +同转的原则。 如果依旧没听出来，可以用错误选项的特点，反向选出答案。  长对话  注意换题信号以及语气的按时作用。  考前磨耳朵 考试前自己先听一两套真题。\n平时如何练习 倍速听 1.2 或 1.5 倍速听，\n","permalink":"https://note.yxzi.xyz/note/subject/english/cet-4/listening/","summary":"Listening 顺序原则 **题目的顺序和对话的先后顺序是绝对一致的，**绝对是第一题的关键句子出现之后，第二题的才可能出来。所以你做题的时候要是听到了第二题的答案但是第一题还没选，那赶紧瞎蒙一个，根本不影响后面的做题。\n视听一致 权威统计，四级的听力有 90%的答案都是原文\n耳朵听到的信息与眼睛所看到的信息越一致，则越容易称为正确答案。\n 关键词与音频内容完全相符的选项。 关键词在音频中出现的次数最多的选项。  选取关键词 纵向：排除相同概念。\n横向：划实不划虚，划组合概念。\n  听音频的同时，眼睛来回扫视画出来的关键词。\n  听见与选项对应的关键词，听到几次则标记几次。\n  同转 关键词与音频内容不完全符合，但都表达用一个意思。\n 同根词 词词替换 短语概念替换 泛指到特指  错误选项的特点  直接被否定。 反义表述。 选项部分信息音频中并未提及。  短篇新闻  划关键字并猜测发音。 使用视听一致 +同转的原则。 如果依旧没听出来，可以用错误选项的特点，反向选出答案。  长对话  注意换题信号以及语气的按时作用。  考前磨耳朵 考试前自己先听一两套真题。\n平时如何练习 倍速听 1.2 或 1.5 倍速听，","title":"English Listening"},{"content":"Reading 做题顺序：\nSection C 仔细阅读\nSection B 长阅读\nSection A 选词填空\nSection C 问题的顺序和文章的顺序一致，第一道题的答案在原文中的位置，一定在第二道题的前面。\nkeyword 读题目的时候，圈出题目中的关键词，比如时间、地点、名字、特定名称、数字数据。\n建议先圈出 2~3 到题目的关键词，然后直接去读文章，等到这个 2~3 题找到答案后，再继续读剩下的题目，继续圈关键词。\nLocate 根据关键字，在原文中锁定答案范围。\nAnalyze 分析选项和原文的匹配程度！\n难一点的题目，会存在同义替换的现象，题目中和原文中的关键词并不是同一个单词，但是意思却一致。\nSectionB 用 KLA 法则，但是要注意：\n 题目的多个关键词在原文中都可以匹配上，或者有同义替换，这就可以确定为正确答案。  SectionA 瞎蒙就对了。\n平时如何练习 第 1 遍\n先计时做，模拟实战。不要看答案，把答案写在纸上。\n第 2 遍\n第 1 遍做完后，对照真题解析把文章中的生词查出来，包括选项题干里面的单词，把意思写在真题旁边。查完做第 2 遍，不用限时，做完后把答案写在纸上，还是不看答案。\n第 3 遍\n对照解析逐句翻译！！就是 1 句 1 句的翻译，不会翻译就看解析里的句子分析，把每个句子翻译通，弄懂在讲什么意思。\n最后再模拟实战，做最后一遍，把答案写在纸上。\n最后对答案，看看 3 遍下来，选的答案变动大不大？正确率提高了多少？如果 3 遍之后还有做错的题，重点分析错题，包括题干、选项还有对应的答案句，弄清楚是为什么错。\n","permalink":"https://note.yxzi.xyz/note/subject/english/cet-4/reading/","summary":"Reading 做题顺序：\nSection C 仔细阅读\nSection B 长阅读\nSection A 选词填空\nSection C 问题的顺序和文章的顺序一致，第一道题的答案在原文中的位置，一定在第二道题的前面。\nkeyword 读题目的时候，圈出题目中的关键词，比如时间、地点、名字、特定名称、数字数据。\n建议先圈出 2~3 到题目的关键词，然后直接去读文章，等到这个 2~3 题找到答案后，再继续读剩下的题目，继续圈关键词。\nLocate 根据关键字，在原文中锁定答案范围。\nAnalyze 分析选项和原文的匹配程度！\n难一点的题目，会存在同义替换的现象，题目中和原文中的关键词并不是同一个单词，但是意思却一致。\nSectionB 用 KLA 法则，但是要注意：\n 题目的多个关键词在原文中都可以匹配上，或者有同义替换，这就可以确定为正确答案。  SectionA 瞎蒙就对了。\n平时如何练习 第 1 遍\n先计时做，模拟实战。不要看答案，把答案写在纸上。\n第 2 遍\n第 1 遍做完后，对照真题解析把文章中的生词查出来，包括选项题干里面的单词，把意思写在真题旁边。查完做第 2 遍，不用限时，做完后把答案写在纸上，还是不看答案。\n第 3 遍\n对照解析逐句翻译！！就是 1 句 1 句的翻译，不会翻译就看解析里的句子分析，把每个句子翻译通，弄懂在讲什么意思。\n最后再模拟实战，做最后一遍，把答案写在纸上。\n最后对答案，看看 3 遍下来，选的答案变动大不大？正确率提高了多少？如果 3 遍之后还有做错的题，重点分析错题，包括题干、选项还有对应的答案句，弄清楚是为什么错。","title":"English Reading"},{"content":"class 创建一个基于原型继承类。\nclass Phone { \t// 调用构造方法 \tconstructor(height, width) { \tthis.area = height * width; \t}  \tfun() { \tconsole.log(\u0026#39;i am function\u0026#39;); \t} }  let apple = new Phone(4, 3); apple.fun(); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/class/","summary":"class 创建一个基于原型继承类。\nclass Phone { \t// 调用构造方法 \tconstructor(height, width) { \tthis.area = height * width; \t}  \tfun() { \tconsole.log(\u0026#39;i am function\u0026#39;); \t} }  let apple = new Phone(4, 3); apple.fun(); ","title":"JavaScrip class"},{"content":"constructor() 用于创建和初始化class创建的对象的特殊方法。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E7%B1%BB/constructor/","summary":"constructor() 用于创建和初始化class创建的对象的特殊方法。","title":"JavaScrip constructor"},{"content":"Object 属性 constructor 返回构造当前对象的构造函数。\nvar array = [];  // return ƒ Array() { [native code] } console.log(array.constructor); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/object/object-%E5%B1%9E%E6%80%A7/","summary":"Object 属性 constructor 返回构造当前对象的构造函数。\nvar array = [];  // return ƒ Array() { [native code] } console.log(array.constructor); ","title":"JavaScrip Object 属性"},{"content":"static 定义静态方法。静态方法不能在类的实例上调用静态方法，而应该通过类本身调用。\nclass Phone { \tstatic name = \u0026#39;静态方法\u0026#39;; }  let apple = new Phone(4, 3); console.log(apple.name); console.log(Phone.name); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E7%B1%BB/static/","summary":"static 定义静态方法。静态方法不能在类的实例上调用静态方法，而应该通过类本身调用。\nclass Phone { \tstatic name = \u0026#39;静态方法\u0026#39;; }  let apple = new Phone(4, 3); console.log(apple.name); console.log(Phone.name); ","title":"JavaScrip static"},{"content":"Map 用于保存键值对，并且能够记住键的原始插入顺序。任何值都可以作为一个键或一个值。\nconst map1 = new Map();  map1.set(\u0026#39;a\u0026#39;, 1); map1.set(\u0026#39;b\u0026#39;, 2); map1.set(\u0026#39;c\u0026#39;, 3);  console.log(map1.get(\u0026#39;a\u0026#39;)); // return 1  map1.set(\u0026#39;a\u0026#39;, 97);  console.log(map1.get(\u0026#39;a\u0026#39;)); // return 97  console.log(map1.size); // return 3  map1.delete(\u0026#39;b\u0026#39;);  console.log(map1.size); // return 2 ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/map/map/","summary":"Map 用于保存键值对，并且能够记住键的原始插入顺序。任何值都可以作为一个键或一个值。\nconst map1 = new Map();  map1.set(\u0026#39;a\u0026#39;, 1); map1.set(\u0026#39;b\u0026#39;, 2); map1.set(\u0026#39;c\u0026#39;, 3);  console.log(map1.get(\u0026#39;a\u0026#39;)); // return 1  map1.set(\u0026#39;a\u0026#39;, 97);  console.log(map1.get(\u0026#39;a\u0026#39;)); // return 97  console.log(map1.size); // return 3  map1.delete(\u0026#39;b\u0026#39;);  console.log(map1.size); // return 2 ","title":"Map"},{"content":"Map 方法 set() 添加或更新指定的键值。\ndelete() 移除指定元素\nget() 返回一个指定元素。\nclear() 清空所有元素\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/map/map-%E6%96%B9%E6%B3%95/","summary":"Map 方法 set() 添加或更新指定的键值。\ndelete() 移除指定元素\nget() 返回一个指定元素。\nclear() 清空所有元素","title":"Map 方法"},{"content":"Promise 方法 than() then() 返回一个 Promise 对象。它有两个参数：Promise 调用resolve() 和调用 rejecte() 情况的回调函数。\n返回 Promise 对象 than()的返回值如果是 Promise 对象，那么该 Promise 对象的执行结果会作为当前 than() 的返回值。\nlet p = new Promise((resolve, reject) =\u0026gt; { \tsetTimeout(() =\u0026gt; { \tresolve(\u0026#39;success\u0026#39;); \t}, 1000); });  let result = p.then( \t(value) =\u0026gt; { \tconsole.log(value); \treturn new Promise((resolve, reject) =\u0026gt; { \treject(\u0026#39;fail\u0026#39;); \t}); \t}, \t(reason) =\u0026gt; { \tconsole.error(reason); \t} );  // rejected // \u0026#34;fail\u0026#34; console.log(result); 返回非 Promise 对象 than()的返回值如果不是 Promise 对象，则 PromiseStatus 为 fulfilled，PromiseResult 为这个非 Promise 对象的值。\nlet p = new Promise((resolve, reject) =\u0026gt; { \tsetTimeout(() =\u0026gt; { \tresolve(\u0026#39;success\u0026#39;); \t}, 1000); });  let result = p.then( \t(value) =\u0026gt; { \tconsole.log(value); \treturn \u0026#39;非 Promise 对象\u0026#39;; \t}, \t(reason) =\u0026gt; { \tconsole.error(reason); \t} );  // fulfilled // 非 Promise 对象 console.log(result); 抛出错误 let p = new Promise((resolve, reject) =\u0026gt; { \tsetTimeout(() =\u0026gt; { \tresolve(\u0026#39;success\u0026#39;); \t}, 1000); });  let result = p.then( \t(value) =\u0026gt; { \tconsole.log(value); \tthrow new Error(\u0026#39;error\u0026#39;); \t}, \t(reason) =\u0026gt; { \tconsole.error(reason); \t} );  // rejected // Error: error at http://127.0.0.1:5502/Study/main.js console.log(result); 链式调用 可以避免回调地狱。\nlet p = new Promise((resolve, reject) =\u0026gt; { \tsetTimeout(() =\u0026gt; { \tresolve(\u0026#39;success\u0026#39;); \t}, 1000); });  p.then((value) =\u0026gt; { \tconsole.log(value); \treturn new Promise((resolve, reject) =\u0026gt; { \tresolve(\u0026#39;success2\u0026#39;); \t}); }) \t.then((value) =\u0026gt; { \tconsole.log(value); \treturn new Promise((resolve, reject) =\u0026gt; { \tresolve(\u0026#39;success3\u0026#39;); \t}); \t}) \t.then((value) =\u0026gt; { \tconsole.log(value); \t}); catch() 返回 promise 对象，并对调用reject()后的情况作处理。\nlet p = new Promise((resolve, reject) =\u0026gt; { \treject(\u0026#39;error\u0026#39;); });  p.catch((err) =\u0026gt; { \tconsole.log(err); }); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/promise/promise-%E6%96%B9%E6%B3%95/","summary":"Promise 方法 than() then() 返回一个 Promise 对象。它有两个参数：Promise 调用resolve() 和调用 rejecte() 情况的回调函数。\n返回 Promise 对象 than()的返回值如果是 Promise 对象，那么该 Promise 对象的执行结果会作为当前 than() 的返回值。\nlet p = new Promise((resolve, reject) =\u0026gt; { \tsetTimeout(() =\u0026gt; { \tresolve(\u0026#39;success\u0026#39;); \t}, 1000); });  let result = p.then( \t(value) =\u0026gt; { \tconsole.log(value); \treturn new Promise((resolve, reject) =\u0026gt; { \treject(\u0026#39;fail\u0026#39;); \t}); \t}, \t(reason) =\u0026gt; { \tconsole.error(reason); \t} );  // rejected // \u0026#34;fail\u0026#34; console.","title":"Promise 方法"},{"content":"Set 用于存储任何类型的唯一值。\n数组去重 const arr = [2, 3, 4, 4, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 5, 32, 3, 4, 5]; console.log([...new Set(arr)]); 交集 并集 let arr = [1, 4, 3, 8]; let arr2 = [5, 1, 7, 2];  let union = [...new Set([...arr, ...arr2])]; console.log(union); 差集 ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/set/set/","summary":"Set 用于存储任何类型的唯一值。\n数组去重 const arr = [2, 3, 4, 4, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 5, 32, 3, 4, 5]; console.log([...new Set(arr)]); 交集 并集 let arr = [1, 4, 3, 8]; let arr2 = [5, 1, 7, 2];  let union = [...new Set([...arr, ...arr2])]; console.log(union); 差集 ","title":"Set"},{"content":"Set 方法 add() 向末尾添加一个指定的元素。\ndelete() 删除指定元素。\nhas() 检测 set 中是否存在指定元素。\nclear() 清空所有元素。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/set/set-%E6%96%B9%E6%B3%95/","summary":"Set 方法 add() 向末尾添加一个指定的元素。\ndelete() 删除指定元素。\nhas() 检测 set 中是否存在指定元素。\nclear() 清空所有元素。","title":"Set 方法"},{"content":"插件 用于增强 Vue，本质是一个包含install()的一个对象。\ninstall()的第一个参数是 Vue 构造 ，第二个参数是一个可选的选项对象：\n使用\n新建 plugins.js，定义一个包含install()的对象，并暴露。\nexport default { \tinstall(Vue, x) { \tconsole.log(Vue, x); \t}, }; 在 main.js 中导入并使用 plugins。\nimport plugins from \u0026#39;./plugins\u0026#39;; Vue.use(plugins, 6666); ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E6%8F%92%E4%BB%B6/","summary":"插件 用于增强 Vue，本质是一个包含install()的一个对象。\ninstall()的第一个参数是 Vue 构造 ，第二个参数是一个可选的选项对象：\n使用\n新建 plugins.js，定义一个包含install()的对象，并暴露。\nexport default { \tinstall(Vue, x) { \tconsole.log(Vue, x); \t}, }; 在 main.js 中导入并使用 plugins。\nimport plugins from \u0026#39;./plugins\u0026#39;; Vue.use(plugins, 6666); ","title":"Vue 插件"},{"content":"混入 将多个组件共用的配置提取成一个 mixin 对象。\n组件自身的配置和mixin的配置相同时，则优先使用组件自身的配置。钩子函数例外，不管是组件自身的钩子函数还是 mixin的钩子函数，这些钩子函数都会被调用，且 mixin 中的钩子函数先调用，组件自身的钩子函数后调用。\nmixins 局部混入，对指定的组件，应用mixin\n使用\n新建mixin.js，在其中配置 mixin 对象，并暴露mixin 对象。\nlet mixin = { \tmethods: { \tfun() { \tconsole.log(‘mixin’); \t}, \t}, };  export default mixin; 对每个需要使用 mixin 的组件配置mixins\nexport default { \tname: \u0026#39;Student\u0026#39;, \tdata() { \treturn { \ttips: \u0026#39;Hi\u0026#39;, \tmyAge: this.age, \t}; \t}, \t// 使用 mixin \tmixins: [mixin], }; mixin 全局混入，对每个组件实例（包括 Vue 实例）都应用指定的mixin。\n使用\n新建mixin.js，在其中配置 mixin 对象，并暴露mixin 对象。\n在 main.js 中导入并使用mixin。\nimport mixin from \u0026#39;./mixin\u0026#39;; Vue.mixin(mixin); ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E6%B7%B7%E5%85%A5/","summary":"混入 将多个组件共用的配置提取成一个 mixin 对象。\n组件自身的配置和mixin的配置相同时，则优先使用组件自身的配置。钩子函数例外，不管是组件自身的钩子函数还是 mixin的钩子函数，这些钩子函数都会被调用，且 mixin 中的钩子函数先调用，组件自身的钩子函数后调用。\nmixins 局部混入，对指定的组件，应用mixin\n使用\n新建mixin.js，在其中配置 mixin 对象，并暴露mixin 对象。\nlet mixin = { \tmethods: { \tfun() { \tconsole.log(‘mixin’); \t}, \t}, };  export default mixin; 对每个需要使用 mixin 的组件配置mixins\nexport default { \tname: \u0026#39;Student\u0026#39;, \tdata() { \treturn { \ttips: \u0026#39;Hi\u0026#39;, \tmyAge: this.age, \t}; \t}, \t// 使用 mixin \tmixins: [mixin], }; mixin 全局混入，对每个组件实例（包括 Vue 实例）都应用指定的mixin。","title":"Vue 混入"},{"content":"Promise Promise 说得通俗一点就是一种写代码的方式，并且是用来写 JavaScript 编程中的异步代码。\n可以封装 ajax.\n基本使用 let p = new Promise((resolve, reject) =\u0026gt; { \tif (0) { \t// 成功 \tresolve(\u0026#39;success\u0026#39;); \t} else { \t// 失败 \treject(\u0026#39;fail\u0026#39;); \t} });  p.then( \t// 如果 p 调用了 resolve() \t(value) =\u0026gt; { \tconsole.log(value); \t}, \t// 如果 p 调用了 reject() \t(reason) =\u0026gt; { \tconsole.error(reason); \t} ); 读取文件 let fs = require(\u0026#39;fs\u0026#39;); let p = new Promise((resolve, reject) =\u0026gt; { \tfs.readFile(\u0026#39;./test.md\u0026#39;, (err, data) =\u0026gt; { \tif (err) { \treject(err); \t} else { \tresolve(data); \t} \t}); });  p.then( \t(value) =\u0026gt; { \t// 将二进制转换为 字符串 \tconsole.log(value.toString()); \t}, \t(reason) =\u0026gt; { \tconsole.error(reason.toString()); \t} ); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/promise/promise/","summary":"Promise Promise 说得通俗一点就是一种写代码的方式，并且是用来写 JavaScript 编程中的异步代码。\n可以封装 ajax.\n基本使用 let p = new Promise((resolve, reject) =\u0026gt; { \tif (0) { \t// 成功 \tresolve(\u0026#39;success\u0026#39;); \t} else { \t// 失败 \treject(\u0026#39;fail\u0026#39;); \t} });  p.then( \t// 如果 p 调用了 resolve() \t(value) =\u0026gt; { \tconsole.log(value); \t}, \t// 如果 p 调用了 reject() \t(reason) =\u0026gt; { \tconsole.error(reason); \t} ); 读取文件 let fs = require(\u0026#39;fs\u0026#39;); let p = new Promise((resolve, reject) =\u0026gt; { \tfs.","title":"Promise"},{"content":"被动语态 语态是谓语动词的一种形式。\n谓语动词是主动语态的句子是主动句，谓语动词是被动语态的句子是被动句。\n主动语态和被动语态 主动语态：主语是动作的执行者。\n I help him.  被动语态：主语是动作的承受者。\n由助动词 be + 及物动词的过去分词构成。\n He is helped by me.  被动语态就是将主动语态中的宾语（him）拿来作主语（He），而且一般的被动句子中没有宾语，除非用双宾动词构成主语。\n一般现在时态 主语 + 助动词 + 及物动词的过去分词 +状语。\n I am believed by my friends. Expensive shoes are bought by rich people. He is cheated.  一般过去时态 主语 + 助动词 be 的过去式 + 及物动词的过去分词 + 状语。\n The house was built in 2001。 Her birthday party was held last week.  一般将来时态 主语 + 助动词 be 的将来时 + 及物动词的过去分词 + 状语\n The Olympic Games will be heldin Beijing in a few months. l am going to be punished tonight. We going to be a abandoned in the future.  现在进行时态 主语 + 助动词 be + being + 及物动词的过去分词。\n The chicken wing is being baked. Many people are being helped. The movie is being watched.  现在完成时态 主语 + be 的完成时态 + 及物动词的过去分词\n The letters have been posted. The work has been finished. These shoes have been made.  否定句 在助动词后面加 not.\n一般疑问句 将助动词到主语之前。\n什么时候使用被动语态？ 在不知道动作的执行者是谁的时候  The house was built last year. My pens were taken.  当动作执行者式泛指或不言自明的时候  The books in the library must not be taken away.  知道动作的执行者，但强调动作的承受者，而不强调谁做的这个动作  My computer has been repaired.  强调我的电脑已经被修好，不强调到底是谁修好的电脑。\n Rainy has repaired my computer.  强调 Rainy 修好了我的电脑，不强调我的电脑被修好\n出于礼貌，委婉而避免提及自己对方时  Your are wished to do it more carefully.  用在文章标题、广告、新闻里等 这群情况经常省略助动词 be.\n Girls Wanted. Road Blocked  当动作的执行者不是人或动物时  The house was washed away by the flood. The price of vegetable is affected by weather. Many people were killed in the accident  含情态动词的被动语态 主语 + 情态动词 + 原型 be + 及物动词的过去分词\n You may be punished.  双宾动词变成被动语态 因为双宾动词有两个宾语，因此变成被动语态时，其中一个宾语作主语。另一个宾语还要被保留。\n  I give a book.（主动句）\n  You were given a book.（被动句）\n  A book was given to you.（被动句）\n  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%A2%AB%E5%8A%A8%E8%AF%AD%E6%80%81/%E8%A2%AB%E5%8A%A8%E8%AF%AD%E6%80%81/","summary":"被动语态 语态是谓语动词的一种形式。\n谓语动词是主动语态的句子是主动句，谓语动词是被动语态的句子是被动句。\n主动语态和被动语态 主动语态：主语是动作的执行者。\n I help him.  被动语态：主语是动作的承受者。\n由助动词 be + 及物动词的过去分词构成。\n He is helped by me.  被动语态就是将主动语态中的宾语（him）拿来作主语（He），而且一般的被动句子中没有宾语，除非用双宾动词构成主语。\n一般现在时态 主语 + 助动词 + 及物动词的过去分词 +状语。\n I am believed by my friends. Expensive shoes are bought by rich people. He is cheated.  一般过去时态 主语 + 助动词 be 的过去式 + 及物动词的过去分词 + 状语。\n The house was built in 2001。 Her birthday party was held last week.","title":"English 被动语态"},{"content":"npm view 显示有关模块的数据。\n","permalink":"https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-view/","summary":"npm view 显示有关模块的数据。","title":"npm view"},{"content":"cookie cookie 是网站的服务器发送到用户浏览器并保存在本地的一个小文件，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。\ncookie 保存了你登录网站时的用户名、密码，有了它，只需要在下次请求服务器时带着 cookie 发送，服务器就不会再让你重新输入用户名、密码登录。\ncookie 是设计用来在服务端和客户端进行信息传递的。\n无法跨浏览器读取 我们使用 chrome 浏览器去访问 github 时，那么 chrome 浏览器会得到一个 cookie，当你下次访问 github 时，就无需再重新输入用户名和密码。但如果你换 Firefox 浏览器去访问 github，那么你依旧需要重新输入用户名和密码，这是因为 cookie 无法跨浏览器读取。即对于相同的网站，每个浏览器都有属于它自己的 cookie。\n作用  会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等）  ","permalink":"https://note.yxzi.xyz/note/technology/internet/http/cookie/","summary":"cookie cookie 是网站的服务器发送到用户浏览器并保存在本地的一个小文件，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。\ncookie 保存了你登录网站时的用户名、密码，有了它，只需要在下次请求服务器时带着 cookie 发送，服务器就不会再让你重新输入用户名、密码登录。\ncookie 是设计用来在服务端和客户端进行信息传递的。\n无法跨浏览器读取 我们使用 chrome 浏览器去访问 github 时，那么 chrome 浏览器会得到一个 cookie，当你下次访问 github 时，就无需再重新输入用户名和密码。但如果你换 Firefox 浏览器去访问 github，那么你依旧需要重新输入用户名和密码，这是因为 cookie 无法跨浏览器读取。即对于相同的网站，每个浏览器都有属于它自己的 cookie。\n作用  会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等）  ","title":"cookie"},{"content":"Symbol 一般用于给对象添加一个独一无二的属性或方法。\n使用Symbol()定义一个Symbol类型的数据。\n// 添加方式一 var game = { \thouse() {}, }; let methods = { \tfun: Symbol(), };  // 给对象中的属性添加方法 game[methods.fun] = function () { \tconsole.log(\u0026#39;方法1\u0026#39;); }; // 添加方式二 var game = { \t[Symbol(\u0026#39;fun\u0026#39;)]: function () { \tconsole.log(\u0026#39;methods one \u0026#39;); \t}, }; console.log(game);  Symbol 是原始类型，不是引用类型，不能使用 new。\nSymbol()可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。\nSymbol 类型的值时唯一的，用来解决命名冲突的问题。\nSymbol 类型的值不能于其他数据进行运算\nSymbol 定义的对象属性不能被遍历\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/symbol/","summary":"Symbol 一般用于给对象添加一个独一无二的属性或方法。\n使用Symbol()定义一个Symbol类型的数据。\n// 添加方式一 var game = { \thouse() {}, }; let methods = { \tfun: Symbol(), };  // 给对象中的属性添加方法 game[methods.fun] = function () { \tconsole.log(\u0026#39;方法1\u0026#39;); }; // 添加方式二 var game = { \t[Symbol(\u0026#39;fun\u0026#39;)]: function () { \tconsole.log(\u0026#39;methods one \u0026#39;); \t}, }; console.log(game);  Symbol 是原始类型，不是引用类型，不能使用 new。\nSymbol()可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。\nSymbol 类型的值时唯一的，用来解决命名冲突的问题。\nSymbol 类型的值不能于其他数据进行运算\nSymbol 定义的对象属性不能被遍历","title":"JavaScrip Symbol"},{"content":"CET 4 ![CET 4](CET 4.assets/CET 4.png)\n分值性价比 写作性价比 = 710 * 15 % / 30 = 3.55\n听力性价比 = 710 * 35 % / 25 = 9.94\n阅读性价比 = 710 * 35 % / 40 = 6.21\n翻译性价比 = 710 * 15 % / 30 = 3.55\n由此可得：\n题目的性价比：听力 \u0026gt; 阅读 \u0026gt; 作文 \u0026gt; 翻译\n提分简易程度：听力 \u0026gt; 阅读 \u0026gt; 作文 \u0026gt; 翻译\n考场必备  准考证、身份证、学生证（缺一不可）。 2B 铅笔、橡皮、0.5mm 黑色中性笔。 考试专用耳机  ","permalink":"https://note.yxzi.xyz/note/subject/english/cet-4/cet-4/","summary":"CET 4 ![CET 4](CET 4.assets/CET 4.png)\n分值性价比 写作性价比 = 710 * 15 % / 30 = 3.55\n听力性价比 = 710 * 35 % / 25 = 9.94\n阅读性价比 = 710 * 35 % / 40 = 6.21\n翻译性价比 = 710 * 15 % / 30 = 3.55\n由此可得：\n题目的性价比：听力 \u0026gt; 阅读 \u0026gt; 作文 \u0026gt; 翻译\n提分简易程度：听力 \u0026gt; 阅读 \u0026gt; 作文 \u0026gt; 翻译\n考场必备  准考证、身份证、学生证（缺一不可）。 2B 铅笔、橡皮、0.5mm 黑色中性笔。 考试专用耳机  ","title":"English CET 4"},{"content":"there be 某个地方（时候）存在某个东西。\n就近原则 there be 句型中的 be，用哪个格式取决于离 be 最近的主语。\n There is a book,a norebook and two dictionaries on the desk. There are two dictionaries, a book ,a notebook on the desk.  there be 和 have 的区别：\n have：谁拥有某个东西。  there be 否定句  There is no people in the room.  there be 疑问句  Are there ten people in the bedroom.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/there-be/","summary":"there be 某个地方（时候）存在某个东西。\n就近原则 there be 句型中的 be，用哪个格式取决于离 be 最近的主语。\n There is a book,a norebook and two dictionaries on the desk. There are two dictionaries, a book ,a notebook on the desk.  there be 和 have 的区别：\n have：谁拥有某个东西。  there be 否定句  There is no people in the room.  there be 疑问句  Are there ten people in the bedroom.  ","title":"English there be"},{"content":"Translation 选择写基础简单句，越简单越好。\n勉强表达原文意思，可以意译，千万别留空。\n","permalink":"https://note.yxzi.xyz/note/subject/english/cet-4/translation/","summary":"Translation 选择写基础简单句，越简单越好。\n勉强表达原文意思，可以意译，千万别留空。","title":"English Translation"},{"content":"Writing 背万能句 首段\nRecently, the rise in the problem of __ has aroused wide concern.\n近来， **__**问题的增加已经引起了广泛的关注。\nNow there is a growing awareness of the necessity to _\n如今，人们越来越意识到 **__**的必要性。\nDifferent people hold different views about**__** .\n对于**__**，不同的人有不同的看法。\ni think ，**_**have become an essential part of people is life\n我认为， **_**已经成为人们生活中必不可少的一部分\n中段\nTalking about __, the first thing that may occur to you and me seems to be __.\n说到**__，我们首先想到的似乎就是_**\nThe same kind of instance may be easy to cite, but it\u0026rsquo;s enough to show the importance of the _\n类似的例子不胜枚举，但这一个就足以说明**__**的重要性。\nBut other people set forth completely totally different argument concerning this case\n不过，对于此，另一些人则持完全不同的观点。\nThese people think that __ is not very good and has too many deficiencies.\n这些人则认为**__**并不是很好，不足之处太多。\nbut To my mind the advantages far overweigh the drawbacks\n但是我认为， 优点胜过缺点。\n末段\nTo sum up,Now we are entering a new era, full of opportunities and challenges,\n总而言之，现在我们正在进入一个充满机会和挑战的新时代。\n**__**can benefit us tremendously if correctly used.\n如果运用得当，**__**会让我们受益匪浅。\n字迹尽量工整，哪怕写慢一些。\n","permalink":"https://note.yxzi.xyz/note/subject/english/cet-4/writing/","summary":"Writing 背万能句 首段\nRecently, the rise in the problem of __ has aroused wide concern.\n近来， **__**问题的增加已经引起了广泛的关注。\nNow there is a growing awareness of the necessity to _\n如今，人们越来越意识到 **__**的必要性。\nDifferent people hold different views about**__** .\n对于**__**，不同的人有不同的看法。\ni think ，**_**have become an essential part of people is life\n我认为， **_**已经成为人们生活中必不可少的一部分\n中段\nTalking about __, the first thing that may occur to you and me seems to be __.\n说到**__，我们首先想到的似乎就是_**","title":"English Writing"},{"content":"理想视口 开启移动端的理想视口。\n\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width,initial-scale=1.0\u0026#34; /\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/language/html/%E7%90%86%E6%83%B3%E8%A7%86%E5%8F%A3/","summary":"理想视口 开启移动端的理想视口。\n\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width,initial-scale=1.0\u0026#34; /\u0026gt; ","title":"HTML 理想视口"},{"content":"package-lock.json 是在 npm install时候生成一份文件。记录了 node_modules 目录下所有模块（包）的名称、版本号、下载地址、及这个模块又依赖了哪些依赖。\n作用 如果重新 npm install 的时候以及当 node_modules 文件夹并不存在或被删除时，需要用到 npm install 重新装载全部依赖时，通过 package-lock.json 可以直接表明下载地址和相关依赖，就无需再从 package.json 逐个分析包的依赖项，因此会大大加快安装速度，package-lock.json 目的就是确保所有库包与你上次安装的完全一样。\n","permalink":"https://note.yxzi.xyz/note/technology/packagemanager/npm/package-lock.json/","summary":"package-lock.json 是在 npm install时候生成一份文件。记录了 node_modules 目录下所有模块（包）的名称、版本号、下载地址、及这个模块又依赖了哪些依赖。\n作用 如果重新 npm install 的时候以及当 node_modules 文件夹并不存在或被删除时，需要用到 npm install 重新装载全部依赖时，通过 package-lock.json 可以直接表明下载地址和相关依赖，就无需再从 package.json 逐个分析包的依赖项，因此会大大加快安装速度，package-lock.json 目的就是确保所有库包与你上次安装的完全一样。","title":"npm package-lock.json"},{"content":"指针函数 next()和prex()会移动指针，有可能导致指针移出数组，导致\n数组不能使用，此时，无法通过next() 和prex()使指针回到数组，只能通过end()或reset()重置指针。\n","permalink":"https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E7%BB%84/%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0/","summary":"指针函数 next()和prex()会移动指针，有可能导致指针移出数组，导致\n数组不能使用，此时，无法通过next() 和prex()使指针回到数组，只能通过end()或reset()重置指针。","title":"PHP 指针函数"},{"content":"closure php 的 Closure，v 也就是匿名函数。\n匿名函数中，默认无法访问外部函数中的变量。\nfunction demo() {  $a = 1;  function fun()  {  // 无法使用 demo() 中的 $a  echo $a;  };  fun(); }; demo(); 通过 use()将外部变量传入到内部函数的作用域内：\nfunction demo() {  $a = 1;  $fun = function () use ($a) {   echo $a;  };  $fun(); };  demo(); 闭包 匿名函数中的use()，其作用就是从父作用域继承变量，继承之后，就会形成一个闭包。\nfunction demo() {  $a = 1;  $fun = function () use ($a) {   echo $a;  };  return $fun; };  $closure = demo();  $closure(); ","permalink":"https://note.yxzi.xyz/note/technology/language/php/closure/","summary":"closure php 的 Closure，v 也就是匿名函数。\n匿名函数中，默认无法访问外部函数中的变量。\nfunction demo() {  $a = 1;  function fun()  {  // 无法使用 demo() 中的 $a  echo $a;  };  fun(); }; demo(); 通过 use()将外部变量传入到内部函数的作用域内：\nfunction demo() {  $a = 1;  $fun = function () use ($a) {   echo $a;  };  $fun(); };  demo(); 闭包 匿名函数中的use()，其作用就是从父作用域继承变量，继承之后，就会形成一个闭包。\nfunction demo() {  $a = 1;  $fun = function () use ($a) {   echo $a;  };  return $fun; };  $closure = demo();  $closure(); ","title":"PHP closure"},{"content":"echo() 、print()、var_dump()的区别 echo() 输出一个或多个字符串。\necho() 实际不是一个函数（而是语言结构），因此可以不使用()。\nprint() 输出一个或多个字符串。\nprint() 实际不是一个函数（而是语言结构），因此可以不使用()。\nvar_dump() 返回变量的类型与值。\n区别  echo()能接受多个字符串类型的参数，能同时输出多个字符串。当echo()接受多个参数时，不能使用括号。 print()只能接收 1 个字符串类型的参数；只能同时输出一个字符串； print()打印的值能直接赋值给一个变量：`$a = print “123” echo()输出的速度比 print() 快。 echo()没有返回值，而print()有返回值，其返回值永远为int类型的 1。  ","permalink":"https://note.yxzi.xyz/note/technology/language/php/echo-printvar_dump%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"echo() 、print()、var_dump()的区别 echo() 输出一个或多个字符串。\necho() 实际不是一个函数（而是语言结构），因此可以不使用()。\nprint() 输出一个或多个字符串。\nprint() 实际不是一个函数（而是语言结构），因此可以不使用()。\nvar_dump() 返回变量的类型与值。\n区别  echo()能接受多个字符串类型的参数，能同时输出多个字符串。当echo()接受多个参数时，不能使用括号。 print()只能接收 1 个字符串类型的参数；只能同时输出一个字符串； print()打印的值能直接赋值给一个变量：`$a = print “123” echo()输出的速度比 print() 快。 echo()没有返回值，而print()有返回值，其返回值永远为int类型的 1。  ","title":"PHP echo() 、print()、var_dump()的区别"},{"content":"static 静态全局变量与普通全局变量的区别 非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态全局变量在各个源文件中都是有效的。\n静态全局变量的作用域只在当前源文件内， 在同一源程序的其它源文件中不能使用它，因此可以避免变量污染。\n静态局部变量与普通局部变量 静态局部变量只被初始化一次，变量下一次的值依据的是上次的结果值。\n静态函数与普通函数 静态函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。\n作用 拥挤函数的执行次数。\n统计函数多次调用的不同结果。\n","permalink":"https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/static/","summary":"static 静态全局变量与普通全局变量的区别 非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态全局变量在各个源文件中都是有效的。\n静态全局变量的作用域只在当前源文件内， 在同一源程序的其它源文件中不能使用它，因此可以避免变量污染。\n静态局部变量与普通局部变量 静态局部变量只被初始化一次，变量下一次的值依据的是上次的结果值。\n静态函数与普通函数 静态函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。\n作用 拥挤函数的执行次数。\n统计函数多次调用的不同结果。","title":"PHP static"},{"content":"伪类型 用于在 PHP 文档里指示参数可以使用的类型和值，但实际上伪类型在 PHP 中不存在。\nmixed mixed 说明一个参数可以接受多种不同的(但不一定是所有的)类型。\n例如：gettype()可以接受所有的 PHP 类型，str_replace()可以接受字符串和数组，\nnumber number 说明一个参数可以是 integer 或者 float。\ncallback 本文档中在 PHP5.4 引入 callable 类型之前使用了 callback 伪类型，二者涵义完全相同，\narray|object array|object 意思是参数既可以是 array 也可以是 object，\nvoid void 作为返回类型意味着函数的返回值是无用的，\nvoid 作为参数列表意味着函数不接受任何参数，\n","permalink":"https://note.yxzi.xyz/note/technology/language/php/%E4%BC%AA%E7%B1%BB%E5%9E%8B/","summary":"伪类型 用于在 PHP 文档里指示参数可以使用的类型和值，但实际上伪类型在 PHP 中不存在。\nmixed mixed 说明一个参数可以接受多种不同的(但不一定是所有的)类型。\n例如：gettype()可以接受所有的 PHP 类型，str_replace()可以接受字符串和数组，\nnumber number 说明一个参数可以是 integer 或者 float。\ncallback 本文档中在 PHP5.4 引入 callable 类型之前使用了 callback 伪类型，二者涵义完全相同，\narray|object array|object 意思是参数既可以是 array 也可以是 object，\nvoid void 作为返回类型意味着函数的返回值是无用的，\nvoid 作为参数列表意味着函数不接受任何参数，","title":"PHP 伪类型"},{"content":"变量 预定义变量 指的是系统提前定义的变量，存储许多需要用到的数据，并且，预定义变量都 是数组。\n$_GET：获取所有表单以 get 方式提交的数据。\n$_POST：获取所有表单以 post 方式提交的 value。\n$_REQUEST：GET 和 POST 提交的都会保存。\n$_GLOBALS：PHP 中所有的全局变量。\n$_SERVER：服务器信息。\n$_SESSION：获取 session 会话数据。\n$_COOKIE：获取 cookie 的会话数据。\n$_ENV：环境信息。\n$_FILES：用户上传的文件信息。\n可变变量 可变变量就是变量的变量。\n$a = \u0026#39;b\u0026#39;; $b = \u0026#39;bb\u0026#39;; // $$a = $ + $a = $ + b = $b = bb echo $$a;  ","permalink":"https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/%E5%8F%98%E9%87%8F/","summary":"变量 预定义变量 指的是系统提前定义的变量，存储许多需要用到的数据，并且，预定义变量都 是数组。\n$_GET：获取所有表单以 get 方式提交的数据。\n$_POST：获取所有表单以 post 方式提交的 value。\n$_REQUEST：GET 和 POST 提交的都会保存。\n$_GLOBALS：PHP 中所有的全局变量。\n$_SERVER：服务器信息。\n$_SESSION：获取 session 会话数据。\n$_COOKIE：获取 cookie 的会话数据。\n$_ENV：环境信息。\n$_FILES：用户上传的文件信息。\n可变变量 可变变量就是变量的变量。\n$a = \u0026#39;b\u0026#39;; $b = \u0026#39;bb\u0026#39;; // $$a = $ + $a = $ + b = $b = bb echo $$a;  ","title":"PHP 变量"},{"content":"外连接 查询主表中的所有记录，如果从表中有与其匹配的记录，则显示该记录的值；如果从表中没有与其匹配的记录，则显示 Null。\n左外链接 LEFT JOIN 的左侧是主表。\n查询男朋友不在男神表的女神名 SELECT b.name AS Name FROM beauty AS b LEFT OUTER JOIN boys boy ON b.boyfriend_id = boy.id WHERE boy.boyName IS NULL 查询哪些部门没有员工 SELECT department_name FROM departments AS d LEFT OUTER JOIN employees e ON d.department_id = e.department_id WHERE e.department_id IS NULL 右外链接 RIGHT JOIN 的右侧是主表。\n查询男朋友不在男神表的女神名 SELECT b.name AS Name FROM boys boy RIGHT OUTER JOIN beauty AS b ON b.boyfriend_id = boy.id WHERE boy.boyName IS NULL 全外链接 查询主表和从表中的所有记录，当某条记录在另一个表中没有匹配记录时，则这条记录的值为 Null；如果两表之间都有对应的匹配记录时，则显示该记录的值。\n","permalink":"https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%A4%96%E8%BF%9E%E6%8E%A5/","summary":"外连接 查询主表中的所有记录，如果从表中有与其匹配的记录，则显示该记录的值；如果从表中没有与其匹配的记录，则显示 Null。\n左外链接 LEFT JOIN 的左侧是主表。\n查询男朋友不在男神表的女神名 SELECT b.name AS Name FROM beauty AS b LEFT OUTER JOIN boys boy ON b.boyfriend_id = boy.id WHERE boy.boyName IS NULL 查询哪些部门没有员工 SELECT department_name FROM departments AS d LEFT OUTER JOIN employees e ON d.department_id = e.department_id WHERE e.department_id IS NULL 右外链接 RIGHT JOIN 的右侧是主表。\n查询男朋友不在男神表的女神名 SELECT b.name AS Name FROM boys boy RIGHT OUTER JOIN beauty AS b ON b.boyfriend_id = boy.","title":"MySQL 外连接"},{"content":"等值链接 判断不同表中都包含的字段是否相等，相等则显示，不等则过滤。且一般都用=来判断。\n一般需要为表起别名。\n查询员工名、部门名、工种名、并按部门名降序（三表链接） SELECT last_name, department_name,job_title FROM employees e INNER JOIN departments d ON e.department_id = d.department_id INNER JOIN jobs j ON e.job_id = j.job_id ORDER BY department_name DESC; ","permalink":"https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-99/%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/","summary":"等值链接 判断不同表中都包含的字段是否相等，相等则显示，不等则过滤。且一般都用=来判断。\n一般需要为表起别名。\n查询员工名、部门名、工种名、并按部门名降序（三表链接） SELECT last_name, department_name,job_title FROM employees e INNER JOIN departments d ON e.department_id = d.department_id INNER JOIN jobs j ON e.job_id = j.job_id ORDER BY department_name DESC; ","title":"MySQL 等值链接"},{"content":"自链接 判断同一张表中的不同字段是否相等，相等则显示，不相等则过滤。需要给同一张表取不同的别名，让系统分清同一张表中的不同字段。\n查询员工名所对应的领导名 SELECT e.last_name AS employeeName,m.last_name AS managerName FROM employees AS e INNER JOIN employees AS m ON e.manager_id = m.employee_id ","permalink":"https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-99/%E8%87%AA%E8%BF%9E%E6%8E%A5/","summary":"自链接 判断同一张表中的不同字段是否相等，相等则显示，不相等则过滤。需要给同一张表取不同的别名，让系统分清同一张表中的不同字段。\n查询员工名所对应的领导名 SELECT e.last_name AS employeeName,m.last_name AS managerName FROM employees AS e INNER JOIN employees AS m ON e.manager_id = m.employee_id ","title":"MySQL 自链接"},{"content":"非等值链接 查询员工的工资和工资级别，并按工资级别降序 SELECT salary,grade_level FROM employees AS e INNER JOIN job_grades AS g ON e.salary BETWEEN g.lowest_sal AND g.highest_sal ORDER BY grade_level DESC ","permalink":"https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-99/%E9%9D%9E%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/","summary":"非等值链接 查询员工的工资和工资级别，并按工资级别降序 SELECT salary,grade_level FROM employees AS e INNER JOIN job_grades AS g ON e.salary BETWEEN g.lowest_sal AND g.highest_sal ORDER BY grade_level DESC ","title":"MySQL 非等值链接"},{"content":"Props 使组件接收外部传入的数据，且属性是只读的，不可更改的，这叫做单向数据流。若需要修改，可以配合data使用，间接修改props中的数据\n一个组件的属性，应该避免被除了自身以外的组件所更改或控制。\n若同时配置使用 data 和 props ，会优先使用props中的数据。\n传递数据 \u0026lt;Sudent ref=\u0026#34;student\u0026#34; name=\u0026#34;Rainy\u0026#34; :age=\u0026#34;20\u0026#34; sex=\u0026#34;男\u0026#34;\u0026gt;\u0026lt;/Sudent\u0026gt; 接收数据 只接收数据 props: [\u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;sex\u0026#34;], 指定属性值类型 props: {  name: String,  age: Number,  sex: String, }, 限制类型、必要性、指定默认值 props: {  name: {  type: String,  // 属性的值是必须的  required: true,  },  age: {  type: Number,  // 属性的默认值  default: 0,  },   sex: {  type: String,  required: true,  }, }, 间接修改 props 中的数据 使用 data间接的修改 props\n\u0026lt;template\u0026gt;  \u0026lt;div\u0026gt;  \u0026lt;h2\u0026gt;{{ name }}\u0026lt;/h2\u0026gt;  \u0026lt;h3\u0026gt;{{ myAge + 1 }}\u0026lt;/h3\u0026gt;  \u0026lt;h3\u0026gt;{{ sex }}\u0026lt;/h3\u0026gt;  \u0026lt;button @click=\u0026#34;fun\u0026#34;\u0026gt;年龄 + 1\u0026lt;/button\u0026gt;  \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;  \u0026lt;script\u0026gt; export default {  name: \u0026#34;Student\u0026#34;,  data() {  return {  tips: \u0026#34;Hi\u0026#34;,  myAge: this.age,  };  },  props: {  name: {  type: String,  // 属性的值是必须的  required: true,  },  age: {  type: Number,  // 属性的默认值  default: 0,  },  sex: {  type: String,  required: true,  },  },  methods: {  fun() {  this.myAge++;  },  }, }; \u0026lt;/script\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/props/","summary":"Props 使组件接收外部传入的数据，且属性是只读的，不可更改的，这叫做单向数据流。若需要修改，可以配合data使用，间接修改props中的数据\n一个组件的属性，应该避免被除了自身以外的组件所更改或控制。\n若同时配置使用 data 和 props ，会优先使用props中的数据。\n传递数据 \u0026lt;Sudent ref=\u0026#34;student\u0026#34; name=\u0026#34;Rainy\u0026#34; :age=\u0026#34;20\u0026#34; sex=\u0026#34;男\u0026#34;\u0026gt;\u0026lt;/Sudent\u0026gt; 接收数据 只接收数据 props: [\u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;sex\u0026#34;], 指定属性值类型 props: {  name: String,  age: Number,  sex: String, }, 限制类型、必要性、指定默认值 props: {  name: {  type: String,  // 属性的值是必须的  required: true,  },  age: {  type: Number,  // 属性的默认值  default: 0,  },   sex: {  type: String,  required: true,  }, }, 间接修改 props 中的数据 使用 data间接的修改 props","title":"Vue Props"},{"content":"组件 用来实现局部（特定）功能效果的代码集合。\n非单文件组件 一个文件中包含 N 个组件。\n非单文件组件的弊端是：组件的样式没有被封装到当前文件中。\n单文件组件 一个文件中只包含 1 个组件。且该文件是vue后缀的文件。\n一个vue文件中包含着三大部分： template、style 以及 script。\n\u0026lt;template\u0026gt; \t\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;  \u0026lt;script\u0026gt; export default { \ttemplate: ` \u0026lt;div\u0026gt; \u0026lt;h1 class=\u0026#39;h\u0026#39;\u0026gt;{{schoolName}}\u0026lt;/h1\u0026gt; \u0026lt;Student\u0026gt;\u0026lt;/Student\u0026gt; \u0026lt;/div\u0026gt; `, \tdata() { \treturn { \tschoolName: \u0026#39;学校\u0026#39;, \t}; \t}, \tcomponents: { \tStudent, \t}, }; \u0026lt;/script\u0026gt;  \u0026lt;style\u0026gt; .h1 { \tcolor: red; } \u0026lt;/style\u0026gt; 与 Vue 实例的区别 组件是可复用的 Vue 实例，组件的 options和 Vue 实例的options都是相同的。只有 el 和data配置不太一样。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6/","summary":"组件 用来实现局部（特定）功能效果的代码集合。\n非单文件组件 一个文件中包含 N 个组件。\n非单文件组件的弊端是：组件的样式没有被封装到当前文件中。\n单文件组件 一个文件中只包含 1 个组件。且该文件是vue后缀的文件。\n一个vue文件中包含着三大部分： template、style 以及 script。\n\u0026lt;template\u0026gt; \t\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;  \u0026lt;script\u0026gt; export default { \ttemplate: ` \u0026lt;div\u0026gt; \u0026lt;h1 class=\u0026#39;h\u0026#39;\u0026gt;{{schoolName}}\u0026lt;/h1\u0026gt; \u0026lt;Student\u0026gt;\u0026lt;/Student\u0026gt; \u0026lt;/div\u0026gt; `, \tdata() { \treturn { \tschoolName: \u0026#39;学校\u0026#39;, \t}; \t}, \tcomponents: { \tStudent, \t}, }; \u0026lt;/script\u0026gt;  \u0026lt;style\u0026gt; .h1 { \tcolor: red; } \u0026lt;/style\u0026gt; 与 Vue 实例的区别 组件是可复用的 Vue 实例，组件的 options和 Vue 实例的options都是相同的。只有 el 和data配置不太一样。","title":"Vue 组件"},{"content":"debugger debugger 被调用时, 浏览器执行 JavaScrip 代码时会暂停在 debugger 语句的位置，并调用 (如果有) 浏览器的调试器进行调试。例如设置断点。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E/","summary":"debugger debugger 被调用时, 浏览器执行 JavaScrip 代码时会暂停在 debugger 语句的位置，并调用 (如果有) 浏览器的调试器进行调试。例如设置断点。","title":"JavaScrip debugger"},{"content":"HTMLElement 方法 focus() 如果可以，将焦点聚焦在指定的元素上。\n如果是创建的新元素，则必须先将创建的新元素插入到页面中，然后再执行focus()，焦点才能成功聚焦到这个新元素上。如果是先聚焦，再插入，焦点则不会聚焦到新元素上。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/htmlelement/htmlelement/","summary":"HTMLElement 方法 focus() 如果可以，将焦点聚焦在指定的元素上。\n如果是创建的新元素，则必须先将创建的新元素插入到页面中，然后再执行focus()，焦点才能成功聚焦到这个新元素上。如果是先聚焦，再插入，焦点则不会聚焦到新元素上。","title":"JavaScript HTMLElement 方法"},{"content":"使用技巧 强行折叠代码块 #region // 折叠代码 #endregion ","permalink":"https://note.yxzi.xyz/note/technology/softwareuse/vscode/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","summary":"使用技巧 强行折叠代码块 #region // 折叠代码 #endregion ","title":"Vs Code 使用技巧"},{"content":"v-cloak 一个没有值的指令。通常配合 CSS 一起用，可以隐藏未经 Vue 解析且带有{{}}的元素，直到 Vue 实例创建完毕。\nVue 实例创建完毕后，元素上的 v-cloak被删除。\nHTML\n\u0026lt;div v-cloak\u0026gt;  {{ message }} \u0026lt;/div\u0026gt; CSS\n[v-cloak] { \tdisplay: none; } 该div不会显示，直到 Vue 实例创建完毕。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-cloak/","summary":"v-cloak 一个没有值的指令。通常配合 CSS 一起用，可以隐藏未经 Vue 解析且带有{{}}的元素，直到 Vue 实例创建完毕。\nVue 实例创建完毕后，元素上的 v-cloak被删除。\nHTML\n\u0026lt;div v-cloak\u0026gt;  {{ message }} \u0026lt;/div\u0026gt; CSS\n[v-cloak] { \tdisplay: none; } 该div不会显示，直到 Vue 实例创建完毕。","title":"Vue v-cloak"},{"content":"v-html 设置元素的 innerHTML，会覆盖元素中的所有内容。但与v-text不同的是，它会识别 HTML 元素\n安全性 在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;div v-html=\u0026#34;msg\u0026#34;\u0026gt;原内容\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; JavaScrip\nvar vm = new Vue({\rel: \u0026#39;#app\u0026#39;,\rdata: {\rmsg: \u0026#39;\u0026lt;a href=javascript:location.href=\u0026#34;http://www.baidu.com?\u0026#34; + document.cookie\u0026gt;XXS 攻击\u0026lt;/a\u0026gt; \u0026#39;,\r},\r});\rVue.config.productionTip = false; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-html/","summary":"v-html 设置元素的 innerHTML，会覆盖元素中的所有内容。但与v-text不同的是，它会识别 HTML 元素\n安全性 在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;div v-html=\u0026#34;msg\u0026#34;\u0026gt;原内容\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; JavaScrip\nvar vm = new Vue({\rel: \u0026#39;#app\u0026#39;,\rdata: {\rmsg: \u0026#39;\u0026lt;a href=javascript:location.href=\u0026#34;http://www.baidu.com?\u0026#34; + document.cookie\u0026gt;XXS 攻击\u0026lt;/a\u0026gt; \u0026#39;,\r},\r});\rVue.config.productionTip = false; ","title":"Vue v-html"},{"content":"v-once 一个没有值的指令。只渲染当前元素一次。之后该元素被视为静态内容。可以用于优化性能。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-once/","summary":"v-once 一个没有值的指令。只渲染当前元素一次。之后该元素被视为静态内容。可以用于优化性能。","title":"Vue v-once"},{"content":"v-pre 跳过当前元素和它的子元素的编译过程。使页面显示原始 Mustache 元素。\n用于跳过大量没有使用指令的元素，这会加快编译速度。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-pre/","summary":"v-pre 跳过当前元素和它的子元素的编译过程。使页面显示原始 Mustache 元素。\n用于跳过大量没有使用指令的元素，这会加快编译速度。","title":"Vue v-pre"},{"content":"v-text 设置元素的文本内容。会覆盖元素中的所有内容。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-text/","summary":"v-text 设置元素的文本内容。会覆盖元素中的所有内容。","title":"Vue v-text"},{"content":"实例方法 ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/","summary":"实例方法 ","title":"Vue 实例方法"},{"content":"生命周期函数 在 Vue 的创建、使用、销毁过程中，会有许多事件，这些事件就被统称为生命周期函数，也叫作生命周期钩子。\n生命周期函数的名字不可更改，但函数中的代码由我们自定义。\n生命周期函数中的 this 的指向是 Vue 实例或组件实例对象。\nbeforeCreate() 在实例初始化之后，进行数据侦听和数据代理之前调用\ncreated() 在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，\nbeforeMount() 在挂载开始之前被调用。\nmounted() 把初始的真实 DOM 树插入到页面后，即 Vue 实例挂载完毕后调用。\n此时一般开始发送 Ajax 请求、启动定时器、绑定自定义事件、订阅消息等初始化操作。\nbeforeUpdate 在数据发生改变后，DOM 被更新之前被调用。此时的数据已经被改变，但页面中不是最新的数据。\nupdated() 此时的数据已经被改变，且页面中也是最新的数据。\nbeforeDestroy() 实例销毁之前调用。在这一步，实例仍然完全可用。但无法引起页面中的数据更新。\n此时一般开始清除定时器、解绑自定义事件、取消订阅消息等收尾操作。\n一般不在该流程操作数据，因为在此时改变数据，并不会引起页面中的数据更新。\ndestroyed() 实例销毁后调用。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/","summary":"生命周期函数 在 Vue 的创建、使用、销毁过程中，会有许多事件，这些事件就被统称为生命周期函数，也叫作生命周期钩子。\n生命周期函数的名字不可更改，但函数中的代码由我们自定义。\n生命周期函数中的 this 的指向是 Vue 实例或组件实例对象。\nbeforeCreate() 在实例初始化之后，进行数据侦听和数据代理之前调用\ncreated() 在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，\nbeforeMount() 在挂载开始之前被调用。\nmounted() 把初始的真实 DOM 树插入到页面后，即 Vue 实例挂载完毕后调用。\n此时一般开始发送 Ajax 请求、启动定时器、绑定自定义事件、订阅消息等初始化操作。\nbeforeUpdate 在数据发生改变后，DOM 被更新之前被调用。此时的数据已经被改变，但页面中不是最新的数据。\nupdated() 此时的数据已经被改变，且页面中也是最新的数据。\nbeforeDestroy() 实例销毁之前调用。在这一步，实例仍然完全可用。但无法引起页面中的数据更新。\n此时一般开始清除定时器、解绑自定义事件、取消订阅消息等收尾操作。\n一般不在该流程操作数据，因为在此时改变数据，并不会引起页面中的数据更新。\ndestroyed() 实例销毁后调用。","title":"Vue 生命周期函数"},{"content":"生命周期流程 flowchart TD;\rnewVue[\u0026#34;new Vue()\u0026#34;] --\u0026gt; init[\u0026#34;初始化：事件、生命周期、但数据代理未开始。\u0026#34;];\rinit --\u0026gt; beforeCraeate[\u0026#34;beforeCraeate()：此时无法通过 vm 访问 data 中的数据，以及 methods 中的方法。\u0026#34;];\rbeforeCraeate --\u0026gt; againInit[\u0026#34;初始化：数据检测、数据代理。\u0026#34;];\ragainInit ---\u0026gt;created[\u0026#34;created()：可以通过 vm 访问到 data 中的数据，以及 methods 中的方法。\u0026#34;];\rcreated --\u0026gt; 挂载流程开始\r挂载流程开始 --\u0026gt; el[\u0026#34;是否配置 el 选项？\u0026#34;]\rel --\u0026gt;|Yse| template[\u0026#34;是否配置 template 选项？\u0026#34;];\rel --\u0026gt;|No| $mount[\u0026#34;当 vm.$mount(el) 调用的时候\u0026#34;];\r$mount --\u0026gt;template;\rtemplate --\u0026gt;|Yes| compileTemplate[\u0026#34;编译 template 到 render() 中\u0026#34;]\rcompileTemplate --\u0026gt;stageOne\rtemplate --\u0026gt;|No|compileEl[\u0026#34;编译 el 指定元的outerHTML 作为 template\u0026#34;];\rcompileEl --\u0026gt; stageOne[\u0026#34;此阶段 Vue 开始解析模板，生成虚拟 DOM（内存中），但页面还无法显示解析好的内容。\u0026#34;]\rstageOne ---\u0026gt;beforeMount[\u0026#34;beforeMount()：此时，页面呈现的是未经 Vue 编译的 DOM 结构。\u0026lt;/br\u0026gt; 此时，所有对 DOM 的操作，最终都没有效果（在 beforeMount 之前才有效果）。\u0026#34;];\rbeforeMount --\u0026gt; $el[\u0026#34;将内存中的虚拟 DOM 转化为真实 DOM 插入到页面。（还将真实 DOM 拷贝了一份在 $el 中）\u0026#34;]\r$el --\u0026gt; mouted[\u0026#34;mouted()：页面中呈现的都是经过 Vue 编译到 DOM。\u0026lt;/br\u0026gt; 对 DOM 的操作均有效（但尽可能避免），至此初始化过程结束，一般在此进行：开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作。\u0026#34;]\rmouted ---\u0026gt;mountEnd[\u0026#34;mouted()：此时，挂载流程结束。更新流程开始\u0026#34;];\rmountEnd --\u0026gt; changes[\u0026#34;当 data 中的数据发生变化\u0026#34;];\rchanges --\u0026gt; beforeUpdate[\u0026#34;beforeUpdate()：此时，data 中的数据是新的，但页面中的数据是旧的，即：页面尚未和最新的数据保持同步。\u0026#34;];\rbeforeUpdate --\u0026gt; compareVNode[\u0026#34;根据新数据，生成新的虚拟 DOM，随后与旧的虚拟DOM进行比对，最终完成页面更新，即：完成了 Model —\u0026gt; view 的更新\u0026#34;];\rcompareVNode --\u0026gt; updated[\u0026#34;updated()：此时，数据和页面都是最新的（方法和数据都可用，且能引起页面上的数据更新），即：页面和数据保持同步。\u0026#34;];\rupdated --\u0026gt; mountEnd;\rupdated ---\u0026gt; $destroy[\u0026#34;vm.$destroy() 被调用：开始销毁一个实例。清理它与其它组件实例的连接，解绑 vm 的全部指令及自定义事件（并非模板中的 @ 事件）。\u0026#34;];\r$destroy --\u0026gt; beforeDestroy[\u0026#34;beforeDestroy()：实例销毁之前调用。此时，实例中的 data、methods、指令等，都处于可用状态（但是，虽然方法和数据都能正常访问和执行，但并不能引起页面上的数据更新），\u0026lt;/\u0026gt;已经马上要执行销毁的过程。一般在此阶段执行：关闭定时器、取消订阅消息、解绑自定义事件等收尾操作。\u0026#34;]\rbeforeDestroy --\u0026gt; destroyed[\u0026#34;destroyed()：实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的自定义事件监听器被移除，所有的子实例也都被销毁。\u0026#34;] ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B/","summary":"生命周期流程 flowchart TD;\rnewVue[\u0026#34;new Vue()\u0026#34;] --\u0026gt; init[\u0026#34;初始化：事件、生命周期、但数据代理未开始。\u0026#34;];\rinit --\u0026gt; beforeCraeate[\u0026#34;beforeCraeate()：此时无法通过 vm 访问 data 中的数据，以及 methods 中的方法。\u0026#34;];\rbeforeCraeate --\u0026gt; againInit[\u0026#34;初始化：数据检测、数据代理。\u0026#34;];\ragainInit ---\u0026gt;created[\u0026#34;created()：可以通过 vm 访问到 data 中的数据，以及 methods 中的方法。\u0026#34;];\rcreated --\u0026gt; 挂载流程开始\r挂载流程开始 --\u0026gt; el[\u0026#34;是否配置 el 选项？\u0026#34;]\rel --\u0026gt;|Yse| template[\u0026#34;是否配置 template 选项？\u0026#34;];\rel --\u0026gt;|No| $mount[\u0026#34;当 vm.$mount(el) 调用的时候\u0026#34;];\r$mount --\u0026gt;template;\rtemplate --\u0026gt;|Yes| compileTemplate[\u0026#34;编译 template 到 render() 中\u0026#34;]\rcompileTemplate --\u0026gt;stageOne\rtemplate --\u0026gt;|No|compileEl[\u0026#34;编译 el 指定元的outerHTML 作为 template\u0026#34;];\rcompileEl --\u0026gt; stageOne[\u0026#34;此阶段 Vue 开始解析模板，生成虚拟 DOM（内存中），但页面还无法显示解析好的内容。\u0026#34;]\rstageOne ---\u0026gt;beforeMount[\u0026#34;beforeMount()：此时，页面呈现的是未经 Vue 编译的 DOM 结构。\u0026lt;/br\u0026gt; 此时，所有对 DOM 的操作，最终都没有效果（在 beforeMount 之前才有效果）。\u0026#34;];\rbeforeMount --\u0026gt; $el[\u0026#34;将内存中的虚拟 DOM 转化为真实 DOM 插入到页面。（还将真实 DOM 拷贝了一份在 $el 中）\u0026#34;]\r$el --\u0026gt; mouted[\u0026#34;mouted()：页面中呈现的都是经过 Vue 编译到 DOM。\u0026lt;/br\u0026gt; 对 DOM 的操作均有效（但尽可能避免），至此初始化过程结束，一般在此进行：开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作。\u0026#34;]\rmouted ---\u0026gt;mountEnd[\u0026#34;mouted()：此时，挂载流程结束。更新流程开始\u0026#34;];\rmountEnd --\u0026gt; changes[\u0026#34;当 data 中的数据发生变化\u0026#34;];\rchanges --\u0026gt; beforeUpdate[\u0026#34;beforeUpdate()：此时，data 中的数据是新的，但页面中的数据是旧的，即：页面尚未和最新的数据保持同步。\u0026#34;];\rbeforeUpdate --\u0026gt; compareVNode[\u0026#34;根据新数据，生成新的虚拟 DOM，随后与旧的虚拟DOM进行比对，最终完成页面更新，即：完成了 Model —\u0026gt; view 的更新\u0026#34;];\rcompareVNode --\u0026gt; updated[\u0026#34;updated()：此时，数据和页面都是最新的（方法和数据都可用，且能引起页面上的数据更新），即：页面和数据保持同步。\u0026#34;];\rupdated --\u0026gt; mountEnd;\rupdated ---\u0026gt; $destroy[\u0026#34;vm.","title":"Vue 生命周期流程"},{"content":"自定义指令 定义指令时，指令名不加v-，使用的时候需要加v-。\n指令名如果是多个单词，多个单词用-隔开。\ndirectives 局部自定义指令，一个指令就是一个函数或对象。\ndirectives中出现的this 都指向 Window。\n函数式 函数中有两个参数：\n element：指令所在的 DOM 元素。 binding：一个对象，其中的value 属性就是自定义指令的属性值。  会在什么时候被调用？\n  指令与元素绑定成功时（初始化）会被调用。但此时元素还没有被 Vue 解析并插入到页面，这会导致在directives中，某些方法不能及时的生效。比如focus()。\n  指令所在的模板被重新解析时。\n  HTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \t\u0026lt;h2\u0026gt;当前 n 的值为：{{n}}\u0026lt;/h2\u0026gt; \t\u0026lt;h3\u0026gt;放大十倍后的 n 为 ：\u0026lt;span v-big=\u0026#34;n\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/h3\u0026gt; \t\u0026lt;button @click=\u0026#34;n++\u0026#34;\u0026gt;点击后 n++\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; JavaScrip\nvar vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \tn: 1, \t}, \tdirectives: { \tbig(element, binding) { \telement.innerText = binding.value * 10; \t}, \t}, });  Vue.config.productionTip = false; 对象式 对象中有三个函数：\n bind()：当指令与元素绑定成功时（初始化），此时元素还没有被 Vue 解析并插入到页面，这会导致自定义属性时，某些方法不能及时的生效。比如focous()。 inserted：指令所在的元素已经被插入到页面时。 update：指令所在的模板被重新解析时。  HTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \t\u0026lt;h2\u0026gt;当前 n 的值为：{{n}}\u0026lt;/h2\u0026gt; \t\u0026lt;h2\u0026gt;放大 100 倍的值：\u0026lt;/h2\u0026gt; \t\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; v-focus-bind=\u0026#34;n\u0026#34; /\u0026gt; \t\u0026lt;button @click=\u0026#34;n++\u0026#34;\u0026gt;点击后 n++\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; JavaScript\nvar vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \tn: 1, \t}, \tdirectives: { \t\u0026#39;focus-bind\u0026#39;: { \tbind(element, binding) { \telement.value = binding.value; \t}, \tinserted(element, binding) { \telement.focus(); \t}, \tupdate(element, binding) { \telement.value = binding.value * 100; \t}, \t}, \t}, });  Vue.config.productionTip = false; directive 全局自定义指令。不同 Vue 实例都可以通用的自定义指令。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;h2\u0026gt;当前 n 的值为：{{n}}\u0026lt;/h2\u0026gt;  \u0026lt;h2\u0026gt;放大 100 倍的值：\u0026lt;/h2\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; v-focus-bind=\u0026#34;n\u0026#34;\u0026gt;  \u0026lt;button @click=\u0026#34;n++\u0026#34;\u0026gt;点击后 n++\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; JavaScript\n// 全局自定义指令 Vue.directive(\u0026#39;focus-bind\u0026#39;, { \tbind(element, binding) { \telement.value = binding.value; \t}, \tinserted(element, binding) { \telement.focus(); \t}, \tupdate(element, binding) { \telement.value = binding.value * 100; \t}, }); var vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \tn: 1, \t}, });  Vue.config.productionTip = false; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","summary":"自定义指令 定义指令时，指令名不加v-，使用的时候需要加v-。\n指令名如果是多个单词，多个单词用-隔开。\ndirectives 局部自定义指令，一个指令就是一个函数或对象。\ndirectives中出现的this 都指向 Window。\n函数式 函数中有两个参数：\n element：指令所在的 DOM 元素。 binding：一个对象，其中的value 属性就是自定义指令的属性值。  会在什么时候被调用？\n  指令与元素绑定成功时（初始化）会被调用。但此时元素还没有被 Vue 解析并插入到页面，这会导致在directives中，某些方法不能及时的生效。比如focus()。\n  指令所在的模板被重新解析时。\n  HTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \t\u0026lt;h2\u0026gt;当前 n 的值为：{{n}}\u0026lt;/h2\u0026gt; \t\u0026lt;h3\u0026gt;放大十倍后的 n 为 ：\u0026lt;span v-big=\u0026#34;n\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/h3\u0026gt; \t\u0026lt;button @click=\u0026#34;n++\u0026#34;\u0026gt;点击后 n++\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; JavaScrip\nvar vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \tn: 1, \t}, \tdirectives: { \tbig(element, binding) { \telement.","title":"Vue 自定义指令"},{"content":"Math 方法 random() 返回一个 0（= 0）到 1（\u0026lt; 1）的随机数。\nfloor() 向下取整，返回一个小于或等于指定数字的最大整数。\nceil() 向上取整，返回一个大于或等于指定数字的最小整数。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/math/math-%E6%96%B9%E6%B3%95/","summary":"Math 方法 random() 返回一个 0（= 0）到 1（\u0026lt; 1）的随机数。\nfloor() 向下取整，返回一个小于或等于指定数字的最大整数。\nceil() 向上取整，返回一个大于或等于指定数字的最小整数。","title":"JavaScript Math 方法"},{"content":"匿名函数 指没有名称的函数。如果单独只写一个匿名函数，此时是不符合语法要求的会报错。\nfunction () { \tconsole.log(\u0026#39;该函数会报错\u0026#39;); }; 需要给匿名函数包裹一个括号，使之成为函数表达式。\n(function (a, b) { \tconsole.log(\u0026#39;匿名函数表达式\u0026#39;); })(); 也可以将一个匿名函数赋给一个变量，再通过变量来调用这个匿名函数。\nvar demo = function () { \tconsole.log(\u0026#39;匿名函数表达式\u0026#39;); }; demo(); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/","summary":"匿名函数 指没有名称的函数。如果单独只写一个匿名函数，此时是不符合语法要求的会报错。\nfunction () { \tconsole.log(\u0026#39;该函数会报错\u0026#39;); }; 需要给匿名函数包裹一个括号，使之成为函数表达式。\n(function (a, b) { \tconsole.log(\u0026#39;匿名函数表达式\u0026#39;); })(); 也可以将一个匿名函数赋给一个变量，再通过变量来调用这个匿名函数。\nvar demo = function () { \tconsole.log(\u0026#39;匿名函数表达式\u0026#39;); }; demo(); ","title":"JavaScript 匿名函数"},{"content":"回调函数 将 A 函数当作 B 函数的参数，并被 B 函数调用，则 A 函数是 B 函数的回调函数。\n一般的函数调用，可以称作是调用，然而执行时才将某个函数传入再调用的调用方式，被称为回调。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","summary":"回调函数 将 A 函数当作 B 函数的参数，并被 B 函数调用，则 A 函数是 B 函数的回调函数。\n一般的函数调用，可以称作是调用，然而执行时才将某个函数传入再调用的调用方式，被称为回调。","title":"JavaScript 回调函数"},{"content":"v-bind 单项数据绑，数据只能从 data 流向页面。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;img v-bind:src=\u0026#34;url\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; JavaScrip\nvar app = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \turl: \u0026#39;https://img1.baidu.com/it/u=999074466,1525171260\u0026amp;fm=253\u0026amp;fmt=auto\u0026amp;app=138\u0026amp;f=JPEG?w=500\u0026amp;h=333\u0026#39;, \t}, }); Vue.config.productionTip = false; 简写\n\u0026lt;!-- 完整语法 --\u0026gt; \u0026lt;a v-bind:href=\u0026#34;url\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt;  \u0026lt;!-- 简写 --\u0026gt; \u0026lt;a :href=\u0026#34;url\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-bind/","summary":"v-bind 单项数据绑，数据只能从 data 流向页面。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;img v-bind:src=\u0026#34;url\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; JavaScrip\nvar app = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \turl: \u0026#39;https://img1.baidu.com/it/u=999074466,1525171260\u0026amp;fm=253\u0026amp;fmt=auto\u0026amp;app=138\u0026amp;f=JPEG?w=500\u0026amp;h=333\u0026#39;, \t}, }); Vue.config.productionTip = false; 简写\n\u0026lt;!-- 完整语法 --\u0026gt; \u0026lt;a v-bind:href=\u0026#34;url\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt;  \u0026lt;!-- 简写 --\u0026gt; \u0026lt;a :href=\u0026#34;url\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt; ","title":"Vue v-bind"},{"content":"过滤器 对数据进行格式化后再显示。\n一般用在{{}}或v-bind之中，\n过滤器不会改变原来的数据。\nfilters 局部过滤器，只能在啊当前 Vue 实例中使用的过滤器。它将|之前的数据当作参数，并传递给在|之后的过滤函数，并作为该过滤函数的参数。\n过滤函数的返回值会被作为最终值解析到模板中。\n传参 过滤函数除了可以将在|之前的数据当作第一个实参时，还能接受额外的其他参数。\n串联 过滤器中的多个过滤函数可以串联，用|将不同的过滤器函数分开，前一个函数的返回值会被当作后一个函数的实参。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \t\u0026lt;!-- 过滤器 --\u0026gt; \t\u0026lt;h3\u0026gt;Vue - filters：{{time | timeFmt}}\u0026lt;/h3\u0026gt; \t\u0026lt;!-- 过滤器地传参 --\u0026gt; \t\u0026lt;h3\u0026gt;Vue - filters：{{time | timeFmt(\u0026#39;YYYY——MM——DD\u0026#39;)}}\u0026lt;/h3\u0026gt; \t\u0026lt;!-- 过滤器串联 --\u0026gt; \t\u0026lt;h3\u0026gt;Vue - filters：{{time | timeFmt(\u0026#39;YYYY——MM——DD\u0026#39;) | mySlice(\u0026#39;YYYY\u0026#39;)}}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; JavaScrip\nvar vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \tmsg: \u0026#39;局部过滤器\u0026#39;, \ttime: 1653135479429, \t}, \tfilters: { \ttimeFmt(val, str = \u0026#39;YYYY年MM月DD日\u0026#39;) { \treturn dayjs(val).format(str); \t}, \tmySlice(val) { \treturn val.slice(0, 4) + \u0026#39; 年\u0026#39;; \t}, \t}, });  Vue.config.productionTip = false; filter 全局过滤器，不同 Vue 实例都可以通用的过滤器。\n当全局过滤器和局部过滤器重名时，会采用局部过滤器。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;!-- 全局过滤器 --\u0026gt;  \u0026lt;h3 v-bind:id=\u0026#34;msg | mySlice\u0026#34;\u0026gt;全局过滤器\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; JavaScript\n// 全局过滤器 Vue.filter(\u0026#39;mySlice\u0026#39;, function () { \treturn val.slice(0, 4) + \u0026#39; 年\u0026#39;; }); var vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \tmsg: \u0026#39;全局过滤器\u0026#39;, \ttime: 1653135479429, \t}, });  Vue.config.productionTip = false; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E8%BF%87%E6%BB%A4%E5%99%A8/","summary":"过滤器 对数据进行格式化后再显示。\n一般用在{{}}或v-bind之中，\n过滤器不会改变原来的数据。\nfilters 局部过滤器，只能在啊当前 Vue 实例中使用的过滤器。它将|之前的数据当作参数，并传递给在|之后的过滤函数，并作为该过滤函数的参数。\n过滤函数的返回值会被作为最终值解析到模板中。\n传参 过滤函数除了可以将在|之前的数据当作第一个实参时，还能接受额外的其他参数。\n串联 过滤器中的多个过滤函数可以串联，用|将不同的过滤器函数分开，前一个函数的返回值会被当作后一个函数的实参。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \t\u0026lt;!-- 过滤器 --\u0026gt; \t\u0026lt;h3\u0026gt;Vue - filters：{{time | timeFmt}}\u0026lt;/h3\u0026gt; \t\u0026lt;!-- 过滤器地传参 --\u0026gt; \t\u0026lt;h3\u0026gt;Vue - filters：{{time | timeFmt(\u0026#39;YYYY——MM——DD\u0026#39;)}}\u0026lt;/h3\u0026gt; \t\u0026lt;!-- 过滤器串联 --\u0026gt; \t\u0026lt;h3\u0026gt;Vue - filters：{{time | timeFmt(\u0026#39;YYYY——MM——DD\u0026#39;) | mySlice(\u0026#39;YYYY\u0026#39;)}}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; JavaScrip\nvar vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \tmsg: \u0026#39;局部过滤器\u0026#39;, \ttime: 1653135479429, \t}, \tfilters: { \ttimeFmt(val, str = \u0026#39;YYYY年MM月DD日\u0026#39;) { \treturn dayjs(val).","title":"Vue 过滤器"},{"content":"递推 从初值出发反复进行某一运算得到所需的结果。\n从已知到未知，从小到大（比如每年长高 9cm，20 则长高年 180 cm，30 年后则长高 270 cm）\nfunction Recursion(n) { \tlet start = 0; \tlet fn = 1; \tfor (let i = 0; i \u0026lt; n; i++) { \tlet t = fn; \tconsole.log(t); \tfn = fn + start; \tstart = t; \t} \treturn fn; }  console.log(Recursion(5)); ","permalink":"https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%80%92%E6%8E%A8/","summary":"递推 从初值出发反复进行某一运算得到所需的结果。\n从已知到未知，从小到大（比如每年长高 9cm，20 则长高年 180 cm，30 年后则长高 270 cm）\nfunction Recursion(n) { \tlet start = 0; \tlet fn = 1; \tfor (let i = 0; i \u0026lt; n; i++) { \tlet t = fn; \tconsole.log(t); \tfn = fn + start; \tstart = t; \t} \treturn fn; }  console.log(Recursion(5)); ","title":"递推"},{"content":"input 输入框。\n为input 设置不同的 type 属性，可以变化为多种形态。\nradio 单选框。\n需要为多个单选按钮设置相同的 name 值。\n性别： \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; id=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; id=\u0026#34;\u0026#34; /\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/language/html/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/input/","summary":"input 输入框。\n为input 设置不同的 type 属性，可以变化为多种形态。\nradio 单选框。\n需要为多个单选按钮设置相同的 name 值。\n性别： \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; id=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; id=\u0026#34;\u0026#34; /\u0026gt; ","title":"HTML input"},{"content":"修饰符 lazy 默认情况下，v-model会实时的同步元素中的数据，但如果添加了lazy，则数据会在当前元素失去焦点的时候同步元素中的数据。\ntrim 自动过滤输入框中的首尾空白字符。\nnumber 自动将输入框中的内容转为数值类型。\n通常是将字符串转换为数值。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/%E4%BF%AE%E9%A5%B0%E7%AC%A6/","summary":"修饰符 lazy 默认情况下，v-model会实时的同步元素中的数据，但如果添加了lazy，则数据会在当前元素失去焦点的时候同步元素中的数据。\ntrim 自动过滤输入框中的首尾空白字符。\nnumber 自动将输入框中的内容转为数值类型。\n通常是将字符串转换为数值。","title":"Vue 修饰符"},{"content":"v-model 双向数据绑定，常用于表单元素（有 value 值）。\n双向绑定是指：数据不仅能从 data 流向页面，也能从页面流向 data。\n该指令是v-on与v-bind的复合版。\n\u0026lt;!-- 类似于语法糖的写法 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;h1\u0026gt;{{text}}\u0026lt;/h1\u0026gt;  \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 相当于这样写--\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;h1\u0026gt;{{text}}\u0026lt;/h1\u0026gt;  \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;text\u0026#34; @input=\u0026#34;text = $event.target.value\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/v-model/","summary":"v-model 双向数据绑定，常用于表单元素（有 value 值）。\n双向绑定是指：数据不仅能从 data 流向页面，也能从页面流向 data。\n该指令是v-on与v-bind的复合版。\n\u0026lt;!-- 类似于语法糖的写法 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;h1\u0026gt;{{text}}\u0026lt;/h1\u0026gt;  \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 相当于这样写--\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;h1\u0026gt;{{text}}\u0026lt;/h1\u0026gt;  \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;text\u0026#34; @input=\u0026#34;text = $event.target.value\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; ","title":"Vue v-model"},{"content":"收集表单数据 用 v-model 在表单 input textarea及 select 上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。\ntype = radio 则v-mode1收 集的是value值，且要给不同的\u0026lt;input type=\u0026quot;radio\u0026quot; /\u0026gt;配置 相同的value 值。\ntype = checkbox  没有配置 input 的value属性，那么v-mode1收集的就是一个布尔值（勾选 or 未勾选，） 配置input的value属性:  v- mode1的初始值是非数组，那么收集的就是布尔值（勾选 or 未勾选） v-mode1的初始值是数组，那么v-mode1收集的的就是value的属性值所组成的数组。    备注: v-mode1 的 三个修饰符:\n lazy:失去焦点再收集数据 number:输入字符串转为有效的数字 trim:输入首尾空格过滤  HTML\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;   \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt;  \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt;  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt;  \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;title\u0026gt;学习\u0026lt;/title\u0026gt;  \u0026lt;style\u0026gt;   \u0026lt;/style\u0026gt;  \u0026lt;/head\u0026gt;   \u0026lt;body\u0026gt;  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;form\u0026gt;  账号：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; v-model.trim=\u0026#34;userInfo.account\u0026#34;\u0026gt;  \u0026lt;/br\u0026gt;\u0026lt;/br\u0026gt;  密码：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; v-model=\u0026#34;userInfo.password\u0026#34;\u0026gt;  \u0026lt;/br\u0026gt;\u0026lt;/br\u0026gt;  性别：  男：\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; id=\u0026#34;\u0026#34; v-model=\u0026#34;userInfo.sex\u0026#34; value=\u0026#34;male\u0026#34;\u0026gt;  女：\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; id=\u0026#34;\u0026#34; v-model=\u0026#34;userInfo.sex\u0026#34; value=\u0026#34;female\u0026#34;\u0026gt;  \u0026lt;/br\u0026gt;\u0026lt;/br\u0026gt;  年龄：\u0026lt;input type=\u0026#34;number\u0026#34; v-model.number=\u0026#34;userInfo.age\u0026#34;\u0026gt;  \u0026lt;/br\u0026gt;\u0026lt;/br\u0026gt;  爱好：  study：\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;study\u0026#34; v-model=\u0026#34;userInfo.hobby\u0026#34;\u0026gt;  games：\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;games\u0026#34; v-model=\u0026#34;userInfo.hobby\u0026#34;\u0026gt;  sports\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;sports\u0026#34; v-model=\u0026#34;userInfo.hobby\u0026#34;\u0026gt;  \u0026lt;/br\u0026gt;\u0026lt;/br\u0026gt;  所属校区：\u0026lt;select name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; v-model=\u0026#34;userInfo.city\u0026#34;\u0026gt;  \u0026lt;option value=\u0026#34;\u0026#34;\u0026gt;请选择校区\u0026lt;/option\u0026gt;  \u0026lt;option value=\u0026#34;sh\u0026#34;\u0026gt;上海\u0026lt;/option\u0026gt;  \u0026lt;option value=\u0026#34;bj\u0026#34;\u0026gt;北京\u0026lt;/option\u0026gt;  \u0026lt;option value=\u0026#34;gz\u0026#34;\u0026gt;贵州\u0026lt;/option\u0026gt;  \u0026lt;/select\u0026gt;   \u0026lt;/br\u0026gt;\u0026lt;/br\u0026gt;  其他信息：\u0026lt;textarea name=\u0026#34;\u0026#34; v-model=\u0026#34;userInfo.other\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt;  \u0026lt;/br\u0026gt;\u0026lt;/br\u0026gt;   \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; v-model=\u0026#34;userInfo.agree\u0026#34;\u0026gt; 阅读并接受\u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;《用户协议》\u0026lt;/a\u0026gt;  \u0026lt;/br\u0026gt;\u0026lt;/br\u0026gt;  \u0026lt;button @click.prevent=\u0026#34;submit\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt;  \u0026lt;/form\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;/body\u0026gt;  \u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;/html\u0026gt; JavaScript\nvar vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \tuserInfo: { \taccount: \u0026#39;\u0026#39;, \tpassword: \u0026#39;\u0026#39;, \tsex: \u0026#39;\u0026#39;, \tage: \u0026#39;\u0026#39;, \t// 双向绑定 checkbox 时：复选框必须设置 \thobby: [\u0026#39;study\u0026#39;, \u0026#39;games\u0026#39;, \u0026#39;sports\u0026#39;], \tcity: \u0026#39;\u0026#39;, \tother: \u0026#39;\u0026#39;, \tagree: \u0026#39;\u0026#39;, \t}, \t}, \tmethods: { \tsubmit() { \tconsole.log(JSON.stringify(this.userInfo)); \t}, \t}, });  Vue.config.productionTip = false; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE/","summary":"收集表单数据 用 v-model 在表单 input textarea及 select 上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。\ntype = radio 则v-mode1收 集的是value值，且要给不同的\u0026lt;input type=\u0026quot;radio\u0026quot; /\u0026gt;配置 相同的value 值。\ntype = checkbox  没有配置 input 的value属性，那么v-mode1收集的就是一个布尔值（勾选 or 未勾选，） 配置input的value属性:  v- mode1的初始值是非数组，那么收集的就是布尔值（勾选 or 未勾选） v-mode1的初始值是数组，那么v-mode1收集的的就是value的属性值所组成的数组。    备注: v-mode1 的 三个修饰符:\n lazy:失去焦点再收集数据 number:输入字符串转为有效的数字 trim:输入首尾空格过滤  HTML\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;   \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt;  \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt;  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt;  \u0026lt;script src=\u0026#34;https://cdn.","title":"Vue 收集表单数据"},{"content":"数据响应式 data 发生变化，视图会自动变化。\n数据代理 通过一个对象代理对另一个对象中的属性的操作（读/写）.\n在 Vue 中，通过 vm 来代理 data 中的属性操作（即操作 vm，就相当于操作 data），使我们更加方便的操作 data 中的数据。\n// 通过 obj2 访问或修改 obj1 中的 x  var obj = { x: 100 }; var obj2 = { y: 200 };  // 给 obj2 定义一个新的属性 x Object.defineProperty(obj2, \u0026#39;x\u0026#39;, { \tget() { \t// 当访问 obj2.x 时，返回 100，并将 100 赋给 obj2.x， \treturn obj.x; \t},  \t// 当 obj2.x 被修改，该方法会调用，value 是修改后的新值 \tset(value) { \t// 将新值赋给 obj.x \t// 这一步完成后，相当于实现了一个数据代理： \t// 通过一个 obj2 代理对另一个 obj 的属性 x 的操作（读/写） \tobj.x = value; \t}, });  // 100 console.log(obj.x);  // 100 console.log(obj2.x);  // 通过修改 obj2.x 的值，来代理修改 obj.x，这就是数据代理 obj2.x = 999;  // 999 console.log(obj.x); 数据劫持 指的是在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果。\n在 Vue 中，通过给对象添加一个setter()实现对该对象的数据劫持。\n实现数据响应式  通过definProperty() 将data中所有的属性添加到 vm 上。 为每一个添加到 vm 上的属性，都添加一个getter()和setter()。 因此，每当我们修改或访问 vm 中的属性，都会调用其属性所对应的getter() 和setter()。 最后，在getter() 和setter()内部来访问或修改data中的属性值。  如何响应对象中的数据？ 通过 setter()实现响应，且要在 nwe Vue 时就传入要响应的数据。\n new Vue 之后再追加的对象属性，Vue 默认不响应。 若需要让 Vue 响应 new Vue 之后追加的对象属性，需要使用 Vue.set()或则 vm.$set()  如何响应数组中的数据？ 通过包裹数组更新元素的方法实现：\n 调用原生更新元素的方法实现对数组进行更新。 重新解析模板，进而更新页面。  原生数组被包裹的方法有：\n push() pop() shift() unshift() splice() sort() reverse()  只要使用以上方法更新数组中的元素，那么就可以实现响应数组中的数据。\n不完整的数据响应式实现 // 模仿 Vue 实现响应式的过程， // 缺陷一：无法直接 vm.attr // 缺陷二：多层级的属性无法被监听到 var data = { \tname: \u0026#39;黔灵山\u0026#39;, \taddress: \u0026#39;贵阳\u0026#39;, \tage: 35, };  // 创建一个监视的实例对象，用于监视 data 中属性的变化  var obs = new Observer(data);  // 此时 data 中有的属性，obs 中都有。  // 定义一个 vm 实例对象 var vm = {}; vm._data = data = obs;  function Observer(obj) { \t// 汇总对象中所有的属性，并形成一个数组 \tvar keys = Object.keys(obj); \t// 遍历 \tkeys.forEach((k) =\u0026gt; { \tObject.defineProperty(this, k, { \tget() { \treturn obj[k]; \t}, \tset(val) { \tconsole.log(\u0026#39;值被修改\u0026#39;); \tobj[k] = val; \t}, \t}); \t}); } ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/","summary":"数据响应式 data 发生变化，视图会自动变化。\n数据代理 通过一个对象代理对另一个对象中的属性的操作（读/写）.\n在 Vue 中，通过 vm 来代理 data 中的属性操作（即操作 vm，就相当于操作 data），使我们更加方便的操作 data 中的数据。\n// 通过 obj2 访问或修改 obj1 中的 x  var obj = { x: 100 }; var obj2 = { y: 200 };  // 给 obj2 定义一个新的属性 x Object.defineProperty(obj2, \u0026#39;x\u0026#39;, { \tget() { \t// 当访问 obj2.x 时，返回 100，并将 100 赋给 obj2.x， \treturn obj.x; \t},  \t// 当 obj2.x 被修改，该方法会调用，value 是修改后的新值 \tset(value) { \t// 将新值赋给 obj.","title":"Vue 数据响应式"},{"content":"转换数据类型 在很多的条件下，需要将指定的数据类型，转换成目标数据类型。\n自动转换 系统根据需求判定并转换（用的比较多，效率偏低）。\n$a = \u0026#39;abc1.1.1\u0026#39;; $b = \u0026#39;1.1.1abc\u0026#39;;  // 0 + 1.1 echo $a + $b; 强制转换 它会先复制一份需要被转换的数据，然后在对这份被复制的数据进行处理（不会处理实际的数据，它处理的是自己拷贝的）。\n() 在变量之前增加一个 ()，括号中的参数为目标数据类型。\n$a = \u0026#39;我是字符串呀\u0026#39;; $b = 123;  // 强制转换，使 a 中的数据变为浮点型 // 但 a 本身的数据并没有变为 float echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;, (float)$a; echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; // 0 echo \u0026#39;a = \u0026#39; . $a; //string echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;;  echo \u0026#39;此时 a 的数据类型依旧为：\u0026#39; . gettype($a); echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; echo \u0026#39;\u0026lt;hr/\u0026gt;\u0026#39;; settype() 设定数据类型，但与前面的强制转换()不同，它会直接改变数据本身。\n\u0026lt;?php $a = \u0026#39;我是字符串呀\u0026#39;; $b = 123;  // 强制设置数据类型 //true var_dump(settype($a, \u0026#39;int\u0026#39;)); echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; // a 的数据类型直接被设置成了 integer，和强制转换大不一样 echo \u0026#39;a 的数据类型为：\u0026#39; . gettype($a); echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; // a 的内容为 0 echo \u0026#39;a = \u0026#39; . $a; 字符串转数值规则\n以字母开头的字符串，转换后一定为 0。\n以数字开头的字符串，截至到字符串为止（不会同时包含两个小数点）。\n$a = \u0026#39;abc1.1.1\u0026#39;; $b = \u0026#39;1.1.1abc\u0026#39;;  // 0,1.1 echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;, (float)$a, \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;, (float)$b; ","permalink":"https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E8%BD%AC%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","summary":"转换数据类型 在很多的条件下，需要将指定的数据类型，转换成目标数据类型。\n自动转换 系统根据需求判定并转换（用的比较多，效率偏低）。\n$a = \u0026#39;abc1.1.1\u0026#39;; $b = \u0026#39;1.1.1abc\u0026#39;;  // 0 + 1.1 echo $a + $b; 强制转换 它会先复制一份需要被转换的数据，然后在对这份被复制的数据进行处理（不会处理实际的数据，它处理的是自己拷贝的）。\n() 在变量之前增加一个 ()，括号中的参数为目标数据类型。\n$a = \u0026#39;我是字符串呀\u0026#39;; $b = 123;  // 强制转换，使 a 中的数据变为浮点型 // 但 a 本身的数据并没有变为 float echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;, (float)$a; echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; // 0 echo \u0026#39;a = \u0026#39; . $a; //string echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;;  echo \u0026#39;此时 a 的数据类型依旧为：\u0026#39; . gettype($a); echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; echo \u0026#39;\u0026lt;hr/\u0026gt;\u0026#39;; settype() 设定数据类型，但与前面的强制转换()不同，它会直接改变数据本身。\n\u0026lt;?php $a = \u0026#39;我是字符串呀\u0026#39;; $b = 123;  // 强制设置数据类型 //true var_dump(settype($a, \u0026#39;int\u0026#39;)); echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; // a 的数据类型直接被设置成了 integer，和强制转换大不一样 echo \u0026#39;a 的数据类型为：\u0026#39; .","title":"PHP 转换数据类型"},{"content":"Class 与 Style 绑定 绑定 Class 字符串 适合场景：类名不确定，且需要要动态获取。\n对象 适合场景：要绑定多个类名，类名个数确定，类名也确定，但需要动态决定是否要应用样式。\n通过修改属性的布尔值来决定是否启用当前样式。\n数组 适合场景：要绑定多个类名，类名个数不确定，类名也不确定。\n通过向数组中添加元素来增加类名，删除元素来移除类名。\n绑定内联样式 对象 CSS 属性名可以用小驼峰式或短横线分隔（用引号括起来）来命名。其中 CSS 属性指是动态值\nHTML\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;   \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt;  \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt;  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt;  \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;title\u0026gt;Vue\u0026lt;/title\u0026gt;  \u0026lt;style\u0026gt;  .basic {  width: 100px;  height: 100px;  margin-top: 10px;  border: 1px solid #000;  }   .style2 {  background-color: rgb(15, 110, 120);  }   .style3 {  background-color: rgb(93, 160, 89);  }   .s1 {  border-radius: 5px;  background-color: aqua;  }   .s2 {  border: 1px solid rgb(250, 3, 3);  background-color: rgb(4, 255, 0);  }   .s3 {  box-shadow: rgba(6, 24, 44, 0.4) 0px 0px 0px 2px, rgba(6, 24, 44, 0.65) 0px 4px 6px -1px, rgba(255, 255, 255, 0.08) 0px 1px 0px inset;  }  \u0026lt;/style\u0026gt;  \u0026lt;/head\u0026gt;  \u0026lt;body\u0026gt;  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;div class=\u0026#34;basic\u0026#34; :class=\u0026#34;style\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt;  \u0026lt;button @click=\u0026#34;changStyle\u0026#34;\u0026gt;点击切换样式\u0026lt;/button\u0026gt;  \u0026lt;div class=\u0026#34;basic\u0026#34; :class=\u0026#34;classArr\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt;  \u0026lt;div class=\u0026#34;basic\u0026#34; :class=\u0026#34;classObj\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt;  \u0026lt;div class=\u0026#34;basic\u0026#34; :style=\u0026#34;styleObj\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt;  \u0026lt;/div\u0026gt;   \u0026lt;/body\u0026gt;  \u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; JavaScrip\nvar vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \tname: \u0026#39;巴黎\u0026#39;, \tstyle: \u0026#39;style2\u0026#39;, \tclassArr: [\u0026#39;s1\u0026#39;, \u0026#39;s2\u0026#39;], \tclassObj: { \ts1: true, \ts2: false, \ts3: true, \t}, \tstyleObj: { \t\u0026#39;font-size\u0026#39;: \u0026#39;50px\u0026#39;, \tcolor: \u0026#39;green\u0026#39;, \tbackgroundColor: \u0026#39;red\u0026#39;, \t}, \t},  \tmethods: { \tchangStyle() { \tthis.style = \u0026#39;style3\u0026#39;; \t}, \t}, });  Vue.config.productionTip = false; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/class-%E4%B8%8E-style-%E7%BB%91%E5%AE%9A/","summary":"Class 与 Style 绑定 绑定 Class 字符串 适合场景：类名不确定，且需要要动态获取。\n对象 适合场景：要绑定多个类名，类名个数确定，类名也确定，但需要动态决定是否要应用样式。\n通过修改属性的布尔值来决定是否启用当前样式。\n数组 适合场景：要绑定多个类名，类名个数不确定，类名也不确定。\n通过向数组中添加元素来增加类名，删除元素来移除类名。\n绑定内联样式 对象 CSS 属性名可以用小驼峰式或短横线分隔（用引号括起来）来命名。其中 CSS 属性指是动态值\nHTML\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;   \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt;  \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt;  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt;  \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;title\u0026gt;Vue\u0026lt;/title\u0026gt;  \u0026lt;style\u0026gt;  .basic {  width: 100px;  height: 100px;  margin-top: 10px;  border: 1px solid #000;  }   .","title":"Vue Class 与 Style 绑定"},{"content":"watch 侦听器，用于侦听 Vue 实例上的数据变动。\nHTML\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \t\u0026lt;title\u0026gt;Vue\u0026lt;/title\u0026gt; \t\u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \t\u0026lt;h2\u0026gt;今天天气很{{weather}}\u0026lt;/h2\u0026gt; \t\u0026lt;button @click=\u0026#34;handoff\u0026#34;\u0026gt;切换天气\u0026lt;/button\u0026gt; \t\u0026lt;h2\u0026gt;{{number.a}}\u0026lt;/h2\u0026gt; \t\u0026lt;button @click=\u0026#34;number.a++\u0026#34;\u0026gt;深度监听a\u0026lt;/button\u0026gt; \t\u0026lt;h2\u0026gt;{{number.b}}\u0026lt;/h2\u0026gt; \t\u0026lt;button @click=\u0026#34;number.b++\u0026#34;\u0026gt;深度监听b\u0026lt;/button\u0026gt; \t\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; JavaScript\nvar vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \tisHot: true, \tnumber: { \ta: 1, \tb: 2, \t}, \t}, \tcomputed: { \tweather() { \treturn this.isHot ? \u0026#39;热\u0026#39; : \u0026#39;冷\u0026#39;; \t}, \t}, \tmethods: { \thandoff() { \tthis.isHot = !this.isHot; \t}, \t}, \twatch: { \tisHot: { \t// 初始化时是否侦听 一次 \timmediate: true, \thandler(newValue, oldValue) { \tconsole.log(\u0026#39;ishot被修改\u0026#39;, newValue, oldValue); \t}, \t}, \tnumber: { \t// 是否进行深度侦听对象的属性。 \tdeep: true, \thandler(newValue, oldValue) { \tconsole.log(\u0026#39;number被修改\u0026#39;, newValue, oldValue); \t}, \t}, \t}, });  Vue.config.productionTip = false; handler() 当侦听的数据发生变动时，会触发hanler().\n侦听的数据必须存在，才能进行侦听。\n它有两个参数，第一个参数是数据改变后的值，第二个参数是数据改变前的值。\nimmediate 初始化页面时是否进行一次侦听。\n当值为false时，只有当数据发生改变才会调用handler()。\n当值为 true时，初始化页面，handler() 也会调用一下。\ndeep 是否深度侦听对象的属性变化。\nVue 实例自身可以侦听到对象属性的改变，但 Vue 实例的watch默认不支持侦听对象属性的改变。\n当值为 false时，不能侦听到对象中属性的变化。\n当值为true时，可以侦听到对象属性的变化。\ncomputed与 watch 的区别：  computed能完成的功能，watch都可以完成。 当用computed和watch都能实现某一个功能的时候，优先使用computed。 watch能完成的功能，computed不一 定 能完成，比如 watch可 以进行异步操作，computed却不能（return 无法异步执行）。  重要的小原则：  所有被 Vue 管理的函数，最好使用普通函数，这样 this 的指向才是 Vue 实例或组件实例对象。 所有不被 Vue 管理的函数（定时器的回调函数、ajax 的回调函数等)，最好使用箭头函数，这样 this 的指向才是 Vue 实例对象。  简写 这种写法无法配置immediate和deep。\nwatch: {  isHot(newValue, oldValue) {  console.log(\u0026#39;ishot被修改\u0026#39;, newValue, oldValue);  }, }, ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/watch/","summary":"watch 侦听器，用于侦听 Vue 实例上的数据变动。\nHTML\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \t\u0026lt;title\u0026gt;Vue\u0026lt;/title\u0026gt; \t\u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \t\u0026lt;h2\u0026gt;今天天气很{{weather}}\u0026lt;/h2\u0026gt; \t\u0026lt;button @click=\u0026#34;handoff\u0026#34;\u0026gt;切换天气\u0026lt;/button\u0026gt; \t\u0026lt;h2\u0026gt;{{number.a}}\u0026lt;/h2\u0026gt; \t\u0026lt;button @click=\u0026#34;number.a++\u0026#34;\u0026gt;深度监听a\u0026lt;/button\u0026gt; \t\u0026lt;h2\u0026gt;{{number.b}}\u0026lt;/h2\u0026gt; \t\u0026lt;button @click=\u0026#34;number.b++\u0026#34;\u0026gt;深度监听b\u0026lt;/button\u0026gt; \t\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; JavaScript\nvar vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \tisHot: true, \tnumber: { \ta: 1, \tb: 2, \t}, \t}, \tcomputed: { \tweather() { \treturn this.","title":"Vue watch"},{"content":"过滤与排序 当用computed和watch都能实现某一个功能的时候，优先使用computed。\n过滤 分别用两种方式实现过滤，computed 与watch，推荐使用前者。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \t\u0026lt;h1\u0026gt;模糊搜索\u0026lt;/h1\u0026gt; \t\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; placeholder=\u0026#34;请输入名字\u0026#34; v-model=\u0026#34;keyWord\u0026#34; /\u0026gt; \t\u0026lt;ul\u0026gt; \t\u0026lt;li v-for=\u0026#34;p in filterPersons\u0026#34; :key=\u0026#34;p.id\u0026#34;\u0026gt;{{p.name}}-{{p.age}}-{{p.sex}}\u0026lt;/li\u0026gt; \t\u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; JavaScrip\nwatch 实现\nvar vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \tkeyWord: \u0026#39;\u0026#39;, \tpersons: [ \t{ id: \u0026#39;001\u0026#39;, name: \u0026#39;马冬梅\u0026#39;, age: 20, sex: \u0026#39;女\u0026#39; }, \t{ id: \u0026#39;002\u0026#39;, name: \u0026#39;周冬雨\u0026#39;, age: 21, sex: \u0026#39;女\u0026#39; }, \t{ id: \u0026#39;003\u0026#39;, name: \u0026#39;周杰伦 \u0026#39;, age: 22, sex: \u0026#39;男\u0026#39; }, \t{ id: \u0026#39;004\u0026#39;, name: \u0026#39;温兆伦 \u0026#39;, age: 18, sex: \u0026#39;男\u0026#39; }, \t], \t// 用来接受过滤后的结果 \tfilterPersons: [], \t}, \tmethods: {}, \twatch: { \tkeyWord: { \t// 初始化 filterPersons 数组 \timmediate: true, \thandler(val) { \t// 将过滤后的结果赋给 persons \tthis.filterPersons = this.persons.filter((p) =\u0026gt; { \t// 返回查找到的字符串第一次出现的索引 \treturn p.name.indexOf(val) !== -1; \t}); \t}, \t}, \t}, });  Vue.config.productionTip = false; computed 实现\nvar vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \tkeyWord: \u0026#39;\u0026#39;, \tpersons: [ \t{ id: \u0026#39;001\u0026#39;, name: \u0026#39;马冬梅\u0026#39;, age: 20, sex: \u0026#39;女\u0026#39; }, \t{ id: \u0026#39;002\u0026#39;, name: \u0026#39;周冬雨\u0026#39;, age: 21, sex: \u0026#39;女\u0026#39; }, \t{ id: \u0026#39;003\u0026#39;, name: \u0026#39;周杰伦 \u0026#39;, age: 22, sex: \u0026#39;男\u0026#39; }, \t{ id: \u0026#39;004\u0026#39;, name: \u0026#39;温兆伦 \u0026#39;, age: 18, sex: \u0026#39;男\u0026#39; }, \t], \t}, \tcomputed: { \tfilterPersons() { \treturn this.persons.filter((p) =\u0026gt; { \treturn p.name.indexOf(this.keyWord) !== -1; \t}); \t}, \t}, });  Vue.config.productionTip = false; 排序 用computed实现\nHTML\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;   \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt;  \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt;  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt;  \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;title\u0026gt;模糊搜索\u0026lt;/title\u0026gt;  \u0026lt;style\u0026gt;   \u0026lt;/style\u0026gt;  \u0026lt;/head\u0026gt;   \u0026lt;body\u0026gt;  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;h1\u0026gt;模糊搜索\u0026lt;/h1\u0026gt;  \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; placeholder=\u0026#34;请输入名字\u0026#34; v-model=\u0026#34;keyWord\u0026#34;\u0026gt;  \u0026lt;button @click=\u0026#34;sortType =\u0026#39;2\u0026#39;\u0026#34;\u0026gt;年龄升序\u0026lt;/button\u0026gt;  \u0026lt;button @click=\u0026#34;sortType =\u0026#39;1\u0026#39;\u0026#34;\u0026gt;年龄降序\u0026lt;/button\u0026gt;  \u0026lt;button @click=\u0026#34;sortType =\u0026#39;0\u0026#39;\u0026#34;\u0026gt;原顺序\u0026lt;/button\u0026gt;   \u0026lt;ul\u0026gt;  \u0026lt;li v-for=\u0026#34;p in filterPersons\u0026#34; :key=\u0026#34;p.id\u0026#34;\u0026gt;  {{p.name}}-{{p.age}}-{{p.sex}}  \u0026lt;/li\u0026gt;  \u0026lt;/ul\u0026gt;   \u0026lt;/div\u0026gt;  \u0026lt;/body\u0026gt;  \u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;/html\u0026gt; JavaScript\nvar vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \tkeyWord: \u0026#39;\u0026#39;, \t// 0 原顺序、1年龄降序、2 年龄升序 \tsortType: \u0026#39;0\u0026#39;, \tpersons: [ \t{ id: \u0026#39;001\u0026#39;, name: \u0026#39;马冬梅\u0026#39;, age: 28, sex: \u0026#39;女\u0026#39; }, \t{ id: \u0026#39;002\u0026#39;, name: \u0026#39;周冬雨\u0026#39;, age: 21, sex: \u0026#39;女\u0026#39; }, \t{ id: \u0026#39;003\u0026#39;, name: \u0026#39;周杰伦\u0026#39;, age: 52, sex: \u0026#39;男\u0026#39; }, \t{ id: \u0026#39;004\u0026#39;, name: \u0026#39;温兆伦\u0026#39;, age: 31, sex: \u0026#39;男\u0026#39; }, \t], \t}, \tcomputed: { \tfilterPersons() { \t// 保存过滤后的数组，以便后续排序 \tvar filterArr = this.persons.filter((p) =\u0026gt; { \t// 检测数组中是否含有输入框中的文本 \treturn p.name.indexOf(this.keyWord) !== -1; \t}); \t// 判断如何进行排序 \t// 年龄降序 \tif (this.sortType == \u0026#39;1\u0026#39;) { \tfilterArr.sort((p1, p2) =\u0026gt; { \treturn p2.age - p1.age; \t}); \t// 年龄升序 \t} else if (this.sortType == \u0026#39;2\u0026#39;) { \tfilterArr.sort((p1, p2) =\u0026gt; { \treturn p1.age - p2.age; \t}); \t} \treturn filterArr; \t}, \t}, });  Vue.config.productionTip = false; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/%E8%BF%87%E6%BB%A4%E4%B8%8E%E6%8E%92%E5%BA%8F/","summary":"过滤与排序 当用computed和watch都能实现某一个功能的时候，优先使用computed。\n过滤 分别用两种方式实现过滤，computed 与watch，推荐使用前者。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \t\u0026lt;h1\u0026gt;模糊搜索\u0026lt;/h1\u0026gt; \t\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; placeholder=\u0026#34;请输入名字\u0026#34; v-model=\u0026#34;keyWord\u0026#34; /\u0026gt; \t\u0026lt;ul\u0026gt; \t\u0026lt;li v-for=\u0026#34;p in filterPersons\u0026#34; :key=\u0026#34;p.id\u0026#34;\u0026gt;{{p.name}}-{{p.age}}-{{p.sex}}\u0026lt;/li\u0026gt; \t\u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; JavaScrip\nwatch 实现\nvar vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \tkeyWord: \u0026#39;\u0026#39;, \tpersons: [ \t{ id: \u0026#39;001\u0026#39;, name: \u0026#39;马冬梅\u0026#39;, age: 20, sex: \u0026#39;女\u0026#39; }, \t{ id: \u0026#39;002\u0026#39;, name: \u0026#39;周冬雨\u0026#39;, age: 21, sex: \u0026#39;女\u0026#39; }, \t{ id: \u0026#39;003\u0026#39;, name: \u0026#39;周杰伦 \u0026#39;, age: 22, sex: \u0026#39;男\u0026#39; }, \t{ id: \u0026#39;004\u0026#39;, name: \u0026#39;温兆伦 \u0026#39;, age: 18, sex: \u0026#39;男\u0026#39; }, \t], \t// 用来接受过滤后的结果 \tfilterPersons: [], \t}, \tmethods: {}, \twatch: { \tkeyWord: { \t// 初始化 filterPersons 数组 \timmediate: true, \thandler(val) { \t// 将过滤后的结果赋给 persons \tthis.","title":"Vue 过滤与排序"},{"content":"Echarts ECharts 是一个使用 JavaScript 实现的开源可视化库，兼容性强，底层依赖矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。\n使用 Echarts 的时候，只需要更改配置项即可。\n","permalink":"https://note.yxzi.xyz/note/technology/storehouse/echarts/echarts/","summary":"Echarts ECharts 是一个使用 JavaScript 实现的开源可视化库，兼容性强，底层依赖矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。\n使用 Echarts 的时候，只需要更改配置项即可。","title":"Echarts"},{"content":"非谓语动词 谓语动词不能作除谓语以外的句子成分，如果想作除谓语以外的句子成分，只能使用非谓语动词。\n以外的所有句子成分和所有从句，从而简化句子，只不过这样的非谓语动词就无法表示时体气等作用了\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/","summary":"非谓语动词 谓语动词不能作除谓语以外的句子成分，如果想作除谓语以外的句子成分，只能使用非谓语动词。\n以外的所有句子成分和所有从句，从而简化句子，只不过这样的非谓语动词就无法表示时体气等作用了","title":"English 非谓语动词"},{"content":"jQuery jQuery 是一个 JavaScript 的类库，jQuery 有的 JavaScript 都有，两者的区别在于用 jQuery 写的代码量更少且功能更大。\n","permalink":"https://note.yxzi.xyz/note/technology/storehouse/jquery/jquery/","summary":"jQuery jQuery 是一个 JavaScript 的类库，jQuery 有的 JavaScript 都有，两者的区别在于用 jQuery 写的代码量更少且功能更大。","title":"jQuery"},{"content":"Uniq ‎ 用于将数组中的所有重复项删除，并按数组中每个元素的首位字符进行升序\n安装 npm install uniq 使用\n// 导入 uniq var uniq = require(\u0026#39;uniq\u0026#39;); // 定义数组 var arr = [199, 9, 3]; // 排序 var result = uniq(arr); // [ 199, 3, 9 ] // 虽然 199 大于 3 和 9，但因为 199 的首位字符为 1，因此，它排在l console.log(result); ","permalink":"https://note.yxzi.xyz/note/technology/storehouse/uniq/uniq/","summary":"Uniq ‎ 用于将数组中的所有重复项删除，并按数组中每个元素的首位字符进行升序\n安装 npm install uniq 使用\n// 导入 uniq var uniq = require(\u0026#39;uniq\u0026#39;); // 定义数组 var arr = [199, 9, 3]; // 排序 var result = uniq(arr); // [ 199, 3, 9 ] // 虽然 199 大于 3 和 9，但因为 199 的首位字符为 1，因此，它排在l console.log(result); ","title":"Uniq"},{"content":"动名词 它长得与谓语动词的进行状态一样，用来作主语，由动词 + ing 构成。\n动名词和现在分词一样，区别在于现在分词作谓语，动名词不能作谓语。\n She is eating an apple. Eating is importtant. writing diaries. My job is teaching English. My hobby is playing basketball.  动名词用于表示抽象的、多次的、泛指动作。\n His job is selling houses.（多次） Smoking is not good for us.（多次）  can not help + 动名词：忍不住\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E5%8A%A8%E5%90%8D%E8%AF%8D/","summary":"动名词 它长得与谓语动词的进行状态一样，用来作主语，由动词 + ing 构成。\n动名词和现在分词一样，区别在于现在分词作谓语，动名词不能作谓语。\n She is eating an apple. Eating is importtant. writing diaries. My job is teaching English. My hobby is playing basketball.  动名词用于表示抽象的、多次的、泛指动作。\n His job is selling houses.（多次） Smoking is not good for us.（多次）  can not help + 动名词：忍不住","title":"English 动名词"},{"content":"动词不定式 它长得与谓语动词原形一样，由 to + 动词原型构成。其中 to 只是一个符号，用于与谓语动词作区分。可以作主语。\n不能单独作谓语。\n To be believe us I want to be beautiful. To work every night. To master English is easy. To get there by bike took me two hours. It is necessary for an adult to learn English grammer. It is kind of you to repair my bike.  通常动词不定式作主语会显得句子头重脚轻，因此，我们可以将句子变化以下，将主语移动到句子后面，前面用一个 it 来充当形式主语：\n To help poor people is our duty. it is our duty to help poor people.  动词不定式用于表示具体的、一次性的、将来的动作。\n My plan is to buy a house next year.（将来） It made happy to find my cellphone.（一次性） It is easy to find a job.（具体）  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E5%8A%A8%E8%AF%8D%E4%B8%8D%E5%AE%9A%E5%BC%8F/","summary":"动词不定式 它长得与谓语动词原形一样，由 to + 动词原型构成。其中 to 只是一个符号，用于与谓语动词作区分。可以作主语。\n不能单独作谓语。\n To be believe us I want to be beautiful. To work every night. To master English is easy. To get there by bike took me two hours. It is necessary for an adult to learn English grammer. It is kind of you to repair my bike.  通常动词不定式作主语会显得句子头重脚轻，因此，我们可以将句子变化以下，将主语移动到句子后面，前面用一个 it 来充当形式主语：\n To help poor people is our duty. it is our duty to help poor people.","title":"English 动词不定式"},{"content":"现在分词 它长得与谓语动词的进行状态一样。\n现在分词必须构成进行时态，且前面必须有助动词。\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E7%8E%B0%E5%9C%A8%E5%88%86%E8%AF%8D/","summary":"现在分词 它长得与谓语动词的进行状态一样。\n现在分词必须构成进行时态，且前面必须有助动词。","title":"English 现在分词"},{"content":"谓语动词 它是只能作谓语，用于表达动作的时间、状态、语气、否定、可能性、必须性等，但想发挥这些作用，需要用到助动词。\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/","summary":"谓语动词 它是只能作谓语，用于表达动作的时间、状态、语气、否定、可能性、必须性等，但想发挥这些作用，需要用到助动词。","title":"English 谓语动词"},{"content":"过去分词 它长得与谓语动词的完成状态一样。\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E8%BF%87%E5%8E%BB%E5%88%86%E8%AF%8D/","summary":"过去分词 它长得与谓语动词的完成状态一样。","title":"English 过去分词"},{"content":"AMD 专门用于浏览器端，实现异步加载模块，该规范依赖于 require.js。\n不是所有模块都支持 AMD 规范，比如 angular.js，但也可以通过 shim配置来使用angular.js\n定义模块 定义没有依赖的模块：\ndefine(function () { \t// 暴露模块 \treturn module; }); 定义有依赖的模块：\n// 显式声明依赖注入 define([\u0026#39;module1\u0026#39;, \u0026#39;module2\u0026#39;, \u0026#39;module2\u0026#39;], function (m1Obj, m2Obj, m3Obj) { \t// 暴露模块 \treturn module; }); 导入模块 require([ \t\u0026#39;module1\u0026#39;, \t\u0026#39;module2\u0026#39;, \t\u0026#39;module3\u0026#39;, \tfunction (m1Obj, m2Obj, m3Obj) { \t// 使用 m1Obj, m2Obj, m3Obj \t}, ]); 实现 使用require.js。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/amd/amd/","summary":"AMD 专门用于浏览器端，实现异步加载模块，该规范依赖于 require.js。\n不是所有模块都支持 AMD 规范，比如 angular.js，但也可以通过 shim配置来使用angular.js\n定义模块 定义没有依赖的模块：\ndefine(function () { \t// 暴露模块 \treturn module; }); 定义有依赖的模块：\n// 显式声明依赖注入 define([\u0026#39;module1\u0026#39;, \u0026#39;module2\u0026#39;, \u0026#39;module2\u0026#39;], function (m1Obj, m2Obj, m3Obj) { \t// 暴露模块 \treturn module; }); 导入模块 require([ \t\u0026#39;module1\u0026#39;, \t\u0026#39;module2\u0026#39;, \t\u0026#39;module3\u0026#39;, \tfunction (m1Obj, m2Obj, m3Obj) { \t// 使用 m1Obj, m2Obj, m3Obj \t}, ]); 实现 使用require.js。","title":"JavaScrip AMD"},{"content":"AMD 实现模块化 将require.js导入到项目目录./libs/require.js\n创建项目结构 ./libs/：第三方模块目录。\n./modules/：自定义模块目录。\n./libs/jquery.js：第三方模块。\n./libs/require.js：第三方模块。\n./modules/alerter.js：有依赖的自定义模块。\n./modules/dataService.js无依赖的自定义模块。\n./main.js：主模块。\n./index.html：入口文件。\n模块化编码 alerter.js\n// 定义无依赖的模块 define(function () { \tvar name = \u0026#39;no have dependencies\u0026#39;; \tfunction fun() { \treturn name; \t} \t// 暴露模块的 fun() \treturn { fun }; }); dataService.js\n// 定义有依赖的模块，该模块依赖 dataService、jquery define([\u0026#39;dataService\u0026#39;, \u0026#39;jquery\u0026#39;], function (dataService, $) { \tvar msg = \u0026#39;have dependencies\u0026#39;; \tfunction showMsg() { \tconsole.log(msg, dataService.fun()); \t} \t$(\u0026#39;body\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;red\u0026#39;); \t// 暴露模块的 showMsg() \treturn { showMsg }; }); main.js\n// 主模块，用 IIFE 执行，比较安全 (function () { \t// 配置 requirejs，使其能找到 main 所依赖的模块 \trequirejs.config({ \t// 基本路径，一般为项目根目录 \tbaseUrl: \u0026#39;./\u0026#39;, \t// 模块路径 \tpaths: { \tdataService: \u0026#39;modules/dataService\u0026#39;, \talerter: \u0026#39;modules/alerter\u0026#39;, \t// jquery 支持 AMD 规范，它内置 jquery 模块（源码中 define 了一个 jquery，因此，这里需要用 jquery，而不是 jQuery） \tjquery: \u0026#39;libs/jquery\u0026#39;, \t}, \t}); \trequirejs([\u0026#39;alerter\u0026#39;], function (alerter) { \talerter.showMsg(); \t}); })(); index.htm\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \t\u0026lt;title\u0026gt;AMD 模块化\u0026lt;/title\u0026gt; \t\u0026lt;/head\u0026gt; \t\u0026lt;body\u0026gt; \t\u0026lt;div class=\u0026#34;wrap\u0026#34;\u0026gt;AMD 模块化\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;!-- 引入 require.js 库 --\u0026gt; \t\u0026lt;!-- data-main 表示当前项目主模块路径 --\u0026gt; \t\u0026lt;script data-main=\u0026#34;main.js\u0026#34; src=\u0026#34;./libs/require.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \t\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/amd/amd-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/","summary":"AMD 实现模块化 将require.js导入到项目目录./libs/require.js\n创建项目结构 ./libs/：第三方模块目录。\n./modules/：自定义模块目录。\n./libs/jquery.js：第三方模块。\n./libs/require.js：第三方模块。\n./modules/alerter.js：有依赖的自定义模块。\n./modules/dataService.js无依赖的自定义模块。\n./main.js：主模块。\n./index.html：入口文件。\n模块化编码 alerter.js\n// 定义无依赖的模块 define(function () { \tvar name = \u0026#39;no have dependencies\u0026#39;; \tfunction fun() { \treturn name; \t} \t// 暴露模块的 fun() \treturn { fun }; }); dataService.js\n// 定义有依赖的模块，该模块依赖 dataService、jquery define([\u0026#39;dataService\u0026#39;, \u0026#39;jquery\u0026#39;], function (dataService, $) { \tvar msg = \u0026#39;have dependencies\u0026#39;; \tfunction showMsg() { \tconsole.log(msg, dataService.fun()); \t} \t$(\u0026#39;body\u0026#39;).","title":"JavaScrip AMD 实现模块化"},{"content":"Browserify 实现模块化 基于本地浏览器端实现模块化，需要用 Browserify来打包。\n创建项目结构 ./dist：打包生成的文件目录。\n./src：模块目录。\n./src/module1.js：自定义模块一。\n./src/module2.js：自定义模块二。\n./src/module3.js：自定义模块三。\n./app.js：主模块。\n./index.html：入口文件。\n模块化编码 module1.js\n// 暴露对象 module.exports = { \tmsg: \u0026#39;module one\u0026#39;, \tfun() { \tconsole.log(this.msg); \t}, }; module2.js\n// 暴露函数 module.exports = function () { \tconsole.log(\u0026#39;module two\u0026#39;); }; module3.js\n// 向暴露 2 个函数，1 个数组  exports.f = function () { \tconsole.log(\u0026#39;modul three f1\u0026#39;); };  exports.f2 = function () { \tconsole.log(\u0026#39;module three f2\u0026#39;); };  exports.arr = [199, 9, 3]; app.js\n// 引入第三方模块 var uniq = require(\u0026#39;uniq\u0026#39;);  // 引入自定义模块 var module1 = require(\u0026#39;./module1\u0026#39;); var module2 = require(\u0026#39;./module2\u0026#39;); var module3 = require(\u0026#39;./module3\u0026#39;);  // 使用自定义模块中的方法 module1.fun(); module2(); module3.f(); module3.f2();  // 使用第三方模块中的方法 var result = uniq(module3.arr); console.log(result); index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \t\u0026lt;title\u0026gt;Browserify 模块化\u0026lt;/title\u0026gt; \t\u0026lt;/head\u0026gt; \t\u0026lt;body\u0026gt; \t\u0026lt;div class=\u0026#34;wrap\u0026#34;\u0026gt;Browserify 模块化\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;./dist/bundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 打包模块 安装 browserify‎‎：\nnpm install -g browserify 不仅要全局安装，当前项目也要安装。\n‎ 现在，使用 ‎‎browserify‎‎ 命令递归地将所有需要的模块 ‎ 从 ./src/app.js‎‎ 打包编译到./dist/bundle.js：‎\n-o表示输出。\nbrowserify ./src/app.js -o ./dist/bundle.js 在 index.html 中引入bundle.js。\n\u0026lt;script src=\u0026#34;./dist/bundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/browserify-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/","summary":"Browserify 实现模块化 基于本地浏览器端实现模块化，需要用 Browserify来打包。\n创建项目结构 ./dist：打包生成的文件目录。\n./src：模块目录。\n./src/module1.js：自定义模块一。\n./src/module2.js：自定义模块二。\n./src/module3.js：自定义模块三。\n./app.js：主模块。\n./index.html：入口文件。\n模块化编码 module1.js\n// 暴露对象 module.exports = { \tmsg: \u0026#39;module one\u0026#39;, \tfun() { \tconsole.log(this.msg); \t}, }; module2.js\n// 暴露函数 module.exports = function () { \tconsole.log(\u0026#39;module two\u0026#39;); }; module3.js\n// 向暴露 2 个函数，1 个数组  exports.f = function () { \tconsole.log(\u0026#39;modul three f1\u0026#39;); };  exports.f2 = function () { \tconsole.log(\u0026#39;module three f2\u0026#39;); };  exports.","title":"JavaScrip Browserify 实现模块化"},{"content":"CMD 专用于浏览器端，异步加载模块。\n惰性加载模块，即使用模块时才会加载。\n实现该规范使用Sea.js\n定义模块 注意，回调函数中的三个参数require, exports, module必须加上，否则会报错。\n定义没有依赖的模块：\ndefine(function (require, exports, module) { \t// 暴露模块，通常用后者 \texports.xxx = value; \tmodule.exports = value; }); 定义有依赖的模块：\ndefine(function (require, exports, module) { \t// 同步导入模块 \tvar module2 = require(\u0026#39;./module2\u0026#39;); \t// 异步导入依赖模块 \trequire.async(\u0026#39;./module3\u0026#39;, function (m3Obj) { \t// 使用 m3Obj \t}); \t// 暴露模块 \texports.xxx = value; }); 导入模块 define(function (require) { \tvar m1 = require(\u0026#39;./module1\u0026#39;); \tvar m4 = require(\u0026#39;./module4\u0026#39;); \tm1.fun(); \tm4.fun2(); }); 实现 浏览器实现使用Sea.js\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/cmd/cmd/","summary":"CMD 专用于浏览器端，异步加载模块。\n惰性加载模块，即使用模块时才会加载。\n实现该规范使用Sea.js\n定义模块 注意，回调函数中的三个参数require, exports, module必须加上，否则会报错。\n定义没有依赖的模块：\ndefine(function (require, exports, module) { \t// 暴露模块，通常用后者 \texports.xxx = value; \tmodule.exports = value; }); 定义有依赖的模块：\ndefine(function (require, exports, module) { \t// 同步导入模块 \tvar module2 = require(\u0026#39;./module2\u0026#39;); \t// 异步导入依赖模块 \trequire.async(\u0026#39;./module3\u0026#39;, function (m3Obj) { \t// 使用 m3Obj \t}); \t// 暴露模块 \texports.xxx = value; }); 导入模块 define(function (require) { \tvar m1 = require(\u0026#39;.","title":"JavaScrip CMD"},{"content":"CMD 实现模块化 创建项目结构 ./libs：第三方模块目录。\n./libs/sea.js：第三方模块。\n./modules：自定义模块目录。\n./modules/module1.js：自定义模块一。\n./modules/module2.js：自定义模块二。\n./modules/module3.js：自定义模块三。\n./modules/module4.js：自定义模块四。\nmodules/main.js：主模块。\n./index.html：入口文件\n模块化编码 module1.js\n// 定义没有依赖的模块 define(function (require, exports, module) { \tvar msg = \u0026#39;module1\u0026#39;; \tfunction fun() { \treturn msg; \t} \t// 暴露模块 \tmodule.exports = { fun }; }); module2.js\n// 定义没有依赖的模块 define(function (require, exports, module) { \tvar msg = \u0026#39;module2\u0026#39;; \tfunction fun2() { \tconsole.log(msg); \t} \t// 暴露模块 \tmodule.exports = fun2; }); module3.js\n// 定义没有依赖的模块 define(function (require, exports, module) { \tvar msg = \u0026#39;module3\u0026#39;; \tfunction fun3() { \tconsole.log(msg); \t} \t// 暴露模块 \texports.module3 = { fun3 }; }); module4.js\n// 定义有依赖的模块，该模块依赖 module2 与 module3 define(function (require, exports, module) { \t// 同步导入模块 \tvar m2 = require(\u0026#39;./module2\u0026#39;); \tm2(); \t// 异步导入模块，因为是异步，因此回调函数不会阻塞 \t// 因此该回到函数中的代码需要等主线程（主模块）执行完毕再执行， \trequire.async(\u0026#39;./module3\u0026#39;, function (m3Obj) { \tm3Obj.module3.fun3(); \t});  \t//导入第三方模块 \trequire(\u0026#39;../libs/jquery\u0026#39;); \t// 使用第三方模块 \t$(\u0026#39;body\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;red\u0026#39;); \t// 该模块上的方法 \tvar msg = \u0026#39;module4\u0026#39;; \tfunction fun4() { \tconsole.log(msg); \t} \t// 暴露模块 \texports.module4 = { fun4 }; }); main.js\n// 定义主模块 define(function (require) { \tvar m1 = require(\u0026#39;./module1\u0026#39;); \tvar m1Value = m1.fun(); \tconsole.log(m1Value);  \tvar m4 = require(\u0026#39;./module4\u0026#39;); \tm4.module4.fun4(); }); index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \t\u0026lt;title\u0026gt;CMD 模块化\u0026lt;/title\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;div class=\u0026#34;wrap\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;!-- 导入 sea.js --\u0026gt; \t\u0026lt;script src=\u0026#34;./libs/sea.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \t\u0026lt;!-- 使用 sea.js --\u0026gt; \t\u0026lt;script\u0026gt; \t// 使用主模块 \tseajs.use(\u0026#39;./modules/main.js\u0026#39;); \t\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/cmd/cmd-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/","summary":"CMD 实现模块化 创建项目结构 ./libs：第三方模块目录。\n./libs/sea.js：第三方模块。\n./modules：自定义模块目录。\n./modules/module1.js：自定义模块一。\n./modules/module2.js：自定义模块二。\n./modules/module3.js：自定义模块三。\n./modules/module4.js：自定义模块四。\nmodules/main.js：主模块。\n./index.html：入口文件\n模块化编码 module1.js\n// 定义没有依赖的模块 define(function (require, exports, module) { \tvar msg = \u0026#39;module1\u0026#39;; \tfunction fun() { \treturn msg; \t} \t// 暴露模块 \tmodule.exports = { fun }; }); module2.js\n// 定义没有依赖的模块 define(function (require, exports, module) { \tvar msg = \u0026#39;module2\u0026#39;; \tfunction fun2() { \tconsole.log(msg); \t} \t// 暴露模块 \tmodule.","title":"JavaScrip CMD 实现模块化"},{"content":"CommonJS 一种为 JS 的表现指定的规范，它希望 JavaScrip 可以运行在任何地方，Node.js采用了这个规范。\n一个单独文件就是一个模块，通过require()来同步加载要依赖的模块，然后通过extports或则module.exports来暴露模块的接口。\n定义模块 两种方式所暴露的模块都是一个对象。\nmodule.expots 将需要暴露的属性或方法保存到exports对象中。\n// ExposedObjects() 将会保存到 exports 对象中，并暴露出去 module.expots = ExposedObjects(){ }; exports.xxx 给exports定义不同的xxx 对象，可以暴露不同属性或方法。\n// 不同的对象暴露不同的方法或属性 expots.obj = ExposedObjects(){ }; expots.obj2 = ExposedObjects2(){ } expots.obj3 = ExposedObjects3(){ } 导入模块 // 导入第三方模块 require(\u0026#39;jquery\u0026#39;); // 导入自定义模块 require(\u0026#39;modules.js\u0026#39;); 实现 服务器端 直接使用 Node.js，加载模块时是同步加载，这会导致阻塞（等待），但因为是在服务器端，影响也不是很大，无非是加载的时间比较长。\n浏览器端 加载模块时是同步加载，也会导致阻塞，且因为是在浏览器端，加载的时间非常长，用户体验不好（页面白屏），因此，我们需要将模块进行编译打包，以此来缩短加载时间。\n打包工具：Browserify.\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/commonjs/","summary":"CommonJS 一种为 JS 的表现指定的规范，它希望 JavaScrip 可以运行在任何地方，Node.js采用了这个规范。\n一个单独文件就是一个模块，通过require()来同步加载要依赖的模块，然后通过extports或则module.exports来暴露模块的接口。\n定义模块 两种方式所暴露的模块都是一个对象。\nmodule.expots 将需要暴露的属性或方法保存到exports对象中。\n// ExposedObjects() 将会保存到 exports 对象中，并暴露出去 module.expots = ExposedObjects(){ }; exports.xxx 给exports定义不同的xxx 对象，可以暴露不同属性或方法。\n// 不同的对象暴露不同的方法或属性 expots.obj = ExposedObjects(){ }; expots.obj2 = ExposedObjects2(){ } expots.obj3 = ExposedObjects3(){ } 导入模块 // 导入第三方模块 require(\u0026#39;jquery\u0026#39;); // 导入自定义模块 require(\u0026#39;modules.js\u0026#39;); 实现 服务器端 直接使用 Node.js，加载模块时是同步加载，这会导致阻塞（等待），但因为是在服务器端，影响也不是很大，无非是加载的时间比较长。\n浏览器端 加载模块时是同步加载，也会导致阻塞，且因为是在浏览器端，加载的时间非常长，用户体验不好（页面白屏），因此，我们需要将模块进行编译打包，以此来缩短加载时间。\n打包工具：Browserify.","title":"JavaScrip CommonJS"},{"content":"ES6 Module 配置 package.json 项目或模块的描述文件。\n{ \t\u0026#34;name\u0026#34;: \u0026#34;es6-module\u0026#34;, \t\u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \t\u0026#34;dependencies\u0026#34;: { \t\u0026#34;jquery\u0026#34;: \u0026#34;^3.6.0\u0026#34;, \t\u0026#34;uniq\u0026#34;: \u0026#34;^1.0.1\u0026#34; \t}, \t\u0026#34;devDependencies\u0026#34;: { \t\u0026#34;@babel/cli\u0026#34;: \u0026#34;^7.17.10\u0026#34;, \t\u0026#34;@babel/core\u0026#34;: \u0026#34;^7.17.12\u0026#34;, \t\u0026#34;@babel/preset-env\u0026#34;: \u0026#34;^7.17.12\u0026#34;, \t\u0026#34;browserify\u0026#34;: \u0026#34;^17.0.0\u0026#34; \t} } 安装 babel/cli Babel 自带的一个内置的 CLI 命令行工具，可通过命令行编译文件。\nnpm install --save-dev @babel/core @babel/cli 其中@babel/core是 babel 的核心库。\nbabel/preset-env 一个智能预设，允许您使用最新的 JavaScript，而无需微观管理目标环境需要哪些语法转换（以及可选的浏览器 polyfills）\nnpm install --save-dev @babel/preset-env 安装 Browserify 用来打包编译模块。\nnpm install -g browserify 配置 babel.config.json bable 的配置文件。\n{ \t\u0026#34;presets\u0026#34;: [ \t[ \t\u0026#34;@babel/preset-env\u0026#34;, \t{ \t\u0026#34;targets\u0026#34;: { \t\u0026#34;edge\u0026#34;: \u0026#34;17\u0026#34;, \t\u0026#34;firefox\u0026#34;: \u0026#34;60\u0026#34;, \t\u0026#34;chrome\u0026#34;: \u0026#34;67\u0026#34;, \t\u0026#34;safari\u0026#34;: \u0026#34;11.1\u0026#34; \t} \t} \t] \t] } 创建项目结构 模块化编码 modules1.js\n// 暴露模块方式一：分别暴露  export function fun1() { \tconsole.log(\u0026#39;fun1 module1\u0026#39;); }  export function fun11() { \tconsole.log(\u0026#39;fun11 module1\u0026#39;); }  export var arr = [9999, 34, 5, 6, 1565, 757, 6]; modules2.js\n// 暴露模块方式二：统一暴露  function fun2() { \tconsole.log(\u0026#39;fun2 module2\u0026#39;); }  function fun22() { \tconsole.log(\u0026#39;fun2 module2\u0026#39;); }  export { fun2, fun22 }; modules3.js\n// 默认暴露，暴露一个函数，接收到的也是一个函数 export default function () { \tconsole.log(\u0026#39;默认暴露\u0026#39;); } main.js\n// 将其他模块所暴露出来的数据引入到主模块  import { fun1, fun11, arr } from \u0026#39;./module1\u0026#39;; import { fun2, fun22 } from \u0026#39;./module2\u0026#39;; // 导入模块三默认暴露的函数 import module3 from \u0026#39;./module3\u0026#39;; // 导入第三方模块 import uniq from \u0026#39;uniq\u0026#39;; import $ from \u0026#39;jquery\u0026#39;;  fun1(); fun11(); fun2(); fun22(); console.log(arr[1]); // 调用默认暴露的函数 module3();  // 调用第三方模块中的方法 var result = uniq(arr); console.log(result);  $(\u0026#39;body\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;black\u0026#39;); index.js\n模块向后兼容 解析 src 目录下的所有 JavaScript 文件，并应用我们所指定的代码转换功能，然后把每个文件输出到 lib 目录下。\n npx babel ./src --out-dir ./lib 之后就会发现lib目录下多了几个文件，这些文件中的代码都向后兼容。\nBrowserify 打包模块 browserify ./lib/main.js -o bundle.js 最后在index.html 中引入build.js 即可。\n\u0026lt;script src=\u0026#34;./dist/build.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/es6-module/es6-module/","summary":"ES6 Module 配置 package.json 项目或模块的描述文件。\n{ \t\u0026#34;name\u0026#34;: \u0026#34;es6-module\u0026#34;, \t\u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \t\u0026#34;dependencies\u0026#34;: { \t\u0026#34;jquery\u0026#34;: \u0026#34;^3.6.0\u0026#34;, \t\u0026#34;uniq\u0026#34;: \u0026#34;^1.0.1\u0026#34; \t}, \t\u0026#34;devDependencies\u0026#34;: { \t\u0026#34;@babel/cli\u0026#34;: \u0026#34;^7.17.10\u0026#34;, \t\u0026#34;@babel/core\u0026#34;: \u0026#34;^7.17.12\u0026#34;, \t\u0026#34;@babel/preset-env\u0026#34;: \u0026#34;^7.17.12\u0026#34;, \t\u0026#34;browserify\u0026#34;: \u0026#34;^17.0.0\u0026#34; \t} } 安装 babel/cli Babel 自带的一个内置的 CLI 命令行工具，可通过命令行编译文件。\nnpm install --save-dev @babel/core @babel/cli 其中@babel/core是 babel 的核心库。\nbabel/preset-env 一个智能预设，允许您使用最新的 JavaScript，而无需微观管理目标环境需要哪些语法转换（以及可选的浏览器 polyfills）\nnpm install --save-dev @babel/preset-env 安装 Browserify 用来打包编译模块。\nnpm install -g browserify 配置 babel.","title":"JavaScrip ES6 Module"},{"content":"ES6 模块化规范 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。\nES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。\n依赖模块需要借助 Browserify来打包。\n暴露模块 使用export来暴露模块，它用于规定模块的对外接口。\n分别暴露 export function fun1() { \tconsole.log(\u0026#39;fun1 module1\u0026#39;); } export function fun11() { \tconsole.log(\u0026#39;fun11 module1\u0026#39;); } export var arr = [9999, 34, 5, 6, 7565, 757, 6]; 统一暴露 function fun2() { \tconsole.log(\u0026#39;fun2 module2\u0026#39;); } function fun22() { \tconsole.log(\u0026#39;fun2 module2\u0026#39;); } export { fun2, fun22 }; 默认暴露 使用默认暴露，可以暴露任意数据类型；且暴露的是什么数据类型，接收到的就是什么数据类型；可以使用任意的变量来接收。\n在同一个模块中，只允许用export default 暴露一次。\n在一个模块中，可以同时使用 export default 和 export 来暴露成员。\n导入模块 使用import来导入模块，用于输入其他模块提供的功能。\nimport { fun1, fun11, arr } from \u0026#39;./module1\u0026#39;; import { fun2, fun22 } from \u0026#39;./module2\u0026#39;;  fun1(); fun11(); fun2(); fun22(); console.log(arr[1]); 实现 用 Babel 将 ES6+ 语法转换为向后兼容 ES5 的语法。\n用 Browserify 打包转换后的主模块文件。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/es6-module/es6-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/","summary":"ES6 模块化规范 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。\nES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。\n依赖模块需要借助 Browserify来打包。\n暴露模块 使用export来暴露模块，它用于规定模块的对外接口。\n分别暴露 export function fun1() { \tconsole.log(\u0026#39;fun1 module1\u0026#39;); } export function fun11() { \tconsole.log(\u0026#39;fun11 module1\u0026#39;); } export var arr = [9999, 34, 5, 6, 7565, 757, 6]; 统一暴露 function fun2() { \tconsole.log(\u0026#39;fun2 module2\u0026#39;); } function fun22() { \tconsole.log(\u0026#39;fun2 module2\u0026#39;); } export { fun2, fun22 }; 默认暴露 使用默认暴露，可以暴露任意数据类型；且暴露的是什么数据类型，接收到的就是什么数据类型；可以使用任意的变量来接收。\n在同一个模块中，只允许用export default 暴露一次。","title":"JavaScrip ES6 模块化规范"},{"content":"NodeJs 实现模块化 基于node.js服务器端实现模块化。\n创建项目结构 ./modules：模块目录。\n./modules/module1.js：自定义模块一。\n./modules/module2.js：自定义模块二。\n./modules/module3.js：自定义模块三。\n./app.js：主模块。\n安装模块 安装 uniq\nnpm install uniq 模块化编码 module1.js\n// 暴露对象 module.exports = { \tmsg: \u0026#39;module one\u0026#39;, \tfun() { \tconsole.log(this.msg); \t}, }; module2.js\n// 暴露函数 module.exports = function () { \tconsole.log(\u0026#39;module two\u0026#39;); }; module3.js\n// 暴露 2 个函数，1 个数组 exports.f = function () { \tconsole.log(\u0026#39;modul three f1\u0026#39;); };  exports.f2 = function () { \tconsole.log(\u0026#39;module three f2\u0026#39;); };  exports.arr = [199, 9, 3]; app.js\n// 导入第三方模块 // uniq 是一个函数，用于对数组进行操作 var uniq = require(\u0026#39;uniq\u0026#39;);  // 导入自定义模块 var module1 = require(\u0026#39;./modules/module1\u0026#39;); var module2 = require(\u0026#39;./modules/module2\u0026#39;); var module3 = require(\u0026#39;./modules/module3\u0026#39;);  // 使用自定义模块 module1.fun(); module2(); module3.f();  // 使用第三方模块 var result = uniq(module3.arr); console.log(result); 终端使用命令node app.js，来运行 js 文件。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/nodejs-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/","summary":"NodeJs 实现模块化 基于node.js服务器端实现模块化。\n创建项目结构 ./modules：模块目录。\n./modules/module1.js：自定义模块一。\n./modules/module2.js：自定义模块二。\n./modules/module3.js：自定义模块三。\n./app.js：主模块。\n安装模块 安装 uniq\nnpm install uniq 模块化编码 module1.js\n// 暴露对象 module.exports = { \tmsg: \u0026#39;module one\u0026#39;, \tfun() { \tconsole.log(this.msg); \t}, }; module2.js\n// 暴露函数 module.exports = function () { \tconsole.log(\u0026#39;module two\u0026#39;); }; module3.js\n// 暴露 2 个函数，1 个数组 exports.f = function () { \tconsole.log(\u0026#39;modul three f1\u0026#39;); };  exports.f2 = function () { \tconsole.log(\u0026#39;module three f2\u0026#39;); };  exports.","title":"JavaScrip NodeJs 实现模块化"},{"content":"模块 向外提供特定功能的 JavaScrip 文件，一个 JavaScrip 文件就是一个模块。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97/","summary":"模块 向外提供特定功能的 JavaScrip 文件，一个 JavaScrip 文件就是一个模块。","title":"JavaScrip 模块"},{"content":"模块化 将一个复杂的 JavaScrip 程序依据一定的规范封装成几个块（文件），并组合在一起的过程就是模块化。块的内部数据是私有的，只向外部暴露了一些接口与外部其他模块通信。\n作用  降低复杂度。 提高解耦性，降低耦合度。 部署方便，功能点明确。  优点  避免变量污染。 更好的分离，按需加载。 更高的复用性。 更高的可维护性。  常见的模块化标准 CommonJS.\nES6 Module.\nAMD.\nCMD.\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96/","summary":"模块化 将一个复杂的 JavaScrip 程序依据一定的规范封装成几个块（文件），并组合在一起的过程就是模块化。块的内部数据是私有的，只向外部暴露了一些接口与外部其他模块通信。\n作用  降低复杂度。 提高解耦性，降低耦合度。 部署方便，功能点明确。  优点  避免变量污染。 更好的分离，按需加载。 更高的复用性。 更高的可维护性。  常见的模块化标准 CommonJS.\nES6 Module.\nAMD.\nCMD.","title":"JavaScrip 模块化"},{"content":"模块化的发展史 全局函数模式 将不同的函数封装成不同的全局函数。\n缺点\n变量非常不安全，会直接污染全局中的变量。\nJavaScrip One\n// msg 变量并不安全，会被其他文件中的 js 代码修改。 var msg = \u0026#39;全局函数模式\u0026#39;; function fun() { \tconsole.log(msg); } JavaScrip Two\nfun(); msg = \u0026#39;全局中的 msg 被其他文件中的 js 代码修改了\u0026#39;; fun(); 命名空间 将全局中的变量定义到一个对象中，以减少 Global 上的变量。\n缺点\n本质是对象，依旧可以通过对象去修改该对象中的变量，变量依旧不安全。\nJavaScrip One\nvar obj = { \t// 将全局中的变量定义为对象的属性，以减少全局中的变量 \tmsg: \u0026#39;命名空间模式\u0026#39;, \tfun() { \tconsole.log(this.msg); \t}, }; JavaScrip Two\nobj.fun(); obj.msg = \u0026#39;对象中的 msg 被其他文件中的 js 代码修改了\u0026#39;; obj.fun(); IIFE 模式 将变量和函数定义到立即执行函数内部，并将方法暴露给 window，以一个匿名闭包（将一个模块暴露给 window 对象，然后在其其他模块中用 window 对象来访问这个这个模块）的方式实现了模块化。\nJavaScrip One\n(function (window) { \t// fun() 和 msg 都无法被其他 js 文件中的调用 \tvar msg = \u0026#39;IIFE 模式\u0026#39;; \tfunction fun() { \tconsole.log(msg); \t}  \t// 将 fun() 暴露给 window 中的 IIFE 对象，使其可以通过 IIFE 对象来调用 fun() \twindow.IIFE = { \t// 访问 IIFE.fun 就会调用 fun()，且 msg 变量无法被修改和访问，成功实现了 meg 变量的私有化 \tfun: fun(), \t}; })(window); JavaScrip Two\n// 通过 window 可正常调用 fun() ，但无法修改私有属性 meg IIFE.fun; IIFE 模式增强 在原先 IIFE 的基础上，可以引入其他的依赖，是现代模块化的基石。\nJavaScrip One\n(function (window, $) { \tvar msg = \u0026#39;IIFE 模式增强\u0026#39;; \tfunction fun() { \tconsole.log(msg); \t} \t// 将 fun() 暴露给 window \twindow.IIFE = fun; \t// 使用 jquery 依赖 \t$(\u0026#39;body\u0026#39;).css(\u0026#39;background\u0026#39;, \u0026#39;red\u0026#39;); \t// 引入 jquery 依赖 })(window, jQuery); JavaScrip Two\n//调用 IIFE，相当于调用 fun() IIFE(); 没有规范的模块化 一个页面引入多个文件：\n\u0026lt;script src=\u0026#34;module1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;module2.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;module3.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;module4.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;module5.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;module6.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 缺点\n 页面所依赖的模块过多，导致请求过多，浪费性能。 依赖关系模糊，必须按照一定的顺序来引入这些依赖，极有可能调换一下这些依赖的顺序，项目就会出现问题。 前两个原因最终会导致项目的难以维护，一个模块出问题，可能会导致整个项目出现严重的问题。  这些问题，可以通过模块化规范来解决。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/","summary":"模块化的发展史 全局函数模式 将不同的函数封装成不同的全局函数。\n缺点\n变量非常不安全，会直接污染全局中的变量。\nJavaScrip One\n// msg 变量并不安全，会被其他文件中的 js 代码修改。 var msg = \u0026#39;全局函数模式\u0026#39;; function fun() { \tconsole.log(msg); } JavaScrip Two\nfun(); msg = \u0026#39;全局中的 msg 被其他文件中的 js 代码修改了\u0026#39;; fun(); 命名空间 将全局中的变量定义到一个对象中，以减少 Global 上的变量。\n缺点\n本质是对象，依旧可以通过对象去修改该对象中的变量，变量依旧不安全。\nJavaScrip One\nvar obj = { \t// 将全局中的变量定义为对象的属性，以减少全局中的变量 \tmsg: \u0026#39;命名空间模式\u0026#39;, \tfun() { \tconsole.log(this.msg); \t}, }; JavaScrip Two\nobj.fun(); obj.msg = \u0026#39;对象中的 msg 被其他文件中的 js 代码修改了\u0026#39;; obj.fun(); IIFE 模式 将变量和函数定义到立即执行函数内部，并将方法暴露给 window，以一个匿名闭包（将一个模块暴露给 window 对象，然后在其其他模块中用 window 对象来访问这个这个模块）的方式实现了模块化。","title":"JavaScrip 模块化的发展史"},{"content":"npm config npm config get registry 查看源地址\nnpm config set registry 设置源地址\n","permalink":"https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-config/","summary":"npm config npm config get registry 查看源地址\nnpm config set registry 设置源地址","title":"npm config"},{"content":"npm init 创建模块。用来初始化生成一个新的package.json文件。默认有一个引导界面，你可以一步步的配置，也可以通过带尾缀-f或-y来直接跳过引导界面。\nnpm init -y/npm init -f\n创建模块，并直接跳过引导，直接生成一个默认的package.json文件。\n使用-f创建，系统会提示npm WARN using \u0026ndash;force Recommended protections disabled.\n","permalink":"https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-init/","summary":"npm init 创建模块。用来初始化生成一个新的package.json文件。默认有一个引导界面，你可以一步步的配置，也可以通过带尾缀-f或-y来直接跳过引导界面。\nnpm init -y/npm init -f\n创建模块，并直接跳过引导，直接生成一个默认的package.json文件。\n使用-f创建，系统会提示npm WARN using \u0026ndash;force Recommended protections disabled.","title":"npm init"},{"content":"npm install 在当前项目中，读取package.json里面的 dependencies 和devDependencies的配置来安装需要依赖的模块。\ninstall 可简写为 i。\nnpm install jquery 在当前项目中安装 jquery 模块，默认安装的是最新版本。\nnpm install jquery -g 全局安装 jquery 模块，默认安装的是最新版本。\nnpm install jquery@3 安装 jquery 3.X.X 中的最新版本。\nnpm install jquery@3.0.1 安装指定版本的模块，也可用于将模块更新到指定版本。\nnpm install \u0026ndash;save --save是默认值，在 package.js文件的 dependencies 字段写入依赖，表示运行依赖（生产环境使用，项目上线后依旧会带着该模块）。\n\u0026#34;dependencies\u0026#34;: {  \u0026#34;jquery\u0026#34;: \u0026#34;^3.6.0\u0026#34; } npm install \u0026ndash;save-dev 在 package.js文件的 devDependencies 字段写入依赖，表示开发依赖（开发环境使用，项目上线后不会再带着该模块）。\n\u0026#34;devDependencies\u0026#34;: {  \u0026#34;jquery\u0026#34;: \u0026#34;^3.6.0\u0026#34; } ","permalink":"https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-install/","summary":"npm install 在当前项目中，读取package.json里面的 dependencies 和devDependencies的配置来安装需要依赖的模块。\ninstall 可简写为 i。\nnpm install jquery 在当前项目中安装 jquery 模块，默认安装的是最新版本。\nnpm install jquery -g 全局安装 jquery 模块，默认安装的是最新版本。\nnpm install jquery@3 安装 jquery 3.X.X 中的最新版本。\nnpm install jquery@3.0.1 安装指定版本的模块，也可用于将模块更新到指定版本。\nnpm install \u0026ndash;save --save是默认值，在 package.js文件的 dependencies 字段写入依赖，表示运行依赖（生产环境使用，项目上线后依旧会带着该模块）。\n\u0026#34;dependencies\u0026#34;: {  \u0026#34;jquery\u0026#34;: \u0026#34;^3.6.0\u0026#34; } npm install \u0026ndash;save-dev 在 package.js文件的 devDependencies 字段写入依赖，表示开发依赖（开发环境使用，项目上线后不会再带着该模块）。\n\u0026#34;devDependencies\u0026#34;: {  \u0026#34;jquery\u0026#34;: \u0026#34;^3.6.0\u0026#34; } ","title":"npm install"},{"content":"npm run package.json的scripts字段，可以用于指定脚本命令，供npm直接调用。npm run会创建一个 Shell，执行指定的命令。\nstart和test属于特殊命令，可以省略 run，其余的都得带上 run。\nnpm run的参数：\n 如果不加任何参数，直接运行，会列出package.json里面所有可以执行的脚本命令 可配置参数，格式是加上两个连词线（\u0026ndash;）  ","permalink":"https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-run/","summary":"npm run package.json的scripts字段，可以用于指定脚本命令，供npm直接调用。npm run会创建一个 Shell，执行指定的命令。\nstart和test属于特殊命令，可以省略 run，其余的都得带上 run。\nnpm run的参数：\n 如果不加任何参数，直接运行，会列出package.json里面所有可以执行的脚本命令 可配置参数，格式是加上两个连词线（\u0026ndash;）  ","title":"npm install"},{"content":"npm list 查看当前项目安装的所有模块。\nnpm list jquery 查看 jquery 模块的版本号。\nnpm list -g 查看本机全局安装的模块\nnpm list -g \u0026ndash;depth 0 列出全局安装的模块 带上[\u0026ndash;depth 0] 不深入到模块的支点 更简洁。\n","permalink":"https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-list/","summary":"npm list 查看当前项目安装的所有模块。\nnpm list jquery 查看 jquery 模块的版本号。\nnpm list -g 查看本机全局安装的模块\nnpm list -g \u0026ndash;depth 0 列出全局安装的模块 带上[\u0026ndash;depth 0] 不深入到模块的支点 更简洁。","title":"npm list"},{"content":"package.json 项目或模块的描述文件。\n使用npm install安装模块的时候，会自动读取项目中package.json里面的 dependencies 和devDependencies的配置，来安装需要依赖的模块。\ninstall 可简写为 i。\nname 模块名。\nversion 模块版本号。\ndescription 模块描述。\n\u0026quot;^3.6.0\u0026quot;表示安装 3.X.X 中最新的版本。 \u0026quot;~3.6.0\u0026quot;表示安装 3.0.X 中最新的版本。\n\u0026quot;3.6.0\u0026quot;若不加^或~，则表示指定安装3.6.0这个版本。\n\u0026#34;dependencies\u0026#34;: {  \u0026#34;jquery\u0026#34;: \u0026#34;^3.6.0\u0026#34; } homepage 包的官网 url\ncontributors 模块的其他贡献者\nmain 程序的主入口文件。默认是模块根目录下的 index.js。\nscript 脚本。\nrepository 模块代码存放的地方，一般是版本控制器：git、svn等。\nkeywords 关键字\nauthor 包的作者姓名\nlicense dependencies/devDependencies 依赖包列表。\ndependencies是运行时依赖的包。\ndevDependencies是开发时依赖的包。\n","permalink":"https://note.yxzi.xyz/note/technology/packagemanager/npm/package.json/","summary":"package.json 项目或模块的描述文件。\n使用npm install安装模块的时候，会自动读取项目中package.json里面的 dependencies 和devDependencies的配置，来安装需要依赖的模块。\ninstall 可简写为 i。\nname 模块名。\nversion 模块版本号。\ndescription 模块描述。\n\u0026quot;^3.6.0\u0026quot;表示安装 3.X.X 中最新的版本。 \u0026quot;~3.6.0\u0026quot;表示安装 3.0.X 中最新的版本。\n\u0026quot;3.6.0\u0026quot;若不加^或~，则表示指定安装3.6.0这个版本。\n\u0026#34;dependencies\u0026#34;: {  \u0026#34;jquery\u0026#34;: \u0026#34;^3.6.0\u0026#34; } homepage 包的官网 url\ncontributors 模块的其他贡献者\nmain 程序的主入口文件。默认是模块根目录下的 index.js。\nscript 脚本。\nrepository 模块代码存放的地方，一般是版本控制器：git、svn等。\nkeywords 关键字\nauthor 包的作者姓名\nlicense dependencies/devDependencies 依赖包列表。\ndependencies是运行时依赖的包。\ndevDependencies是开发时依赖的包。","title":"npm package.json"},{"content":"npm uninstall 卸载当前项目中的模块。\nnpm uninstall -g 卸载全局中的模块（慎用）\n","permalink":"https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-uninstall/","summary":"npm uninstall 卸载当前项目中的模块。\nnpm uninstall -g 卸载全局中的模块（慎用）","title":"npm uninstall"},{"content":"npm update 将模块更新到最新版本\nnpm update jquery -g 更新指定全局模块。\n","permalink":"https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-update/","summary":"npm update 将模块更新到最新版本\nnpm update jquery -g 更新指定全局模块。","title":"npm update"},{"content":"基础命令 npm -v 查看本机已安装的 npm 的版本\nnpm help 查看 npm 命令列表。\n","permalink":"https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/","summary":"基础命令 npm -v 查看本机已安装的 npm 的版本\nnpm help 查看 npm 命令列表。","title":"npm 基础命令"},{"content":"data data 中的数据，不是直接在 Vue 实例中，而是在_data中，而_data在 Vue 实例中。\ndata 中的数据，Vue 使用了数据代理和数据劫持，从而实现了数据响应式。\n书写方式 对象式 Vue 实例中使用对象式和函数式都可以。\ndata: {  name: \u0026#39;Vue 实例\u0026#39;, }, 函数式 在组件实例中必须使用函数式，否则会报错。\ndata() {  return {  name: \u0026#39;组件实例\u0026#39;,  }; }, ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/data/","summary":"data data 中的数据，不是直接在 Vue 实例中，而是在_data中，而_data在 Vue 实例中。\ndata 中的数据，Vue 使用了数据代理和数据劫持，从而实现了数据响应式。\n书写方式 对象式 Vue 实例中使用对象式和函数式都可以。\ndata: {  name: \u0026#39;Vue 实例\u0026#39;, }, 函数式 在组件实例中必须使用函数式，否则会报错。\ndata() {  return {  name: \u0026#39;组件实例\u0026#39;,  }; }, ","title":"Vue data"},{"content":"methods methods 中的函数，其 this 都指向 Vue 实例或者组件实例对象。\n任何 Vue 实例中的方法，只能使用普通函数，不能使用箭头函数，否则箭头函数中的 this 指向就不再是 Vue，而是 window。\nvar vm = new Vue({ \tel: \u0026#39;#root\u0026#39;, \tdata: { \tname: \u0026#39;China\u0026#39;, \t},  // 方法 \tmethods: {  // 只能使用普通函数 \tshowInfo() { \tconsole.log(this); \t},  // 不能使用箭头函数  showInfo:()=\u0026gt; { \tconsole.log(this); \t}, \t}, \t}, }); Vue.config.productionTip = false; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/methods/","summary":"methods methods 中的函数，其 this 都指向 Vue 实例或者组件实例对象。\n任何 Vue 实例中的方法，只能使用普通函数，不能使用箭头函数，否则箭头函数中的 this 指向就不再是 Vue，而是 window。\nvar vm = new Vue({ \tel: \u0026#39;#root\u0026#39;, \tdata: { \tname: \u0026#39;China\u0026#39;, \t},  // 方法 \tmethods: {  // 只能使用普通函数 \tshowInfo() { \tconsole.log(this); \t},  // 不能使用箭头函数  showInfo:()=\u0026gt; { \tconsole.log(this); \t}, \t}, \t}, }); Vue.config.productionTip = false; ","title":"Vue methods"},{"content":"键盘事件 @键盘事件.按键key值\nVue 中常用的按键别名：\n 回车：enter 删除：delete 退出：esc 空格：space 换行：tab（必须配合 keydow 使用，如果使用 keyup，那么按下 tab 后，当前元素会失去焦点，则元素的 keyup 事件则不会触发）  Vue 未提供别名的按键，可以使用按键原始的 key 值去绑定，但要注意，部分按键的 key 值默认是大坨峰命名，需要转为短横线命名，比如CapsLock。\n\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; @keydown.Caps-Lock=\u0026#39;showInfo\u0026#39;\u0026gt; 系统修饰键（用法特殊）： ctrl、 alt、 shift、 meta。\n 配合 keyup 使用：按下修饰键的同时，再按下其他健，随后只释放其他健，事件才被触发。 配合 keydown 使用：正常触发事件。  自定义 KeyCode\n使用 Vue.confing.keyCode.自定义键名 = KeyCode\n键盘事件连写\n表示按下 ctrl + y才能触发事件。\n\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; @keyup.ctrl.y=\u0026#39;showInfo\u0026#39;\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E4%BA%8B%E4%BB%B6/%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/","summary":"键盘事件 @键盘事件.按键key值\nVue 中常用的按键别名：\n 回车：enter 删除：delete 退出：esc 空格：space 换行：tab（必须配合 keydow 使用，如果使用 keyup，那么按下 tab 后，当前元素会失去焦点，则元素的 keyup 事件则不会触发）  Vue 未提供别名的按键，可以使用按键原始的 key 值去绑定，但要注意，部分按键的 key 值默认是大坨峰命名，需要转为短横线命名，比如CapsLock。\n\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; @keydown.Caps-Lock=\u0026#39;showInfo\u0026#39;\u0026gt; 系统修饰键（用法特殊）： ctrl、 alt、 shift、 meta。\n 配合 keyup 使用：按下修饰键的同时，再按下其他健，随后只释放其他健，事件才被触发。 配合 keydown 使用：正常触发事件。  自定义 KeyCode\n使用 Vue.confing.keyCode.自定义键名 = KeyCode\n键盘事件连写\n表示按下 ctrl + y才能触发事件。\n\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; @keyup.ctrl.y=\u0026#39;showInfo\u0026#39;\u0026gt; ","title":"Vue 键盘事件"},{"content":"Yarn Yarn 在 npm5 之前，优势明显，但在 npm5 之后，两者差别不大。\n安装 全局安装：\nnpm install -g yarn 如果以后要将 Yarn 更新到最新版本，请运行：\nyarn set version latest 优点 速度快\n 并行安装。 离线模式  安装版本统一\n更简洁的输出。\n多注册来源处理。\n更好的命令语义化。\n","permalink":"https://note.yxzi.xyz/note/technology/packagemanager/yarn/yarn/","summary":"Yarn Yarn 在 npm5 之前，优势明显，但在 npm5 之后，两者差别不大。\n安装 全局安装：\nnpm install -g yarn 如果以后要将 Yarn 更新到最新版本，请运行：\nyarn set version latest 优点 速度快\n 并行安装。 离线模式  安装版本统一\n更简洁的输出。\n多注册来源处理。\n更好的命令语义化。","title":"yarn"},{"content":"命令 yarn add 添加模块。\nyarn remove 删除模块。\nyarn add jquery \u0026ndash;dev 安装开发环境的jquery依赖。\n","permalink":"https://note.yxzi.xyz/note/technology/packagemanager/yarn/yarn-add/","summary":"命令 yarn add 添加模块。\nyarn remove 删除模块。\nyarn add jquery \u0026ndash;dev 安装开发环境的jquery依赖。","title":"yarn 命令"},{"content":"包管理器 ","permalink":"https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/","summary":"包管理器 ","title":"包管理器"},{"content":"基础 注释 // 开头的注释，less 不会将其编译到 css 文件中。\n/**/ 包裹的注释，less 才会将其编译到 css 文件中\n// 该注释不可见\r/* 该注释可见 */ 变量 使用@来申明一个变量: @color: #008c8c。\n作为普通属性值只来使用：使用@color\n作为选择器和属性名或 URL：@{attr}、@{class}、@{ur1}的形式。\n// 属性值变量\r@color2: #2775e0;\r@color: #198484;\r// 选择器变量\r@class: .indiv;\r// 属性名变量\r@attr:width;\rdiv {\r// 使用属性名变量\r@{attr}: 100px;\rheight: 100px;\r// 使用属性值变量\rbackground-color: @color2;\r// 使用选择器变量\r@{class}{\rwidth: 40px;\rheight: 50px;\rbackground-color: @color;\r}\r} 被编译为：\ndiv { \twidth: 100px; \theight: 100px; \tbackground-color: #2775e0; } div .indiv { \twidth: 40px; \theight: 50px; \tbackground-color: #198484; } 惰性求值 变量在使用前不必声明。\n.lazy-eval {\r// 在使用 @var 时，无需提前对其声明\rwidth: @var;\rheight: 100px;\rbackground-color: aqua;\r}\r// 在使用 @a 时，无需提前对其声明\r@var: @w;\r@w: 100px; 定义变量两次时，将使用变量的最后一个定义，从当前范围向上搜索。这类似于 css 本身，其中定义中的最后一个属性用于确定值。\n@var: 0;\r.class {\r@var: 1;\r.brass {\r@var: 2;\r// 最后定义的 @var: 3 才是 @var 的最终值\rthree: @var;\r@var: 3;\r}\r// 使用当前块作用域中的 @var，因此为 1\rone: @var;\r} 运算 Less 支持+、-、*、/运算，基本与 JavaScript 相同。\n计算的各值中，若只有一个值带有单位，那么计算结果的单位会依照这个值的单位。\n计算的各值中，如果都没有单位，则计算结果也没有单位。\n计算的各值种，\n// 单位不同，则转换后再进行计算\r// 6cm\r@conversion-1: 5cm + 10mm;\r// -1.5cm\r@conversion-2: 2 - 3cm - 5mm;\r// 结果的单位为首次带单位的值的单位\r// 10px\r@compute: 2px + 3rem + 5rem;\r// 10rem\r@compute: 2rem + 3em + 5px;\r// 10em\r@compute: 2 + 3em + 5px;\r// 无法转换的情况\r// 4px\r@incompatible-units: 2 + 5px - 3cm;\r// 变量也可以转换\r@base: 5%;\r// 10%\r@filler: @base * 2;\r// 15%\r@other: @base + @filler; 避免编译 有时候，我们不希望 Less 帮我们编译或计算一些属性，这时候就可以使用~''的方式来避免编译某些属性。\n","permalink":"https://note.yxzi.xyz/note/technology/language/css/less/%E5%9F%BA%E7%A1%80/","summary":"基础 注释 // 开头的注释，less 不会将其编译到 css 文件中。\n/**/ 包裹的注释，less 才会将其编译到 css 文件中\n// 该注释不可见\r/* 该注释可见 */ 变量 使用@来申明一个变量: @color: #008c8c。\n作为普通属性值只来使用：使用@color\n作为选择器和属性名或 URL：@{attr}、@{class}、@{ur1}的形式。\n// 属性值变量\r@color2: #2775e0;\r@color: #198484;\r// 选择器变量\r@class: .indiv;\r// 属性名变量\r@attr:width;\rdiv {\r// 使用属性名变量\r@{attr}: 100px;\rheight: 100px;\r// 使用属性值变量\rbackground-color: @color2;\r// 使用选择器变量\r@{class}{\rwidth: 40px;\rheight: 50px;\rbackground-color: @color;\r}\r} 被编译为：\ndiv { \twidth: 100px; \theight: 100px; \tbackground-color: #2775e0; } div .","title":""},{"content":"Less Less 一门向后兼容的 CSS 扩展语言。它扩展了 CSS，使 CSS 更易于维护和扩展。\nLess 官方文档\n安装 Node.js：\nnpm install -g less 引入：\n\u0026lt;script src=\u0026#34;//cdnjs.cloudflare.com/ajax/libs/less.js/3.11.1/less.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 将 less 编译为 css 在 less 文件的目录引入执行，就会得到一个 编译后的 css 文件。\nlessc styles.less \u0026gt; styles.css 当然，如果你使用的是 Vs Code，那么直接安装Easy Less扩展即可，每当你保存 less 文件的时候，它会自动将 less 文件编译为 css 文件，方便的很。\n","permalink":"https://note.yxzi.xyz/note/technology/language/css/less/less/","summary":"Less Less 一门向后兼容的 CSS 扩展语言。它扩展了 CSS，使 CSS 更易于维护和扩展。\nLess 官方文档\n安装 Node.js：\nnpm install -g less 引入：\n\u0026lt;script src=\u0026#34;//cdnjs.cloudflare.com/ajax/libs/less.js/3.11.1/less.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 将 less 编译为 css 在 less 文件的目录引入执行，就会得到一个 编译后的 css 文件。\nlessc styles.less \u0026gt; styles.css 当然，如果你使用的是 Vs Code，那么直接安装Easy Less扩展即可，每当你保存 less 文件的时候，它会自动将 less 文件编译为 css 文件，方便的很。","title":"Less"},{"content":"继承 使用 :extend()将混合规则集继承给指定的选择器。extend 是一个 Less 伪类\n继承规则集不能带()。\n// 定义一个继承，它不能有()\r.center {\rposition: absolute;\rleft: 50%;\rtop: 50%;\rtransform: translate(-50%, -50%);\r}\r.wrap {\rwidth: 300px;\rheight: 300px;\rbackground-color: aqua;\r.inner {\r// 将 .center 中的规则集继承到 .wrap .inner{} 中\r// 使用 all\r\u0026amp;:extend(.center);\r\u0026amp;:nth-child(1) {\rwidth: 500px;\rheight: 100px;\rbackground-color: pink;\r}\r\u0026amp;:nth-child(2) {\rwidth: 80px;\rheight: 80px;\rbackground-color: rgb(210, 29, 59);\r}\r}\r} ","permalink":"https://note.yxzi.xyz/note/technology/language/css/less/%E7%BB%A7%E6%89%BF/","summary":"继承 使用 :extend()将混合规则集继承给指定的选择器。extend 是一个 Less 伪类\n继承规则集不能带()。\n// 定义一个继承，它不能有()\r.center {\rposition: absolute;\rleft: 50%;\rtop: 50%;\rtransform: translate(-50%, -50%);\r}\r.wrap {\rwidth: 300px;\rheight: 300px;\rbackground-color: aqua;\r.inner {\r// 将 .center 中的规则集继承到 .wrap .inner{} 中\r// 使用 all\r\u0026amp;:extend(.center);\r\u0026amp;:nth-child(1) {\rwidth: 500px;\rheight: 100px;\rbackground-color: pink;\r}\r\u0026amp;:nth-child(2) {\rwidth: 80px;\rheight: 80px;\rbackground-color: rgb(210, 29, 59);\r}\r}\r} ","title":"Less 继承"},{"content":"MVVM 双向数据绑定，数据影响视图，视图影响数据\nM：模型，指 data 中的数据。\nV：视图，指模板。\nVM：视图模型，指 Vue 实例对象。\ndata 中的所有属性，最后都出现在了 Vue 实例上。\nvue 实例上的所有属性，以及 Vue 原型上的所有属性，在 Vue 模板中国都可以直接使用。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/mvvm/","summary":"MVVM 双向数据绑定，数据影响视图，视图影响数据\nM：模型，指 data 中的数据。\nV：视图，指模板。\nVM：视图模型，指 Vue 实例对象。\ndata 中的所有属性，最后都出现在了 Vue 实例上。\nvue 实例上的所有属性，以及 Vue 原型上的所有属性，在 Vue 模板中国都可以直接使用。","title":"Vue MVVM"},{"content":"set 给响应式对象添加一个属性，并且这个新属性是响应式的，因此，且会触发视图的更新。\n该对象必须是响应式对象，因为 Vue 无法探测普通的新增属性。\n该对象不能是 Vue 实例，或者 Vue 实例的根数据对象：data、。\n如果响应式对象为 array，则第二个参数为 index.\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E5%85%A8%E5%B1%80-api/set/","summary":"set 给响应式对象添加一个属性，并且这个新属性是响应式的，因此，且会触发视图的更新。\n该对象必须是响应式对象，因为 Vue 无法探测普通的新增属性。\n该对象不能是 Vue 实例，或者 Vue 实例的根数据对象：data、。\n如果响应式对象为 array，则第二个参数为 index.","title":"Vue set"},{"content":"插值语法 用于解析元素包含的内容，一般使用{{name}}来进行插值，其中name必须是 JavaScrip 表达式，且可以直接读取data中的所有数据。\n\u0026lt;!-- 插值语法 --\u0026gt; \u0026lt;h1\u0026gt;hello！{{name}}\u0026lt;/h1\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8F%92%E5%80%BC%E8%AF%AD%E6%B3%95/","summary":"插值语法 用于解析元素包含的内容，一般使用{{name}}来进行插值，其中name必须是 JavaScrip 表达式，且可以直接读取data中的所有数据。\n\u0026lt;!-- 插值语法 --\u0026gt; \u0026lt;h1\u0026gt;hello！{{name}}\u0026lt;/h1\u0026gt; ","title":"Vue 插值语法"},{"content":"哈夫曼树 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;queue\u0026gt;using namespace std;  typedef struct node{ \tint data; \tstruct node *lchild, *rchild; } n;  //创建一个节点 node * get_a_node(int data){ \tnode *c = (node *)malloc(sizeof(node)); \tc-\u0026gt;data = data; \tc-\u0026gt;lchild = 0; \tc-\u0026gt;rchild = 0; \treturn c; }   int main(){ \tqueue\u0026lt;node *\u0026gt;q; \t//构建一棵树 \tnode *t = get_a_node(1); \tt-\u0026gt;lchild = get_a_node(2); \tt-\u0026gt;rchild = get_a_node(3); \tt-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5); \tt-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7); \tt-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);  \tq.push(t); \t//在这里测试你所完成的函数 \twhile (q.size() \u0026gt; 0){ \tnode *c = q.front(); \tif(c-\u0026gt;lchild) \tq.push(c-\u0026gt;lchild); \tif(c-\u0026gt;rchild) \tq.push(c-\u0026gt;rchild); \tprintf(\u0026#34;%d \u0026#34;,c-\u0026gt;data); \tq.pop(); \t} } ","permalink":"https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/","summary":"哈夫曼树 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;queue\u0026gt;using namespace std;  typedef struct node{ \tint data; \tstruct node *lchild, *rchild; } n;  //创建一个节点 node * get_a_node(int data){ \tnode *c = (node *)malloc(sizeof(node)); \tc-\u0026gt;data = data; \tc-\u0026gt;lchild = 0; \tc-\u0026gt;rchild = 0; \treturn c; }   int main(){ \tqueue\u0026lt;node *\u0026gt;q; \t//构建一棵树 \tnode *t = get_a_node(1); \tt-\u0026gt;lchild = get_a_node(2); \tt-\u0026gt;rchild = get_a_node(3); \tt-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5); \tt-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7); \tt-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);  \tq.","title":"哈夫曼树"},{"content":"style scoped 默认情况，给不同的组件书写 CSS 样式，最终都会汇总到一个文件，这极有可能导致样式覆盖等问题。\n因此，我们可以给组件中的给\u0026lt;style\u0026gt;添加scoped属性，以表示它的样式只作用于当前模块，很好的实现了样式私有化的目的，这是一个非常好的机制。\n\u0026lt;style scoped\u0026gt; .demo { \tfont-size: 2rem; } \u0026lt;/style\u0026gt; 使用该属性后，它会给组件添加唯一的自定义属性，使我们原本的 CSS 选择器变为 CSS 属性选择器，使得该组件的样式是私有化。\n为什么要慎用 在实际业务中我们往往会对公共组件样式做细微的调整，如果添加了scoped属性，那么样式将会变得不易修改。\nlang 配置当前\u0026lt;style\u0026gt;中所使用的语言，使得 Vue 可以解析。例如：lees\n\u0026lt;style lang=\u0026#34;less\u0026#34;\u0026gt; .demo { \tfont-size: 2rem; \t.sub { \tcolor: rgb(59, 119, 123); \t} } \u0026lt;/style\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/style/","summary":"style scoped 默认情况，给不同的组件书写 CSS 样式，最终都会汇总到一个文件，这极有可能导致样式覆盖等问题。\n因此，我们可以给组件中的给\u0026lt;style\u0026gt;添加scoped属性，以表示它的样式只作用于当前模块，很好的实现了样式私有化的目的，这是一个非常好的机制。\n\u0026lt;style scoped\u0026gt; .demo { \tfont-size: 2rem; } \u0026lt;/style\u0026gt; 使用该属性后，它会给组件添加唯一的自定义属性，使我们原本的 CSS 选择器变为 CSS 属性选择器，使得该组件的样式是私有化。\n为什么要慎用 在实际业务中我们往往会对公共组件样式做细微的调整，如果添加了scoped属性，那么样式将会变得不易修改。\nlang 配置当前\u0026lt;style\u0026gt;中所使用的语言，使得 Vue 可以解析。例如：lees\n\u0026lt;style lang=\u0026#34;less\u0026#34;\u0026gt; .demo { \tfont-size: 2rem; \t.sub { \tcolor: rgb(59, 119, 123); \t} } \u0026lt;/style\u0026gt; ","title":"Vue style"},{"content":"使用组件 组件之间可以嵌套。\n使用组件分为三步：\n 定义组件。 注册组件。 应用组件。  组件名 -命名法：任何环境都可以使用。\n大坨峰命名法：只能在脚手架环境下使用（更推荐）。\n组件名应尽可能避免与 HTML 已有的元素重名。\n定义组件 组件无el配置项。\ndata 必须是一个函数，该函数返回的对象作为该组件的数据。避免组件被复用时，其数据还存在引用关系。\n由于没有el，组件的虚拟 DOM 树必须定义在template 或 render()中。\n创建组件的时候，可以使用 name配置项指定当前组件在 Vue 开发者工具中所呈现的名字。\nconst Student = Vue.extend({ \t// 指定组件名 \tname: \u0026#39;Rainy\u0026#39;, \ttemplate: ` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{studentName}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; `, \tdata() { \treturn { \tstudentName: \u0026#39;忧心\u0026#39;, \t}; \t}, }); 简写 简写方式定义组件，虽然我们没有调用 Vue.extend()方法，但实际上当我们注册组件时， Vue 会帮我们调用该方法。\nconst School = { \ttemplate: ` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{schoolName}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; `, \tdata() { \treturn { \tschoolName: \u0026#39;哈佛\u0026#39;, \t}; \t}, }; 注册组件 局部注册组件 只能在当前实例 el 所指定的容器中使用的组件。\n在 Vue 实例中使用components配置项，建议组件名和子组件名相同。\nvar vm = new Vue({ \ttemplate: `\u0026lt;school\u0026gt;\u0026lt;/school\u0026gt;`, \tel: \u0026#39;#app\u0026#39;, \tcomponents: { \tschool, \t}, }); 全局注册组件 任何容器中都可以使用的组件。\n使用Vue.component()，第一个参数是组件的名字，第二个参数是子组件的名字。\nVue.component(\u0026#39;school\u0026#39;, school); 应用组件 成对方式 \u0026lt;GlobalAssembly\u0026gt;\u0026lt;/GlobalAssembly\u0026gt; 如果当前不是脚手架环境，那么应用大坨峰命名的组件，会报错：\n[Vue warn]: Unknown custom element: \u0026lt;globalassembly\u0026gt; - did you register the component correctly? For recursive components, make sure to provide the \u0026#34;name\u0026#34; option 自闭合方式 \u0026lt;GlobalAssembly /\u0026gt; 当前不在脚手架环境时，不推荐使用自闭合的方式来应用组件。因为这会导致某些 BUG\n组件的嵌套 HTML\n\u0026lt;!-- 应用组件 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; JavaScript\nconst Student = Vue.extend({ \tname: \u0026#39;Rainy\u0026#39;, \ttemplate: ` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{studentName}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt;`, \tdata() { \treturn { \tstudentName: \u0026#39;学生\u0026#39;, \t}; \t}, });  const Hello = Vue.extend({ \ttemplate: ` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{globalName}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; `, \tdata() { \treturn { \tglobalName: \u0026#39;hello\u0026#39;, \t}; \t}, }); const School = { \ttemplate: ` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{schoolName}}\u0026lt;/h1\u0026gt; \u0026lt;Student\u0026gt;\u0026lt;/Student\u0026gt; \u0026lt;/div\u0026gt; `, \tdata() { \treturn { \tschoolName: \u0026#39;学校\u0026#39;, \t}; \t}, \tcomponents: { \tStudent, \t}, };  const App = { \ttemplate: ` \u0026lt;div\u0026gt; \u0026lt;Hello\u0026gt;\u0026lt;/Hello\u0026gt; \u0026lt;School\u0026gt;\u0026lt;/School\u0026gt; \u0026lt;/div\u0026gt; `, \tcomponents: { \tHello, \tSchool, \t}, };  // 局部注册组件 var vm = new Vue({ \ttemplate: `\u0026lt;App\u0026gt;\u0026lt;/App\u0026gt;`, \tel: \u0026#39;#app\u0026#39;, \tcomponents: { \tApp, \t}, });  Vue.config.productionTip = false; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6/","summary":"使用组件 组件之间可以嵌套。\n使用组件分为三步：\n 定义组件。 注册组件。 应用组件。  组件名 -命名法：任何环境都可以使用。\n大坨峰命名法：只能在脚手架环境下使用（更推荐）。\n组件名应尽可能避免与 HTML 已有的元素重名。\n定义组件 组件无el配置项。\ndata 必须是一个函数，该函数返回的对象作为该组件的数据。避免组件被复用时，其数据还存在引用关系。\n由于没有el，组件的虚拟 DOM 树必须定义在template 或 render()中。\n创建组件的时候，可以使用 name配置项指定当前组件在 Vue 开发者工具中所呈现的名字。\nconst Student = Vue.extend({ \t// 指定组件名 \tname: \u0026#39;Rainy\u0026#39;, \ttemplate: ` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{studentName}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; `, \tdata() { \treturn { \tstudentName: \u0026#39;忧心\u0026#39;, \t}; \t}, }); 简写 简写方式定义组件，虽然我们没有调用 Vue.extend()方法，但实际上当我们注册组件时， Vue 会帮我们调用该方法。\nconst School = { \ttemplate: ` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{schoolName}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; `, \tdata() { \treturn { \tschoolName: \u0026#39;哈佛\u0026#39;, \t}; \t}, }; 注册组件 局部注册组件 只能在当前实例 el 所指定的容器中使用的组件。","title":"Vue 使用组件"},{"content":"插槽 单个插槽。将一个组件的内容，传递到\u0026lt;slot\u0026gt;\u0026lt;/solt\u0026gt;中。\n\u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; 具名插槽 有时我们需要多个插槽，就需要给 \u0026lt;slot\u0026gt; 带上一个名字。\n一个不带 name 的 \u0026lt;slot\u0026gt; 出口会带有隐含的名字“default”。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E6%8F%92%E6%A7%BD/","summary":"插槽 单个插槽。将一个组件的内容，传递到\u0026lt;slot\u0026gt;\u0026lt;/solt\u0026gt;中。\n\u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; 具名插槽 有时我们需要多个插槽，就需要给 \u0026lt;slot\u0026gt; 带上一个名字。\n一个不带 name 的 \u0026lt;slot\u0026gt; 出口会带有隐含的名字“default”。","title":"Vue 插槽"},{"content":"组件树 一个组件创建好后，往往会在各种地方使用它。它可能多次出现在 Vue 实例中，也可能出现在其他组件实例中，于是就形成了一棵组件树。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E6%A0%91/","summary":"组件树 一个组件创建好后，往往会在各种地方使用它。它可能多次出现在 Vue 实例中，也可能出现在其他组件实例中，于是就形成了一棵组件树。","title":"Vue 组件树"},{"content":"重要的内置关系 VueConponent.prototype.__proto__ === Vue.prototype\n为什么要有这个关系？\n让该组件实例对象可以访问到 Vue 原型上的属性和方法。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; JavaScrip\n// VueComponent 的实例对象 school const school = { \ttemplate: ` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{schoolName}}\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#39;fun\u0026#39;\u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; `, \tdata() { \treturn { \tschoolName: \u0026#39;哈佛\u0026#39;, \t}; \t}, \tmethods: { \tfun() { \t// 调用 school 上没有的 val \tconsole.log(this.val); \t}, \t}, }; Vue.component(\u0026#39;school\u0026#39;, school);  // Vue new Vue({ \ttemplate: `\u0026lt;school\u0026gt;\u0026lt;/school\u0026gt;`, \tel: \u0026#39;#app\u0026#39;, \tdata: {}, }); // Vue 的 prototype Vue.prototype.val = \u0026#39;我是 Vue 原型对象上的属性\u0026#39;; Vue.config.productionTip = false; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E7%BD%AE%E5%85%B3%E7%B3%BB/","summary":"重要的内置关系 VueConponent.prototype.__proto__ === Vue.prototype\n为什么要有这个关系？\n让该组件实例对象可以访问到 Vue 原型上的属性和方法。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; JavaScrip\n// VueComponent 的实例对象 school const school = { \ttemplate: ` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{schoolName}}\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#39;fun\u0026#39;\u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; `, \tdata() { \treturn { \tschoolName: \u0026#39;哈佛\u0026#39;, \t}; \t}, \tmethods: { \tfun() { \t// 调用 school 上没有的 val \tconsole.log(this.val); \t}, \t}, }; Vue.component(\u0026#39;school\u0026#39;, school);  // Vue new Vue({ \ttemplate: `\u0026lt;school\u0026gt;\u0026lt;/school\u0026gt;`, \tel: \u0026#39;#app\u0026#39;, \tdata: {}, }); // Vue 的 prototype Vue.","title":"Vue 重要的内置关系"},{"content":"VueCli 安装 全局安装：\nnpm install -g @vue/cli 安装完成后，用命令检查安装的版本\nvue --version 创建项目 vue create vue-cli 接下来就是一些导航选择，根据自己选择即可。\n运行工程 创建完成后，用cd进入 vue-cli 目录，再用npm run serve启动工程，出现以下提示即为运行成功：\n App running at:  - Local: http://localhost:8080/  - Network: unavailable Local：它会将工程托管到本地的一个服务器地址 http://localhost:8080/。\nNetwork：运行时的网络状态。\n项目中的目录文件 node_modules：保存着 Vue 所有直接或间接依赖的第三方库。\npublic：保存着页面模板。\nsrc：源代码目录。\npackage.json：工程配置文件\n  serve：开发环境，它会将工程托管到一个本地服务器进行预览。\n  build：生产环境，它会将工程打包成一个dist文件夹，这个文件夹就是我们工程的源代码\n  vue.config.js：vue-cli 的配置文件，大部分都配置都是 webpack 配置\n \u0026#34;scripts\u0026#34;: {\r\u0026#34;serve\u0026#34;: \u0026#34;vue-cli-service serve\u0026#34;,\r\u0026#34;build\u0026#34;: \u0026#34;vue-cli-service build\u0026#34;\r}, 还原工程 使用npm install，它会根据package.json文件中的dependencies和devDependencies来还原node_modules目录\n配置二年级\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/vuecli/vuecli/","summary":"VueCli 安装 全局安装：\nnpm install -g @vue/cli 安装完成后，用命令检查安装的版本\nvue --version 创建项目 vue create vue-cli 接下来就是一些导航选择，根据自己选择即可。\n运行工程 创建完成后，用cd进入 vue-cli 目录，再用npm run serve启动工程，出现以下提示即为运行成功：\n App running at:  - Local: http://localhost:8080/  - Network: unavailable Local：它会将工程托管到本地的一个服务器地址 http://localhost:8080/。\nNetwork：运行时的网络状态。\n项目中的目录文件 node_modules：保存着 Vue 所有直接或间接依赖的第三方库。\npublic：保存着页面模板。\nsrc：源代码目录。\npackage.json：工程配置文件\n  serve：开发环境，它会将工程托管到一个本地服务器进行预览。\n  build：生产环境，它会将工程打包成一个dist文件夹，这个文件夹就是我们工程的源代码\n  vue.config.js：vue-cli 的配置文件，大部分都配置都是 webpack 配置\n \u0026#34;scripts\u0026#34;: {\r\u0026#34;serve\u0026#34;: \u0026#34;vue-cli-service serve\u0026#34;,\r\u0026#34;build\u0026#34;: \u0026#34;vue-cli-service build\u0026#34;\r}, 还原工程 使用npm install，它会根据package.json文件中的dependencies和devDependencies来还原node_modules目录\n配置二年级","title":"VueCli"},{"content":"Object 方法 defineProperty() 用于在一个对象上定义一个新属性，或者修改一个对象的已有属性，并返回此对象。\n使用 defineProperty() 定义的属性无法被枚举。\nvalue 该属性对应的值。默认值为undefined。\nenumerable 控制属性是否可以被枚举。\n可枚举属性是指那些内部enumerable设置为 true 的属性，对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true，对于通过Object.defineProperty() 等定义的属性，该标识值默认为 false。\nwritable 控制属性是否可以被修改，默认值为false\nconfigurable 控制属性是否可以被删除，默认值为false\nget() 当访问当前属性时，会调用此函数。该函数的返回值会被用作当前属性的值。\nset() 当前属性值被修改时，会调用此函数。该方法接受一个参数（当前属性被赋予的新值），会传入赋值时的 this 对象。\nvar number = 20; var person = { \tName: \u0026#39;张三\u0026#39;, \tsex: \u0026#39;男\u0026#39;, \t// age: 25, }; Object.defineProperty(person, \u0026#39;age\u0026#39;, { \t// 每当我们读取 person 的 age 属性时，get() 就会被调用，且返回值是 age 的值 \tget() { \tconsole.log(\u0026#39;读取 age 的值\u0026#39;); \treturn number; \t}, \t// 每当我们修改 person 的 age 属性时，set() 就会被调用，且会收到被修改后的的值 \tset(value) { \tconsole.log(\u0026#39;age 的值被修改为：\u0026#39;, value); \tnumber = value; \t}, }); keys() 返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。\ntoString() toString() 方法用于返回一个表示该对象的字符串。\n每个对象都有 toString() 方法，但 undefined 与 null 没有，因为它们不是对象。\n当 number、string、boolean 原值类型的数据调用 toString() 方法时，都会先进行包装类。 因为 Number 对象覆盖了 Object 对象上的 toString() 方法（因为 Number 对象将 toString 方法重写了），所以它不继承自 Object.prototype.toString()。\n另外，document.write() 方法，它也使用了 toString() 方法。\n重写 toSrting() demo.prototype = { \ttoSrting: function () { \t// 重新写一个同名但不同功能的 toSrting 方法，覆盖构造函数 demo 的原型的 toSrting 方法 \treturn \u0026#39;重写的 toSrting()\u0026#39;; \t}, }; function demo() {} var a = new demo(); console.log(a.toSrting()); // 调用对象 a 的构造函数的原型对象中的重写后的 toString 方法 重写 document.write() var obj = Object.create(null); obj.toString = function () { \treturn \u0026#39;重写的 document.write() 方法\u0026#39;; }; document.write(obj); create() 该方法创建一个新对象， () 中可以指定这个新创建的对象的原型对象，即可以为 object 或 null，但不能为原始值。\n使用 null 作为原型对象的对象，该对象没有原型（即没有属性 proto ），但它也是一个对象。\n重写 toSrting() var a = {}; var b = Object.create(a); // 将对象 a 放入 creat 方法中，即将对象 b 的原型变为对象 a hasOwnProperty() 该方法用于判断指定对象的属性是否是该对象自身的，或是该对象的原型的属性，并会返回一个布尔值。该方法通常与 for in 语句配合使用。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/object/objet-%E6%96%B9%E6%B3%95/","summary":"Object 方法 defineProperty() 用于在一个对象上定义一个新属性，或者修改一个对象的已有属性，并返回此对象。\n使用 defineProperty() 定义的属性无法被枚举。\nvalue 该属性对应的值。默认值为undefined。\nenumerable 控制属性是否可以被枚举。\n可枚举属性是指那些内部enumerable设置为 true 的属性，对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true，对于通过Object.defineProperty() 等定义的属性，该标识值默认为 false。\nwritable 控制属性是否可以被修改，默认值为false\nconfigurable 控制属性是否可以被删除，默认值为false\nget() 当访问当前属性时，会调用此函数。该函数的返回值会被用作当前属性的值。\nset() 当前属性值被修改时，会调用此函数。该方法接受一个参数（当前属性被赋予的新值），会传入赋值时的 this 对象。\nvar number = 20; var person = { \tName: \u0026#39;张三\u0026#39;, \tsex: \u0026#39;男\u0026#39;, \t// age: 25, }; Object.defineProperty(person, \u0026#39;age\u0026#39;, { \t// 每当我们读取 person 的 age 属性时，get() 就会被调用，且返回值是 age 的值 \tget() { \tconsole.log(\u0026#39;读取 age 的值\u0026#39;); \treturn number; \t}, \t// 每当我们修改 person 的 age 属性时，set() 就会被调用，且会收到被修改后的的值 \tset(value) { \tconsole.","title":"JavaScript Object 方法"},{"content":"箭头函数 任何可以使用匿名函数的位置均可以使用箭头函数。\n箭头函数适合与 this 无关的回调，不适合与 this 有关的回调。\n// 普通匿名函数 var sum = function (a, b) { \treturn a + b; }; console.log(sum(1, 2)); // 箭头函数 var sumES6 = (a, b) =\u0026gt; { \treturn a + b; }; console.log(sumES6(4, 3)); 可以看出，定义箭头函在数语法上要比普通函数简洁得多。\n参数 没有参数，直接写一个空括号()即可。\n只有一个参数，可以省去包裹参数的括号。\n多个参数，将参数依次用逗号(,)分隔。\n// 无参数 var fun1 = () =\u0026gt; { \tconsole.log(\u0026#39;无参数\u0026#39;); };  // 只有一个参数 var fun2 = (name) =\u0026gt; { \tconsole.log(name); };  // 多个参数 var fun3 = (val1, val2, val3) =\u0026gt; { \treturn [val1, val2, val3]; }; 函数体 如果箭头函数的函数体中只有一句代码，可以省去函数体的大括号{ }，此时rturn 必须省略。\nlet f2 = function (val) { \treturn val; }; // 等同于 let f = (val) =\u0026gt; val;  console.log(f(12)); console.log(f2(999)); this 箭头函数没有自己的this，它会捕获自己在定义时（注意，是定义时，不是调用时）所处的作用域作为this。所以，箭头函数中this的指向在它被定义的时候就已经确定了，之后永远不会改变。\nvar id = \u0026#39;Global\u0026#39;; var obj = { \tid: \u0026#39;Obj\u0026#39;, \tfun() { \t//普通函数 \tsetTimeout(function () { \t// 普通函数的 this 指向了 window 中的 id \tconsole.log(this.id); \t}, 000); \t}, \tfun1() { \t// 箭头函数 \tsetTimeout(() =\u0026gt; { \t// 箭头函数的 this 指向了 obj1 中的 id \tconsole.log(this.id); \t}, 1000); \t}, };  obj.fun1(); obj.fun(); fun1中的setTimeout()中使用普通函数，1 秒后函数执行时，这时函数其实是在全局作用域执行的，因为setTimeout()是 window 的方法，所以函数中的this指向Window对象。因此，this.id就指向全局变量中的id。\n而fun2中的setTimeout()中使用的是箭头函数，这个箭头函数的this在定义时就确定了，它继承了它外层fun2的执行环境（obj），因此，setTimeout()中的 this 就变为了 fun2 的执行环境 obj。\nthis 指向无法改变 call()、apply()、bind()无法改变箭头函数中 this 的指向。\n这是由于箭头函数的this定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数this的指向，虽然这么做代码不会报错。\n不能作为构造函数 因为箭头函数没有直接的this，所以箭头函数无法作为构造函数去实例化一个对象。或者说构造函数不能定义成箭头函数，否则用new时会报错。\nlet Fun = (name, age) =\u0026gt; { \tthis.name = name; \tthis.age = age; };  let p = new Fun(\u0026#39;rainy\u0026#39;, 21); 没有 arguments // 普通函数 function fun(a) { \tconsole.log(a); \tconsole.log(arguments); } fun(000); // 箭头函数 let ES6fun = (val) =\u0026gt; { \tconsole.log(val); // 111 \t// 下面一行会报错 \t// 因为全局作用域和块级作用域中都没有 arguments 对象 \tconsole.log(arguments); }; ES6fun(111); 没有 prototype let fun = function () { \tconsole.log(\u0026#39;Hello World !\u0026#39;); }; // {constructor: ƒ} console.log(fun.prototype);  let ES5Fun = () =\u0026gt; { \tconsole.log(\u0026#39;Hello World !\u0026#39;); }; // undefined console.log(ES5Fun.prototype); 不能用作 Generator()，不能使用 yield ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","summary":"箭头函数 任何可以使用匿名函数的位置均可以使用箭头函数。\n箭头函数适合与 this 无关的回调，不适合与 this 有关的回调。\n// 普通匿名函数 var sum = function (a, b) { \treturn a + b; }; console.log(sum(1, 2)); // 箭头函数 var sumES6 = (a, b) =\u0026gt; { \treturn a + b; }; console.log(sumES6(4, 3)); 可以看出，定义箭头函在数语法上要比普通函数简洁得多。\n参数 没有参数，直接写一个空括号()即可。\n只有一个参数，可以省去包裹参数的括号。\n多个参数，将参数依次用逗号(,)分隔。\n// 无参数 var fun1 = () =\u0026gt; { \tconsole.log(\u0026#39;无参数\u0026#39;); };  // 只有一个参数 var fun2 = (name) =\u0026gt; { \tconsole.log(name); };  // 多个参数 var fun3 = (val1, val2, val3) =\u0026gt; { \treturn [val1, val2, val3]; }; 函数体 如果箭头函数的函数体中只有一句代码，可以省去函数体的大括号{ }，此时rturn 必须省略。","title":"JavaScript 箭头函数"},{"content":"语法糖 对象属性简写 简写对象的属性以及方法。\nvar name = \u0026#39;月色\u0026#39;; var age = 20; var sex = \u0026#39;男\u0026#39;; // 传统对象的属性 var person = { \tname: name, \tage: age, \tFun: function () { \tconsole.log(sex); \t}, }; // 语法糖对象的属性 var personES6 = { \tname, \tage, \tFun() { \tconsole.log(sex); \t}, }; console.log(person); console.log(personES6); 模板字符串 用反引号``声明（传统字符串是双引号或单引号）。\n通过模板字符串，你可以以${表达式}的形式在模板中插入任何 JavaScript 表达式、变量。\n默认支持多行，无需使用\\n来换行。\nvar person = { \tname: \u0026#39;Rainy\u0026#39;, \tage: \u0026#39;20\u0026#39;, }; // 传统字符串拼接 var str = \u0026#39;my name is \u0026#39; + person.name + \u0026#39; \\nand age is \u0026#39; + person.age; console.log(str);  // 模板字符串嵌入 var strES6 = `my name is ${person.name}and age is ${person.age}`; console.log(strES6); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E6%B3%95%E7%B3%96/","summary":"语法糖 对象属性简写 简写对象的属性以及方法。\nvar name = \u0026#39;月色\u0026#39;; var age = 20; var sex = \u0026#39;男\u0026#39;; // 传统对象的属性 var person = { \tname: name, \tage: age, \tFun: function () { \tconsole.log(sex); \t}, }; // 语法糖对象的属性 var personES6 = { \tname, \tage, \tFun() { \tconsole.log(sex); \t}, }; console.log(person); console.log(personES6); 模板字符串 用反引号``声明（传统字符串是双引号或单引号）。\n通过模板字符串，你可以以${表达式}的形式在模板中插入任何 JavaScript 表达式、变量。\n默认支持多行，无需使用\\n来换行。\nvar person = { \tname: \u0026#39;Rainy\u0026#39;, \tage: \u0026#39;20\u0026#39;, }; // 传统字符串拼接 var str = \u0026#39;my name is \u0026#39; + person.","title":"JavaScript 语法糖"},{"content":"Mustache Mustache 是一个 轻逻辑放模板解析引擎。\n小程序的 wxml 中的代码、Vue 中的插值都是用的 mustache。\n语法 {{keyName}} 简单的变量替换。\n{{{keyName}}} 输出会将等特殊字符转译，如果想保持内容原样输出可以使用{{{}}}。\n{{#keyName}} {{/keyName}} 以#开始、以/结束表示区块，它会根据当前上下文中的键值来对区块进行一次或多次渲染。它的功能很强大，有类似 if、foreach 的功能。\n{{^keyName}} {{/keyName}} 该语法与{{#keyName}} {{/keyName}} 类似，不同在于它是当 keyName 值为 null, undefined, false 时才渲染输出该区块内容。\n{{.}} 表示枚举，可以循环输出整个数组。\n{{!comments}} 表示注释\n{{\u0026gt;partials}} 以\u0026gt;开始表示子模块，当结构比较复杂时，我们可以使用该语法将复杂的结构拆分成几个小的子模块。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/mustache/","summary":"Mustache Mustache 是一个 轻逻辑放模板解析引擎。\n小程序的 wxml 中的代码、Vue 中的插值都是用的 mustache。\n语法 {{keyName}} 简单的变量替换。\n{{{keyName}}} 输出会将等特殊字符转译，如果想保持内容原样输出可以使用{{{}}}。\n{{#keyName}} {{/keyName}} 以#开始、以/结束表示区块，它会根据当前上下文中的键值来对区块进行一次或多次渲染。它的功能很强大，有类似 if、foreach 的功能。\n{{^keyName}} {{/keyName}} 该语法与{{#keyName}} {{/keyName}} 类似，不同在于它是当 keyName 值为 null, undefined, false 时才渲染输出该区块内容。\n{{.}} 表示枚举，可以循环输出整个数组。\n{{!comments}} 表示注释\n{{\u0026gt;partials}} 以\u0026gt;开始表示子模块，当结构比较复杂时，我们可以使用该语法将复杂的结构拆分成几个小的子模块。","title":"Mustache"},{"content":"判断变量类型 is_XX() 判断一个变量是否为指定数据类型，最终返回这个变量所保存数据的数据类型。\nBool 类型不能用 echo 来查看，需要使用 var_dump() 查看。\n// true var_dump(is_int($a)); echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;;  // false var_dump(is_int($b)); echo \u0026#39;\u0026lt;hr/\u0026gt;\u0026#39;; gettype() 获取变量的类型，得到的是该类型对应的字符串。\n// string echo \u0026#39;a 的数据类型为：\u0026#39; . gettype($a); echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; // integer echo \u0026#39;b 的数据类型为：\u0026#39; . gettype($b);  echo \u0026#39;\u0026lt;hr/\u0026gt;\u0026#39;; ","permalink":"https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","summary":"判断变量类型 is_XX() 判断一个变量是否为指定数据类型，最终返回这个变量所保存数据的数据类型。\nBool 类型不能用 echo 来查看，需要使用 var_dump() 查看。\n// true var_dump(is_int($a)); echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;;  // false var_dump(is_int($b)); echo \u0026#39;\u0026lt;hr/\u0026gt;\u0026#39;; gettype() 获取变量的类型，得到的是该类型对应的字符串。\n// string echo \u0026#39;a 的数据类型为：\u0026#39; . gettype($a); echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; // integer echo \u0026#39;b 的数据类型为：\u0026#39; . gettype($b);  echo \u0026#39;\u0026lt;hr/\u0026gt;\u0026#39;; ","title":"PHP 判断数据类型"},{"content":"数组 索引数组 用数字作为键名的数组一般叫做索引数组。用字符串表示键的数组就是下面要介绍的关联数组。索引数组的键是整数，而且从 0 开始以此类推。\n关联数组 数组的key是字符串。\n特点   可以使用整数或字符串作为下标。\n  下标为整数则为索引数组。\n  下标都为字符串，则为关联数组。\n    不同的下标（字符串、整数）可以混合存在，则为混合数组。\n  数组中元素的顺序以放入顺序为准，与指定的下标无关。\n  特殊的下标自动转换：false、true、null。\n  ","permalink":"https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/","summary":"数组 索引数组 用数字作为键名的数组一般叫做索引数组。用字符串表示键的数组就是下面要介绍的关联数组。索引数组的键是整数，而且从 0 开始以此类推。\n关联数组 数组的key是字符串。\n特点   可以使用整数或字符串作为下标。\n  下标为整数则为索引数组。\n  下标都为字符串，则为关联数组。\n    不同的下标（字符串、整数）可以混合存在，则为混合数组。\n  数组中元素的顺序以放入顺序为准，与指定的下标无关。\n  特殊的下标自动转换：false、true、null。\n  ","title":"PHP 数组"},{"content":"文件包含 在一个 PHP 脚本中，将另一个文件的代码插入到当前文件，并使用另一个文件中的方法、变量等等。\n用于实现代码模块化。\n被包含的文件是单独进行编译的\n包含方式 include() 一般放在程序的流程控制中，当程序执行时碰到才会引用，简化程序的执行流程。\ninclude()引入的文件有错误时，会继续执行，并返回一个警告。\ninclude once() 检查当前文件是否已经在前面被引入过了，如果已经引入过，则不在引入。\n可以避免某写代码重新执行而报错，比如重复引入导致常量重复定义。\nrequire() 一般放在 PHP 文件的最前面，程序在执行前就会先导入要引用的文件。\nrequire()引入的文件有错误时，执行会中断，并返回一个致命错误。\nrequire onec() 检查当前文件是否已经在前面被引入过了，如果已经引入过，则不在引入。\n可以避免某写代码重新执行而报错，比如重复引入导致常量重复定义。\n","permalink":"https://note.yxzi.xyz/note/technology/language/php/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","summary":"文件包含 在一个 PHP 脚本中，将另一个文件的代码插入到当前文件，并使用另一个文件中的方法、变量等等。\n用于实现代码模块化。\n被包含的文件是单独进行编译的\n包含方式 include() 一般放在程序的流程控制中，当程序执行时碰到才会引用，简化程序的执行流程。\ninclude()引入的文件有错误时，会继续执行，并返回一个警告。\ninclude once() 检查当前文件是否已经在前面被引入过了，如果已经引入过，则不在引入。\n可以避免某写代码重新执行而报错，比如重复引入导致常量重复定义。\nrequire() 一般放在 PHP 文件的最前面，程序在执行前就会先导入要引用的文件。\nrequire()引入的文件有错误时，执行会中断，并返回一个致命错误。\nrequire onec() 检查当前文件是否已经在前面被引入过了，如果已经引入过，则不在引入。\n可以避免某写代码重新执行而报错，比如重复引入导致常量重复定义。","title":"PHP 文件包含"},{"content":"流程控制代替语法 代替 for PHP 本身是嵌入到 HTML 中的脚本语言，因此，我们可以这样书写：\n// 生成了九个一级标题元素。 \u0026lt;?php for ($i = 1; $i \u0026lt; 10; $i++) { ?\u0026gt;\u0026lt;h1\u0026gt;一级标题\u0026lt;/h1\u0026gt; \u0026lt;?php } ?\u0026gt; 但是，如果我们以上面这种方式将 PHP 代码嵌入到 HTML 中，那么{}给我们所带来的观感是非常不好的。\n因此， PHP 提供了一种代替{}的机制：\n\u0026lt;?php for ($i = 1; $i \u0026lt; 10; $i++) : ?\u0026gt;\u0026lt;h1\u0026gt;一级标题\u0026lt;/h1\u0026gt; \u0026lt;?php endfor; ?\u0026gt; 同样的，除了for，PHP 还支持 if、switch、while、foreach：\n\u0026lt;?php if (1 \u0026lt; 2) : ?\u0026gt;\u0026lt;h1\u0026gt;一级标题\u0026lt;/h1\u0026gt; \u0026lt;?php endif; ?\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/language/php/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%BB%A3%E6%9B%BF%E8%AF%AD%E6%B3%95/","summary":"流程控制代替语法 代替 for PHP 本身是嵌入到 HTML 中的脚本语言，因此，我们可以这样书写：\n// 生成了九个一级标题元素。 \u0026lt;?php for ($i = 1; $i \u0026lt; 10; $i++) { ?\u0026gt;\u0026lt;h1\u0026gt;一级标题\u0026lt;/h1\u0026gt; \u0026lt;?php } ?\u0026gt; 但是，如果我们以上面这种方式将 PHP 代码嵌入到 HTML 中，那么{}给我们所带来的观感是非常不好的。\n因此， PHP 提供了一种代替{}的机制：\n\u0026lt;?php for ($i = 1; $i \u0026lt; 10; $i++) : ?\u0026gt;\u0026lt;h1\u0026gt;一级标题\u0026lt;/h1\u0026gt; \u0026lt;?php endfor; ?\u0026gt; 同样的，除了for，PHP 还支持 if、switch、while、foreach：\n\u0026lt;?php if (1 \u0026lt; 2) : ?\u0026gt;\u0026lt;h1\u0026gt;一级标题\u0026lt;/h1\u0026gt; \u0026lt;?php endif; ?\u0026gt; ","title":"PHP 流程控制代替语法"},{"content":"运算符 错误抑制符 在 PHP 中 有一些错误可以提前预知，但是这些错误可能无法避免，但又不希望报错给用户看，可以使用错误抑制符@()处理。\n\u0026lt;?php $a = 10; $b = 0; @($c = $a / $b);  echo $c; 错误抑制符通常在生产环境（上线）会用到，在开发的时候不会用系统本身最好没有任何。\n","permalink":"https://note.yxzi.xyz/note/technology/language/php/%E8%BF%90%E7%AE%97%E7%AC%A6/","summary":"运算符 错误抑制符 在 PHP 中 有一些错误可以提前预知，但是这些错误可能无法避免，但又不希望报错给用户看，可以使用错误抑制符@()处理。\n\u0026lt;?php $a = 10; $b = 0; @($c = $a / $b);  echo $c; 错误抑制符通常在生产环境（上线）会用到，在开发的时候不会用系统本身最好没有任何。","title":"PHP 运算符"},{"content":"RegExp 属性 lastIndex 从 0 开始，表示字符在进行下一次匹配时的起始位置，这个属性会被exec()和test()用到。\n该属性可以被手动修改。\nvar reg = /ab/g;  var str = \u0026#39;abababab\u0026#39;;  // 第一次匹配，lastIndex 变为 2 console.log(reg.exec(str)); // lastIndex = 2 console.log(reg.lastIndex); //手动修改 lastIndex reg.lastIndex = 0; // 修改成功，lastIndex = 2 console.log(reg.exec(str)); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/regexp/regexp-%E5%B1%9E%E6%80%A7/","summary":"RegExp 属性 lastIndex 从 0 开始，表示字符在进行下一次匹配时的起始位置，这个属性会被exec()和test()用到。\n该属性可以被手动修改。\nvar reg = /ab/g;  var str = \u0026#39;abababab\u0026#39;;  // 第一次匹配，lastIndex 变为 2 console.log(reg.exec(str)); // lastIndex = 2 console.log(reg.lastIndex); //手动修改 lastIndex reg.lastIndex = 0; // 修改成功，lastIndex = 2 console.log(reg.exec(str)); ","title":"RegExp 属性"},{"content":"量词 表示数量。\nn+ 匹配 n 一次或多次，等价于 {1,}。\nvar reg = /a+/g;  var str = \u0026#39;aavva\u0026#39;;  var result = str.match(reg); console.log(result); n* 匹配 n 零次或多次。等价于{0,}。\nvar reg = /a*/g;  var str = \u0026#39;aavva\u0026#39;;  var result = str.match(reg); console.log(result); n? 匹配 n 零次或一次。等价于 {0,1}。\nvar reg = /a?/g;  var str = \u0026#39;aavva\u0026#39;;  var result = str.match(reg); console.log(result); n{x} 匹配 n 表达式 x 次。x 是一个非负整数。\nvar reg = /o{2}/g;  var str = \u0026#39;boooody\u0026#39;;  var result = str.match(reg); console.log(result); {x,y} 最少匹配 x 次且最多匹配 y 次。x 和 y 均为非负整数，其中 n x\u0026lt;= y。\n{x,} 至少匹配 x 次，最多匹配无数次。x 是一个非负整数。\n^n 匹配以 n 开头的字符串。从字符串开头开始匹配。\n如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 \\n 或 \\r之后的位置。\nvar reg = /^ma/g;  var str = \u0026#39;mallandmalls\u0026#39;;  var result = str.match(reg); console.log(result); n$ 匹配以 n 结尾的字符串。从字符串末尾开始匹配。\n如果设置了 RegExp 对象的 Multiline 属性，$ 也匹配\\n或\\r之后的位置。\nvar reg = /ll$/g;  var str = \u0026#39;mallandmall\u0026#39;;  var result = str.match(reg); console.log(result); ^n$ 限定匹配到字符串必须是 n。\nvar reg = /^rainy$/g;  var str = \u0026#39;rainy\u0026#39;;  var result = str.match(reg); console.log(result); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E9%87%8F%E8%AF%8D/","summary":"量词 表示数量。\nn+ 匹配 n 一次或多次，等价于 {1,}。\nvar reg = /a+/g;  var str = \u0026#39;aavva\u0026#39;;  var result = str.match(reg); console.log(result); n* 匹配 n 零次或多次。等价于{0,}。\nvar reg = /a*/g;  var str = \u0026#39;aavva\u0026#39;;  var result = str.match(reg); console.log(result); n? 匹配 n 零次或一次。等价于 {0,1}。\nvar reg = /a?/g;  var str = \u0026#39;aavva\u0026#39;;  var result = str.match(reg); console.log(result); n{x} 匹配 n 表达式 x 次。x 是一个非负整数。\nvar reg = /o{2}/g;  var str = \u0026#39;boooody\u0026#39;;  var result = str.","title":"RegExp 量词"},{"content":"computd 通过已有的属性计算出来的属性。\n计算属性最终会出现在 Vue 实例上，直接调用即可。\n如果计算属性有可能被修改，那必须写set()去响应修改，且要引起计算属性所依赖的属性发生变化。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \t\u0026lt;p\u0026gt;姓：{{ firstName }}\u0026lt;/p\u0026gt; \t\u0026lt;p\u0026gt;名：{{ lastName }}\u0026lt;/p\u0026gt; \t\u0026lt;p\u0026gt;全名：{{ fullName }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; JavaScrip\nvar vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \ttext: \u0026#39;表单\u0026#39;, \tfirstName: \u0026#39;苏\u0026#39;, \tlastName: \u0026#39;明敏\u0026#39;, \t}, \tcomputed: { \tfullName: { \tget() { \treturn this.firstName + \u0026#39;-\u0026#39; + this.lastName; \t}, \tset(value) { \tvar arr = value.split(\u0026#39;-\u0026#39;); \tthis.firstName = arr[0]; \tthis.lastName = arr[1]; \t}, \t}, \t}, }); Vue.config.productionTip = false; 原理：底层借助了defineproperty()提供的get()和set()。\nget() 什么时候调用？  初始化时，get()会被调用，且返回值会被作为 fullname 的属性值。 fullname 所依赖的值（这里依赖的 firstName 和 lastNmae）发生变化的时候。  computed 与 method 的区别：  计算属性可以赋值，而方法不行。 计算属性会进行缓存：只要与计算属性相关的数据没有发生变化，则直接使用缓存结果，不会重新调用方法来重新计算。 凡是根据已有数据计算得到新数据的无参函数，都应该尽量写成计算属性，而非方法。  简写 计算属性大多时候都不需 set()，只需要get()，因此很多时候，当我们确定某个计算属性只读的时候，我们可以使用computd 的简写。\ncomputed: {  fullName() {  return this.firstName + \u0026#39;-\u0026#39; + this.lastName;  }, }, ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/computd/","summary":"computd 通过已有的属性计算出来的属性。\n计算属性最终会出现在 Vue 实例上，直接调用即可。\n如果计算属性有可能被修改，那必须写set()去响应修改，且要引起计算属性所依赖的属性发生变化。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \t\u0026lt;p\u0026gt;姓：{{ firstName }}\u0026lt;/p\u0026gt; \t\u0026lt;p\u0026gt;名：{{ lastName }}\u0026lt;/p\u0026gt; \t\u0026lt;p\u0026gt;全名：{{ fullName }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; JavaScrip\nvar vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \ttext: \u0026#39;表单\u0026#39;, \tfirstName: \u0026#39;苏\u0026#39;, \tlastName: \u0026#39;明敏\u0026#39;, \t}, \tcomputed: { \tfullName: { \tget() { \treturn this.firstName + \u0026#39;-\u0026#39; + this.lastName; \t}, \tset(value) { \tvar arr = value.","title":"Vue computd"},{"content":"key 表示节点的唯一标识key。\n使用 v-for 时，如果不给元素加上 key，那么 Vue 会默认将 index当作元素的key。\n该属性可以干预diff 算法，在同一层级，key值相同的节点会进行比对，key值不同的节点则不会比对。\n在循环生成的节点中，vue 强烈建议给予每个节点唯一且稳定的 key 值。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;div v-if=\u0026#34;handoff === \u0026#39;login\u0026#39;\u0026#34;\u0026gt; \u0026lt;label\u0026gt;登录\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; key=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt; \u0026lt;label\u0026gt;注册\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; key=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- handoff 等于：如果 login 为 true，则 handoff === register，否则 handoff === login --\u0026gt; \u0026lt;button @click=\u0026#34;handoff = handoff === \u0026#39;login\u0026#39;?\u0026#39;register\u0026#39;:\u0026#39;login\u0026#39;\u0026#34;\u0026gt;切换\u0026lt;/button\u0026gt;  \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; JavaScrip\nvar app = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \ttext: \u0026#39;表单\u0026#39;, \thandoff: \u0026#39;login\u0026#39;, \t}, }); Vue.config.productionTip = false; 虚拟 DMO 树中 key 的作用 key 是虚拟 DOM 对象的唯一标识，当数据发生变化时，Vue 会根据新数据生成一棵新虚拟 DOM 树，随后将其与旧虚拟 DOM 树比对（diff算法）。\n比对规则：\n 在旧虚拟 DOM 树中找到了与新虚拟 DOM 树中相同key的节点：  若两棵虚拟 DOM 树中的节点没有变化，则直接使用之前已经生成好的真实 DOM 节点。 若两棵虚拟 DOM 树中的节点有变化，则仅将两棵虚拟 DOM 树有差异的节点渲染为真实 DOM 节点。    这样可最小程度的改动真实 DOM，提升页面渲染效率。\n 在旧虚拟 DOM 树中未找到与新虚拟 DOM 树中相同key的节点：  将未找到的虚拟 DOM 节点渲染为真实 DOM 节点。    用 index 作为 key 可能会引发的问题：  若对数据进行逆序添加、逆序删除等其他破坏数组元素顺序的操作，会产生没有必要的 DOM 更新，导致渲染效率低。 如果结构中还包含表单类 DOM，则会导致错误的 DOM 更新，并会导致界面渲染出现严重的问题。  开发中如何选择 key？  最好使用每条数据的唯一标识符作为 key，比如 id、手机号、身份证号等具有唯一性的值。 如果不存在对数据的逆序添加、逆序删除等破坏数组元素顺序的操作，仅用于渲染展示，则可以直接使用 index作为 key。  ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7/key/","summary":"key 表示节点的唯一标识key。\n使用 v-for 时，如果不给元素加上 key，那么 Vue 会默认将 index当作元素的key。\n该属性可以干预diff 算法，在同一层级，key值相同的节点会进行比对，key值不同的节点则不会比对。\n在循环生成的节点中，vue 强烈建议给予每个节点唯一且稳定的 key 值。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;div v-if=\u0026#34;handoff === \u0026#39;login\u0026#39;\u0026#34;\u0026gt; \u0026lt;label\u0026gt;登录\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; key=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt; \u0026lt;label\u0026gt;注册\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;\u0026#34; key=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- handoff 等于：如果 login 为 true，则 handoff === register，否则 handoff === login --\u0026gt; \u0026lt;button @click=\u0026#34;handoff = handoff === \u0026#39;login\u0026#39;?\u0026#39;register\u0026#39;:\u0026#39;login\u0026#39;\u0026#34;\u0026gt;切换\u0026lt;/button\u0026gt;  \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; JavaScrip\nvar app = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \ttext: \u0026#39;表单\u0026#39;, \thandoff: \u0026#39;login\u0026#39;, \t}, }); Vue.","title":"Vue key"},{"content":"ref 用于给元素或子组件注册唯一标识，这个唯一标识将会被注册到父组件的 $refs 对象上。\n对于 HTML 元素，获取的是 DOM 元素，与 id 是一样的；对于组件，获取的是组件实例对象。\n$refs 不是响应式的属性。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7/ref/","summary":"ref 用于给元素或子组件注册唯一标识，这个唯一标识将会被注册到父组件的 $refs 对象上。\n对于 HTML 元素，获取的是 DOM 元素，与 id 是一样的；对于组件，获取的是组件实例对象。\n$refs 不是响应式的属性。","title":"Vue ref"},{"content":"v-for 循环渲染元素。\n当和 v-if 一起使用时，v-for 的优先级比 v-if 更高。\n可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法。\n不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \t\u0026lt;ul\u0026gt; \t\u0026lt;li v-for=\u0026#34;(p,index) in persons\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt;{{p.name}} and {{p.age}}\u0026lt;/li\u0026gt; \t\u0026lt;/ul\u0026gt;  \t\u0026lt;ul\u0026gt; \t\u0026lt;li v-for=\u0026#34;(f,index) in fruits\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt;{{f}}\u0026lt;/li\u0026gt; \t\u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; JavaScrip\nvar vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \t// 遍历数组 \tpersons: [ \t{ id: \u0026#39;001\u0026#39;, name: \u0026#39;小明\u0026#39;, age: 9 }, \t{ id: \u0026#39;002\u0026#39;, name: \u0026#39;小苏\u0026#39;, age: 21 }, \t{ id: \u0026#39;003\u0026#39;, name: \u0026#39;小朱 \u0026#39;, age: 20 }, \t], \t// 遍历对象 \tfruits: { \tname: \u0026#39;banana\u0026#39;, \tcolor: \u0026#39;yellow\u0026#39;, \tkg: \u0026#39;3kg\u0026#39;, \t}, \t}, });  Vue.config.productionTip = false; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/v-for/","summary":"v-for 循环渲染元素。\n当和 v-if 一起使用时，v-for 的优先级比 v-if 更高。\n可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法。\n不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \t\u0026lt;ul\u0026gt; \t\u0026lt;li v-for=\u0026#34;(p,index) in persons\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt;{{p.name}} and {{p.age}}\u0026lt;/li\u0026gt; \t\u0026lt;/ul\u0026gt;  \t\u0026lt;ul\u0026gt; \t\u0026lt;li v-for=\u0026#34;(f,index) in fruits\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt;{{f}}\u0026lt;/li\u0026gt; \t\u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; JavaScrip\nvar vm = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \t// 遍历数组 \tpersons: [ \t{ id: \u0026#39;001\u0026#39;, name: \u0026#39;小明\u0026#39;, age: 9 }, \t{ id: \u0026#39;002\u0026#39;, name: \u0026#39;小苏\u0026#39;, age: 21 }, \t{ id: \u0026#39;003\u0026#39;, name: \u0026#39;小朱 \u0026#39;, age: 20 }, \t], \t// 遍历对象 \tfruits: { \tname: \u0026#39;banana\u0026#39;, \tcolor: \u0026#39;yellow\u0026#39;, \tkg: \u0026#39;3kg\u0026#39;, \t}, \t}, });  Vue.","title":"Vue v-for"},{"content":"v-if 控制元素是否存在。\n如果多个 if 指令：v-if、v-else、v-else-if连用，则使用它们的元素必须紧挨。\n在 \u0026lt;template\u0026gt; 元素上使用 v-if 时，最终的渲染结果将不包含 \u0026lt;template\u0026gt; 元素。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;!-- 如果 isShow 为 true，则插入 img，如果 isShow 为 false，则移除 img --\u0026gt;  \u0026lt;img v-if=\u0026#34;isShow\u0026#34; :src=\u0026#34;url\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;!-- 否则（img 已移除），则显示 button 元素，如果 img 已插入，则移除 button--\u0026gt; \u0026lt;button v-else=\u0026#34;!isShow\u0026#34;\u0026gt;切换\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; JavaScript\nvar app = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \turl: \u0026#39;https://img1.baidu.com/it/u=999074466,1525171260\u0026amp;fm=253\u0026amp;fmt=auto\u0026amp;app=138\u0026amp;f=JPEG?w=500\u0026amp;h=333\u0026#39;, \t}, }); Vue.config.productionTip = false; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/v-if/","summary":"v-if 控制元素是否存在。\n如果多个 if 指令：v-if、v-else、v-else-if连用，则使用它们的元素必须紧挨。\n在 \u0026lt;template\u0026gt; 元素上使用 v-if 时，最终的渲染结果将不包含 \u0026lt;template\u0026gt; 元素。\nHTML\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;!-- 如果 isShow 为 true，则插入 img，如果 isShow 为 false，则移除 img --\u0026gt;  \u0026lt;img v-if=\u0026#34;isShow\u0026#34; :src=\u0026#34;url\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;!-- 否则（img 已移除），则显示 button 元素，如果 img 已插入，则移除 button--\u0026gt; \u0026lt;button v-else=\u0026#34;!isShow\u0026#34;\u0026gt;切换\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; JavaScript\nvar app = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { \turl: \u0026#39;https://img1.baidu.com/it/u=999074466,1525171260\u0026amp;fm=253\u0026amp;fmt=auto\u0026amp;app=138\u0026amp;f=JPEG?w=500\u0026amp;h=333\u0026#39;, \t}, }); Vue.config.productionTip = false; ","title":"Vue v-if"},{"content":"v-on 注册一个事件，可简写为@。\n支持一些指令修饰符，比如 prevent。\n事件函数必须存在于methods中，事件参数为event。\n\u0026lt;!-- 完整语法 --\u0026gt; \u0026lt;a v-on:click=\u0026#34;doSomething\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt;  \u0026lt;!-- 缩写 --\u0026gt; \u0026lt;a @click=\u0026#34;doSomething\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt; 调用事件函数时\n 不加括号，调用事件函数就可以直接获取到该函数的事件对象。 加了 ()， 除了可以使用$event来获取事件对象，还能传入其他的参数。  \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;  \u0026lt;button @click=\u0026#39;showInfo\u0026#39;\u0026gt;提示信息\u0026lt;/button\u0026gt;  \u0026lt;button @click=\u0026#39;showInfo2($event,6666)\u0026#39;\u0026gt;提示信息\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-on/","summary":"v-on 注册一个事件，可简写为@。\n支持一些指令修饰符，比如 prevent。\n事件函数必须存在于methods中，事件参数为event。\n\u0026lt;!-- 完整语法 --\u0026gt; \u0026lt;a v-on:click=\u0026#34;doSomething\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt;  \u0026lt;!-- 缩写 --\u0026gt; \u0026lt;a @click=\u0026#34;doSomething\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt; 调用事件函数时\n 不加括号，调用事件函数就可以直接获取到该函数的事件对象。 加了 ()， 除了可以使用$event来获取事件对象，还能传入其他的参数。  \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;  \u0026lt;button @click=\u0026#39;showInfo\u0026#39;\u0026gt;提示信息\u0026lt;/button\u0026gt;  \u0026lt;button @click=\u0026#39;showInfo2($event,6666)\u0026#39;\u0026gt;提示信息\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ","title":"Vue v-on"},{"content":"v-show 控制元素是否可见，如果元素不可见，则该元素display:none。\nHTML \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;img v-show=\u0026#34;isShow\u0026#34; :src=\u0026#34;url\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;isShow = !isShow\u0026#34;\u0026gt;切换\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; JavaScript var app = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { url: \u0026#39;https://img1.baidu.com/it/u=999074466,1525171260\u0026amp;fm=253\u0026amp;fmt=auto\u0026amp;app=138\u0026amp;f=JPEG?w=500\u0026amp;h=333\u0026#39; }, }); Vue.config.productionTip = false; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/v-show/","summary":"v-show 控制元素是否可见，如果元素不可见，则该元素display:none。\nHTML \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;img v-show=\u0026#34;isShow\u0026#34; :src=\u0026#34;url\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;isShow = !isShow\u0026#34;\u0026gt;切换\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; JavaScript var app = new Vue({ \tel: \u0026#39;#app\u0026#39;, \tdata: { url: \u0026#39;https://img1.baidu.com/it/u=999074466,1525171260\u0026amp;fm=253\u0026amp;fmt=auto\u0026amp;app=138\u0026amp;f=JPEG?w=500\u0026amp;h=333\u0026#39; }, }); Vue.config.productionTip = false; ","title":"Vue v-show"},{"content":"挂载 将生成的真实 DOM 树，插入到页面上的过程，称之为挂载。\n挂载方式 通过el:'CSS 选择器'来挂载。\nnew Vue({ \t// vue 代码 }).$mount(\u0026#39;#app\u0026#39;); 通过Vue 实例.$mount('CSS 选择器')进行稍后挂载。\n// 或者 var v = Vue({ \t// vue 代码 }); v.$mount(\u0026#39;#app\u0026#39;); ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E6%8C%82%E8%BD%BD/","summary":"挂载 将生成的真实 DOM 树，插入到页面上的过程，称之为挂载。\n挂载方式 通过el:'CSS 选择器'来挂载。\nnew Vue({ \t// vue 代码 }).$mount(\u0026#39;#app\u0026#39;); 通过Vue 实例.$mount('CSS 选择器')进行稍后挂载。\n// 或者 var v = Vue({ \t// vue 代码 }); v.$mount(\u0026#39;#app\u0026#39;); ","title":"Vue 挂载"},{"content":"指令 用于解析元素（属性、内存、事件等），比如使用v-binds:url来进行解析，使得该属性成为动态属性。其中 url必须是 JavaScrip 表达式，也可以直接读取 data 中的数据。\nVue 中的指令始终以v-开头。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%8C%87%E4%BB%A4/","summary":"指令 用于解析元素（属性、内存、事件等），比如使用v-binds:url来进行解析，使得该属性成为动态属性。其中 url必须是 JavaScrip 表达式，也可以直接读取 data 中的数据。\nVue 中的指令始终以v-开头。","title":"Vue 指令"},{"content":"指令修饰符 prevent 阻止元素默认行为，比如 a 元素的跳转。\n指令修饰符可以连写，先阻止元素默认行为，再阻止元素冒泡。\n\u0026lt;a @click.prevent.stop=\u0026#34;btn\u0026#34; href=\u0026#34;https://ke.qq.com/\u0026#34;\u0026gt;123\u0026lt;/a\u0026gt; stop 阻止元素的事件冒泡。\nonce 事件只触发一次\ncapture 使用事件的捕获模式\nself 只有 event.target 是当前操作的元素时，才触发该事件\n\u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;  \u0026lt;!--因为触发事件冒泡 target 不是 div，而是 button--\u0026gt;  \u0026lt;!--所以点击 button 不会触发事件冒泡--\u0026gt;  \u0026lt;div @click.self=\u0026#39;showInfo2\u0026#39;\u0026gt;  \u0026lt;button @click=\u0026#39;showInfo\u0026#39;\u0026gt;提示信息\u0026lt;/button\u0026gt;  \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; passive 事件的默认行为立即执行，无需等待事件的回调执行完毕\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%8C%87%E4%BB%A4%E4%BF%AE%E9%A5%B0%E7%AC%A6/","summary":"指令修饰符 prevent 阻止元素默认行为，比如 a 元素的跳转。\n指令修饰符可以连写，先阻止元素默认行为，再阻止元素冒泡。\n\u0026lt;a @click.prevent.stop=\u0026#34;btn\u0026#34; href=\u0026#34;https://ke.qq.com/\u0026#34;\u0026gt;123\u0026lt;/a\u0026gt; stop 阻止元素的事件冒泡。\nonce 事件只触发一次\ncapture 使用事件的捕获模式\nself 只有 event.target 是当前操作的元素时，才触发该事件\n\u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;  \u0026lt;!--因为触发事件冒泡 target 不是 div，而是 button--\u0026gt;  \u0026lt;!--所以点击 button 不会触发事件冒泡--\u0026gt;  \u0026lt;div @click.self=\u0026#39;showInfo2\u0026#39;\u0026gt;  \u0026lt;button @click=\u0026#39;showInfo\u0026#39;\u0026gt;提示信息\u0026lt;/button\u0026gt;  \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; passive 事件的默认行为立即执行，无需等待事件的回调执行完毕","title":"Vue 指令修饰符"},{"content":"注入 配置的实例对象中的部分内容会被提取到 Vue 实例中：\n data:{} methods: {}  该过程称之为注入，注入的目的有两个：\n完成数据响应式 Vue 是如何知道数据被更改的？\nvue 2.0，是通过object.defineProperty()完成的数据响应式。该方法有很多缺陷，比如我们新增或删除data中的属性，此时的页面会无法正常响应。\nvue 3.0，是通过 Class proxy。\n绑定 this 通过 bind()来改变 this 的指向。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%B3%A8%E5%85%A5/","summary":"注入 配置的实例对象中的部分内容会被提取到 Vue 实例中：\n data:{} methods: {}  该过程称之为注入，注入的目的有两个：\n完成数据响应式 Vue 是如何知道数据被更改的？\nvue 2.0，是通过object.defineProperty()完成的数据响应式。该方法有很多缺陷，比如我们新增或删除data中的属性，此时的页面会无法正常响应。\nvue 3.0，是通过 Class proxy。\n绑定 this 通过 bind()来改变 this 的指向。","title":"Vue 注入"},{"content":"组件化 将页面按照功能细分为若干个区域，每一个区域就是一个组件，每个组件包含：\n 功能（JS） 内容（模板） 样式（CSS）  作用 复用编码、简化项目编码、提高运行效率。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%8C%96/","summary":"组件化 将页面按照功能细分为若干个区域，每一个区域就是一个组件，每个组件包含：\n 功能（JS） 内容（模板） 样式（CSS）  作用 复用编码、简化项目编码、提高运行效率。","title":"Vue 组件化"},{"content":"虚拟 DOM 树 它是一个普通的对象，对应着真实的 DOM 树；虚拟 DOM 树的节点都是虚拟的节点。\n为了提高效率，vue 会把模板编译成为虚拟 DOM 树，然后生成真实 DOM 树。\n因为浏览器如果直接修改真实的 DOM 树，这是非常影响效率的，但如果修改一个对象，那么效率是非常高的。\n有什么用 当数据更改时，会将更改后的内容编译成一棵新的虚拟 DOM 树，然后将其与旧的虚拟 DOM 树比对（diff算法），仅将两棵虚拟 DOM 属有差异的节点渲染为真实 DOM 树，没有差异的节点则直接使用旧虚拟 DOM 树所对应的真实 DOM 树上的节点（复用）。这样可最小程度的改动真实 DOM，提升页面渲染效率。\n因此，对于 Vue 而言，提升效率重点在于两个方面：\n  减少新的虚拟 DOM 的生成。\n  保证虚拟 DOM 树对比之后，只有必要的节点发生变化。\n  如何生成虚拟 DOM 树 生成虚拟 DOM 树的方式：\n 在挂载的元素内部直接书写，此时使用元素的outerHTML作为模板。优先级最低。 在template配置中书写,，它是一个模板字符串。优先级比第一种方式高。 在render()中直接创建虚拟节点树，此时，完全脱离模板（无需模板解析器代码），这会省略将模板编译为虚拟 DOM 树的步骤。优先级最高。  当我们将 Vue 编译为浏览器可识别的 HTML 代码的时候，此时已无需使用模板解析器，因此，我们可以直接引入只有 Vue 核心代码（不包含模板解析器代码，无法使用template配置项）的vue.runtime.xxx.js，来精简我们的项目。    使用render()循环创建 1—6 级标题：\nvar app = new Vue({ \tel: \u0026#39;#app\u0026#39;, \trender(t) { \tvar titles = []; \tfor (var i = 1; i \u0026lt;= 6; i++) { \ttitles.push(t(`h${i}`, `${i}级标题`)); \t} \treturn t(\u0026#39;div\u0026#39;, titles); \t}, }); Vue.config.productionTip = false; 虚拟 DOM 树只能有一个根节点 相对应的，模板也必须是单根的。因为diff 算法决定了只能对两棵虚拟 DOM 树进行比对。\nvar app = new Vue({ \tel: \u0026#39;#app\u0026#39;,  \t// 因为虚拟 DOM 树必须是单根，因此模板也必须是单根 \t// 即它们都只能有一个根节点 \ttemplate: ` \u0026lt;div\u0026gt;第一个根节点\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;第二个根节点\u0026lt;/div\u0026gt; `, }); Vue.config.productionTip = false; 模板 模板的作用，是为了生成虚拟 DOM 树。\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;  \u0026lt;h1\u0026gt;{{ title }}\u0026lt;/h1\u0026gt;  \u0026lt;ul\u0026gt;  \u0026lt;li v-for=\u0026#39;(item ,i) in product\u0026#39;\u0026gt;  名称：{{item.name}} 熟悉程度：{{item.familiar}}  \u0026lt;button @click=\u0026#34;remove(i)\u0026#34;\u0026gt;删除\u0026lt;/button\u0026gt;  \u0026lt;button @click=\u0026#34;item.familiar++\u0026#34;\u0026gt;增加\u0026lt;/button\u0026gt;   \u0026lt;/li\u0026gt;   \u0026lt;/ul\u0026gt;  \u0026lt;/div\u0026gt; 真实 DOM \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \t\u0026lt;h1\u0026gt;vue 加载成功!\u0026lt;/h1\u0026gt; \t\u0026lt;ul\u0026gt; \t\u0026lt;li\u0026gt; \t名称：JavaScrip 熟悉程度：3 \t\u0026lt;button\u0026gt;删除\u0026lt;/button\u0026gt; \u0026lt;button\u0026gt;增加\u0026lt;/button\u0026gt; \t\u0026lt;/li\u0026gt; \t\u0026lt;li\u0026gt; \t名称：C 熟悉程度：2 \t\u0026lt;button\u0026gt;删除\u0026lt;/button\u0026gt; \u0026lt;button\u0026gt;增加\u0026lt;/button\u0026gt; \t\u0026lt;/li\u0026gt; \t\u0026lt;li\u0026gt; \t名称：Go 熟悉程度：1 \t\u0026lt;button\u0026gt;删除\u0026lt;/button\u0026gt; \u0026lt;button\u0026gt;增加\u0026lt;/button\u0026gt; \t\u0026lt;/li\u0026gt; \t\u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/%E8%99%9A%E6%8B%9F-dom-%E6%A0%91/","summary":"虚拟 DOM 树 它是一个普通的对象，对应着真实的 DOM 树；虚拟 DOM 树的节点都是虚拟的节点。\n为了提高效率，vue 会把模板编译成为虚拟 DOM 树，然后生成真实 DOM 树。\n因为浏览器如果直接修改真实的 DOM 树，这是非常影响效率的，但如果修改一个对象，那么效率是非常高的。\n有什么用 当数据更改时，会将更改后的内容编译成一棵新的虚拟 DOM 树，然后将其与旧的虚拟 DOM 树比对（diff算法），仅将两棵虚拟 DOM 属有差异的节点渲染为真实 DOM 树，没有差异的节点则直接使用旧虚拟 DOM 树所对应的真实 DOM 树上的节点（复用）。这样可最小程度的改动真实 DOM，提升页面渲染效率。\n因此，对于 Vue 而言，提升效率重点在于两个方面：\n  减少新的虚拟 DOM 的生成。\n  保证虚拟 DOM 树对比之后，只有必要的节点发生变化。\n  如何生成虚拟 DOM 树 生成虚拟 DOM 树的方式：\n 在挂载的元素内部直接书写，此时使用元素的outerHTML作为模板。优先级最低。 在template配置中书写,，它是一个模板字符串。优先级比第一种方式高。 在render()中直接创建虚拟节点树，此时，完全脱离模板（无需模板解析器代码），这会省略将模板编译为虚拟 DOM 树的步骤。优先级最高。  当我们将 Vue 编译为浏览器可识别的 HTML 代码的时候，此时已无需使用模板解析器，因此，我们可以直接引入只有 Vue 核心代码（不包含模板解析器代码，无法使用template配置项）的vue.runtime.xxx.js，来精简我们的项目。    使用render()循环创建 1—6 级标题：","title":"Vue 虚拟 DOM 树"},{"content":"VueComponent   一个组件的本质是一个名为VueComponent()的构造函数， 且不是程序员定义的，是Vue. extend()生成的。\n  我们只需要应用某个组件，像这样\u0026lt;school\u0026gt;\u0026lt;/school\u0026gt;，Vue 解析时会帮我们创建这个school组件的实例对象，即 Vue 内部会执行：new VueComponent(options).\n  每次调用 Vue.extend()时，都会重新定义一个全新的VueComponent()。此，每次调用Vue.extend()时，返回的都是一个全新的VueComponent()，\n  关于 this 的指向：\n 在 Vue 实例中，data、methods、watch、computed 配置中的普通函数，其 this 指向都是 Vue 实例对象。 在组件实例中，data、methods、watch、computed 配置中的普通函数，其 this 指向都是VueComponent 实例对象。    Vue 实例简称vm、组件实例简称 vc。\n  $children属性表示了当前实例（Vue 实例和组件实例）上的子实例。\n  ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/vuecomponent/","summary":"VueComponent   一个组件的本质是一个名为VueComponent()的构造函数， 且不是程序员定义的，是Vue. extend()生成的。\n  我们只需要应用某个组件，像这样\u0026lt;school\u0026gt;\u0026lt;/school\u0026gt;，Vue 解析时会帮我们创建这个school组件的实例对象，即 Vue 内部会执行：new VueComponent(options).\n  每次调用 Vue.extend()时，都会重新定义一个全新的VueComponent()。此，每次调用Vue.extend()时，返回的都是一个全新的VueComponent()，\n  关于 this 的指向：\n 在 Vue 实例中，data、methods、watch、computed 配置中的普通函数，其 this 指向都是 Vue 实例对象。 在组件实例中，data、methods、watch、computed 配置中的普通函数，其 this 指向都是VueComponent 实例对象。    Vue 实例简称vm、组件实例简称 vc。\n  $children属性表示了当前实例（Vue 实例和组件实例）上的子实例。\n  ","title":"VueComponent"},{"content":"时间线 浏览器加载一个页面时，当开始执行 JavaScrip 的那一刻，浏览器会有一个特定的加载顺序，按照这个加载顺序一步步的执行的过程，就会形成一个时间线。\n顺序 大致就三步：创建 Document ——\u0026gt; DOMTree 解析完毕，文档加载完毕并执行完毕。\n 创建 Document 对象，开始解析 Web 页面。 解析 HTML 元素和它们的文本内容后添加 Element 对象和 Text 节点到文档中。此时的document.readyState = 'loading'。 如遇到 link 引入的外部 CSS，那么创建线程加载这个 CSS，并继续解析文档。 遇到 script 引入的外部 JS，并且没有设置异步 async、defer 等，浏览器则同步加载这个 JS 文件，并阻塞，等待 JS 加载完成并执行该脚本，然后继续解析文档。 遇到 script 引入的外部 JS，井且设置有异步 async、defer 等，浏览器创建异步线程加载，井继续解析文档。对于 async 属性的脚本，脚本加载完成后立即执行。(异步加载的 JS 文件，其中禁止使用 document.write()) 遇到 img 等有 src 属性的元素，先正常解析 DOM 结构，然后浏览器异步加载 src，并继续解析文档。 当文档（DOMTree）解析完成，此时的document.readyState = 'interactive'。 文档解析完成后，所有设置有 defer 的脚本会按照顺序执行。（注意与 async 的不同,但同样禁止使用 document.write()） document 对象触发 DOMContentLoaded 事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。 当所有 async 的脚本加载完成并执行完毕后、img 等加载完成后，document.readyState = 'complete',，window 对象触发 load 事件 从此，以异步响应方式处理用户输入、网络事件等。、  监听文档加载状态 // 创建 Document 时的状态 console.log(document.readyState);  // 监听文档的加载状态 document.onreadystatechange = function () { \tconsole.log(document.readyState); };  // 文档解析完所执行的事件，此时文档还没有加载完毕，仅仅只是解析完毕。 document.addEventListener( \t\u0026#39;DOMContentLoaded\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;DOMContentLoaded 事件被触发！\\n\\n标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。\u0026#39;); \t}, \tfalse ); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%97%B6%E9%97%B4%E7%BA%BF/","summary":"时间线 浏览器加载一个页面时，当开始执行 JavaScrip 的那一刻，浏览器会有一个特定的加载顺序，按照这个加载顺序一步步的执行的过程，就会形成一个时间线。\n顺序 大致就三步：创建 Document ——\u0026gt; DOMTree 解析完毕，文档加载完毕并执行完毕。\n 创建 Document 对象，开始解析 Web 页面。 解析 HTML 元素和它们的文本内容后添加 Element 对象和 Text 节点到文档中。此时的document.readyState = 'loading'。 如遇到 link 引入的外部 CSS，那么创建线程加载这个 CSS，并继续解析文档。 遇到 script 引入的外部 JS，并且没有设置异步 async、defer 等，浏览器则同步加载这个 JS 文件，并阻塞，等待 JS 加载完成并执行该脚本，然后继续解析文档。 遇到 script 引入的外部 JS，井且设置有异步 async、defer 等，浏览器创建异步线程加载，井继续解析文档。对于 async 属性的脚本，脚本加载完成后立即执行。(异步加载的 JS 文件，其中禁止使用 document.write()) 遇到 img 等有 src 属性的元素，先正常解析 DOM 结构，然后浏览器异步加载 src，并继续解析文档。 当文档（DOMTree）解析完成，此时的document.readyState = 'interactive'。 文档解析完成后，所有设置有 defer 的脚本会按照顺序执行。（注意与 async 的不同,但同样禁止使用 document.write()） document 对象触发 DOMContentLoaded 事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。 当所有 async 的脚本加载完成并执行完毕后、img 等加载完成后，document.","title":"JavaScrip 时间线"},{"content":"RegExp 一种查找以及字符串替换的操作。\n直接量（推荐使用） var reg = /abcde/i;  var str = \u0026#39;abCDE\u0026#39;;  var result = reg.test(str); console.log(result); new RegExp var str = \u0026#39;abCDE\u0026#39;; var reg = new RegExp(\u0026#39;abc\u0026#39;, \u0026#39;i\u0026#39;); var result = reg.test(str); console.log(result); 贪婪匹配 匹配时，能多匹配，就不会少匹配。\n正则表达式默认的匹配模式就是贪婪匹配。\n非贪婪匹配 匹配时，能少匹配，就不会多匹配。\n+? 重复 1 次或更多次，但尽可能少重复。\nvar str = \u0026#39;aaaa\u0026#39;; var reg = /a+?/g; var result = str.match(reg); console.log(result); 除了+?，还有：\n*? 重复任意次，但尽可能少重复。\n?? 重复 0 次或 1 次，但尽可能少重复。\n{n,m}? 重复 n 到 m 次，但尽可能少重复。\n{n,}? 重复 n 次以上，但尽可能少重复。\nvar str = \u0026#39;aaaa\u0026#39;; var reg = /a{1,}?/g; var result = str.match(reg); console.log(result); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"RegExp 一种查找以及字符串替换的操作。\n直接量（推荐使用） var reg = /abcde/i;  var str = \u0026#39;abCDE\u0026#39;;  var result = reg.test(str); console.log(result); new RegExp var str = \u0026#39;abCDE\u0026#39;; var reg = new RegExp(\u0026#39;abc\u0026#39;, \u0026#39;i\u0026#39;); var result = reg.test(str); console.log(result); 贪婪匹配 匹配时，能多匹配，就不会少匹配。\n正则表达式默认的匹配模式就是贪婪匹配。\n非贪婪匹配 匹配时，能少匹配，就不会多匹配。\n+? 重复 1 次或更多次，但尽可能少重复。\nvar str = \u0026#39;aaaa\u0026#39;; var reg = /a+?/g; var result = str.match(reg); console.log(result); 除了+?，还有：\n*? 重复任意次，但尽可能少重复。\n?? 重复 0 次或 1 次，但尽可能少重复。\n{n,m}? 重复 n 到 m 次，但尽可能少重复。","title":"RegExp"},{"content":"修饰符 i 不区分大小写，即 A 和 a 没有区别。\nvar reg = /abcde/i;  var str = \u0026#39;abCDE\u0026#39;;  var result = reg.test(str); console.log(result); g 全局匹配。查找字符串中所有的匹配项。\n即匹配到一个匹配项后，还会继续匹配后续的字符串，它找出字符串中所有的匹配项。\nvar reg = /ab/g; var str = \u0026#39;abababababab\u0026#39;;  var result = str.match(reg); console.log(result); 如果不加该修饰符，则只匹配一个匹配项：\nvar reg = /ab/; var str = \u0026#39;abababababab\u0026#39;;  var result = str.match(reg); console.log(result); m 多行匹配，通常需要配合g来用。用边界字符^表示只匹配每一行的开头，用$匹配每一行的结尾，注意时是多行匹配，而不是整个字符串的开头和结尾。\nvar reg = /^a/gm;  var str = \u0026#39;abcababa\\nabab\u0026#39;;  var result = str.match(reg); console.log(result); s 默认情况下的圆点 . 是 匹配除换行符 \\n 之外的任何字符，加上 s 之后, . 中包含换行符 \\n。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E4%BF%AE%E9%A5%B0%E7%AC%A6/","summary":"修饰符 i 不区分大小写，即 A 和 a 没有区别。\nvar reg = /abcde/i;  var str = \u0026#39;abCDE\u0026#39;;  var result = reg.test(str); console.log(result); g 全局匹配。查找字符串中所有的匹配项。\n即匹配到一个匹配项后，还会继续匹配后续的字符串，它找出字符串中所有的匹配项。\nvar reg = /ab/g; var str = \u0026#39;abababababab\u0026#39;;  var result = str.match(reg); console.log(result); 如果不加该修饰符，则只匹配一个匹配项：\nvar reg = /ab/; var str = \u0026#39;abababababab\u0026#39;;  var result = str.match(reg); console.log(result); m 多行匹配，通常需要配合g来用。用边界字符^表示只匹配每一行的开头，用$匹配每一行的结尾，注意时是多行匹配，而不是整个字符串的开头和结尾。\nvar reg = /^a/gm;  var str = \u0026#39;abcababa\\nabab\u0026#39;;  var result = str.match(reg); console.","title":"RegExp 修饰符"},{"content":"元字符 \\n 将 n 标记为一个特殊字符（将特殊字符进行转义）、或一个原义字符、或一个向后引用、或一个八进制转义符。\n\\w 匹配字母、数字、下划线。等价于[A-Za-z0-9_]。\nvar reg = /\\wcd2/g;  var str = \u0026#39;bcd2\u0026#39;;  var result = str.match(reg); console.log(result); \\W 匹配非字母、数字、下划线。等价于 [^A-Za-z0-9_]。\nvar reg = /\\Wcd2/g;  var str = \u0026#39;b*cd2\u0026#39;;  var result = str.match(reg); console.log(result); \\d 匹配一个数字字符。等价于 [0-9]。\n\\D 匹配一个非数字字符。等价于 [^0-9]。\n\\s 匹配任何空白字符，包括空格符、制表符\\t、回车符\\r、换行符\\n、垂直制表符\\v、换页符\\f。\n等价于 [ \\f\\n\\r\\t\\v]。\n\\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。\n\\b 匹配一个单词边界，也就是指单词和空格间的位置。\n例如， er\\b可以匹配 never 中的 \u0026rsquo;er\u0026rsquo;，但不能匹配 verb 中的 er。\nvar reg = /\\bname/g;  var str = \u0026#39;my name is rainy\u0026#39;;  var result = str.match(reg); console.log(result); \\B 匹配非单词边界。er\\B能匹配 verb 中的 er，但不能匹配 never 中的 er。\nvar reg = /\\Bname\\B/g;  var str = \u0026#39;mynameis rainy\u0026#39;;  var result = str.match(reg); console.log(result); \\t 匹配一个制表符。等价于 \\x09 和 \\cI。\n匹配的制表符必须是字符串中所存在的\\t\nvar reg = /\\tc/g;  var str = \u0026#39;\\tc\u0026#39;;  var result = str.match(reg); console.log(result); \\u 匹配一个用四个十六进制数字表示的 Unicode 字符。\n例如， \\u4e2d\\u56fd的匹配项是：中国。\nvar reg = /\\u0072\\u0061\\u0069\\u006e\\u0079\\u0020\\u662f\\u61a8\\u61a8/g;  var str = \u0026#39;rainy 是憨憨\u0026#39;;  var result = str.match(reg); console.log(result); Unicode 字符也可以使用区间的方式进行匹配，下面是匹配一切字符。\nvar reg = /[\\u0000-\\uffff]/g;  var str = \u0026#39;(?)\u0026#39;;  var result = str.match(reg); console.log(result); 匹配一切的字符，也可以用补集的方式：原集合 + 原集合的补集 = All\n// 数字字符 + 非数字字符 = 一切字符 var reg = /[\\d\\D]/g;  var str = \u0026#39;123abc...china牛逼？\u0026#39;;  var result = str.match(reg); console.log(result); . 匹配除换行符\\n和回车符\\r之外的任何单个字符。相当于 [^\\n\\r]。\nvar reg = /./g;  var str = \u0026#39;臣世雨\u0026#39;;  var result = str.match(reg); console.log(result); .不能写在[]中，若写到[]中，会匹配到 null。\nvar reg = /[.]/g;  var str = \u0026#39;臣世雨\u0026#39;;  var result = str.match(reg); console.log(result); x|y 匹配 x 或 y。\nvar reg = /a|b/g;  var str = \u0026#39;abcabvba\u0026#39;;  var result = str.match(reg);  console.log(result); x(?=n) 正向肯定预查，匹配 x 后面的字符串为 n 的匹配项。\n这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。\nvar str = \u0026#39;abaaa\u0026#39;; var reg = /a(?=b)/g; var result = str.match(reg); console.log(result); x(?!n) 正向否定预查，匹配 x 后面的字符串不为 n 的匹配项。\nvar str = \u0026#39;abaaa\u0026#39;; var reg = /a(?!b)/g; var result = str.match(reg); console.log(result); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E5%85%83%E5%AD%97%E7%AC%A6/","summary":"元字符 \\n 将 n 标记为一个特殊字符（将特殊字符进行转义）、或一个原义字符、或一个向后引用、或一个八进制转义符。\n\\w 匹配字母、数字、下划线。等价于[A-Za-z0-9_]。\nvar reg = /\\wcd2/g;  var str = \u0026#39;bcd2\u0026#39;;  var result = str.match(reg); console.log(result); \\W 匹配非字母、数字、下划线。等价于 [^A-Za-z0-9_]。\nvar reg = /\\Wcd2/g;  var str = \u0026#39;b*cd2\u0026#39;;  var result = str.match(reg); console.log(result); \\d 匹配一个数字字符。等价于 [0-9]。\n\\D 匹配一个非数字字符。等价于 [^0-9]。\n\\s 匹配任何空白字符，包括空格符、制表符\\t、回车符\\r、换行符\\n、垂直制表符\\v、换页符\\f。\n等价于 [ \\f\\n\\r\\t\\v]。\n\\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。\n\\b 匹配一个单词边界，也就是指单词和空格间的位置。\n例如， er\\b可以匹配 never 中的 \u0026rsquo;er\u0026rsquo;，但不能匹配 verb 中的 er。\nvar reg = /\\bname/g;  var str = \u0026#39;my name is rainy\u0026#39;;  var result = str.","title":"RegExp 元字符"},{"content":"实例 匹配字符串首或尾是数字的字符串 var reg = /^\\d|\\d$/g;  var str = \u0026#39;2dfds\u0026#39;;  var result = str.match(reg); console.log(result); 匹配字符串首尾都是数字的字符串 var reg = /^\\d[\\s\\S]*\\d$/g;  var str = \u0026#39;2dfds2\u0026#39;;  var result = str.match(reg); console.log(result); 将以 - 分割的字符串变为小驼峰式的字符串 var str = \u0026#39;the-first-name\u0026#39;; var reg = /-(\\w)/g; var result = str.replace(reg, function ($, $1) { \treturn $1.toUpperCase(); }); console.log(result); 字符串去重 var str = \u0026#39;aaaabbbbccccddddd\u0026#39;; var reg = /(\\w)\\1+/g; var result = str.replace(reg, \u0026#39;$1\u0026#39;); console.log(result); 字符串每三位加一个符号 从字符串末尾开始匹配\n匹配空（空在 (?= 的前面）后面的为 3 的倍数位个的字符串，该字符串每 3 个为 1 组，每组的前面都存在一个空。\n且每组数字的前面不能是单词边界，否则当字符串刚好是 3 的倍数个时，替换后的字符串的开头就会存在.。\n需要匹配一次或多次。\n最后将匹配到结果 n 个（空）替换为 . 即可。\nvar str = \u0026#39;123456789\u0026#39;;  var reg = /(?=(\\B)(\\d{3})+$)/g; var result = str.replace(reg, \u0026#39;.\u0026#39;); console.log(result); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E5%AE%9E%E4%BE%8B/","summary":"实例 匹配字符串首或尾是数字的字符串 var reg = /^\\d|\\d$/g;  var str = \u0026#39;2dfds\u0026#39;;  var result = str.match(reg); console.log(result); 匹配字符串首尾都是数字的字符串 var reg = /^\\d[\\s\\S]*\\d$/g;  var str = \u0026#39;2dfds2\u0026#39;;  var result = str.match(reg); console.log(result); 将以 - 分割的字符串变为小驼峰式的字符串 var str = \u0026#39;the-first-name\u0026#39;; var reg = /-(\\w)/g; var result = str.replace(reg, function ($, $1) { \treturn $1.toUpperCase(); }); console.log(result); 字符串去重 var str = \u0026#39;aaaabbbbccccddddd\u0026#39;; var reg = /(\\w)\\1+/g; var result = str.replace(reg, \u0026#39;$1\u0026#39;); console.","title":"RegExp 实例"},{"content":"RegExp 方法 exec() 如果匹配模式带有g修饰符，则每匹配一次，匹配结束的位置就是下一次匹配的起始位置。\n如果匹配模式不带g修饰符，则不管匹配多少次，匹配的起始位置始终都只从lastIndex = 0开始。即不管匹配多少次，lastIndex 都只为 0。\n加 g 修饰符 // 加 g 修饰符 var reg = /ab/g;  var str = \u0026#39;abababab\u0026#39;;  // 第一次匹配，lastIndex 从 0 开始匹配，匹配完后 lastIndex = 2 console.log(reg.exec(str));  // 第二次匹配，lastIndex 从 2 开始匹配，匹配完后 lastIndex = 4 console.log(reg.exec(str));  // 第三次匹配，lastIndex 从 4 开始匹配，匹配完后 lastIndex = 6 console.log(reg.exec(str));  // 第四次匹配，lastIndex 从 6 开始匹配，匹配后 lastIndex = 8 console.log(reg.exec(str));  // 第五次匹配，lastIndex 从 8 开始匹配， // 因为从 8 开始匹配，无法匹配到任何值，因此此处返回 null // 返回 null 之后，lastIndex 从起始位置 0 开始，即现在的 lastIndex = 0， console.log(reg.exec(str));  // 重新从 0 开始检索匹配，匹配完后 lastIndex = 2 console.log(reg.exec(str));  // reture 2 console.log(reg.lastIndex); 不加 g 修饰符 // 不加 g 修饰符 var reg = /ab/;  var str = \u0026#39;abababab\u0026#39;;  // lastIndex = 0 console.log(reg.exec(str));  // lastIndex = 0 console.log(reg.exec(str));  // lastIndex = 0 console.log(reg.exec(str));  // lastIndex = 0 console.log(reg.exec(str));  // lastIndex = 0 console.log(reg.exec(str));  // lastIndex = 0 console.log(reg.exec(str));  // reture 0 console.log(reg.lastIndex); 与()的使用 配合()使用的时候，除了会返回匹配结果，还会返回()中第一次匹配的子表达式的值，并且这些值是类数组的数据位，它们存在于类数组的索引位中。\nvar reg = /(\\w)\\1(\\w)\\2/g;  var str = \u0026#39;ccddvvffff\u0026#39;;  var result = reg.exec(str);  console.log(result); 第一次匹配的子表达式的内容是 cc 和 dd。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/regexp/regexp-%E6%96%B9%E6%B3%95/","summary":"RegExp 方法 exec() 如果匹配模式带有g修饰符，则每匹配一次，匹配结束的位置就是下一次匹配的起始位置。\n如果匹配模式不带g修饰符，则不管匹配多少次，匹配的起始位置始终都只从lastIndex = 0开始。即不管匹配多少次，lastIndex 都只为 0。\n加 g 修饰符 // 加 g 修饰符 var reg = /ab/g;  var str = \u0026#39;abababab\u0026#39;;  // 第一次匹配，lastIndex 从 0 开始匹配，匹配完后 lastIndex = 2 console.log(reg.exec(str));  // 第二次匹配，lastIndex 从 2 开始匹配，匹配完后 lastIndex = 4 console.log(reg.exec(str));  // 第三次匹配，lastIndex 从 4 开始匹配，匹配完后 lastIndex = 6 console.log(reg.exec(str));  // 第四次匹配，lastIndex 从 6 开始匹配，匹配后 lastIndex = 8 console.log(reg.exec(str));  // 第五次匹配，lastIndex 从 8 开始匹配， // 因为从 8 开始匹配，无法匹配到任何值，因此此处返回 null // 返回 null 之后，lastIndex 从起始位置 0 开始，即现在的 lastIndex = 0， console.","title":"RegExp 方法"},{"content":"普通字符 () 匹配与()中的字表达式相同的字符。可以用()来标记一个子表达式的开始和结束位置，后面我们可以用\\1（反向引用）来引用第一个()中的字表达式。\n// 表示匹配与 \\w 相同的四个连续的字符 var reg = /(\\w)\\1\\1\\1/g;  var str = \u0026#39;aaaabbbbccccc\u0026#39;;  var result = str.match(reg);  console.log(result); 也可以使用\\2来引用第二个子表达式：\nvar reg = /(\\w)\\1(\\w)\\2/g;  var str = \u0026#39;ccddvvffff\u0026#39;;  var result = str.match(reg);  console.log(result); 普通字符 () 标记一个子表达式的开始和结束位置，即匹配与()中的字表达式相同的字符，之后我们可以用\\1（反向引用）来引用第一个()中的字表达式。\n// 表示匹配与 \\w 相同的四个连续的字符 var reg = /(\\w)\\1\\1\\1/g;  var str = \u0026#39;aaaabbbbccccc\u0026#39;;  var result = str.match(reg);  console.log(result); 也可以使用\\2来引用第二个子表达式：\nvar reg = /(\\w)\\1(\\w)\\2/g;  var str = \u0026#39;ccddvvffff\u0026#39;;  var result = str.match(reg);  console.log(result); [] 匹配字符的范围，一个[]就表示一个字符，比如[ab][ab]就表示匹配两个相连的 ab。\n  [str]，匹配包含 str 的字符。\n  [A-Z]，匹配 A-Z 的字符。\n  [a-z]，匹配 a - z 的字符。\n  [0-9]，匹配 0 - 9 的字符。\n  [A-z] = 匹配[A-Z] + [a-z]的字符\n  [^rainy]，匹配除 rainy 之外的任意字符。\n  var reg = /[0-9][A-z][a-z]/gm;  var str = \u0026#39;111Exg54gGfg000\u0026#39;;  var result = str.match(reg); console.log(result); x{n} 表示匹配 n 个连续的 x 的字符串。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/","summary":"普通字符 () 匹配与()中的字表达式相同的字符。可以用()来标记一个子表达式的开始和结束位置，后面我们可以用\\1（反向引用）来引用第一个()中的字表达式。\n// 表示匹配与 \\w 相同的四个连续的字符 var reg = /(\\w)\\1\\1\\1/g;  var str = \u0026#39;aaaabbbbccccc\u0026#39;;  var result = str.match(reg);  console.log(result); 也可以使用\\2来引用第二个子表达式：\nvar reg = /(\\w)\\1(\\w)\\2/g;  var str = \u0026#39;ccddvvffff\u0026#39;;  var result = str.match(reg);  console.log(result); 普通字符 () 标记一个子表达式的开始和结束位置，即匹配与()中的字表达式相同的字符，之后我们可以用\\1（反向引用）来引用第一个()中的字表达式。\n// 表示匹配与 \\w 相同的四个连续的字符 var reg = /(\\w)\\1\\1\\1/g;  var str = \u0026#39;aaaabbbbccccc\u0026#39;;  var result = str.match(reg);  console.log(result); 也可以使用\\2来引用第二个子表达式：\nvar reg = /(\\w)\\1(\\w)\\2/g;  var str = \u0026#39;ccddvvffff\u0026#39;;  var result = str.","title":"RegExp 普通字符"},{"content":"Document Document 是文档的根，表示整个文档，它包含所有元素，包括 html 元素。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document/","summary":"Document Document 是文档的根，表示整个文档，它包含所有元素，包括 html 元素。","title":"JavaScript Document"},{"content":"Document 属性 head 和 body 表示文档中的 head 和 body 元素。\ndocument.head; document.body; documentElement 表示文档中的 html 元素。\ndocument.documentElement; ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document-%E5%B1%9E%E6%80%A7/","summary":"Document 属性 head 和 body 表示文档中的 head 和 body 元素。\ndocument.head; document.body; documentElement 表示文档中的 html 元素。\ndocument.documentElement; ","title":"JavaScript Document 属性"},{"content":"Document 方法 查找节点 使用 querySelectorAll 和 querySelector 方法选择的元素不是实时的，而使用 getElements 方法选择的元素是实时的。\n比如，使用 querySelecto 选择 div 元素，并存放到 ele 变量中，如果后面我们在文档中删除或增加一个 div 元素，ele 中的 div 元素依旧不变。\ngetElementById() 选择文档中指定 id 的元素，id 是唯一的，所以是 getElement，不是 getElements\nvar ele = document.getElementById(\u0026#39;only\u0026#39;); getElementsByTagName() 选择文档中指定标签名的元素，返回结果是一个类数组\nvar ele = document.getElementsByTagName(\u0026#39;span\u0026#39;); getElementsByTagName(\u0026rsquo;*') 选择文档中的所有元素。\nvar ele = document.getElementsByTagName(\u0026#39;*\u0026#39;); getElementsByName() 选择文档中指定 name 的元素，ele 是一个类数组，需要注意，该元素只有部分元素才能生效\nvar ele = document.getElementsByName(\u0026#39;span\u0026#39;); getElementsByClassName() 选择文档中指定 class 的元素\nvar ele = document.getElementsByClassName(\u0026#39;build\u0026#39;); querySelector() 选择匹配指定选择器的第一个元素。不实时\nvar ele = document.querySelector(\u0026#39;div \u0026gt; span a .test\u0026#39;); querySelectorAll() 选择匹配指定选择器的所有元素。不实时\nvar eles = document.querySelectorAll(\u0026#39;div\u0026#39;); open() 打开一个要写入的文档。\n此时已注册到文档、文档中的节点或文档的 window 的所有事件监听器都会被清除。\n当 write()在页面加载后调用，会发生自动的open()调用。\nwrite() 将一个文本字符串写入一个由open()打开的文档流。\n如果该方法在文档加载完成后执行，那么其中的字符串会覆盖文档中的大部分元素，只留下 html head和body元素，写入的字符串在body元素中。\nwindow.onload = function () { \tdocument.write(\u0026#39;我会覆盖文档中的内容\u0026#39;); }; 因此，该方法禁止在异步加载中使用，因为这会导致文档没加载完毕，就将文档给覆盖了。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document-%E6%96%B9%E6%B3%95/","summary":"Document 方法 查找节点 使用 querySelectorAll 和 querySelector 方法选择的元素不是实时的，而使用 getElements 方法选择的元素是实时的。\n比如，使用 querySelecto 选择 div 元素，并存放到 ele 变量中，如果后面我们在文档中删除或增加一个 div 元素，ele 中的 div 元素依旧不变。\ngetElementById() 选择文档中指定 id 的元素，id 是唯一的，所以是 getElement，不是 getElements\nvar ele = document.getElementById(\u0026#39;only\u0026#39;); getElementsByTagName() 选择文档中指定标签名的元素，返回结果是一个类数组\nvar ele = document.getElementsByTagName(\u0026#39;span\u0026#39;); getElementsByTagName(\u0026rsquo;*') 选择文档中的所有元素。\nvar ele = document.getElementsByTagName(\u0026#39;*\u0026#39;); getElementsByName() 选择文档中指定 name 的元素，ele 是一个类数组，需要注意，该元素只有部分元素才能生效\nvar ele = document.getElementsByName(\u0026#39;span\u0026#39;); getElementsByClassName() 选择文档中指定 class 的元素\nvar ele = document.getElementsByClassName(\u0026#39;build\u0026#39;); querySelector() 选择匹配指定选择器的第一个元素。不实时\nvar ele = document.querySelector(\u0026#39;div \u0026gt; span a .","title":"JavaScript Document 方法"},{"content":"伪元素和伪类 伪类选择器和伪元素选择器都是 CSS 选择器的一种。\n伪类选择器使用:开头。\n伪元素选择器使用::开头\n伪类 用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态根据用户行为而动态变化。\n比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的 css 类相似，可以为已有的元素添加样式，但是它只有处于 DOM 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。\n伪元素 伪元素用于创建一些不在 DOM 树中的元素（虚拟元素），并为其添加其 CSS 样式。伪元素开头为双冒号::。\n比如说，我们可以用::before或::after在一个元素的前面或后面增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在 DOM 树中，因为他们都是虚拟的元素。\n ","permalink":"https://note.yxzi.xyz/note/technology/language/html/%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB/","summary":"伪元素和伪类 伪类选择器和伪元素选择器都是 CSS 选择器的一种。\n伪类选择器使用:开头。\n伪元素选择器使用::开头\n伪类 用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态根据用户行为而动态变化。\n比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的 css 类相似，可以为已有的元素添加样式，但是它只有处于 DOM 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。\n伪元素 伪元素用于创建一些不在 DOM 树中的元素（虚拟元素），并为其添加其 CSS 样式。伪元素开头为双冒号::。\n比如说，我们可以用::before或::after在一个元素的前面或后面增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在 DOM 树中，因为他们都是虚拟的元素。\n ","title":"HTML 伪元素和伪类"},{"content":"DOCTYPE 用来告知浏览器该使用了哪种渲染方式来渲染当前文档。\n文档首行是\u0026lt;!DOCTYPE html\u0026gt;，则浏览器渲染模式为标准模式；首行不是或没有\u0026lt;!DOCTYPE html\u0026gt;则浏览器的渲染模式为怪异模式。\n目前浏览器的渲染引擎使用三种模式：怪异模式、接近标准模式、以及标准模式。\n历史问题 在很久以前的网络上，页面通常有两种版本：为网景的 Navigator 准备的版本，以及为微软的 Internet Explorer 准备的版本。\n当 W3C 创立网络标准后，为了不破坏当时既有的网站，浏览器不能直接弃用这些标准。因此，浏览器采用了两种模式，用以把能符合新规范的网站和老旧网站区分开。\n标准模式 在标准模式下，行为即由 HTML 与 CSS 的规范描述的行为。\n在接近标准模式下，只有少数的怪异行为被实现。\n怪异模式 在怪异模式下，文档会兼容之前的网页。也叫混杂模式。\ncompatMode 返回当前浏览器采用的渲染方式。\nBackCompat 标准兼容模式关闭，当 document.compatMode 等于 BackCompat 时，浏览器客户区宽度为 document.body.clientWidth;\nCSS1Compat 标准兼容模式开启,当 document.compatMode 等于 CSS1Compat 时浏览器客户区宽度为 document.documentElement.clientWidth;\n","permalink":"https://note.yxzi.xyz/note/technology/language/html/doctype/","summary":"DOCTYPE 用来告知浏览器该使用了哪种渲染方式来渲染当前文档。\n文档首行是\u0026lt;!DOCTYPE html\u0026gt;，则浏览器渲染模式为标准模式；首行不是或没有\u0026lt;!DOCTYPE html\u0026gt;则浏览器的渲染模式为怪异模式。\n目前浏览器的渲染引擎使用三种模式：怪异模式、接近标准模式、以及标准模式。\n历史问题 在很久以前的网络上，页面通常有两种版本：为网景的 Navigator 准备的版本，以及为微软的 Internet Explorer 准备的版本。\n当 W3C 创立网络标准后，为了不破坏当时既有的网站，浏览器不能直接弃用这些标准。因此，浏览器采用了两种模式，用以把能符合新规范的网站和老旧网站区分开。\n标准模式 在标准模式下，行为即由 HTML 与 CSS 的规范描述的行为。\n在接近标准模式下，只有少数的怪异行为被实现。\n怪异模式 在怪异模式下，文档会兼容之前的网页。也叫混杂模式。\ncompatMode 返回当前浏览器采用的渲染方式。\nBackCompat 标准兼容模式关闭，当 document.compatMode 等于 BackCompat 时，浏览器客户区宽度为 document.body.clientWidth;\nCSS1Compat 标准兼容模式开启,当 document.compatMode 等于 CSS1Compat 时浏览器客户区宽度为 document.documentElement.clientWidth;","title":"HTML DOCTYPE"},{"content":"表单元素 label 关联指定的表单元素。\nfor 为需要关联的元素 id，关联之后，当点击label 时，也可以聚焦到label所关联的元素。\n\u0026lt;label for=\u0026#34;account\u0026#34;\u0026gt;账号：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;account\u0026#34; /\u0026gt; select 下拉列表。\noption 定义下拉列表中可选择的选项。\n通过添加 selected 属性来定义默认选项。\n\u0026lt;select name=\u0026#34;cars\u0026#34;\u0026gt; \t\u0026lt;option value=\u0026#34;volvo\u0026#34; selected\u0026gt;Volvo\u0026lt;/option\u0026gt; \t\u0026lt;option value=\u0026#34;saab\u0026#34;\u0026gt;Saab\u0026lt;/option\u0026gt; \t\u0026lt;option value=\u0026#34;fiat\u0026#34;\u0026gt;Fiat\u0026lt;/option\u0026gt; \t\u0026lt;option value=\u0026#34;audi\u0026#34;\u0026gt;Audi\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; textarea 文本域（多行输入框）。\n\u0026lt;textarea name=\u0026#34;message\u0026#34; rows=\u0026#34;10\u0026#34; cols=\u0026#34;30\u0026#34;\u0026gt; The cat was playing in the garden. \u0026lt;/textarea\u0026gt; button 按钮。\n\u0026lt;button type=\u0026#34;button\u0026#34; onclick=\u0026#34;alert(\u0026#39;Hello World!\u0026#39;)\u0026#34;\u0026gt;Click Me!\u0026lt;/button\u0026gt; datalist datalist为 input 设置预定义的下拉列表。\ninput 获取焦点时，可以看到预定义的下拉列表。\ninput 的 list 属性必须为 datalist的 id。\n\u0026lt;form\u0026gt; \t\u0026lt;input list=\u0026#34;browsers\u0026#34; /\u0026gt; \t\u0026lt;datalist id=\u0026#34;browsers\u0026#34;\u0026gt; \t\u0026lt;option value=\u0026#34;Internet Explorer\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; \t\u0026lt;option value=\u0026#34;Firefox\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; \t\u0026lt;option value=\u0026#34;Chrome\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; \t\u0026lt;option value=\u0026#34;Opera\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; \t\u0026lt;option value=\u0026#34;Safari\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; \t\u0026lt;/datalist\u0026gt; \u0026lt;/form\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/language/html/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/","summary":"表单元素 label 关联指定的表单元素。\nfor 为需要关联的元素 id，关联之后，当点击label 时，也可以聚焦到label所关联的元素。\n\u0026lt;label for=\u0026#34;account\u0026#34;\u0026gt;账号：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;account\u0026#34; /\u0026gt; select 下拉列表。\noption 定义下拉列表中可选择的选项。\n通过添加 selected 属性来定义默认选项。\n\u0026lt;select name=\u0026#34;cars\u0026#34;\u0026gt; \t\u0026lt;option value=\u0026#34;volvo\u0026#34; selected\u0026gt;Volvo\u0026lt;/option\u0026gt; \t\u0026lt;option value=\u0026#34;saab\u0026#34;\u0026gt;Saab\u0026lt;/option\u0026gt; \t\u0026lt;option value=\u0026#34;fiat\u0026#34;\u0026gt;Fiat\u0026lt;/option\u0026gt; \t\u0026lt;option value=\u0026#34;audi\u0026#34;\u0026gt;Audi\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; textarea 文本域（多行输入框）。\n\u0026lt;textarea name=\u0026#34;message\u0026#34; rows=\u0026#34;10\u0026#34; cols=\u0026#34;30\u0026#34;\u0026gt; The cat was playing in the garden. \u0026lt;/textarea\u0026gt; button 按钮。\n\u0026lt;button type=\u0026#34;button\u0026#34; onclick=\u0026#34;alert(\u0026#39;Hello World!\u0026#39;)\u0026#34;\u0026gt;Click Me!\u0026lt;/button\u0026gt; datalist datalist为 input 设置预定义的下拉列表。\ninput 获取焦点时，可以看到预定义的下拉列表。\ninput 的 list 属性必须为 datalist的 id。","title":"HTML 表单元素"},{"content":"Date 创建一个 Date 实例，该实例呈现时间中的某个时刻。\nDate 对象基于格林威治 Unix Time Stamp，即自 1970 年 1 月 1 日（UTC）起经过的毫秒数。\nDate 对象有大量的设置、获取和操作日期的方法。 但它并不含有任何属性。\nDate 对象中存放的都是被构造出来的那一刻的时间，而不是随着系统时间改变而改变。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/date/","summary":"Date 创建一个 Date 实例，该实例呈现时间中的某个时刻。\nDate 对象基于格林威治 Unix Time Stamp，即自 1970 年 1 月 1 日（UTC）起经过的毫秒数。\nDate 对象有大量的设置、获取和操作日期的方法。 但它并不含有任何属性。\nDate 对象中存放的都是被构造出来的那一刻的时间，而不是随着系统时间改变而改变。","title":"JavaScript Date"},{"content":"Element 用来遍历元素节点。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element/","summary":"Element 用来遍历元素节点。","title":"JavaScript Element"},{"content":"Event stopPropagation() 用于取消事件的捕获和冒泡，W3C 推荐的方法。\ncancelBubble() 功能与stopPropagation()相同， IE 独有，但在 Chrome 中也可以用。\nvar wrapper = document.getElementsByClassName(\u0026#39;wrapper\u0026#39;)[0];  document.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;document\u0026#39;); \t}, \tfalse );  wrapper.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction (event) { \tconsole.log(\u0026#39;点击了子元素\u0026#39;);  \tevent.stopPropagation(); \t// IE 独有，但 Chrome 也可以使用 \tevent.cancelBubble = true; \t}, \tfalse ); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event-%E6%96%B9%E6%B3%95/","summary":"Event stopPropagation() 用于取消事件的捕获和冒泡，W3C 推荐的方法。\ncancelBubble() 功能与stopPropagation()相同， IE 独有，但在 Chrome 中也可以用。\nvar wrapper = document.getElementsByClassName(\u0026#39;wrapper\u0026#39;)[0];  document.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;document\u0026#39;); \t}, \tfalse );  wrapper.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction (event) { \tconsole.log(\u0026#39;点击了子元素\u0026#39;);  \tevent.stopPropagation(); \t// IE 独有，但 Chrome 也可以使用 \tevent.cancelBubble = true; \t}, \tfalse ); ","title":"JavaScript Event"},{"content":"Event 表示在 DOM 中出现的事件。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event/","summary":"Event 表示在 DOM 中出现的事件。","title":"JavaScript Event"},{"content":"Event 属性 target 返回触发当前事件的事件源对象。\ndocument.onclick = function (event) { \tconsole.log(event.target); }; ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event-%E5%B1%9E%E6%80%A7/","summary":"Event 属性 target 返回触发当前事件的事件源对象。\ndocument.onclick = function (event) { \tconsole.log(event.target); }; ","title":"JavaScript Event 属性"},{"content":"EventTarget addEventListener() 监听一个对象，并给这个对象绑定指定的事件处理函数。\n第一个参数是事件类型，第二个参数是事件的回调回函数。\nthis 的指向是 DOM 元素本身，第三个参数是一个布尔值，用于定义该对象应该使用哪一种事件处理模型（冒泡、捕获）进行触发。\n优点 可以给同一个对象同一类型事件绑定多个事件处理函数，并且会按绑定事件的先后顺序去执行。\n// 旧事件 div.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;第一个事件\u0026#39;); \t}, \tfalse ); // 新事件，不会fu div.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;第二个事件\u0026#39;); \t}, \tfalse ); attachEvent() IE 独有事件，它与 addEventListener() 差不多。\nthis 指向 window。\nfor 绑定 addEventListener() 事件 var li = document.getElementsByTagName(\u0026#39;li\u0026#39;);  var len = li.length; for (var i = 0; i \u0026lt; len; i++) { \t// 用立即执行函数解决闭包内存泄漏的问题 \t(function (i) { \tli[i].addEventListener( \t\u0026#39;click\u0026#39;, \tfunction () { \tconsole.log(i); \t}, \tfalse \t); \t})(i); } removeEventListener() 删除使用 addEventListener() 添加的事件。\n需要将 addEventListener() 绑定的匿名函数变为命名函数。或者说，用匿名函数绑定的事件，都无法用 addEventListener() 来删除。\nvar div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0];  // 因为原本 addEventListener() 中的回调函数是匿名的， // 所以无法使用 removeEventListener() 来移除 addEventListener() // 因此，需要将回调函数编为命名函数 div.addEventListener(\u0026#39;click\u0026#39;, fun, false); // 命名函数 function fun() { \tconsole.log(666); \t// 移除 addEventListener 事件 \tdiv.removeEventListener(\u0026#39;click\u0026#39;, fun, false); } ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/events/eventtarget/","summary":"EventTarget addEventListener() 监听一个对象，并给这个对象绑定指定的事件处理函数。\n第一个参数是事件类型，第二个参数是事件的回调回函数。\nthis 的指向是 DOM 元素本身，第三个参数是一个布尔值，用于定义该对象应该使用哪一种事件处理模型（冒泡、捕获）进行触发。\n优点 可以给同一个对象同一类型事件绑定多个事件处理函数，并且会按绑定事件的先后顺序去执行。\n// 旧事件 div.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;第一个事件\u0026#39;); \t}, \tfalse ); // 新事件，不会fu div.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;第二个事件\u0026#39;); \t}, \tfalse ); attachEvent() IE 独有事件，它与 addEventListener() 差不多。\nthis 指向 window。\nfor 绑定 addEventListener() 事件 var li = document.getElementsByTagName(\u0026#39;li\u0026#39;);  var len = li.length; for (var i = 0; i \u0026lt; len; i++) { \t// 用立即执行函数解决闭包内存泄漏的问题 \t(function (i) { \tli[i].","title":"JavaScript EventTarget"},{"content":"get 方法 getDate() 返回一个月中的某天 1 — 31\ngetDay() 返回一周中的某天 0 — 6。\n注意，0 表示周一，6 表示周日。\ngetMonth() 返回一年终的某月 0 — 11。\n注意，0 表示一月，11 表示 12 月\ngetFullYear() 获取四位数的年份 XXXX。\n以前是用的 getYear() 方法，因为以前表示日期用的六位制 YY.MM.DD，直到 1999 年 12 月 31 日之后，变成了 2000 年，这个时候的日期用六位制已经无法表示了，因此，现在改用八位制 YYYY.MM.DD。\ngetHours() 获取小时 0 — 23\ngetMinutes() 获取分 0 — 59\ngetSeconds() 获取秒 0 — 59\ngetMilliseconds() 获取毫秒 0 — 999\ngetTime() 获取毫秒（从格林威治时间 1970 年 1 月 1 日至今的毫秒数），也叫获取时间戳。\n时间戳 用于验证执行某个程序所花费的毫秒数。\n// for 执行前的时间戳 var firstTime = new Date().getTime();  // 计算执行 for 循环所花的毫秒数 for (var i = 0; i \u0026lt; 1000000; i++) {}  // for 执行后的时间戳 var lastTime = new Date().getTime();  // 执行完 for 的时间戳减去 for 执行前的时间戳 // 就可以算出执行 for 循环所花费的时间 console.log(lastTime - firstTime); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/get-%E6%96%B9%E6%B3%95/","summary":"get 方法 getDate() 返回一个月中的某天 1 — 31\ngetDay() 返回一周中的某天 0 — 6。\n注意，0 表示周一，6 表示周日。\ngetMonth() 返回一年终的某月 0 — 11。\n注意，0 表示一月，11 表示 12 月\ngetFullYear() 获取四位数的年份 XXXX。\n以前是用的 getYear() 方法，因为以前表示日期用的六位制 YY.MM.DD，直到 1999 年 12 月 31 日之后，变成了 2000 年，这个时候的日期用六位制已经无法表示了，因此，现在改用八位制 YYYY.MM.DD。\ngetHours() 获取小时 0 — 23\ngetMinutes() 获取分 0 — 59\ngetSeconds() 获取秒 0 — 59\ngetMilliseconds() 获取毫秒 0 — 999\ngetTime() 获取毫秒（从格林威治时间 1970 年 1 月 1 日至今的毫秒数），也叫获取时间戳。\n时间戳 用于验证执行某个程序所花费的毫秒数。","title":"JavaScript get 方法"},{"content":"GlobalEventHandlers 全局事件句柄，在 JavaScrip 中，为了将属性和事件区分开，所有事件的命名都是小写的，而不是像属性那样用小驼峰式命名。\nonclick 当指定元素被点击时，所触发的事件。它的兼容性非常好。\n基本等于将事件写到 HTML 元素的onclick内联属性上。\nthis 的指向是 DOM 元素本身。\n只能监听鼠标左键，无法监听右键和滚轮。\nonmousedown + onmouseup = onclick\n缺点 一个元素只能绑定一个事件，如果给这个元素定义新的事件，那么新的事件会覆盖旧的事件。\nvar div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0];  // 旧事件 div.onclick = function () { \tconsole.log(\u0026#39;旧事件\u0026#39;); }; // 新事件，会覆盖旧事件 div.onclick = function () { \tconsole.log(\u0026#39;新s\u0026#39;); }; 点击事件只触发一次 div.onclick = function () { \tconsole.log(4555); \t// 使 onclick 事件只能被触发一次 \tdiv.onclick = null; }; oncontextmenu 鼠标右键单击指定对象时，所触发的事件。\nonmousemove 鼠标移动到指定对象上时，所触发的事件。\nonmousedown 鼠标按下指定对象时，所触发的事件。\n可以监听鼠标左键、右键以及滚轮。\nonmouseup 鼠标按键按下后松开指定对象时，所触发的事件。\n可以监听鼠标左键、右键以及滚轮。\nonmouseover/onmouseenter 鼠标移进指定对象时，所触发的事件。\nonmouseenter 是 HTML 5 新规范中的属性。\nonmouseout/onmouseleave 鼠标移出指定对象时，所触发的事件。\nonmouseleave 是 HTML 5 新规范中的属性。\nonkeydown 按下鼠标键盘上的按键时，所触发的事件。\n如果一直按着按键，那么事件会持续触发。\n可以监听键盘上的任意键。\nonkeypress 按下并释放键盘上的按键时，所触发的事件。\n只能监听键盘上的字母键和数字键，不能监听一些特殊按键（ALT、CTRL、SHIFT、ESC、箭头等）。\n可以将按键的 charCode 转换为 ASCII 码。\ndocument.onkeypress = function (e) { \tconsole.log(String.fromCharCode(e.charCode)); }; onkeyup 松开鼠标键盘上的按键时，所触发的事件。\noninput input 中的文本（value）每次发生变化时，所触发的事件。\nonfocus 元素获得焦点时，所触发的事件。\nonchange input 元素中的文本（value）被修改，并且失去焦点时，所触发的事件。如果文本没有被修改，则事件不会被触发。\nonblur 元素失去焦点时，所触发的事件。\nonscroll 当文档的滚动条滚动的时，所触发的事件。\nonwheel 当滚动鼠标的滚轮时，所触发的事件\nonload 当文档资源全部加载完成时，所触发的事件。\n该事件尽量别用，因为它的效率非常的慢，执行 onload的时候，它会等待页面渲染完成后才被触发。\n不要将主程序的代码放到 onload 中，这会让你非常的 Low。\n但我们可以用它来知道页面渲染完毕的时间戳。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/events/globaleventhandlers/","summary":"GlobalEventHandlers 全局事件句柄，在 JavaScrip 中，为了将属性和事件区分开，所有事件的命名都是小写的，而不是像属性那样用小驼峰式命名。\nonclick 当指定元素被点击时，所触发的事件。它的兼容性非常好。\n基本等于将事件写到 HTML 元素的onclick内联属性上。\nthis 的指向是 DOM 元素本身。\n只能监听鼠标左键，无法监听右键和滚轮。\nonmousedown + onmouseup = onclick\n缺点 一个元素只能绑定一个事件，如果给这个元素定义新的事件，那么新的事件会覆盖旧的事件。\nvar div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0];  // 旧事件 div.onclick = function () { \tconsole.log(\u0026#39;旧事件\u0026#39;); }; // 新事件，会覆盖旧事件 div.onclick = function () { \tconsole.log(\u0026#39;新s\u0026#39;); }; 点击事件只触发一次 div.onclick = function () { \tconsole.log(4555); \t// 使 onclick 事件只能被触发一次 \tdiv.onclick = null; }; oncontextmenu 鼠标右键单击指定对象时，所触发的事件。\nonmousemove 鼠标移动到指定对象上时，所触发的事件。\nonmousedown 鼠标按下指定对象时，所触发的事件。","title":"JavaScript GlobalEventHandlers"},{"content":"HTMLElement 属性 innerText/textContent 设置或获取指定元素所包含的文本信息，只返文本信息，不返回所包含的元素。\n另外，设置元素内容的时候，如果元素内容中有子元素，则这些子元素也会被覆盖。\ninnerText 很容易 与 textContent 混淆, 但这两个属性间实际上有很重要的区别. 大体来说, innerText 可操作已被渲染的内容， 而 textContent 则不会。\nvar body = document.getElementsByTagName(\u0026#39;body\u0026#39;)[0]; var div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0]; // 设置内容 div.innerText = \u0026#39;123\u0026#39;; /textContent div.textContent = \u0026#39;456\u0026#39;; offsetHeight 它返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。\noffsetWidth 它返回该元素的像素宽度，宽度包含该元素的水平内边距和边框，且是一个整数。\noffsetLeft 返回当前元素左边界相对于最近的定位父元素的左边界的像素值。该值包含 border\n如果当前元素的父元素中没有定位元素，则返回相对文档左边界的像素值。\noffsetTop 它返回当前元素顶边界相对于最近的定位父元素的顶边界的像素值。该值包含 border\n如果当前元素的父元素中没有定位元素，则返回相对文档左边界的像素值。\noffsetParent 返回距离当前元素最近的定位父元素。\n如果当前元素的父元素中没有定位元素，则返回 body。\nstyle 设置或返回 ele 的内联样式表中的 attr，并不会返回内嵌样式表和外链样式表中的 CSS 属性。\n设置的值必须为字符串格式。\n如果是设置 float 这样的保留字属性，则尽量使用 cssFloat ，虽然也可以使用 float 设置，但是 W3C 并不建议使用 float，因为 float 是一个保留字，未来可能会成为关键字，避免未来的命名冲突。\n复合属性尽量分开设置，比如boder，尽量分别设置borderWidth、borderStyle和borderColor。\n组合单词的属性名，变为小驼峰式的属性名来进行设置，比如background-color变为backgroundColor。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/htmlelement/htmlelement-%E5%B1%9E%E6%80%A7/","summary":"HTMLElement 属性 innerText/textContent 设置或获取指定元素所包含的文本信息，只返文本信息，不返回所包含的元素。\n另外，设置元素内容的时候，如果元素内容中有子元素，则这些子元素也会被覆盖。\ninnerText 很容易 与 textContent 混淆, 但这两个属性间实际上有很重要的区别. 大体来说, innerText 可操作已被渲染的内容， 而 textContent 则不会。\nvar body = document.getElementsByTagName(\u0026#39;body\u0026#39;)[0]; var div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0]; // 设置内容 div.innerText = \u0026#39;123\u0026#39;; /textContent div.textContent = \u0026#39;456\u0026#39;; offsetHeight 它返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。\noffsetWidth 它返回该元素的像素宽度，宽度包含该元素的水平内边距和边框，且是一个整数。\noffsetLeft 返回当前元素左边界相对于最近的定位父元素的左边界的像素值。该值包含 border\n如果当前元素的父元素中没有定位元素，则返回相对文档左边界的像素值。\noffsetTop 它返回当前元素顶边界相对于最近的定位父元素的顶边界的像素值。该值包含 border\n如果当前元素的父元素中没有定位元素，则返回相对文档左边界的像素值。\noffsetParent 返回距离当前元素最近的定位父元素。\n如果当前元素的父元素中没有定位元素，则返回 body。\nstyle 设置或返回 ele 的内联样式表中的 attr，并不会返回内嵌样式表和外链样式表中的 CSS 属性。\n设置的值必须为字符串格式。\n如果是设置 float 这样的保留字属性，则尽量使用 cssFloat ，虽然也可以使用 float 设置，但是 W3C 并不建议使用 float，因为 float 是一个保留字，未来可能会成为关键字，避免未来的命名冲突。","title":"JavaScript HTMLElement 属性"},{"content":"set 方法 setDate() 以数值 1-31 设置日\nvar date = new Date(); // 设置日期中的第 18 天 var d = date.setDate(18); console.log(d); // 输出被更改后的时间戳，因为日变了，所以日对应的周也会跟着变。 console.log(date); 定时执行某个代码\n用 set 方法设置一个未来的时间点，然后判断当 getTime() 的毫秒数与 set 的毫秒数相差小于 1000 的时候，相当于此刻的时间点已经和设置的时间点重合，可以执行一些需要在这个时间点所执行的操作。\n用它可以实现倒计时抢漏、闹钟等功能。\nsetTime() 设置从 1970 年 1 月 1 日至今的毫秒数。\nvar date = new Date(); // 将 date 设置为从格林威治时间至今的毫秒数（毫秒数会转换为日期） date.setTime(12343546557501); // 返回设置的日期 console.log(date); 闹钟 var date = new Date(); // 设置未来的某个时间点的分和秒，当格林威治时间到达我们设置的时间戳，会执行某个操作 date.setMinutes(10); date.setSeconds(5);  // 定时器，每隔 1000 毫秒会执行一次回调函数 setInterval(function () { \t// 判断格林威治时间是否和设置的时间点相差小于 1000 毫秒（小于 1000 毫秒则表示格林威治时间已经到大我们设置的时间戳） \tif (new Date().getTime() - date.getTime() \u0026gt; 1000) { \t// 到达我们设置的时间点后所执行的操作 \tconsole.log(\u0026#39;闹钟！\u0026#39;); \t} }, 1000); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/set-%E6%96%B9%E6%B3%95/","summary":"set 方法 setDate() 以数值 1-31 设置日\nvar date = new Date(); // 设置日期中的第 18 天 var d = date.setDate(18); console.log(d); // 输出被更改后的时间戳，因为日变了，所以日对应的周也会跟着变。 console.log(date); 定时执行某个代码\n用 set 方法设置一个未来的时间点，然后判断当 getTime() 的毫秒数与 set 的毫秒数相差小于 1000 的时候，相当于此刻的时间点已经和设置的时间点重合，可以执行一些需要在这个时间点所执行的操作。\n用它可以实现倒计时抢漏、闹钟等功能。\nsetTime() 设置从 1970 年 1 月 1 日至今的毫秒数。\nvar date = new Date(); // 将 date 设置为从格林威治时间至今的毫秒数（毫秒数会转换为日期） date.setTime(12343546557501); // 返回设置的日期 console.log(date); 闹钟 var date = new Date(); // 设置未来的某个时间点的分和秒，当格林威治时间到达我们设置的时间戳，会执行某个操作 date.setMinutes(10); date.setSeconds(5);  // 定时器，每隔 1000 毫秒会执行一次回调函数 setInterval(function () { \t// 判断格林威治时间是否和设置的时间点相差小于 1000 毫秒（小于 1000 毫秒则表示格林威治时间已经到大我们设置的时间戳） \tif (new Date().","title":"JavaScript set 方法"},{"content":"String 方法 fromCharCode() 将 UTF-16 组成的值转换为一个字符串。\nmatch() 检索并返回字符串匹配正则表达式的结果。\n参数通常是一个正则表达式，\nvar reg = /ab/g;  var str = \u0026#39;abababababab\u0026#39;;  var result = str.match(reg); console.log(result); slice() 从字符串的第 n 位字符开始截取，一直截取到字符串最末。并返回一个新的字符串，且不会改动原字符串。\nsearch() 返回子字符串在字符串中的起始位置（索引值）这个字符串也可以使正则表达式。\n匹配失败返回 -1。\nvar str = \u0026#39;eedsddvv\u0026#39;;  var reg = /(\\w)\\1(\\w)\\2/g;  var result = str.search(reg);  console.log(result); split() 使用指定的分隔符字符串将一个字符串对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。\n除了会返回匹配结果，还会返回()中第一次匹配的子表达式的值，并且这些值是类数组的数据位，它们存在于类数组的索引位中。\nvar str = \u0026#39;dfjajfdsssajfiovvdsafjttidjf\u0026#39;;  var reg = /(\\w)\\1/g;  var result = str.split(reg);  console.log(result); 用数之来分割字符串 var str = \u0026#39;dfjajfdss0sajfiovvds0afjttidjf\u0026#39;;  var reg = /\\d/g;  var result = str.split(reg);  console.log(result); replace() 匹配普通字符串时，只能匹配一次。这也是非正则表达式的缺陷，它没有访问字符串全局的权限。\nvar str = \u0026#39;aafjdfeijogfjdalgala\u0026#39;; // 只将字符串中的第一个 a 替换成了 y // 后面的 a 并没被替换 var result = str.replace(\u0026#39;a\u0026#39;, \u0026#39;y\u0026#39;); console.log(result); 匹配带g的正则表达式时，就可以全局匹配：\nvar str = \u0026#39;aaaaa\u0026#39;; var reg = /a/g; // 字符串中全部的 a 都被替换为了 y var result = str.replace(reg, \u0026#39;y\u0026#39;); console.log(result); $ 反向引用 用$来反向引用正则表达式中()子表达式中的内容。\n$1 表示正则表达式中第一个()中的内容；$2 表示正则表达式中第二个()中的内容，以此类推\u0026hellip;\nvar str = \u0026#39;aabbaabb\u0026#39;; var reg = /(\\w)\\1(\\w)\\2/g;  var result = str.replace(reg, \u0026#39;$2$2$1$1\u0026#39;); console.log(result); 回调函数 用回调函数的方式来实现替换。\n如果是全局匹配，每匹配一次，回调函数都会执行一次。如果不是全局匹配，则只匹配一次，回调函数也只执行一次。\n 函数的第一个参数是正则表达式匹配到结果。 函数的第二个参数是**正则表达式中第一个()中的内容。 函数的第三个参数是**正则表达式中第二个()中的内容。 以此类推\u0026hellip;  var str = \u0026#39;aabbaabb\u0026#39;; var reg = /(\\w)\\1(\\w)\\2/g;  var result = str.replace(reg, function ($, $1, $2) { \treturn $2 + $2 + $1 + $1; }); console.log(result); 甚至还可以自定义返回 reture 的值：\nvar str = \u0026#39;aabbaabb\u0026#39;; var reg = /(\\w)\\1(\\w)\\2/g;  var result = str.replace(reg, function ($, $1, $2) { \t// return bbaahollobbaahollo，因为需要匹配两次 \treturn $2 + $2 + $1 + $1 + \u0026#39;hollo\u0026#39;; }); console.log(result); toUpperCase() 将指定字符串转为大写形式并返回（如果调用该方法的值不是字符串类型会被强制转换）。\nvar sentence = \u0026#39;my name is rainy\u0026#39;;  // return MY NAME IS RAINY console.log(sentence.toUpperCase()); toLowerCase() var sentence = \u0026#39;MY NAME IS RAINY\u0026#39;;  // return my name is rainy console.log(sentence.toLowerCase()); substring() 返回一个字符串在开始索引到结束索引之间的字符串, 或从开始索引直到字符串的末尾的字符串。\nindexOf() 返回字符串中所包含某个字符串第一次出现的索引。\n用indexOf()判断一个字符串中是否包含空字符串，会返回0，而不是-1。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/string/string-%E6%96%B9%E6%B3%95/","summary":"String 方法 fromCharCode() 将 UTF-16 组成的值转换为一个字符串。\nmatch() 检索并返回字符串匹配正则表达式的结果。\n参数通常是一个正则表达式，\nvar reg = /ab/g;  var str = \u0026#39;abababababab\u0026#39;;  var result = str.match(reg); console.log(result); slice() 从字符串的第 n 位字符开始截取，一直截取到字符串最末。并返回一个新的字符串，且不会改动原字符串。\nsearch() 返回子字符串在字符串中的起始位置（索引值）这个字符串也可以使正则表达式。\n匹配失败返回 -1。\nvar str = \u0026#39;eedsddvv\u0026#39;;  var reg = /(\\w)\\1(\\w)\\2/g;  var result = str.search(reg);  console.log(result); split() 使用指定的分隔符字符串将一个字符串对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。\n除了会返回匹配结果，还会返回()中第一次匹配的子表达式的值，并且这些值是类数组的数据位，它们存在于类数组的索引位中。\nvar str = \u0026#39;dfjajfdsssajfiovvdsafjttidjf\u0026#39;;  var reg = /(\\w)\\1/g;  var result = str.split(reg);  console.log(result); 用数之来分割字符串 var str = \u0026#39;dfjajfdss0sajfiovvds0afjttidjf\u0026#39;;  var reg = /\\d/g;  var result = str.","title":"JavaScript String 方法"},{"content":"Window 属性 innerWidth 和 innerHeight 返回视口的宽度和高度。\n视口就是浏览器中能看到网页的部分。\n// 视口宽度 var WViewport = window.innerWidth; // 视口高度 var HViewport = window.innerHeight; console.log(\u0026#39;视口宽度：\u0026#39; + WViewport); console.log(\u0026#39;视口高度：\u0026#39; + HViewport); pageYOffset 和 pageXOffset 返回滚动条当前的纵向滚动距离和横向滚动距离。\n// 纵向滚动条的滚动距离 var Ydistance = window.pageYOffset; // 横向滚动条的滚动距离 var Xdistance = window.pageXOffset; console.log(Ydistance); console.log(Xdistance); IE 8 及 IE 8 以下的浏览器 document.body.scrollLeft/Top 和 document.documentElement.scorllLeft/Top这个两个属性的兼容性机器混乱，Top 代表纵向，Left 代表横向\n在 IE 8 及 IE 8 以下的浏览器中，这两个属性中只要其中一个有值，则另一个属性的值一定为 0。因此， 如果我们要考虑兼容性的问题，都会将这两个属性相加，以兼容 IE 8 及其 IE 8 以下的浏览器。\nDOMContentLoaded 文档解析完成后执行的事件。\n它和window.onload的区别是，window.onload是在文档加载完成后所触发的事件，而DOMContentLoaded，无需等文档全部加载完成，只需要等文档（DOMTree）解析完成后，DOMContentLoaded就会被触发。\nDOMContentLoaded事件只能使用addEventListener来监听\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;title\u0026gt;DOMContentLoaded\u0026lt;/title\u0026gt; \t、 \t\u0026lt;script\u0026gt; \t// 让 JavaScrip 代码在文档解析完毕之后执行，并不会报错 \tdocument.addEventListener( \t\u0026#39;DOMContentLoaded\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;DOMContentLoaded 事件被触发！\\n\\n标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。\u0026#39;); \t}, \tfalse \t); \t\u0026lt;/script\u0026gt; \t\u0026lt;style\u0026gt; \tdiv { \twidth: 100px; \theight: 100px; \tbackground-color: rgb(15, 190, 131); \t} \t\u0026lt;/style\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;div\u0026gt;123\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/window/window-%E5%B1%9E%E6%80%A7/","summary":"Window 属性 innerWidth 和 innerHeight 返回视口的宽度和高度。\n视口就是浏览器中能看到网页的部分。\n// 视口宽度 var WViewport = window.innerWidth; // 视口高度 var HViewport = window.innerHeight; console.log(\u0026#39;视口宽度：\u0026#39; + WViewport); console.log(\u0026#39;视口高度：\u0026#39; + HViewport); pageYOffset 和 pageXOffset 返回滚动条当前的纵向滚动距离和横向滚动距离。\n// 纵向滚动条的滚动距离 var Ydistance = window.pageYOffset; // 横向滚动条的滚动距离 var Xdistance = window.pageXOffset; console.log(Ydistance); console.log(Xdistance); IE 8 及 IE 8 以下的浏览器 document.body.scrollLeft/Top 和 document.documentElement.scorllLeft/Top这个两个属性的兼容性机器混乱，Top 代表纵向，Left 代表横向\n在 IE 8 及 IE 8 以下的浏览器中，这两个属性中只要其中一个有值，则另一个属性的值一定为 0。因此， 如果我们要考虑兼容性的问题，都会将这两个属性相加，以兼容 IE 8 及其 IE 8 以下的浏览器。\nDOMContentLoaded 文档解析完成后执行的事件。","title":"JavaScript Window 属性"},{"content":"Window 方法 scroll() 和 scrollTo() 使文档的滚动条滚动至文档中的特定位置。\n//让水平的滚动条滚动到 100 像素的位置，再让垂直滚动条滚动到 200 像素的位置 scrollTo(100, 200); scrollBy() 使文档的滚动条按指定的偏移量滚动。\n//　让垂直滚动条滚动 10px， scrollTo(0, 10); // 重复执行的话，滚动条会再滚动 10px scrollTo(0, 10); getComputedStyle() 返回指定元素经过计算后的 CSS 样式,，且返回的值都是绝对值，它是一个只读属性。\n返回的样式是元素在浏览器中最终渲染效果的样式。\n第一个参数是元素，第二个参数是伪元素。\ngetComputedStyle() 的第二个参数可以获取第一个参数（元素）的伪元素（::before、::after等）的 CSS 样式。\n第二个参数不是必须的，当不查询元素的伪元素的时候可以忽略或者传入 null。\ncurrentStyle 只读属性，返回的 CSS 属性的值没有经过计算。IE 独有属性。\n获取指定元素的指定 CSS 属性 var div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0];  function GetStyle(elem, name) { \tif (window.getComputedStyle) { \treturn window.getComputedStyle(elem, null)[name]; \t} else { \treturn elem.currentStyle[name]; \t} } setInterval() 用于每隔一段时间调用一个函数或一个代码片段。\nsetTimeout() 使函数或代码在经过一段指定的时间才开始执行。\nclearInterval() 取之前通过 setInterval() 设置的重复定时任务。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/window/window-%E6%96%B9%E6%B3%95/","summary":"Window 方法 scroll() 和 scrollTo() 使文档的滚动条滚动至文档中的特定位置。\n//让水平的滚动条滚动到 100 像素的位置，再让垂直滚动条滚动到 200 像素的位置 scrollTo(100, 200); scrollBy() 使文档的滚动条按指定的偏移量滚动。\n//　让垂直滚动条滚动 10px， scrollTo(0, 10); // 重复执行的话，滚动条会再滚动 10px scrollTo(0, 10); getComputedStyle() 返回指定元素经过计算后的 CSS 样式,，且返回的值都是绝对值，它是一个只读属性。\n返回的样式是元素在浏览器中最终渲染效果的样式。\n第一个参数是元素，第二个参数是伪元素。\ngetComputedStyle() 的第二个参数可以获取第一个参数（元素）的伪元素（::before、::after等）的 CSS 样式。\n第二个参数不是必须的，当不查询元素的伪元素的时候可以忽略或者传入 null。\ncurrentStyle 只读属性，返回的 CSS 属性的值没有经过计算。IE 独有属性。\n获取指定元素的指定 CSS 属性 var div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0];  function GetStyle(elem, name) { \tif (window.getComputedStyle) { \treturn window.getComputedStyle(elem, null)[name]; \t} else { \treturn elem.currentStyle[name]; \t} } setInterval() 用于每隔一段时间调用一个函数或一个代码片段。","title":"JavaScript Window 方法"},{"content":"事件句柄 事件发生时进行的操作。\n事件句柄就是一个将元素的特定事件与某个函数关联起来，比如 onclick、onmouseover 等都是事件句柄，它们会指向一个给定的函数，如果事件发生，那么就会执行此函数。\ndocument.oncontextmenu = function () { \tconsole.log(\u0026#39;鼠标右击事件句柄\u0026#39;); }; document.onclick = function () { \tconsole.log(\u0026#39;点击事件句柄\u0026#39;); }; ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%8F%A5%E6%9F%84/","summary":"事件句柄 事件发生时进行的操作。\n事件句柄就是一个将元素的特定事件与某个函数关联起来，比如 onclick、onmouseover 等都是事件句柄，它们会指向一个给定的函数，如果事件发生，那么就会执行此函数。\ndocument.oncontextmenu = function () { \tconsole.log(\u0026#39;鼠标右击事件句柄\u0026#39;); }; document.onclick = function () { \tconsole.log(\u0026#39;点击事件句柄\u0026#39;); }; ","title":"JavaScript 事件句柄"},{"content":"事件处理模型 一个对象的一个事件类型，只能触发一种事件处理模型，也就是要么触发事件冒泡，要么触发事件捕获。\n另外，并不是所有事件都存冒泡，比如 focus、blur、change、submit、reset、select 等事件。\n事件冒泡 结构上（非视觉上）为嵌套关系的元素，会存在事件冒泡的情况。即同一类型的事件，触发事件源，事件会以由内（事件源）至外的顺序被触发。\nHTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;   \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;  \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt;  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt;  \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt;  \u0026lt;style\u0026gt;  * {  margin: 0;  padding: 0;  }   .wrapper {  width: 300px;  height: 300px;  background-color: rgb(183, 43, 43);  }   .content {  width: 200px;  height: 200px;  background-color: rgb(12, 175, 200);  }   .box {  width: 100px;  height: 100px;  background-color: rgb(107, 37, 206);  }  \u0026lt;/style\u0026gt;  \u0026lt;/head\u0026gt;   \u0026lt;body\u0026gt;  \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt;  \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;  \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;/body\u0026gt;  \u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;/html\u0026gt; JavaScrip var wrapper = document.getElementsByClassName(\u0026#39;wrapper\u0026#39;)[0]; var content = document.getElementsByClassName(\u0026#39;content\u0026#39;)[0]; var box = document.getElementsByClassName(\u0026#39;box\u0026#39;)[0]; wrapper.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;wrapper\u0026#39;); \t}, \tfalse ); content.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;content\u0026#39;); \t}, \tfalse );  // 因为 box 在 wrapper 和 content 中， // 会导致点击 box ，同时触发 wrapper 和 content 的事件。 box.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;box\u0026#39;); \t}, \tfalse ); 事件捕获 想让对象的事件触发捕获，需要将 addEventListener() 中的第三个参数的值（false）变为 true 即可。\n结构上存在嵌套的元素，会存在事件捕获。即同一类型的事件，触发事件源，事件会以由外至内（事件源）的顺序被触发。\n事件捕获与事件冒泡正好相反。\nIE 浏览器上没有事件捕获的情况。\nvar wrapper = document.getElementsByClassName(\u0026#39;wrapper\u0026#39;)[0]; var content = document.getElementsByClassName(\u0026#39;content\u0026#39;)[0]; var box = document.getElementsByClassName(\u0026#39;box\u0026#39;)[0];  window.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;window\u0026#39;); \t}, \ttrue ); document.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;document\u0026#39;); \t}, \ttrue ); document.documentElement.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;html\u0026#39;); \t}, \ttrue ); document.body.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;body\u0026#39;); \t}, \ttrue );  wrapper.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;wrapper\u0026#39;); \t}, \ttrue ); content.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;content\u0026#39;); \t}, \ttrue ); // 点击 box，会先触发 window 的事件，再以此触发 document、html、body、wrapper、content，最后再触发 content box.addEventListener( \t\u0026#39;click\u0026#39;, \tfunction () { \tconsole.log(\u0026#39;box\u0026#39;); \t}, \ttrue ); 冒泡和捕获的触发顺序 如果同一个对象，给它的同一类型事件绑定多个事件处理函数，有冒泡，也有捕获的时候，那么一定是先触发事件捕获，再触发事件冒泡，不管事件的绑定的先后顺序。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B/","summary":"事件处理模型 一个对象的一个事件类型，只能触发一种事件处理模型，也就是要么触发事件冒泡，要么触发事件捕获。\n另外，并不是所有事件都存冒泡，比如 focus、blur、change、submit、reset、select 等事件。\n事件冒泡 结构上（非视觉上）为嵌套关系的元素，会存在事件冒泡的情况。即同一类型的事件，触发事件源，事件会以由内（事件源）至外的顺序被触发。\nHTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;   \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;  \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt;  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt;  \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt;  \u0026lt;style\u0026gt;  * {  margin: 0;  padding: 0;  }   .wrapper {  width: 300px;  height: 300px;  background-color: rgb(183, 43, 43);  }   .content {  width: 200px;  height: 200px;  background-color: rgb(12, 175, 200);  }   .","title":"JavaScript 事件处理模型"},{"content":"事件对象 在 DOM 中发生事件时，所有相关信息都会被收集并存储在一个名为**event **的对象中。这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型、可能与特定事件相关的任何其他数据等。\n每个事件处理函数都有一个形参 event，这个 **event **就可以在函数中被当做 event 对象来使用。\n// event 是一个参数，系统会自动将事件对象传给他。 document.onclick = function (event) { \tconsole.log(event); }; srcElement 表示触发当前事件的事件源对象。\n可以用event.target来获取事件的 srcElement。\nButton 表示触发当前事件是鼠标的左键还是右键，又或者是滚轮。\n0 表示鼠标左键，1 表示鼠标滚轮，2 表示鼠标右键。\ndiv.onmousedown = function (event) { \tif (event.button == 0) { \tconsole.log(\u0026#39;Left Click\u0026#39;); \t} else if (event.button == 1) { \tconsole.log(\u0026#39;Roller\u0026#39;); \t} else if (event.button == 2) { \tconsole.log(\u0026#39;Right Click\u0026#39;); \t} }; charCode 键盘事件的事件对象上的属性，返回按下的键的 ASCII 码 。\n事件委托 利用事件冒泡和事件源对象进行的操作。\n想象一个场景，一个 ul 中有十个 li，每个 li 中的文本都不一样，我们需要实现单击每个 li，返回每个 li 中所包含文本信息。\n我们需要给每个 li 绑定点击事件，正常的情况应该用 for 遍历每个 li，然后一个个的添加点击事件，这样的方式当然没问题，但是，如果说有几亿个 li 元素呢？for 显然行不通。\n我们可以用事件冒泡和事件源来实现这个功能：\n点击 li，冒泡触发 ul 的单击事件，再获取触发 ul 单击事件的事件源对象，也就是 li，最后返回 li 中的文本即可。\nvar ul = document.getElementsByTagName(\u0026#39;ul\u0026#39;)[0];  // 因为 ul 包含 li，所以，点击 li，会触发 li 的事件冒泡 // 从而触发 ul 的点击事件，而 ul 的点击事件是： // 返回事件源对象（li）所包含的文本信息。 // 这样就无需用 for 遍历 li 来一个个的绑定点击事件了 // 并且，后续扩展也非常的方便，只需要添加 li 即可 ul.onclick = function (event) { \t// 事件源对象为 li \tvar target = event.target; \t// 返回 li 所包含的文本信息 \tconsole.log(target.innerText); }; 优点 性能高，不需要遍历所有的元素一个个的绑定事件。\n扩展性高，当增加新元素时，不需要重新绑定事件。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/","summary":"事件对象 在 DOM 中发生事件时，所有相关信息都会被收集并存储在一个名为**event **的对象中。这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型、可能与特定事件相关的任何其他数据等。\n每个事件处理函数都有一个形参 event，这个 **event **就可以在函数中被当做 event 对象来使用。\n// event 是一个参数，系统会自动将事件对象传给他。 document.onclick = function (event) { \tconsole.log(event); }; srcElement 表示触发当前事件的事件源对象。\n可以用event.target来获取事件的 srcElement。\nButton 表示触发当前事件是鼠标的左键还是右键，又或者是滚轮。\n0 表示鼠标左键，1 表示鼠标滚轮，2 表示鼠标右键。\ndiv.onmousedown = function (event) { \tif (event.button == 0) { \tconsole.log(\u0026#39;Left Click\u0026#39;); \t} else if (event.button == 1) { \tconsole.log(\u0026#39;Roller\u0026#39;); \t} else if (event.button == 2) { \tconsole.log(\u0026#39;Right Click\u0026#39;); \t} }; charCode 键盘事件的事件对象上的属性，返回按下的键的 ASCII 码 。","title":"JavaScript 事件对象"},{"content":"区分点击事件与长按事件 HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;title\u0026gt;区分点击事件与长按事件.m\u0026lt;/title\u0026gt; \t\u0026lt;style\u0026gt; \tdiv { \twidth: 100px; \theight: 100px; \tbackground-color: rgb(15, 190, 131); \t} \t\u0026lt;/style\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;div style=\u0026#34;position:absolute;left:0;top:0;\u0026#34;\u0026gt;该拖曳只对内联样式有效\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; JavaScrip var div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0];  var firstTime = new Date(); var lastTime = new Date(); var key = false; // 元素按下时的时间 document.onmousedown = function () { \tfirstTime = new Date().getTime(); \t// 按下元素移动 \tdocument.onmousemove = function () { \t// 事件 \t}; }; // 元素按下后松开的时间， // 用它们的时间差来判断用户是点击了元素，还是长按了元素 document.onmouseup = function () { \tlastTime = new Date().getTime(); \t// 因为长按的时间肯定比点击时间要久，因此只需要判断长按的时间是否大于 100 毫秒 \t// 大于的话则是长按，小于则是点击，将 key 变为 true（会触发下面的点击事件） \tif (lastTime - firstTime \u0026lt; 100) { \tkey = true; \t//大于 100，长按事件 \t} else { \tconsole.log(\u0026#39;长按元素\u0026#39;); \t} };  div.onclick = function () { \t// key 为 true，触发点击事件 \tif (key) { \tconsole.log(\u0026#39;单击元素\u0026#39;); \t} }; ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E5%8C%BA%E5%88%86%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E4%B8%8E%E9%95%BF%E6%8C%89%E4%BA%8B%E4%BB%B6/","summary":"区分点击事件与长按事件 HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;title\u0026gt;区分点击事件与长按事件.m\u0026lt;/title\u0026gt; \t\u0026lt;style\u0026gt; \tdiv { \twidth: 100px; \theight: 100px; \tbackground-color: rgb(15, 190, 131); \t} \t\u0026lt;/style\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;div style=\u0026#34;position:absolute;left:0;top:0;\u0026#34;\u0026gt;该拖曳只对内联样式有效\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; JavaScrip var div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0];  var firstTime = new Date(); var lastTime = new Date(); var key = false; // 元素按下时的时间 document.","title":"JavaScript 区分点击事件与长按事件"},{"content":"定时器 定时操作的方法全是 Window 对象的方法，这些方法中的 this 都指向 Window\nsetIntereval() 每隔多少毫秒再循环执行一次回调函数中的代码。\n需要注意，这个间隔时间一旦定义就无法被修改。\n非常不准确，可以用时间戳来证明。\n返回值是一个 id 数值，这个 id 作为当前定时器的唯一标识符。\n// 定时器 var time = 1000; setInterval(function () { \tconsole.log(\u0026#39;定时器\u0026#39;); }, time); // 修改 time，虽然 time 被修改了，但定时器中的 time 依旧也是 1000 time = 10; console.log(time); clearIntereval() 清除由 setInterval() 设置的定时操作。\n参数是一个数值。\nvar i = 0; var time = setInterval(function () { \tconsole.log(i++); \tif (i \u0026gt; 10) { \tclearInterval(time); \tconsole.log(\u0026#39;定时器已暂停\u0026#39;); \t} }, 100); setTimeout() 在指定毫秒数之后执行回调函数中的代码。回调函数中的代码只会执行因此。\nsetTimeout(function () { \tconsole.log(\u0026#39;定时器\u0026#39;); }, 1000); setTimeout() 和 setIntereval() 的另一种写法 这种写法不常用。\nsetInterval(\u0026#39;console.log(\u0026#34;setInterval 的另一种写法\u0026#34;)\u0026#39;, 1000);  setTimeout(\u0026#39;console.log(\u0026#34;setTimeout 的另一种写法\u0026#34;)\u0026#39;, 1000); clearTimeout() 取消由 setTimeout() 设置的定时操作。\n参数是一个数值。\nvar time = setTimeout(function () { \tconsole.log(\u0026#39;定时器\u0026#39;); }, 1000);  clearTimeout(time);  ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/window/%E5%AE%9A%E6%97%B6%E5%99%A8/","summary":"定时器 定时操作的方法全是 Window 对象的方法，这些方法中的 this 都指向 Window\nsetIntereval() 每隔多少毫秒再循环执行一次回调函数中的代码。\n需要注意，这个间隔时间一旦定义就无法被修改。\n非常不准确，可以用时间戳来证明。\n返回值是一个 id 数值，这个 id 作为当前定时器的唯一标识符。\n// 定时器 var time = 1000; setInterval(function () { \tconsole.log(\u0026#39;定时器\u0026#39;); }, time); // 修改 time，虽然 time 被修改了，但定时器中的 time 依旧也是 1000 time = 10; console.log(time); clearIntereval() 清除由 setInterval() 设置的定时操作。\n参数是一个数值。\nvar i = 0; var time = setInterval(function () { \tconsole.log(i++); \tif (i \u0026gt; 10) { \tclearInterval(time); \tconsole.log(\u0026#39;定时器已暂停\u0026#39;); \t} }, 100); setTimeout() 在指定毫秒数之后执行回调函数中的代码。回调函数中的代码只会执行因此。","title":"JavaScript 定时器"},{"content":"拖拽元素 HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;title\u0026gt;拖拽元素\u0026lt;/title\u0026gt; \t\u0026lt;style\u0026gt; \tdiv { \twidth: 100px; \theight: 100px; \tbackground-color: rgb(15, 190, 131); \t} \t\u0026lt;/style\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;div style=\u0026#34;position:absolute;left:0;top:0;\u0026#34;\u0026gt;该拖曳只对内联样式有效\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; JavaScrip function drag(elem) { \tvar disX, disY; \t// 鼠标 \telem.onmousedown = function (event) { \tdisX = event.pageX - parseInt(elem.style.left); \tdisY = event.pageY - parseInt(elem.style.top);  \tdocument.onmousemove = function (event) { \telem.style.left = event.pageX - disX + \u0026#39;px\u0026#39;; \telem.style.top = event.pageY - disY + \u0026#39;px\u0026#39;; \t}; \t}; }  var div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0];  drag(div); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E6%8B%96%E6%8B%BD%E5%85%83%E7%B4%A0/","summary":"拖拽元素 HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;title\u0026gt;拖拽元素\u0026lt;/title\u0026gt; \t\u0026lt;style\u0026gt; \tdiv { \twidth: 100px; \theight: 100px; \tbackground-color: rgb(15, 190, 131); \t} \t\u0026lt;/style\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;div style=\u0026#34;position:absolute;left:0;top:0;\u0026#34;\u0026gt;该拖曳只对内联样式有效\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; JavaScrip function drag(elem) { \tvar disX, disY; \t// 鼠标 \telem.","title":"JavaScript 拖拽元素"},{"content":"脚本化 CSS 用 JavaScrip 间接操作 CSS，它是通过内联样式表去间接控制 CSS。\n间接操作 CSS 时，只有ele.style.attr是读写操作，除此之外的任何操作都是只读操作。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E8%84%9A%E6%9C%AC%E5%8C%96-css/","summary":"脚本化 CSS 用 JavaScrip 间接操作 CSS，它是通过内联样式表去间接控制 CSS。\n间接操作 CSS 时，只有ele.style.attr是读写操作，除此之外的任何操作都是只读操作。","title":"JavaScript 脚本化 CSS"},{"content":"自动阅读 JavaScrip var start = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0];\rvar stop = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0];\rvar time;\r// 定义一个 key，用来判断自动阅读是否暂停\r// 如果不加判断，setInterval() 就会被重复执行多个（导致自动阅读的速度增加），而 clearInterval() 则只能暂停第一个 setInterval()（导致自动阅读无法被暂停）\rvar key = \u0026#39;自动阅读已暂停\u0026#39;;\rstart.onclick = function () {\r// 判断自动阅读的状态\rif (key == \u0026#39;自动阅读已暂停\u0026#39;) {\r// 用 setInterval() 反复执行 scrollBy() 实现页面自动向下滚动\rtime = setInterval(function () {\rwindow.scrollBy(0, 10);\r}, 100);\r// 自动阅读已开始\rkey = \u0026#39;自动阅读已开始\u0026#39;;\r}\r};\r// 自动阅读已暂停\rstop.onclick = function () {\rclearInterval(time);\rkey = \u0026#39;自动阅读已暂停\u0026#39;;\r}; ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E8%87%AA%E5%8A%A8%E9%98%85%E8%AF%BB/","summary":"自动阅读 JavaScrip var start = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0];\rvar stop = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0];\rvar time;\r// 定义一个 key，用来判断自动阅读是否暂停\r// 如果不加判断，setInterval() 就会被重复执行多个（导致自动阅读的速度增加），而 clearInterval() 则只能暂停第一个 setInterval()（导致自动阅读无法被暂停）\rvar key = \u0026#39;自动阅读已暂停\u0026#39;;\rstart.onclick = function () {\r// 判断自动阅读的状态\rif (key == \u0026#39;自动阅读已暂停\u0026#39;) {\r// 用 setInterval() 反复执行 scrollBy() 实现页面自动向下滚动\rtime = setInterval(function () {\rwindow.scrollBy(0, 10);\r}, 100);\r// 自动阅读已开始\rkey = \u0026#39;自动阅读已开始\u0026#39;;\r}\r};\r// 自动阅读已暂停\rstop.onclick = function () {\rclearInterval(time);\rkey = \u0026#39;自动阅读已暂停\u0026#39;;\r}; ","title":"JavaScript 自动阅读"},{"content":"返回父元素节点. JavaScrip function re(e, n) { \t// 如果 e 不为 null 并且 n 不为 0 \twhile (e \u0026amp;\u0026amp; n) { \t// 获取当前节点的父元素 \te = e.parentElement; \t// 每次循环一次，则想上找一层的父元素，直到 n 为 0 \tn--; \t} \treturn e; }  var i = document.getElementsByTagName(\u0026#39;i\u0026#39;)[0];  var result = re(i, 3); console.log(result); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E8%BF%94%E5%9B%9E%E7%88%B6%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9/","summary":"返回父元素节点. JavaScrip function re(e, n) { \t// 如果 e 不为 null 并且 n 不为 0 \twhile (e \u0026amp;\u0026amp; n) { \t// 获取当前节点的父元素 \te = e.parentElement; \t// 每次循环一次，则想上找一层的父元素，直到 n 为 0 \tn--; \t} \treturn e; }  var i = document.getElementsByTagName(\u0026#39;i\u0026#39;)[0];  var result = re(i, 3); console.log(result); ","title":"JavaScript 返回父元素节点."},{"content":"阻止默认事件 默认事件：表单提交、a 元素跳转、右键菜单等。\nreture false 阻止某个对象的默认事件，只支持阻止事件句柄 onclick，不支持addEventListener()。\ndocument.oncontextmenu = function () { \tconsole.log(\u0026#39;鼠标右击事件\u0026#39;); \treturn false; };  document.onclick = function () { \tconsole.log(\u0026#39;文档被点击\u0026#39;); \treturn false; }; preventDefault() 阻止某个对象的默认事件，支持事件句柄，以及addEventListener()。\ndocument.addEventListener( \t\u0026#39;contextmenu\u0026#39;, \tfunction (event) { \tconsole.log(\u0026#39;鼠标右击事件\u0026#39;); \tevent.preventDefault(); \t}, \tfalse ); document.onconte; xtmenu = function (event) { \tconsole.log(\u0026#39;鼠标右击事件\u0026#39;); \tevent.preventDefault(); }; returnValue() 兼容 IE，与preventDefault()一样，支持阻止事件句柄、以及addEventListener()。\ndocument.oncontextmenu = function (event) { \tconsole.log(\u0026#39;鼠标右击事件\u0026#39;); \tevent.returnValue = false; };  document.addEventListener( \t\u0026#39;contextmenu\u0026#39;, \tfunction (event) { \tconsole.log(\u0026#39;鼠标右击事件\u0026#39;); \tevent.returnValue = false; \t}, \tfalse ); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/events/%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6/","summary":"阻止默认事件 默认事件：表单提交、a 元素跳转、右键菜单等。\nreture false 阻止某个对象的默认事件，只支持阻止事件句柄 onclick，不支持addEventListener()。\ndocument.oncontextmenu = function () { \tconsole.log(\u0026#39;鼠标右击事件\u0026#39;); \treturn false; };  document.onclick = function () { \tconsole.log(\u0026#39;文档被点击\u0026#39;); \treturn false; }; preventDefault() 阻止某个对象的默认事件，支持事件句柄，以及addEventListener()。\ndocument.addEventListener( \t\u0026#39;contextmenu\u0026#39;, \tfunction (event) { \tconsole.log(\u0026#39;鼠标右击事件\u0026#39;); \tevent.preventDefault(); \t}, \tfalse ); document.onconte; xtmenu = function (event) { \tconsole.log(\u0026#39;鼠标右击事件\u0026#39;); \tevent.preventDefault(); }; returnValue() 兼容 IE，与preventDefault()一样，支持阻止事件句柄、以及addEventListener()。\ndocument.oncontextmenu = function (event) { \tconsole.log(\u0026#39;鼠标右击事件\u0026#39;); \tevent.","title":"JavaScript 阻止默认事件"},{"content":"JavaScript JavaScrip 是单线程的语言的原因是因为 JavaScrip 需要对 HTML 页面进行操作，无法一边操作 HTML 文档，一边又加载 HTML 文档。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/javascrip/","summary":"JavaScript JavaScrip 是单线程的语言的原因是因为 JavaScrip 需要对 HTML 页面进行操作，无法一边操作 HTML 文档，一边又加载 HTML 文档。","title":"JavaScrip"},{"content":"异步加载 JS 有时候，我们需要加载一些工具包，这些工具包与加载 HTML 文档无关，因此，我们就需要异步加载 JavaScrip，即实现 JavaScrip 的多线程。\naysnc=\u0026ldquo;aysnc\u0026rdquo; 异步加载，加载 JavaScrip 文件完就执行，aysnc 只能加载外部 JavaScrip，并不能将 JavaScrip 代码写到 script 元素中。\ndefer = \u0026ldquo;defer\u0026rdquo; 异步加载，即一边加载 JavaScrip 文件，一边加载 HTML 文档，但是，它需要等 DOM 文档解析完毕后，才会执行其中的 JavaScrip 代码，相当于window.onload，IE 独有。\n可以将 JavaScrip 代码写到 script 元素中。\n\u0026lt;script src=\u0026#34;vue.js\u0026#34; defer=\u0026#34;defer\u0026#34;\u0026gt; \tconsole.log(\u0026#39;IE 异步加载\u0026#39;) \u0026lt;/script\u0026gt; 按需异步加载 JS 当我们用创建一个 script 元素，那么需要将它插入到页面中，才会执行这个 JavaScrip 文件。如果不插入的话，仅仅只执行加载这个 JavaScrip 文件，这样，我们就实现了一个异步加载 JavaScrip 的过程。\n因为加载 JavaScrip 文件需要一个过程，而程序执行代码的时候，并不会等 main.js 文件下载完毕才继续执行后续代码，因此，这时候如果立即执行 main.js 中的某个方法，会报错。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;title\u0026gt;拖拽\u0026lt;/title\u0026gt; \t\u0026lt;style\u0026gt; \tdiv { \twidth: 100px; \theight: 100px; \tbackground-color: rgb(15, 190, 131); \t} \t\u0026lt;/style\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;div\u0026gt;123\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; \tvar script = document.createElement(\u0026#39;script\u0026#39;);  \tscript.type = \u0026#39;text/javascript\u0026#39;; \t// 加载 js 文件，需要个过程 \tscript.src = \u0026#39;js/main.js\u0026#39;; \t// 如果不将 script 插入到文档中，则不会执行 main.js 中的代码 \tdocument.head.appendChild(script); \t// 如果立即执行 fun()，会报错（fun 未定义） \t// fun() \t// 延迟 1 秒执行 fun()，不会报错，因为此时的 main.js 已经加载完毕 \tsetTimeout(function () { \tfun(); \t}, 1000); \t\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 这时候，就需要用到onload，它可以等 JavaScrip 文件资源加载完毕后再执行事件，最后，将script.src 放到script.onload的后面，等。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;title\u0026gt;拖拽\u0026lt;/title\u0026gt; \t\u0026lt;style\u0026gt; \tdiv { \twidth: 100px; \theight: 100px; \tbackground-color: rgb(15, 190, 131); \t} \t\u0026lt;/style\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;div\u0026gt;123\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; \tfunction loadScript(url, callback) { \tvar script = document.createElement(\u0026#39;script\u0026#39;); \tscript.type = \u0026#39;text/javascript\u0026#39;; \tscript.onload = function () { \tcallback(); \t}; \tscript.src = url; \tdocument.head.appendChild(script); \t} \t// 定义一个匿名函数，使得系统在解析代码的时候，并不会解析函数中的 fun() \tloadScript(\u0026#39;/js/main.js\u0026#39;, function () { \tfun(); \t}); \t\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD-js/","summary":"异步加载 JS 有时候，我们需要加载一些工具包，这些工具包与加载 HTML 文档无关，因此，我们就需要异步加载 JavaScrip，即实现 JavaScrip 的多线程。\naysnc=\u0026ldquo;aysnc\u0026rdquo; 异步加载，加载 JavaScrip 文件完就执行，aysnc 只能加载外部 JavaScrip，并不能将 JavaScrip 代码写到 script 元素中。\ndefer = \u0026ldquo;defer\u0026rdquo; 异步加载，即一边加载 JavaScrip 文件，一边加载 HTML 文档，但是，它需要等 DOM 文档解析完毕后，才会执行其中的 JavaScrip 代码，相当于window.onload，IE 独有。\n可以将 JavaScrip 代码写到 script 元素中。\n\u0026lt;script src=\u0026#34;vue.js\u0026#34; defer=\u0026#34;defer\u0026#34;\u0026gt; \tconsole.log(\u0026#39;IE 异步加载\u0026#39;) \u0026lt;/script\u0026gt; 按需异步加载 JS 当我们用创建一个 script 元素，那么需要将它插入到页面中，才会执行这个 JavaScrip 文件。如果不插入的话，仅仅只执行加载这个 JavaScrip 文件，这样，我们就实现了一个异步加载 JavaScrip 的过程。\n因为加载 JavaScrip 文件需要一个过程，而程序执行代码的时候，并不会等 main.js 文件下载完毕才继续执行后续代码，因此，这时候如果立即执行 main.js 中的某个方法，会报错。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.","title":"JavaScrip 异步加载 JS"},{"content":"异步和同步 同步 异步 异步是目的，多线程是手段。\n异步是和同步相对的。同步即阻塞，也即在做 A 的时候做不了 B，AB 可以同时做互不干扰就叫异步。为了实现异步，可以利用多线程。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5/","summary":"异步和同步 同步 异步 异步是目的，多线程是手段。\n异步是和同步相对的。同步即阻塞，也即在做 A 的时候做不了 B，AB 可以同时做互不干扰就叫异步。为了实现异步，可以利用多线程。","title":"JavaScrip 异步和同步"},{"content":"浏览器渲染页面 构建 DOM 树 解析 DOM 节点，将 HTML 元素以树形结构（二叉树）的方式添加到 DOM 树上，解析的时候只解析节点本身，不解析节点的属性或其包含的文本。\n此时还未加载 DOM 树，仅仅只是解析 DOM 节点。\n构建 CSS 树 构建 Render 树 DOMTree + CSSTree = RenderTree\nRenderTree 构建完成之后，浏览器渲染引擎才正式开始绘制页面\nreFlow 该过程需要重新构建整个文档，非常浪费性能。\n指的是网络浏览器为了重新渲染部分或全部的文档而重新计算文档中元素的位置和几何结构的过程。例如 dom 节点的删除与添加、dom 节点的宽高发生变化、节点的位置变变化等。\nrepaint 该过程只重新绘制部分元素。\n一个元素的外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。例如改变 vidibility、outline、背景色等属性。\n节点布局 页面渲染 ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2/","summary":"浏览器渲染页面 构建 DOM 树 解析 DOM 节点，将 HTML 元素以树形结构（二叉树）的方式添加到 DOM 树上，解析的时候只解析节点本身，不解析节点的属性或其包含的文本。\n此时还未加载 DOM 树，仅仅只是解析 DOM 节点。\n构建 CSS 树 构建 Render 树 DOMTree + CSSTree = RenderTree\nRenderTree 构建完成之后，浏览器渲染引擎才正式开始绘制页面\nreFlow 该过程需要重新构建整个文档，非常浪费性能。\n指的是网络浏览器为了重新渲染部分或全部的文档而重新计算文档中元素的位置和几何结构的过程。例如 dom 节点的删除与添加、dom 节点的宽高发生变化、节点的位置变变化等。\nrepaint 该过程只重新绘制部分元素。\n一个元素的外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。例如改变 vidibility、outline、背景色等属性。\n节点布局 页面渲染 ","title":"JavaScrip 浏览器渲染页面"},{"content":"生成器 用function*定义一个生成器函数，该函数通过next()来调用。\n生成器函数在执行时能暂停，后面又能从暂停处继续执行。\n生成器函数可以被当作一个迭代器来使用。\nfunction* fun() { \tconsole.log(\u0026#39;我是生成器函数\u0026#39;); }  let iterator = fun(); iterator.next(); yield yield关键字使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。\nfunction* fun() { \tyield console.log(\u0026#39;第一段代码\u0026#39;); \tyield console.log(\u0026#39;第二段代码\u0026#39;); \tyield console.log(\u0026#39;第三段代码\u0026#39;); \tyield console.log(\u0026#39;第四段代码\u0026#39;); }  let iterator = fun(); iterator.next(); iterator.next(); iterator.next(); iterator.next(); iterator.next(); 调用 next()时，如果传入了参数，那么这个参数会传给上一条执行的 yield 左边的变量：\nfunction* fun(val) { \tlet result = yield console.log(\u0026#39;第一段代码\u0026#39;); \tconsole.log(result); \t// 将 str 传给 result \tyield console.log(\u0026#39;第二段代码\u0026#39;); \tyield console.log(\u0026#39;第三段代码\u0026#39;); \tyield console.log(\u0026#39;第四段代码\u0026#39;); }  let iterator = fun(); console.log(iterator.next()); console.log(iterator.next(\u0026#39;str\u0026#39;)); 生成器异步编程：\nfunction getUser() { \tsetTimeout(() =\u0026gt; { \tlet data = \u0026#39;用户ID\u0026#39;; \titerator.next(data); \t}, 1000); } function getOrder() { \tsetTimeout(() =\u0026gt; { \tlet data = \u0026#39;用户订单\u0026#39;; \titerator.next(data); \t}, 1000); } function getInfo() { \tsetTimeout(() =\u0026gt; { \tlet data = \u0026#39;用户信息\u0026#39;; \titerator.next(data); \t}, 1000); }  function* fun() { \tlet user = yield getUser(); \tconsole.log(user); \tlet order = yield getOrder(); \tconsole.log(order); \tlet info = yield getInfo(); \tconsole.log(info); }  let iterator = fun();  iterator.next(); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E7%94%9F%E6%88%90%E5%99%A8/","summary":"生成器 用function*定义一个生成器函数，该函数通过next()来调用。\n生成器函数在执行时能暂停，后面又能从暂停处继续执行。\n生成器函数可以被当作一个迭代器来使用。\nfunction* fun() { \tconsole.log(\u0026#39;我是生成器函数\u0026#39;); }  let iterator = fun(); iterator.next(); yield yield关键字使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。\nfunction* fun() { \tyield console.log(\u0026#39;第一段代码\u0026#39;); \tyield console.log(\u0026#39;第二段代码\u0026#39;); \tyield console.log(\u0026#39;第三段代码\u0026#39;); \tyield console.log(\u0026#39;第四段代码\u0026#39;); }  let iterator = fun(); iterator.next(); iterator.next(); iterator.next(); iterator.next(); iterator.next(); 调用 next()时，如果传入了参数，那么这个参数会传给上一条执行的 yield 左边的变量：\nfunction* fun(val) { \tlet result = yield console.log(\u0026#39;第一段代码\u0026#39;); \tconsole.log(result); \t// 将 str 传给 result \tyield console.log(\u0026#39;第二段代码\u0026#39;); \tyield console.","title":"JavaScrip 生成器"},{"content":"表达式 表达式是一组代码的集合，它会返回一个值。\nJavaScript 有以下表达式类型：\n 算数：得出一个数字，例如 3.14159. 字符串：得出一个字符串, 例如 \u0026ldquo;Fred\u0026rdquo; 或 \u0026ldquo;234\u0026rdquo;. 逻辑值：得出 true 或者 false。 基本表达式：javascript 中基本的关键字和一般表达式。 左值表达式：分配给左值。  ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"表达式 表达式是一组代码的集合，它会返回一个值。\nJavaScript 有以下表达式类型：\n 算数：得出一个数字，例如 3.14159. 字符串：得出一个字符串, 例如 \u0026ldquo;Fred\u0026rdquo; 或 \u0026ldquo;234\u0026rdquo;. 逻辑值：得出 true 或者 false。 基本表达式：javascript 中基本的关键字和一般表达式。 左值表达式：分配给左值。  ","title":"JavaScrip 表达式"},{"content":"迭代器 它是一个对象。\nfor 用于创建一个循环，由三个表达式和一个用于在循环中执行的代码块组成。\nwhile 当指定表达式为 true，则循环执行代码体，直到表达式为 false 时结束循环。\n在一个循环语句中，应当有使表达式为 false 的条件，否则会造成死循环。\ndo while 不管指定条件是否为 true，其代码块都会被执行一次，直到开始第二次循环时，才开始判断指定条件，直到指定条件为 false 时结束循环。\nfor in 用于以任意顺序遍历一个对象（除 Symbol 以外）的属性。\n因为 for...in 是为遍历对象的属性而构建的，所以并不建议与数组一起使用。\n通常与 Object.hasOwnPropert() 一起使用。\nvar obj = { \tname: \u0026#39;zhu\u0026#39;, \tage: \u0026#39;18\u0026#39;, \tgander: \u0026#39;man\u0026#39;, \theight: 174, \t__proto__: { \tlastName: \u0026#39;不属于 obj 自身的属性\u0026#39;, \t}, }; Object.prototype.zxy = \u0026#39;我是 obj 原型上的属性\u0026#39;; for (var key in obj) { \t// 判断 obj 是否含有自身所没有的属性。 \tif (!obj.hasOwnProperty(key)) { \t// 返回 obj 自身所没有的属性：zxy。 \tconsole.log(key + \u0026#39;：\u0026#39; + obj[key]); \t} } for (var key in obj) { \tif (obj.hasOwnProperty(key)) { \t// 判断对象 obj 是否含有自身有的属性值。 \tconsole.log(key + \u0026#39;：\u0026#39; + obj[key]); \t// 返回对象 obj 自身拥有的属性，即不返回其原型上的属性。 \t} } console.log(key + \u0026#39;：\u0026#39; + obj[key]); // 返回对象 obj 的属性名与属性值（obj[key] 为对象 obj 的属性值），但因为在这里使用了 obj.key， // 系统会将 obj[key] 隐式转换为 obj[\u0026#39;key\u0026#39;]，使得 key 作为一个属性值，而不是作为一个变量。 for\u0026hellip;of 用于自定义遍历可迭代对象的属性。\nlet arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;];  for (const element of arr) { \tconsole.log(element); } 原理  创建一个指针对象，指向当前数据结构的起始位置。 第一次调用对象的nekt() ，指针自动指向数据结构的第一个成员。 接下来不断调用next()，指针一直往后移动，直到指向最后一个成员，移出对象则value为undefined。 每调用next()返回一个包含value 和 done属性的对象。  自定义迭代器 let obj = { \tname: \u0026#39;tender\u0026#39;, \tarr: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;], \t[Symbol.iterator]() { \tlet index = 0; \tlet that = this; \treturn { \tnext: function () { \tif (index \u0026lt; that.arr.length) { \tlet result = { \tdone: false, \tvalue: that.arr[index], \t}; \tindex++; \treturn result; \t} else { \treturn { done: true, value: \u0026#39;没有值了\u0026#39; }; \t} \t}, \t}; \t}, };  for (let v of obj) { \tconsole.log(v); }  // 手动调用 next() 进行遍历 let iterator = obj[Symbol.iterator](); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next()); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E8%BF%AD%E4%BB%A3%E5%99%A8/","summary":"迭代器 它是一个对象。\nfor 用于创建一个循环，由三个表达式和一个用于在循环中执行的代码块组成。\nwhile 当指定表达式为 true，则循环执行代码体，直到表达式为 false 时结束循环。\n在一个循环语句中，应当有使表达式为 false 的条件，否则会造成死循环。\ndo while 不管指定条件是否为 true，其代码块都会被执行一次，直到开始第二次循环时，才开始判断指定条件，直到指定条件为 false 时结束循环。\nfor in 用于以任意顺序遍历一个对象（除 Symbol 以外）的属性。\n因为 for...in 是为遍历对象的属性而构建的，所以并不建议与数组一起使用。\n通常与 Object.hasOwnPropert() 一起使用。\nvar obj = { \tname: \u0026#39;zhu\u0026#39;, \tage: \u0026#39;18\u0026#39;, \tgander: \u0026#39;man\u0026#39;, \theight: 174, \t__proto__: { \tlastName: \u0026#39;不属于 obj 自身的属性\u0026#39;, \t}, }; Object.prototype.zxy = \u0026#39;我是 obj 原型上的属性\u0026#39;; for (var key in obj) { \t// 判断 obj 是否含有自身所没有的属性。 \tif (!","title":"JavaScrip 迭代器"},{"content":"Array 方法 splice(start,deleteCount,item\u0026hellip;) 从数组的索引 start 开始删除 deleteCount 个元素，并在索引为 start 的地方添加若干个 item 元素，并返回一个新数组。\n此方法会改变原数组。\nshift() 删除数组的第一个元素，并返回该元素的值。\n此方法会改变原数组。\nunshift() 将一个或多个元素添加到数组的开头，并返回该数组的新长度，该方法会修改原有数组。\nfilter() 用于对数组进行过滤，它返回一个过滤后的数组，如果没有任何数组元素通过测试，则返回空数组。\nfilter()不会对空数组进行检测，不会改变原始数组。\nsort() 用原地算法对数组的元素进行排序，并返回数组。\n此方法会改变原数组。\n它的参数为一个回调函数compareFunction，该回调函数有a、b两个参数，它们分别代表数组中当前进行比较的两个元素：\na 表示在后的那个元素。\nb 表示在前的那个元素\n数字升序：\nvar arr = [5, 3, 9, 2, 5, 1, 7]; var result = arr.sort(function (a, b) { \treturn a - b; });  console.log(arr); 数字降序：\nvar arr = [5, 3, 9, 2, 5, 1, 7]; var result = arr.sort(function (a, b) { \treturn b - a; });  console.log(arr); pop() 从数组中删除最后一个元素，并返回该元素的值。\n此方法会改变原数组。\npush() 将一个或多个元素添加到数组的末尾，并返回该数组的新长度。\n此方法会改变原数组。\nreverse() 将数组中元素的位置反转，并返回该数组。\n此方法会改变原数组。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/array/array-%E6%96%B9%E6%B3%95/","summary":"Array 方法 splice(start,deleteCount,item\u0026hellip;) 从数组的索引 start 开始删除 deleteCount 个元素，并在索引为 start 的地方添加若干个 item 元素，并返回一个新数组。\n此方法会改变原数组。\nshift() 删除数组的第一个元素，并返回该元素的值。\n此方法会改变原数组。\nunshift() 将一个或多个元素添加到数组的开头，并返回该数组的新长度，该方法会修改原有数组。\nfilter() 用于对数组进行过滤，它返回一个过滤后的数组，如果没有任何数组元素通过测试，则返回空数组。\nfilter()不会对空数组进行检测，不会改变原始数组。\nsort() 用原地算法对数组的元素进行排序，并返回数组。\n此方法会改变原数组。\n它的参数为一个回调函数compareFunction，该回调函数有a、b两个参数，它们分别代表数组中当前进行比较的两个元素：\na 表示在后的那个元素。\nb 表示在前的那个元素\n数字升序：\nvar arr = [5, 3, 9, 2, 5, 1, 7]; var result = arr.sort(function (a, b) { \treturn a - b; });  console.log(arr); 数字降序：\nvar arr = [5, 3, 9, 2, 5, 1, 7]; var result = arr.sort(function (a, b) { \treturn b - a; });  console.","title":"JavaScript Array 方法"},{"content":"Element 属性 innerHTML 设置或返回指定元素的内容。返回的内容包含这个元素所包含的子元素以及文本信息。\n它会解析 HTML 结构。\n设置元素内容的时候，如果元素内容中有子元素，则这些子元素也会被覆盖。\n可以在元素内容的后面追加新内容。\nvar body = document.getElementsByTagName(\u0026#39;body\u0026#39;)[0]; var div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0]; // 设置内容 div.innerHTML = \u0026#39;123\u0026#39;; // 追加内容 div.innerHTML += \u0026#39;456\u0026#39;; // 写入 html 元素 div.innerHTML += \u0026#39;\u0026lt;span\u0026gt;写入的元素\u0026lt;/span\u0026gt;\u0026#39;; childElementCount 返回指定元素节点的子元素节点的个数，不包含子元素节点的子元素节点。\nfirstElementChild 返回指定元素节点的第一个元素节点。\nlastElementChild 返回指定元素节点的最后一个元素节点。\nchildren 返回当前元素节点的所有子元素节点，不包含子元素节点的子元素节点。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element-%E5%B1%9E%E6%80%A7/","summary":"Element 属性 innerHTML 设置或返回指定元素的内容。返回的内容包含这个元素所包含的子元素以及文本信息。\n它会解析 HTML 结构。\n设置元素内容的时候，如果元素内容中有子元素，则这些子元素也会被覆盖。\n可以在元素内容的后面追加新内容。\nvar body = document.getElementsByTagName(\u0026#39;body\u0026#39;)[0]; var div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0]; // 设置内容 div.innerHTML = \u0026#39;123\u0026#39;; // 追加内容 div.innerHTML += \u0026#39;456\u0026#39;; // 写入 html 元素 div.innerHTML += \u0026#39;\u0026lt;span\u0026gt;写入的元素\u0026lt;/span\u0026gt;\u0026#39;; childElementCount 返回指定元素节点的子元素节点的个数，不包含子元素节点的子元素节点。\nfirstElementChild 返回指定元素节点的第一个元素节点。\nlastElementChild 返回指定元素节点的最后一个元素节点。\nchildren 返回当前元素节点的所有子元素节点，不包含子元素节点的子元素节点。","title":"JavaScript Element 属性"},{"content":"Element 方法 setAttribute() 设置指定元素的属性和属性的值。设置的属性名可以是自定义的属性。\n如果这个指定的属性已存在，则仅更改值。\ngetAttribute() 返回指定属性名的属性值。\ngetBoundingClientRect() 返回元素的尺寸，以及相对于视口的位置。\n如果是标准盒子模型，元素的宽高等于width/height + padding + border-width 的总和。如果box-sizing: border-box，元素的宽高等于 width/height。\n返回的结果不是事实的，是静态的。\nvar div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0]; var ele = div.getBoundingClientRect(); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element-%E6%96%B9%E6%B3%95/","summary":"Element 方法 setAttribute() 设置指定元素的属性和属性的值。设置的属性名可以是自定义的属性。\n如果这个指定的属性已存在，则仅更改值。\ngetAttribute() 返回指定属性名的属性值。\ngetBoundingClientRect() 返回元素的尺寸，以及相对于视口的位置。\n如果是标准盒子模型，元素的宽高等于width/height + padding + border-width 的总和。如果box-sizing: border-box，元素的宽高等于 width/height。\n返回的结果不是事实的，是静态的。\nvar div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0]; var ele = div.getBoundingClientRect(); ","title":"JavaScript Element 方法"},{"content":"Node 属性 用来遍历节点树。\nparentElement 返回当前元素节点的父元素节点。\nparentNode 返回指定节点的父节点，一个节点的父节点只有一个。\nchildNodes 返回指定节点所包含的所有子节点。\nfirstChild 返回指定节点所包含的最后一个节点\nlastChild 返回指定节点所包含的第一个节点\nnextSibling 返回在指定节点后面的兄弟节点，如果指定节点为最后一个节点，则返回 null。\npreviousSibling 返回在指定节点前面的兄弟节点，如果指定节点为第一个节点，则返回 null。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/dom/node/node-%E5%B1%9E%E6%80%A7/","summary":"Node 属性 用来遍历节点树。\nparentElement 返回当前元素节点的父元素节点。\nparentNode 返回指定节点的父节点，一个节点的父节点只有一个。\nchildNodes 返回指定节点所包含的所有子节点。\nfirstChild 返回指定节点所包含的最后一个节点\nlastChild 返回指定节点所包含的第一个节点\nnextSibling 返回在指定节点后面的兄弟节点，如果指定节点为最后一个节点，则返回 null。\npreviousSibling 返回在指定节点前面的兄弟节点，如果指定节点为第一个节点，则返回 null。","title":"JavaScript Node 属性"},{"content":"操作节点 增加节点 createElement() 创建一个元素节点，但还没有插入到文档中，需要用 appendChild() 将元素插入到文档中。\nvar div = document.createElement(\u0026#39;div\u0026#39;); createTextNod() 创建一个文本节点，但还没有插入到文档中，需要用 appendChild() 将元素插入到文档中。\nvar text = document.createTextNode(\u0026#39;我是文本节点\u0026#39;); createComment() 创建一个文本节点，但还没有插入到文档中，需要用 appendChild() 将元素插入到文档中。\nvar comment = document.createComment(\u0026#39;我是一个注释\u0026#39;); createDocumentFragment(\u0026rsquo;') 创建了一虚拟的节点对象，也可以说是创建一个文档碎片\nvar fragment = document.createDocumentFragment(\u0026#39;\u0026#39;); 插入节点 ele.appendChild(subEle) 在 ele 节点的最后一个子节点之后添加 subEle 节点。\n如果 subEle 节点已经在文档中存在，那么会将 subEle 节点移动到 ele 节点中。\nvar body = document.getElementsByTagName(\u0026#39;body\u0026#39;)[0]; var div = document.createElement(\u0026#39;div\u0026#39;); var text = document.createTextNode(\u0026#39;插入的文本\u0026#39;); body.appendChild(div); div.appendChild(text); ele.insertBefore(subEleOne,subEleTwo) 在 ele 节点的子节点 subEleTwo 之前插入一个 subEleOne 节点。\nvar body = document.getElementsByTagName(\u0026#39;body\u0026#39;)[0]; var span = document.createElement(\u0026#39;span\u0026#39;); // 将 span 插入到 body 的末尾 body.appendChild(span); var div = document.createElement(\u0026#39;div\u0026#39;); // 在 body 的子元素 span 之前插入 div 元素 body.insertBefore(div, span); 删除节点 ele.removeChild(subEle) 将 ele 节点的子节点 subEle 删除并返回，后续如果需要，还可以使用整个子节点。\n如果删除成功，可返回被删除的节点，如果删除失败，则返回 NULL。\nvar body = document.getElementsByTagName(\u0026#39;body\u0026#39;)[0]; var div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0]; var re = body.removeChild(div); console.log(\u0026#39;被删除的节点：\u0026#39; + re); ele.remove() 将 ele 节点彻底删除，并不会返回。\nvar div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0]; var re = div.remove(); // undefined console.log(\u0026#39;被删除的节点：\u0026#39; + re); 替换节点 ele.replaceChild(subEleOne, subEleTwo) 将 ele 的子节点 subEleOne 替换为新节点 subEleTwo。\n被替换的节点会被返回，并没有被彻底删除。\nvar body = document.getElementsByTagName(\u0026#39;body\u0026#39;)[0]; var div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0]; var span = document.createElement(\u0026#39;span\u0026#39;); var rep = body.replaceChild(span, div); // 返回被替换的节点 console.log(rep); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E6%93%8D%E4%BD%9C%E8%8A%82%E7%82%B9/","summary":"操作节点 增加节点 createElement() 创建一个元素节点，但还没有插入到文档中，需要用 appendChild() 将元素插入到文档中。\nvar div = document.createElement(\u0026#39;div\u0026#39;); createTextNod() 创建一个文本节点，但还没有插入到文档中，需要用 appendChild() 将元素插入到文档中。\nvar text = document.createTextNode(\u0026#39;我是文本节点\u0026#39;); createComment() 创建一个文本节点，但还没有插入到文档中，需要用 appendChild() 将元素插入到文档中。\nvar comment = document.createComment(\u0026#39;我是一个注释\u0026#39;); createDocumentFragment(\u0026rsquo;') 创建了一虚拟的节点对象，也可以说是创建一个文档碎片\nvar fragment = document.createDocumentFragment(\u0026#39;\u0026#39;); 插入节点 ele.appendChild(subEle) 在 ele 节点的最后一个子节点之后添加 subEle 节点。\n如果 subEle 节点已经在文档中存在，那么会将 subEle 节点移动到 ele 节点中。\nvar body = document.getElementsByTagName(\u0026#39;body\u0026#39;)[0]; var div = document.createElement(\u0026#39;div\u0026#39;); var text = document.createTextNode(\u0026#39;插入的文本\u0026#39;); body.appendChild(div); div.appendChild(text); ele.insertBefore(subEleOne,subEleTwo) 在 ele 节点的子节点 subEleTwo 之前插入一个 subEleOne 节点。\nvar body = document.","title":"JavaScript 操作节点"},{"content":"类数组 类数组是可以当作数组来使用的对象\n类数组虽然在写法上跟数组一样，但它实际上是 object，且数组能调用的方法它都不能调用的数组。\n比如 arguments，函数的第一个参数是 argument[0]，写法上跟数组一样，但是不是数组，它的原型是 Object，它也不能调用数组的一些方法。\n特点 具有对象和数组的特性，既可以当作对象来用，也可以当作数组来用（并不是所有的数组方法都能使用，可以自己手动添加）\n数据位 存在于数组索引位上的数据。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/array/%E7%B1%BB%E6%95%B0%E7%BB%84/","summary":"类数组 类数组是可以当作数组来使用的对象\n类数组虽然在写法上跟数组一样，但它实际上是 object，且数组能调用的方法它都不能调用的数组。\n比如 arguments，函数的第一个参数是 argument[0]，写法上跟数组一样，但是不是数组，它的原型是 Object，它也不能调用数组的一些方法。\n特点 具有对象和数组的特性，既可以当作对象来用，也可以当作数组来用（并不是所有的数组方法都能使用，可以自己手动添加）\n数据位 存在于数组索引位上的数据。","title":"JavaScript 类数组"},{"content":"Ajax IE 缓存问题 IE 浏览器会会对 Ajax 请求的的结果进行缓存，这会导致下次请求服务器的时候，使用的是本地的缓存，而不是服务器响应的最新数据，这会对一些时效性比较强的一些场景产生影响。\nJavaScript 在 open 方法种中的 url 路径中加上一个参数...?t=' + Date.now()即可。该值是获取当前时间戳。\nconst div = document.getElementById(\u0026#39;result\u0026#39;); const btn = document.getElementById(\u0026#39;btn\u0026#39;); btn.onclick = function () { \tconst xhr = new XMLHttpRequest(); \t// 获取时间戳，解决IE 浏览器缓存的问题 \txhr.open(\u0026#39;POST\u0026#39;, \u0026#39;http://localhost:8000/ie?t=\u0026#39; + Date.now()); \txhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;); \txhr.setRequestHeader(\u0026#39;name\u0026#39;, \u0026#39;Rainy\u0026#39;); \txhr.send(\u0026#39;a=100\u0026amp;b=200\u0026#39;); \txhr.onreadystatechange = function () { \tif (xhr.readyState == 4) { \tif (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { \tdiv.innerHTML = xhr.response; \t} else { \t} \t} \t}; }; ","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/ie-%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/","summary":"Ajax IE 缓存问题 IE 浏览器会会对 Ajax 请求的的结果进行缓存，这会导致下次请求服务器的时候，使用的是本地的缓存，而不是服务器响应的最新数据，这会对一些时效性比较强的一些场景产生影响。\nJavaScript 在 open 方法种中的 url 路径中加上一个参数...?t=' + Date.now()即可。该值是获取当前时间戳。\nconst div = document.getElementById(\u0026#39;result\u0026#39;); const btn = document.getElementById(\u0026#39;btn\u0026#39;); btn.onclick = function () { \tconst xhr = new XMLHttpRequest(); \t// 获取时间戳，解决IE 浏览器缓存的问题 \txhr.open(\u0026#39;POST\u0026#39;, \u0026#39;http://localhost:8000/ie?t=\u0026#39; + Date.now()); \txhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;); \txhr.setRequestHeader(\u0026#39;name\u0026#39;, \u0026#39;Rainy\u0026#39;); \txhr.send(\u0026#39;a=100\u0026amp;b=200\u0026#39;); \txhr.onreadystatechange = function () { \tif (xhr.readyState == 4) { \tif (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { \tdiv.","title":"Ajax IE 缓存问题"},{"content":"Jsonp 实现原理 script标签本身具有跨域的特性，JSONP 借助这个特定来解决的跨域问题。\n服务端 const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;);  const app = express();  const port = 8000;  app.all(\u0026#39;/jsonp\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \t// 定义数据 \tconst data = { \tname: \u0026#39;Rainy\u0026#39;, \t}; \t// 将数据转为字符串 \tlet str = JSON.stringify(data); \t// 响应结果，一个函数调用，函数已经在前端提前声明 \tresponse.end(`handle(${str})`); });  app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \t\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./css/main.css\u0026#34; /\u0026gt; \t\u0026lt;title\u0026gt;jsonp 原理演示\u0026lt;/title\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script\u0026gt; \t// 声明函数，对数据进行处理 \tfunction handle(data) { \tconst result = document.getElementById(\u0026#39;result\u0026#39;); \tresult.innerHTML = data.name; \t} \t\u0026lt;/script\u0026gt; \t\u0026lt;!-- 服务器路径引入 --\u0026gt; \t\u0026lt;!-- \u0026lt;script src=\u0026#34;http://127.0.0.1:5500/js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; --\u0026gt;  \t\u0026lt;!-- 用 script 标签发送请求，将响应的结果解析为 js 代码，如果响应的结果不是 js 代码 ，则会报错：Uncaught SyntaxError: Unexpected identifier，这是因为js 引擎无法解析响应的内容，比如一个字符串--\u0026gt; \t\u0026lt;script src=\u0026#34;http://localhost:8000/jsonp\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; CSS #result { \twidth: 200px; \theight: 100px; \tborder: 1px solid #999; } ","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/jsonp-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","summary":"Jsonp 实现原理 script标签本身具有跨域的特性，JSONP 借助这个特定来解决的跨域问题。\n服务端 const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;);  const app = express();  const port = 8000;  app.all(\u0026#39;/jsonp\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \t// 定义数据 \tconst data = { \tname: \u0026#39;Rainy\u0026#39;, \t}; \t// 将数据转为字符串 \tlet str = JSON.stringify(data); \t// 响应结果，一个函数调用，函数已经在前端提前声明 \tresponse.end(`handle(${str})`); });  app.listen(port, () =\u0026gt; { \tconsole.","title":"Ajax Jsonp 实现原理"},{"content":"POST 请求 使用 POST 的方式向服务端发送一个请求。\n服务端 const express = require(\u0026#39;express\u0026#39;); const app = express(); const port = 8000; // 创建路由规则，允许所有方式的请求 app.all(\u0026#39;/server\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.send(\u0026#39;Hello World! POST\u0026#39;); });  app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./css/main.css\u0026#34; /\u0026gt; \t\u0026lt;title\u0026gt;POST 请求\u0026lt;/title\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点击按钮，发送q\u0026lt;/button\u0026gt; \t\u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; CSS #result { \twidth: 200px; \theight: 100px; \tborder: 1px solid #999; } JavaScript const btn = document.getElementById(\u0026#39;btn\u0026#39;); const div = document.getElementById(\u0026#39;result\u0026#39;); btn.onclick = function () {  const xhr = new XMLHttpRequest();  // 请求方式为 post  xhr.open(\u0026#39;POST\u0026#39;, \u0026#39;http://localhost:8000/server)  // 设置 请求的参数  xhr.send(‘a=100\u0026amp;b=200’);  xhr.onreadystatechange = function () {  if (xhr.readyState == 4) {  if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) {  console.log(xhr.response);  div.innerHTML = xhr.response  } else {   }  }  } } ","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/post-%E8%AF%B7%E6%B1%82/","summary":"POST 请求 使用 POST 的方式向服务端发送一个请求。\n服务端 const express = require(\u0026#39;express\u0026#39;); const app = express(); const port = 8000; // 创建路由规则，允许所有方式的请求 app.all(\u0026#39;/server\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.send(\u0026#39;Hello World! POST\u0026#39;); });  app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./css/main.css\u0026#34; /\u0026gt; \t\u0026lt;title\u0026gt;POST 请求\u0026lt;/title\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点击按钮，发送q\u0026lt;/button\u0026gt; \t\u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;.","title":"Ajax POST 请求"},{"content":"手动取消请求 服务端 const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;);  const app = express();  const port = 8000;  app.all(\u0026#39;/delay\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \t// 设置延时响应 \tsetTimeout(() =\u0026gt; { \tresponse.send(\u0026#39;Hello IE\u0026#39;); \t}, 1000); }); app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./css/main.css\u0026#34; /\u0026gt; \t\u0026lt;title\u0026gt;手动取消请求\u0026lt;/title\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点击按钮，发送请求\u0026lt;/button\u0026gt; \t\u0026lt;button id=\u0026#34;btne\u0026#34;\u0026gt;点击按钮，取消请求\u0026lt;/button\u0026gt;  \t\u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; CSS #result { \twidth: 200px; \theight: 100px; \tborder: 1px solid #999; } JavaScrip const div = document.getElementById(\u0026#39;result\u0026#39;); const btn = document.getElementById(\u0026#39;btn\u0026#39;); const btne = document.getElementById(\u0026#39;btne\u0026#39;); let xhr = null; btn.onclick = function () { \txhr = new XMLHttpRequest(); \txhr.open(\u0026#39;POST\u0026#39;, \u0026#39;http://localhost:8000/delay\u0026#39;); \txhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;); \txhr.setRequestHeader(\u0026#39;name\u0026#39;, \u0026#39;Rainy\u0026#39;); \txhr.send(\u0026#39;a=100\u0026amp;b=200\u0026#39;); \txhr.onreadystatechange = function () { \tif (xhr.readyState == 4) { \tif (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { \tdiv.innerHTML = xhr.response; \t} else { \t} \t} \t}; }; //　单手动取消请求 btne.onclick = function () { \txhr.abort(); }; ","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/%E6%89%8B%E5%8A%A8%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82/","summary":"手动取消请求 服务端 const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;);  const app = express();  const port = 8000;  app.all(\u0026#39;/delay\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \t// 设置延时响应 \tsetTimeout(() =\u0026gt; { \tresponse.send(\u0026#39;Hello IE\u0026#39;); \t}, 1000); }); app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.","title":"Ajax 手动取消请求"},{"content":"请求超时设置 服务端 const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;);  const app = express();  const port = 8000;  // 针对 ie 缓存的设置 app.all(\u0026#39;/delay\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \t// 设置延时响应 \tsetTimeout(() =\u0026gt; { \tresponse.send(\u0026#39;Hello IE\u0026#39;); \t}, 3000); });  app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./css/main.css\u0026#34; /\u0026gt; \t\u0026lt;title\u0026gt;请求超时设置\u0026lt;/title\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点击按钮，发送请求\u0026lt;/button\u0026gt; \t\u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; CSS #result { \twidth: 200px; \theight: 100px; \tborder: 1px solid #999; } JavaScrip const div = document.getElementById(\u0026#39;result\u0026#39;); const btn = document.getElementById(\u0026#39;btn\u0026#39;); btn.onclick = function () { \tconst xhr = new XMLHttpRequest(); \t// 超时 2s 后没有响应则取消请求 \txhr.timeout = 2000; \t// 超时回调 \txhr.ontimeout = function () { \tconsole.log(\u0026#39;请求超时，请稍候重试\u0026#39;); \t}; \t// 网络异常回调 \txhr.onerror = function () { \talert(\u0026#39;网络异常\u0026#39;); \t}; \txhr.open(\u0026#39;POST\u0026#39;, \u0026#39;http://localhost:8000/delay\u0026#39;); \txhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;); \txhr.setRequestHeader(\u0026#39;name\u0026#39;, \u0026#39;Rainy\u0026#39;); \txhr.send(\u0026#39;a=100\u0026amp;b=200\u0026#39;); \txhr.onreadystatechange = function () { \tif (xhr.readyState == 4) { \tif (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { \tdiv.innerHTML = xhr.response; \t} else { \t} \t} \t}; }; ","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/%E8%AF%B7%E6%B1%82%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/","summary":"请求超时设置 服务端 const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;);  const app = express();  const port = 8000;  // 针对 ie 缓存的设置 app.all(\u0026#39;/delay\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \t// 设置延时响应 \tsetTimeout(() =\u0026gt; { \tresponse.send(\u0026#39;Hello IE\u0026#39;); \t}, 3000); });  app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.","title":"Ajax 请求超时设置"},{"content":"跨域 同源策略 同源策略是一种出于浏览器安全方面的考虑而出台的一种策略，它可以保证用户信息的安全，防止恶意的网站窃取。同源策略只允许与本域下的接口交互，不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。\n同源：同协议、同域名、同端口，必须完全相同，违背同源策略，就是跨域。\n同源策略的限制范围  Cookie，localStorage，IndexDB 无法读取 DOM 无法获得 AJAX 请求不能发送  如何解决跨域问题 JSONP JSONP 是浏览器与客户端跨域通信常用的一种方法。\nscript标签本身具有跨域的特性，JSONP 就是借助这个特定来解决跨域的问题的。\nCORS CORS 的全称是跨源资源共享，是一种 ajax 跨域请求资源的方式.\n// * 表示所有网站都可以跨域请求当前服务器 response.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); // 也可以只有某个网站才能对服务器发送跨域请求 response.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;yxzi.xyz\u0026#39;); ","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/%E8%B7%A8%E5%9F%9F/","summary":"跨域 同源策略 同源策略是一种出于浏览器安全方面的考虑而出台的一种策略，它可以保证用户信息的安全，防止恶意的网站窃取。同源策略只允许与本域下的接口交互，不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。\n同源：同协议、同域名、同端口，必须完全相同，违背同源策略，就是跨域。\n同源策略的限制范围  Cookie，localStorage，IndexDB 无法读取 DOM 无法获得 AJAX 请求不能发送  如何解决跨域问题 JSONP JSONP 是浏览器与客户端跨域通信常用的一种方法。\nscript标签本身具有跨域的特性，JSONP 就是借助这个特定来解决跨域的问题的。\nCORS CORS 的全称是跨源资源共享，是一种 ajax 跨域请求资源的方式.\n// * 表示所有网站都可以跨域请求当前服务器 response.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); // 也可以只有某个网站才能对服务器发送跨域请求 response.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;yxzi.xyz\u0026#39;); ","title":"Ajax 跨域"},{"content":"重复发送请求的问题 当用户重复发送同一个请求的时候，我们为了服务器的效率考虑，需要将之前发送的请求取消掉，只发送一个最新的请求，这样，服务器所受到的压力就要小很多。\n服务端 const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;);  const app = express();  const port = 8000;  app.all(\u0026#39;/delay\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \t// 设置延时响应 \tsetTimeout(() =\u0026gt; { \tresponse.send(\u0026#39;Hello IE\u0026#39;); \t}, 1000); });  app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./css/main.css\u0026#34; /\u0026gt; \t\u0026lt;title\u0026gt;重复发送请求的问题\u0026lt;/title\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点击按钮，发送请求\u0026lt;/button\u0026gt; \t\u0026lt;button id=\u0026#34;btne\u0026#34;\u0026gt;点击按钮，取消请求\u0026lt;/button\u0026gt;  \t\u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; CSS #result{  width: 200px;  height: 100px;  border: 1px solid #999; } JavaScrip const div = document.getElementById(\u0026#39;result\u0026#39;); const btn = document.getElementById(\u0026#39;btn\u0026#39;); const btne = document.getElementById(\u0026#39;btne\u0026#39;); let xhr = null; // 定义标识，还未开始发送请求或上一个请求已经完成 let isSending = false; btn.onclick = function () { \t// 如果已经有请求正在发送 \tif (isSending == true) { \t// 取消之前的请求 \txhr.abort(); \t}  \txhr = new XMLHttpRequest(); \t// 修改标识，表示正在发送请求 \tisSending = true; \txhr.open(\u0026#39;POST\u0026#39;, \u0026#39;http://localhost:8000/delay\u0026#39;); \txhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;); \txhr.setRequestHeader(\u0026#39;name\u0026#39;, \u0026#39;Rainy\u0026#39;); \txhr.send(\u0026#39;a=100\u0026amp;b=200\u0026#39;); \txhr.onreadystatechange = function () { \t// 当请求完成（readyState == 4）的时候， \tif (xhr.readyState == 4) { \t// 则当前的请求完成 \tisSending = false; \t} \t}; }; btne.onclick = function () { \txhr.abort(); }; ","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E7%9A%84%E9%97%AE%E9%A2%98/","summary":"重复发送请求的问题 当用户重复发送同一个请求的时候，我们为了服务器的效率考虑，需要将之前发送的请求取消掉，只发送一个最新的请求，这样，服务器所受到的压力就要小很多。\n服务端 const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;);  const app = express();  const port = 8000;  app.all(\u0026#39;/delay\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \t// 设置延时响应 \tsetTimeout(() =\u0026gt; { \tresponse.send(\u0026#39;Hello IE\u0026#39;); \t}, 1000); });  app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.","title":"Ajax 重复发送请求的问题"},{"content":"Axios Axios 是一个基于 promise 的 HTTP 库，简单的讲就是可以发送 get、post 请求。说到 get、post，大家应该第一时间想到的就是 Jquery 吧，毕竟前几年 Jquery 比较火的时候，大家都在用他。但是由于 Vue、React 等框架的出现，Jquery 也不是那么吃香了。也正是 Vue、React 等框架的出现，促使了 Axios 轻量级库的出现，因为 Vue 等，不需要操作 Dom，所以不需要引入 Jquery.js 了。\n安装 npm install axios CND \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/axios/","summary":"Axios Axios 是一个基于 promise 的 HTTP 库，简单的讲就是可以发送 get、post 请求。说到 get、post，大家应该第一时间想到的就是 Jquery 吧，毕竟前几年 Jquery 比较火的时候，大家都在用他。但是由于 Vue、React 等框架的出现，Jquery 也不是那么吃香了。也正是 Vue、React 等框架的出现，促使了 Axios 轻量级库的出现，因为 Vue 等，不需要操作 Dom，所以不需要引入 Jquery.js 了。\n安装 npm install axios CND \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; ","title":"Axios"},{"content":"Axios 发送 Ajax 请求 服务端 const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;);  const app = express();  const port = 8000;  app.all(\u0026#39;/axios\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;);  \tconst data = { name: \u0026#39;Rainy\u0026#39; }; \tconst str = JSON.stringify(data); \tresponse.send(data); });  app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \t\u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \t\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./css/main.css\u0026#34; /\u0026gt; \t\u0026lt;title\u0026gt;Axios 发送 Ajax 请求\u0026lt;/title\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点击按钮，发送 GET 请求\u0026lt;/button\u0026gt; \t\u0026lt;button id=\u0026#34;btnTwo\u0026#34;\u0026gt;点击按钮，发送 POST 请求\u0026lt;/button\u0026gt; \t\u0026lt;button id=\u0026#34;btnThree\u0026#34;\u0026gt;点击按钮，发送通用方式请求\u0026lt;/button\u0026gt;  \t\u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; CSS #result{  width: 200px;  height: 100px;  border: 1px solid #999; } JavaScrip // get 方式 $(\u0026#39;#btn\u0026#39;).click(function () { \taxios.get(\u0026#39;http://localhost:8000/axios\u0026#39;, { \t// url 参数 \tparams: { \tID: 12345, \t}, \t// 请求头 \theaders: { \tname: \u0026#39;Su\u0026#39;, \t}, \t}) \t// 数据返回和处理 \t.then(function (response) { \tconsole.log(response); \t}) \t.catch(function (error) { \tconsole.log(error); \t}); });  // post 方式 $(\u0026#39;#btnTwo\u0026#39;).click(function () { \t// url \t// 请求体 \t// 其他配置 \taxios.post( \t\u0026#39;http://localhost:8000/axios\u0026#39;, \t{ \tusername: \u0026#39;rainy\u0026#39;, \tpassword: 1234, \t}, \t{ \t// url 参数 \tparams: { \tid: 200, \tvip: 10, \t}, \t// 请求头 \theaders: { \tage: 19, \t}, \t} \t); });  // 通用方式 $(\u0026#39;#btnThree\u0026#39;).click(function () { \taxios({ \tmethod: \u0026#39;post\u0026#39;, \turl: \u0026#39;http://localhost:8000/axios\u0026#39;, \t// url 参数 \tparams: { \tvip: 100, \t}, \t// 头信息 \theaders: { \ta: 13456, \t}, \t// 请求体 \tdata: { \tfirstName: \u0026#39;Fred\u0026#39;, \tlastName: \u0026#39;Flintstone\u0026#39;, \t}, \t}).then((response) =\u0026gt; { \tconsole.log(response); \t}); }); ","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/axios-%E5%8F%91%E9%80%81-ajax/","summary":"Axios 发送 Ajax 请求 服务端 const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;);  const app = express();  const port = 8000;  app.all(\u0026#39;/axios\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;);  \tconst data = { name: \u0026#39;Rainy\u0026#39; }; \tconst str = JSON.stringify(data); \tresponse.send(data); });  app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.","title":"Axios 发送 Ajax 请求"},{"content":"Fetch 发送 Ajax 服务端 const { json } = require(\u0026#39;body-parser\u0026#39;) const express = require(\u0026#39;express\u0026#39;)  const app = express()  const port = 8000  app.all(\u0026#39;/fetch\u0026#39;, (request, response) =\u0026gt; {  response.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;)  response.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;)   const data = { name: \u0026#39;Rainy\u0026#39; }  const str = JSON.stringify(data);  response.send(data) })   app.listen(port, () =\u0026gt; {  console.log(`服务已经启动`) }) HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;   \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;  \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt;  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt;  \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./css/main.css\u0026#34;\u0026gt;  \u0026lt;title\u0026gt;fetch 发送 Ajax 请求\u0026lt;/title\u0026gt;  \u0026lt;/head\u0026gt;   \u0026lt;body\u0026gt;  \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点击按钮，发送请求\u0026lt;/button\u0026gt;    \u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   \u0026lt;/body\u0026gt;  \u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;/html\u0026gt; CSS #result{  width: 200px;  height: 100px;  border: 1px solid #999; } JavaScrip // fetch方式 $(\u0026#39;#btn\u0026#39;).click(function () { \tfetch(\u0026#39;http://localhost:8000/fetch\u0026#39;, { \t// 请求方式 \tmethod: \u0026#39;post\u0026#39;, \t// 请求头 \theaders: { \tname: \u0026#39;rainy\u0026#39;, \t}, \t// 请求体 \tbody: \u0026#39;username=admin\u0026#39;, \t}) \t.then((response) =\u0026gt; { \t// 返回字符串 \t// return response.text(); \t// 返回json对象 \treturn response.json(); \t}) \t.then((response) =\u0026gt; { \tconsole.log(response); \t}); }); ","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/fetch-%E5%8F%91%E9%80%81-ajax/","summary":"Fetch 发送 Ajax 服务端 const { json } = require(\u0026#39;body-parser\u0026#39;) const express = require(\u0026#39;express\u0026#39;)  const app = express()  const port = 8000  app.all(\u0026#39;/fetch\u0026#39;, (request, response) =\u0026gt; {  response.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;)  response.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;)   const data = { name: \u0026#39;Rainy\u0026#39; }  const str = JSON.stringify(data);  response.send(data) })   app.listen(port, () =\u0026gt; {  console.log(`服务已经启动`) }) HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;   \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;  \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt;  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.","title":"Fetch 发送 Ajax"},{"content":"Jquery 发送 Ajax 服务端 HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;   \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;  \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt;  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt;  \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./css/main.css\u0026#34;\u0026gt;  \u0026lt;title\u0026gt;Jquery 发送 Ajax\u0026lt;/title\u0026gt;  \u0026lt;/head\u0026gt;   \u0026lt;body\u0026gt;  \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点击按钮，发送 GET 请求\u0026lt;/button\u0026gt;  \u0026lt;button id=\u0026#34;btnTwo\u0026#34;\u0026gt;点击按钮，发送 POST 请求\u0026lt;/button\u0026gt;  \u0026lt;button id=\u0026#34;btnThree\u0026#34;\u0026gt;点击按钮，发送通用方式请求\u0026lt;/button\u0026gt;   \u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   \u0026lt;/body\u0026gt;  \u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;/html\u0026gt; CSS #result { \twidth: 200px; \theight: 100px; \tborder: 1px solid #999; } JavaScrip // get 方式 $(\u0026#39;#btn\u0026#39;).click(function () { \t// 路径 \t// 参数 \t// 回调，对响应体的操作 \t// 响应体类型 \t$.get( \t\u0026#39;http://localhost:8000/jquery\u0026#39;, \t{ a: 100, b: 200 }, \tfunction (data) { \tconsole.log(data); \t}, \t\u0026#39;json\u0026#39; \t); });  // post 方式 $(\u0026#39;#btnTwo\u0026#39;).click(function () { \t$.post( \t\u0026#39;http://localhost:8000/jquery\u0026#39;, \t{ a: 100, b: 200 }, \tfunction (data) { \tconsole.log(data); \t}, \t\u0026#39;json\u0026#39; \t); });  // 通用方式 $(\u0026#39;#btnThree\u0026#39;).click(function () { \t$.ajax({ \t// url \turl: \u0026#39;http://localhost:8000/jquery\u0026#39;, \t// 参数 \tdata: { a: 200, b: 300 }, \t// 响应体类型 \tdataType: \u0026#39;json\u0026#39;, \t// 请求类型 \ttype: \u0026#39;get\u0026#39;, \t// 请求成功后的h \tsuccess: function (data) { \tconsole.log(data.name); \t}, \t// 请求失败的回调 \terror: function () { \tconsole.log(\u0026#39;出错\u0026#39;); \t}, \t// 标头信息 \theaders: { \ta: 1000, \tc: 2000, \t}, \t}); }); ","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/jquery-%E5%8F%91%E9%80%81-ajax/","summary":"Jquery 发送 Ajax 服务端 HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;   \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;  \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt;  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt;  \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./css/main.css\u0026#34;\u0026gt;  \u0026lt;title\u0026gt;Jquery 发送 Ajax\u0026lt;/title\u0026gt;  \u0026lt;/head\u0026gt;   \u0026lt;body\u0026gt;  \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点击按钮，发送 GET 请求\u0026lt;/button\u0026gt;  \u0026lt;button id=\u0026#34;btnTwo\u0026#34;\u0026gt;点击按钮，发送 POST 请求\u0026lt;/button\u0026gt;  \u0026lt;button id=\u0026#34;btnThree\u0026#34;\u0026gt;点击按钮，发送通用方式请求\u0026lt;/button\u0026gt;   \u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   \u0026lt;/body\u0026gt;  \u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;/html\u0026gt; CSS #result { \twidth: 200px; \theight: 100px; \tborder: 1px solid #999; } JavaScrip // get 方式 $(\u0026#39;#btn\u0026#39;).","title":"Jquery 发送 Ajax"},{"content":"Jquery 发送 Jsonp 服务端 const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;);  const app = express();  const port = 8000;  app.all(\u0026#39;/jquery_jsonp\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \t// 定义数据 \tconst data = { \tcity: \u0026#39;贵州\u0026#39;, \t}; \t// 将数据转为字符串 \tlet str = JSON.stringify(data); \t// 接受 callback \tlet cb = request.query.callback; \t// 响应结果， \tresponse.end(`${cb}(${str})`); });  app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \t\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./css/main.css\u0026#34; /\u0026gt; \t\u0026lt;title\u0026gt;Jquery 发送 Jsonp\u0026lt;/title\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点击按钮，发送 Jsonp 请求\u0026lt;/button\u0026gt; \t\u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; CSS #result { \twidth: 200px; \theight: 100px; \tborder: 1px solid #999; } JavaScrip $(\u0026#39;#btn\u0026#39;).click(function () { \t$.getJSON(\u0026#39;http://localhost:8000/jquery_jsonp?callback=?\u0026#39;, function (data) { \t$(\u0026#39;#result\u0026#39;).html(` 我现在在：${data.city}`); \t}); }); ","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/jquery-%E5%8F%91%E9%80%81-jsonp/","summary":"Jquery 发送 Jsonp 服务端 const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;);  const app = express();  const port = 8000;  app.all(\u0026#39;/jquery_jsonp\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \t// 定义数据 \tconst data = { \tcity: \u0026#39;贵州\u0026#39;, \t}; \t// 将数据转为字符串 \tlet str = JSON.stringify(data); \t// 接受 callback \tlet cb = request.query.callback; \t// 响应结果， \tresponse.","title":"Jquery 发送 Jsonp"},{"content":"原生 Jsonp 的实现 服务端 const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;);  const app = express();  const port = 8000;  app.all(\u0026#39;/check\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \t// 定义数据 \tconst data = { \texist: 1, \tmsg: \u0026#39;用户已经存在\u0026#39;, \t}; \t// 将数据转为字符串 \tlet str = JSON.stringify(data); \t// 响应结果，一个函数调用，函数已经在前端提前声明 \tresponse.end(`handle(${str})`); });  app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;   \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;  \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt;  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt;  \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./css/main.css\u0026#34;\u0026gt;  \u0026lt;title\u0026gt;jsonp 原理演示\u0026lt;/title\u0026gt;  \u0026lt;/head\u0026gt;   \u0026lt;body\u0026gt;  用户名：\u0026lt;input id=\u0026#34;in\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt;  \u0026lt;p id=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;  \u0026lt;/body\u0026gt;  \u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   \u0026lt;/html\u0026gt; JavaScrip const input = document.getElementById(\u0026#39;in\u0026#39;); const text = document.getElementById(\u0026#39;text\u0026#39;); // 声明函数，对数据进行处理 function handle(data) { \ttext.innerHTML = data.msg; \tinput.style.border = \u0026#39;solid 1px #f00\u0026#39;; }  input.onblur = function () { \t// 获取用户的输入值 \tlet username = this.value; \t// 向服务器发送请求，检测用户名是否存在 \t// 创建 script 元素 \tconst script = document.createElement(\u0026#39;script\u0026#39;); \t// 设置 script 的 src 属性 \tscript.src = \u0026#39;http://localhost:8000/check\u0026#39;; \t// 将 script 插入到文档中 \tdocument.body.appendChild(script); }; ","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/%E5%8E%9F%E7%94%9F-jsonp-%E7%9A%84%E5%AE%9E%E7%8E%B0/","summary":"原生 Jsonp 的实现 服务端 const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;);  const app = express();  const port = 8000;  app.all(\u0026#39;/check\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \t// 定义数据 \tconst data = { \texist: 1, \tmsg: \u0026#39;用户已经存在\u0026#39;, \t}; \t// 将数据转为字符串 \tlet str = JSON.stringify(data); \t// 响应结果，一个函数调用，函数已经在前端提前声明 \tresponse.end(`handle(${str})`); });  app.listen(port, () =\u0026gt; { \tconsole.","title":"原生 Jsonp 的实现"},{"content":"Ajax 可以理解为异步的 JavaScript 和 xml。\n它是一种在无需重新加载整个网页的情况下，能够更新部分网页内容的技术。\n它不是一种新的编程语言，而是一种将现有标准组合在一起使用的新方式。\n优点 可以无需刷新页面与服务器进行通信。\n允许根据用户事件来更新部分页面内容。\n缺点 没有浏览历史，无法进行网页后退或前进的操作。\n存在跨域问题。默认情况下，不同的域名之间，无法发送 Ajax 请求。\n对 SEO 的优化不友好，Ajax 返回当数据不会在网页源代码中存在。\n","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/ajax/","summary":"Ajax 可以理解为异步的 JavaScript 和 xml。\n它是一种在无需重新加载整个网页的情况下，能够更新部分网页内容的技术。\n它不是一种新的编程语言，而是一种将现有标准组合在一起使用的新方式。\n优点 可以无需刷新页面与服务器进行通信。\n允许根据用户事件来更新部分页面内容。\n缺点 没有浏览历史，无法进行网页后退或前进的操作。\n存在跨域问题。默认情况下，不同的域名之间，无法发送 Ajax 请求。\n对 SEO 的优化不友好，Ajax 返回当数据不会在网页源代码中存在。","title":"Ajax"},{"content":"GET 请求 使用 GET 的方式向服务端发送一个请求。\n服务端 const express = require(\u0026#39;express\u0026#39;); const app = express(); const port = 8000; app.get(\u0026#39;/server\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.send(\u0026#39;Hello World! GET\u0026#39;); }); // 允许 get 方式的请求 app.get(\u0026#39;/server\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.send(\u0026#39;Hello World!\u0026#39;); }); app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./css/main.css\u0026#34; /\u0026gt; \t\u0026lt;title\u0026gt;GET 请求\u0026lt;/title\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点击发送请求\u0026lt;/button\u0026gt; \t\u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; CSS #result { \twidth: 200px; \theight: 100px; \tborder: 1px solid #999; } JavaScript const btn = document.getElementById(\u0026#39;btn\u0026#39;); const div = document.getElementById(\u0026#39;result\u0026#39;); btn.onclick = function () { \tconst xhr = new XMLHttpRequest(); \t// 请求方式为 get \txhr.open(\u0026#39;GET\u0026#39;, \u0026#39;http://localhost:8000/server?a=100\u0026amp;b=300\u0026#39;); \txhr.send(); \txhr.onreadystatechange = function () { \tif (xhr.readyState == 4) { \tif (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { \tconsole.log(xhr.response); \tdiv.innerHTML = xhr.response; \t} else { \t} \t} \t}; }; ","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/get-%E8%AF%B7%E6%B1%82/","summary":"GET 请求 使用 GET 的方式向服务端发送一个请求。\n服务端 const express = require(\u0026#39;express\u0026#39;); const app = express(); const port = 8000; app.get(\u0026#39;/server\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.send(\u0026#39;Hello World! GET\u0026#39;); }); // 允许 get 方式的请求 app.get(\u0026#39;/server\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.send(\u0026#39;Hello World!\u0026#39;); }); app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.","title":"Ajax GET 请求"},{"content":"响应 JSON 数据 服务端 const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;); const app = express(); const port = 8000; app.all(\u0026#39;/json-server\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \t// 响应一个数据 \tconst data = { \tname: \u0026#39;Rainy\u0026#39;, \tage: \u0026#39;18\u0026#39;, \t}; \t// 将对象转换为字符串类型的数据 \tlet str = JSON.stringify(data); \t// 设置响应体，响应体只能是一个字符串 \tresponse.send(str); });  app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./css/main.css\u0026#34; /\u0026gt; \t\u0026lt;title\u0026gt;服务端返回 JSON 数据\u0026lt;/title\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点击键盘上的任意键，发送请求\u0026lt;/button\u0026gt; \t\u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;./js/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; CSS #result { \twidth: 200px; \theight: 100px; \tborder: 1px solid #999; } JavaScrip const div = document.getElementById(\u0026#39;result\u0026#39;); window.onkeydown = function () {  const xhr = new XMLHttpRequest();  // 自动转换，将响应的数据转换为json类型对象  xhr.responseType = \u0026#39;json\u0026#39;  xhr.open(\u0026#39;POST\u0026#39;, \u0026#39;http://localhost:8000/json-server\u0026#39;)  xhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;)  xhr.setRequestHeader(\u0026#39;name\u0026#39;, \u0026#39;Rainy\u0026#39;)  xhr.send(\u0026#39;a=100\u0026amp;b=200\u0026#39;);  xhr.onreadystatechange = function () {  if (xhr.readyState == 4) {  if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) {  // 获取响应体中的内容  div.innerHTML = xhr.response.age  } else {   }  }  } } 手动获取响应体中的内容 const div = document.getElementById(\u0026#39;result\u0026#39;); window.onkeydown = function () { \tconst xhr = new XMLHttpRequest(); \txhr.open(\u0026#39;POST\u0026#39;, \u0026#39;http://localhost:8000/json-server\u0026#39;); \txhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;); \txhr.setRequestHeader(\u0026#39;name\u0026#39;, \u0026#39;Rainy\u0026#39;); \txhr.send(\u0026#39;a=100\u0026amp;b=200\u0026#39;); \txhr.onreadystatechange = function () { \tif (xhr.readyState == 4) { \tif (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { \t// 手动转换，将响应的字符串转换为对象 \tlet data = JSON.parse(xhr.response); \tdiv.innerHTML = data.name; \t} else { \t} \t} \t}; }; ","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/%E5%93%8D%E5%BA%94-json-%E6%95%B0%E6%8D%AE/","summary":"响应 JSON 数据 服务端 const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;); const app = express(); const port = 8000; app.all(\u0026#39;/json-server\u0026#39;, (request, response) =\u0026gt; { \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \t// 响应一个数据 \tconst data = { \tname: \u0026#39;Rainy\u0026#39;, \tage: \u0026#39;18\u0026#39;, \t}; \t// 将对象转换为字符串类型的数据 \tlet str = JSON.stringify(data); \t// 设置响应体，响应体只能是一个字符串 \tresponse.send(str); });  app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); HTML \u0026lt;!","title":"Ajax 响应 JSON 数据"},{"content":"Express 基于 Node.js 的 Web 开发框架，可以快速地搭建一个完整功能的网站。\n安装 新建一个工作区，输入npm install express --save即可。\n基本使用 新建一个名为Express.js的 js 文件，输入代码：\n// 引入 express const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;);  // 创建应用对象 const app = express();  // 设置端口号 const port = 8000;  // 创建路由规则，允许所有方 式的请求 app.all(\u0026#39;/json-server\u0026#39;, (request, response) =\u0026gt; { \t// 设置响应头，允许跨域 \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \t// 允许接收所有类型的响应头 \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \t// 响应一个数据 \tconst data = { \tname: \u0026#39;Rainy\u0026#39;, \tage: \u0026#39;18\u0026#39;, \t}; \t// 将对象转换为字符串类型的数据 \tlet str = JSON.stringify(data);  \t// 设置响应体，响应体只能是一个字符串 \tresponse.send(str); });  // 监听端口 app.listen(port, () =\u0026gt; { \tconsole.log(`服务已经启动`); }); 完成后在当前目录下打开终端，输入node Express.js命令启动服务器。\nPS E:\\Code\\Web\\Test\u0026gt; node Express.js 服务已经启动 打开浏览器，输入 localhost:8000 即可出现Hello World!\n","permalink":"https://note.yxzi.xyz/note/technology/frame/express/express/","summary":"Express 基于 Node.js 的 Web 开发框架，可以快速地搭建一个完整功能的网站。\n安装 新建一个工作区，输入npm install express --save即可。\n基本使用 新建一个名为Express.js的 js 文件，输入代码：\n// 引入 express const { json } = require(\u0026#39;body-parser\u0026#39;); const express = require(\u0026#39;express\u0026#39;);  // 创建应用对象 const app = express();  // 设置端口号 const port = 8000;  // 创建路由规则，允许所有方 式的请求 app.all(\u0026#39;/json-server\u0026#39;, (request, response) =\u0026gt; { \t// 设置响应头，允许跨域 \tresponse.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); \t// 允许接收所有类型的响应头 \tresponse.setHeader(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;*\u0026#39;); \t// 响应一个数据 \tconst data = { \tname: \u0026#39;Rainy\u0026#39;, \tage: \u0026#39;18\u0026#39;, \t}; \t// 将对象转换为字符串类型的数据 \tlet str = JSON.","title":"Express"},{"content":"HTTP 超文本传输协议。详细规定了浏览器和万维网服务器之间互相通信的规则。\n请求报文 浏览器向服务器发送内容的过程叫做请求。\n请求报文一般包含四部分：行、头、空行、体。\n请求行 请求类型：GET、POST 等。\nURL 。\nHTTP 协议的版本。\nGET /ValidateLogin?\u0026amp;userI=4234234\u0026amp;password=234234 HTTP/1.1 请求头 请求头的格式通常时键名:键值\nAccept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en- Cookie: Hm_lvt_a2e2e465098d883036e3cfad66f7203d=1633793709; Hm_lvt_bf329994f1e3ebf56f3712e11a46cb4a=1633794836; Hm_lvt_8516e418a4e3ac3474b3c13bdb4687e7=1638612924; _uab_collina=164345858532791240726438 Host: 127.0.0.1:5500 Content-Type # 设置请求体n类型 请求空行 空行必须有。\n请求体 GET 的请求体是空的。\nPOST 的请求体可以不为空，也可以为空。\n响应报文 服务器给客户端/浏览器返回结果的过程叫做响应。\n响应报文一般包含四部分：行、头、空行、体。\n响应行 HTTP 版本\n响应状态码\n响应状态字符串\nHTTP/1.1 200 OK 响应头 Server: JSP3/2.0.14 Date: Sat, 30 Apr 2022 08:16:27 GMT Content-Type: text/javascript; charset=utf-8 Content-Length: 15758 Content-Encoding: gzip 响应空行 必须有\n响应体 主要的返回结果\n","permalink":"https://note.yxzi.xyz/note/technology/internet/http/http/","summary":"HTTP 超文本传输协议。详细规定了浏览器和万维网服务器之间互相通信的规则。\n请求报文 浏览器向服务器发送内容的过程叫做请求。\n请求报文一般包含四部分：行、头、空行、体。\n请求行 请求类型：GET、POST 等。\nURL 。\nHTTP 协议的版本。\nGET /ValidateLogin?\u0026amp;userI=4234234\u0026amp;password=234234 HTTP/1.1 请求头 请求头的格式通常时键名:键值\nAccept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en- Cookie: Hm_lvt_a2e2e465098d883036e3cfad66f7203d=1633793709; Hm_lvt_bf329994f1e3ebf56f3712e11a46cb4a=1633794836; Hm_lvt_8516e418a4e3ac3474b3c13bdb4687e7=1638612924; _uab_collina=164345858532791240726438 Host: 127.0.0.1:5500 Content-Type # 设置请求体n类型 请求空行 空行必须有。\n请求体 GET 的请求体是空的。\nPOST 的请求体可以不为空，也可以为空。\n响应报文 服务器给客户端/浏览器返回结果的过程叫做响应。\n响应报文一般包含四部分：行、头、空行、体。\n响应行 HTTP 版本\n响应状态码\n响应状态字符串\nHTTP/1.1 200 OK 响应头 Server: JSP3/2.0.14 Date: Sat, 30 Apr 2022 08:16:27 GMT Content-Type: text/javascript; charset=utf-8 Content-Length: 15758 Content-Encoding: gzip 响应空行 必须有","title":"HTTP"},{"content":"JOSN 一种轻量级的数据传输格式。本质上就是对象，用来传输的对象。\n它在与后端的数据交互中有较为广泛的应用。\n优点 JSON 比 XML 更小、更快，更易解析。\n语法 客户端与服务端的交互数据无非就是两种：\n 数组 对象  于是乎，JSON 所表示的数据要么就是对象，要么就是数组。\nJSON 数组 var employees = [ \t{ firstName: \u0026#39;Bill\u0026#39;, lastName: \u0026#39;Gates\u0026#39; }, \t{ firstName: \u0026#39;George\u0026#39;, lastName: \u0026#39;Bush\u0026#39; }, \t{ firstName: \u0026#39;Thomas\u0026#39;, lastName: \u0026#39;Carter\u0026#39; }, ]; JSON 对象 var obj = { \tage: 20, \tstr: \u0026#39;zhongfucheng\u0026#39;, \tmethod: function () { \talert(\u0026#39;我爱学习\u0026#39;); \t}, }; ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/json/json/","summary":"JOSN 一种轻量级的数据传输格式。本质上就是对象，用来传输的对象。\n它在与后端的数据交互中有较为广泛的应用。\n优点 JSON 比 XML 更小、更快，更易解析。\n语法 客户端与服务端的交互数据无非就是两种：\n 数组 对象  于是乎，JSON 所表示的数据要么就是对象，要么就是数组。\nJSON 数组 var employees = [ \t{ firstName: \u0026#39;Bill\u0026#39;, lastName: \u0026#39;Gates\u0026#39; }, \t{ firstName: \u0026#39;George\u0026#39;, lastName: \u0026#39;Bush\u0026#39; }, \t{ firstName: \u0026#39;Thomas\u0026#39;, lastName: \u0026#39;Carter\u0026#39; }, ]; JSON 对象 var obj = { \tage: 20, \tstr: \u0026#39;zhongfucheng\u0026#39;, \tmethod: function () { \talert(\u0026#39;我爱学习\u0026#39;); \t}, }; ","title":"JavaScrip JSON"},{"content":"JSON 方法 stringify() 将一个对象或值转换为 JSON 字符串。\nvar obj = { \tname: \u0026#39;rainy\u0026#39;, \tage: \u0026#39;20\u0026#39;, }; var result = JSON.stringify(obj); // 对象 console.log(obj);  // 字符串 console.log(result); parse() 将 JSON 字符串转换为对象。\n\rvar json = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;rainy\u0026#34;, \u0026#34;age:\u0026#34;:20}\u0026#39;;\rvar obj = JSON.parse(json);\r// 字符串\rconsole.log(json);\r// 对象\rconsole.log(obj); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/json/json-%E6%96%B9%E6%B3%95/","summary":"JSON 方法 stringify() 将一个对象或值转换为 JSON 字符串。\nvar obj = { \tname: \u0026#39;rainy\u0026#39;, \tage: \u0026#39;20\u0026#39;, }; var result = JSON.stringify(obj); // 对象 console.log(obj);  // 字符串 console.log(result); parse() 将 JSON 字符串转换为对象。\n\rvar json = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;rainy\u0026#34;, \u0026#34;age:\u0026#34;:20}\u0026#39;;\rvar obj = JSON.parse(json);\r// 字符串\rconsole.log(json);\r// 对象\rconsole.log(obj); ","title":"JavaScrip JSON 方法"},{"content":"交叉链接 返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积\n笛卡尔乘积错误 表 1 有 N 行，表 2 有 M 行，最终的查询结果就是 M * N 行。****\nSELECT b.name,boy.boyName FROM beauty AS b,boys AS boy 笛卡尔乘积也叫交叉链接：\nSELECT b.name,boy.boyName FROM beauty AS b CROSS JOIN boys boy 导致错误的原因是因为没有添加有效的链接条件。\n只需要添加有效的链接条件即可：\nSELECT b.name,boy.boyName FROM beauty AS b LEFT OUTER JOIN boys AS boy # 链接条件 ON b.boyfriend_id = boy.id ","permalink":"https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E4%BA%A4%E5%8F%89%E9%93%BE%E6%8E%A5/","summary":"交叉链接 返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积\n笛卡尔乘积错误 表 1 有 N 行，表 2 有 M 行，最终的查询结果就是 M * N 行。****\nSELECT b.name,boy.boyName FROM beauty AS b,boys AS boy 笛卡尔乘积也叫交叉链接：\nSELECT b.name,boy.boyName FROM beauty AS b CROSS JOIN boys boy 导致错误的原因是因为没有添加有效的链接条件。\n只需要添加有效的链接条件即可：\nSELECT b.name,boy.boyName FROM beauty AS b LEFT OUTER JOIN boys AS boy # 链接条件 ON b.boyfriend_id = boy.id ","title":"MySQL 交叉链接"},{"content":"Node.js Node.js 不是一种独立的语言，也不是一个 JavaScript 的框架，Node.js 只是一个让 JavaScript 运行在浏览器之外的平台。\n安装 Node.js ","permalink":"https://note.yxzi.xyz/note/technology/nodejs/nodejs/","summary":"Node.js Node.js 不是一种独立的语言，也不是一个 JavaScript 的框架，Node.js 只是一个让 JavaScript 运行在浏览器之外的平台。\n安装 Node.js ","title":"NodeJs"},{"content":"Nodemon 当我们开发一个 node 后端服务时，每次更改服务端文件，均需重启一下服务才能生效。这使我们的开发效率降低了很多。Nodemon 的出现，放我们可以随时监听文件的变更，自动重启服务，我们开发时只需关注代码即可，不再需要手动重启服务。\n安装 终端运行\nnpm install -g nodemon 使用 nodemon server.js ","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/nodemon/","summary":"Nodemon 当我们开发一个 node 后端服务时，每次更改服务端文件，均需重启一下服务才能生效。这使我们的开发效率降低了很多。Nodemon 的出现，放我们可以随时监听文件的变更，自动重启服务，我们开发时只需关注代码即可，不再需要手动重启服务。\n安装 终端运行\nnpm install -g nodemon 使用 nodemon server.js ","title":"Nodemon"},{"content":"npm 镜像 因为 npm 服务器在国外，因此我们有时候 install 一些 package 的时候，会因为网络问题而下载失败，比如运行npm install时，出现以下错误：\n idealTree:Test: sill idealTree buildDeps 所以，我们需要换一个国内的镜像。\n配置源地址为国内的淘宝镜像：\nnpm config set registry https://registry.npm.taobao.org 使用 nrm 工具切换淘宝源\nnpx nrm use tao 检查是否设置成功：\nnpm config get registry # 淘宝镜像 https://registry.npm.taobao.org/ 重新安装即可。\n","permalink":"https://note.yxzi.xyz/note/technology/packagemanager/npm/npm-%E9%95%9C%E5%83%8F/","summary":"npm 镜像 因为 npm 服务器在国外，因此我们有时候 install 一些 package 的时候，会因为网络问题而下载失败，比如运行npm install时，出现以下错误：\n idealTree:Test: sill idealTree buildDeps 所以，我们需要换一个国内的镜像。\n配置源地址为国内的淘宝镜像：\nnpm config set registry https://registry.npm.taobao.org 使用 nrm 工具切换淘宝源\nnpx nrm use tao 检查是否设置成功：\nnpm config get registry # 淘宝镜像 https://registry.npm.taobao.org/ 重新安装即可。","title":"npm 镜像"},{"content":"XML 可扩展标记语言，主要用来传输和存储数据。\nXML 和 HTML 类似，不同的是 HTML 中都是预定义的标签，用来呈现数据；而 XML 中没有预定义标签，都是自定义标签，用来表示一些数据。\n不过，现在地 XML 已经被 JSON 取代了。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/json/xml/","summary":"XML 可扩展标记语言，主要用来传输和存储数据。\nXML 和 HTML 类似，不同的是 HTML 中都是预定义的标签，用来呈现数据；而 XML 中没有预定义标签，都是自定义标签，用来表示一些数据。\n不过，现在地 XML 已经被 JSON 取代了。","title":"XML"},{"content":"against 表示接触 against + 人或事物的词语 表示靠着某人某物。强调两个事物的直接接触。\n  He sat against the tree.\n  She stood against each other.\n  表示反对 against + 某些词语 表示反对\u0026hellip;。\n  I am against this plan.\n  Are you for this plan.\n  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/against/","summary":"against 表示接触 against + 人或事物的词语 表示靠着某人某物。强调两个事物的直接接触。\n  He sat against the tree.\n  She stood against each other.\n  表示反对 against + 某些词语 表示反对\u0026hellip;。\n  I am against this plan.\n  Are you for this plan.\n  ","title":"English against"},{"content":"along 表示运动 along + 地点或位置的词语 表示沿着某个地方运动。喜欢与动作表示动作趋向的不及物动词搭配。\n We go along the river.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/along/","summary":"along 表示运动 along + 地点或位置的词语 表示沿着某个地方运动。喜欢与动作表示动作趋向的不及物动词搭配。\n We go along the river.  ","title":"English along"},{"content":"among among + 名词的复数或表示复数的代词 表示在三者或三者以上的人或人或事物当中\n I am the poorest among all my friend.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/among/","summary":"among among + 名词的复数或表示复数的代词 表示在三者或三者以上的人或人或事物当中\n I am the poorest among all my friend.  ","title":"English among"},{"content":"beyondqian 表示位置 beyond + 比较远的位置的词语 表示**在\u0026hellip;外边。**强调在很远的地方的那一边。\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/beyond/","summary":"beyondqian 表示位置 beyond + 比较远的位置的词语 表示**在\u0026hellip;外边。**强调在很远的地方的那一边。","title":"English beyond"},{"content":"内链接 查询的是多张表交集部分的记录。\nSQL 99 内链接 SQL 99 支持内链接、外连接以及交叉链接，并且该版本的链接查询语法要比 SQL 92 的可读性要高）。\nSELECT 查询列表 FROM 表一 别名 INNER JOIN 表二 别名 # SQL 92 用 WHERE，SQL99 用 ON ON 链接条件 WHERE SQL 92 内链接 SQL 92 只支持内链接，语法：\nSELECT 查询列表 FROM 表一 别名,表二 别名 WHERE 链接条件 ","permalink":"https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/%E5%86%85%E9%93%BE%E6%8E%A5/","summary":"内链接 查询的是多张表交集部分的记录。\nSQL 99 内链接 SQL 99 支持内链接、外连接以及交叉链接，并且该版本的链接查询语法要比 SQL 92 的可读性要高）。\nSELECT 查询列表 FROM 表一 别名 INNER JOIN 表二 别名 # SQL 92 用 WHERE，SQL99 用 ON ON 链接条件 WHERE SQL 92 内链接 SQL 92 只支持内链接，语法：\nSELECT 查询列表 FROM 表一 别名,表二 别名 WHERE 链接条件 ","title":"MySQL  内链接"},{"content":"across 表示穿过/横穿 across + 物体的词语 表示在物体的表面穿过。经常与一些表示动作趋向的不及物动词搭配。\n We walk across the road. The children run across the street.  表示位置 across + 位置的词语 表示在\u0026hellip;对面\n My parents live across the street.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/across/","summary":"across 表示穿过/横穿 across + 物体的词语 表示在物体的表面穿过。经常与一些表示动作趋向的不及物动词搭配。\n We walk across the road. The children run across the street.  表示位置 across + 位置的词语 表示在\u0026hellip;对面\n My parents live across the street.  ","title":"English across"},{"content":"into 表示运动 动作趋势的不及物动词 + into 表示**\u0026hellip;进/进入\u0026hellip;**\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/into/","summary":"into 表示运动 动作趋势的不及物动词 + into 表示**\u0026hellip;进/进入\u0026hellip;**","title":"English into"},{"content":"outside 表示位置 outside + 位置或地点的词语 表示在某个地方的外面或外部。\n The temperature outside my house is ver low.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/outside/","summary":"outside 表示位置 outside + 位置或地点的词语 表示在某个地方的外面或外部。\n The temperature outside my house is ver low.  ","title":"English outside"},{"content":"with 表示同伴 with +人或动物的词语 表示与\u0026hellip;一起。\n I go to the park with my daughter every day. I take the bus with her. She was with her friend last night.  表示具有/携带 with + 事物的词语\n表示具有\u0026hellip;。\n The girl with big eyes and yellow hair is my daughter. I want to buy a house with a swimming pool. The boy with a book is my friend.  表示工具 with +具体工具的词语。\n表示用\u0026hellip;/以\u0026hellip;。\n He opened the lock with a needle. I made a hole with a drill. He killed a man with a brick.  表示因为  His face turned red with anger.  表示时间 表示随着\u0026hellip;.。\n With these words she went out.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/with/","summary":"with 表示同伴 with +人或动物的词语 表示与\u0026hellip;一起。\n I go to the park with my daughter every day. I take the bus with her. She was with her friend last night.  表示具有/携带 with + 事物的词语\n表示具有\u0026hellip;。\n The girl with big eyes and yellow hair is my daughter. I want to buy a house with a swimming pool. The boy with a book is my friend.  表示工具 with +具体工具的词语。\n表示用\u0026hellip;/以\u0026hellip;。","title":"English with"},{"content":"within 表示时间 within +一段时间的词语 表示在一段时间之内。\n We will be famous within five years. We will finsh our course within a month.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/within/","summary":"within 表示时间 within +一段时间的词语 表示在一段时间之内。\n We will be famous within five years. We will finsh our course within a month.  ","title":"English within"},{"content":"without 表示没有 without + 事物的词语 表示没有带某个物品 。强调本来应该带某物，但是因为疏忽或其他原因没有带就去做其他事情的情况\n He went out without his hat. He went to the restaurant without money.  without + 动名词/动名词短语 表示没有做某事，就去做另外一件事去了。\n She always attends my class without eating dinner.  表示条件 without + 某人/某物 表示如果没有，就\u0026hellip;\n without air, we could not live.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/without/","summary":"without 表示没有 without + 事物的词语 表示没有带某个物品 。强调本来应该带某物，但是因为疏忽或其他原因没有带就去做其他事情的情况\n He went out without his hat. He went to the restaurant without money.  without + 动名词/动名词短语 表示没有做某事，就去做另外一件事去了。\n She always attends my class without eating dinner.  表示条件 without + 某人/某物 表示如果没有，就\u0026hellip;\n without air, we could not live.  ","title":"English without"},{"content":"等值链接 判断不同表中都包含的字段是否相等，相等则显示，不等则过滤。且一般都用=来判断。\n查询的是多张表的交集字段。\n一般需要为表起别名。\n注意\n使用链接查询，很多时候容易出现Column '字段名' in ambiguousfield 错误，这种情况一般是因为不同的表中含有相同的字段名，导致系统无法知道我们到底要查询哪个表中的字段。这个时候只需要指定一下我们要查询的是哪个表中的字段即可。\n查询女神名所对应的男神名 SELECT name,boyName FROM beauty,boys WHERE beauty.boyfriend_id = boys.id; 查询员工名所对应的部门名 SELECT last_name AS 员工名,department_name AS 部门名 FROM employees,departments WHERE employees.department_id = departments.department_id 查询员工名、工种号、工种名 链接查询通常比较长，因此我们可以给表定义一个别名。\n注意，如果我们为一些表起了别名之后，后续的语句当中如果需要用到这些表，则只能用我们定义的别名，不能用原本的表名。\n# 因为jobs 表和 employees 表中都用 job_id， # 系统不知道我们到底要查询哪一个， # 因此，这里需要指定一下我们要查询哪个表中的job_id SELECT last_name,员工表.job_id,job_title FROM employees AS 员工表, jobs AS 工种表 WHERE 员工表.job_id = 工种表.job_id; 查询城市名中第二个字符为 o 的部门和城市名 SELECT department_name,\tcity FROM departments AS 部门表,locations AS 位置表 WHERE 部门表.location_id = 位置表.location_id AND 位置表.city LIKE \u0026#39;_o%\u0026#39;; 查询每个城市的部门个数 SELECT COUNT(*),city FROM departments AS 部门表, locations AS 位置表 WHERE 部门表.location_id = 位置表.location_id GROUP BY city 查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资 SELECT department_name,部门表.manager_id,MIN(salary) FROM departments AS 部门表,employees AS 员工表 WHERE 部门表.department_id = 员工表.department_id AND commission_pct IS NOT NULL GROUP BY department_name,部门表.manager_id 查询每个工种的工种名和员工的个数，并且按员工的个数降序 SELECT job_title AS 工种名,COUNT(*) AS 员工个数 FROM employees AS 员工表, jobs AS 工种表 WHERE 员工表.job_id = 工种表.job_id GROUP BY 工种名 ORDER BY 员工个数 DESC 查询员工名、部门名和所在城市 SELECT last_name,department_name,city FROM employees AS 员工表, departments AS 部门表, locations AS 位置表 WHERE 员工表.department_id = 部门表.department_id AND 部门表.location_id = 位置表.location_id ","permalink":"https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-92/%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/","summary":"等值链接 判断不同表中都包含的字段是否相等，相等则显示，不等则过滤。且一般都用=来判断。\n查询的是多张表的交集字段。\n一般需要为表起别名。\n注意\n使用链接查询，很多时候容易出现Column '字段名' in ambiguousfield 错误，这种情况一般是因为不同的表中含有相同的字段名，导致系统无法知道我们到底要查询哪个表中的字段。这个时候只需要指定一下我们要查询的是哪个表中的字段即可。\n查询女神名所对应的男神名 SELECT name,boyName FROM beauty,boys WHERE beauty.boyfriend_id = boys.id; 查询员工名所对应的部门名 SELECT last_name AS 员工名,department_name AS 部门名 FROM employees,departments WHERE employees.department_id = departments.department_id 查询员工名、工种号、工种名 链接查询通常比较长，因此我们可以给表定义一个别名。\n注意，如果我们为一些表起了别名之后，后续的语句当中如果需要用到这些表，则只能用我们定义的别名，不能用原本的表名。\n# 因为jobs 表和 employees 表中都用 job_id， # 系统不知道我们到底要查询哪一个， # 因此，这里需要指定一下我们要查询哪个表中的job_id SELECT last_name,员工表.job_id,job_title FROM employees AS 员工表, jobs AS 工种表 WHERE 员工表.job_id = 工种表.job_id; 查询城市名中第二个字符为 o 的部门和城市名 SELECT department_name,\tcity FROM departments AS 部门表,locations AS 位置表 WHERE 部门表.","title":"MySQL 等值链接"},{"content":"自链接 判断同一张表中的不同字段是否相等，相等则显示，不相等则过滤。\n需要给同一张表取不同的别名，让系统分清同一张表中的不同字段。\n查询员工名所对应的领导名 SELECT 员工表.last_name AS 员工,领导表.last_name AS 领导 FROM employees AS 员工表, employees AS 领导表 WHERE 员工表.manager_id= 领导表.employee_id; ","permalink":"https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-92/%E8%87%AA%E9%93%BE%E6%8E%A5/","summary":"自链接 判断同一张表中的不同字段是否相等，相等则显示，不相等则过滤。\n需要给同一张表取不同的别名，让系统分清同一张表中的不同字段。\n查询员工名所对应的领导名 SELECT 员工表.last_name AS 员工,领导表.last_name AS 领导 FROM employees AS 员工表, employees AS 领导表 WHERE 员工表.manager_id= 领导表.employee_id; ","title":"MySQL 自链接"},{"content":"非等值链接 新建查询并运行。\nCREATE TABLE job_grades (grade_level VARCHAR(3),  lowest_sal int,  highest_sal int);  INSERT INTO job_grades VALUES (\u0026#39;A\u0026#39;, 1000, 2999);  INSERT INTO job_grades VALUES (\u0026#39;B\u0026#39;, 3000, 5999);  INSERT INTO job_grades VALUES(\u0026#39;C\u0026#39;, 6000, 9999);  INSERT INTO job_grades VALUES(\u0026#39;D\u0026#39;, 10000, 14999);  INSERT INTO job_grades VALUES(\u0026#39;E\u0026#39;, 15000, 24999);  INSERT INTO job_grades VALUES(\u0026#39;F\u0026#39;, 25000, 40000); 查询员工的工资和工资级别 SELECT salary,grade_level FROM employees AS 员工表, job_grades 工资等级表 WHERE 员工表.salary BETWEEN 工资等级表.lowest_sal AND 工资等级表.highest_sal ","permalink":"https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-92/%E9%9D%9E%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/","summary":"非等值链接 新建查询并运行。\nCREATE TABLE job_grades (grade_level VARCHAR(3),  lowest_sal int,  highest_sal int);  INSERT INTO job_grades VALUES (\u0026#39;A\u0026#39;, 1000, 2999);  INSERT INTO job_grades VALUES (\u0026#39;B\u0026#39;, 3000, 5999);  INSERT INTO job_grades VALUES(\u0026#39;C\u0026#39;, 6000, 9999);  INSERT INTO job_grades VALUES(\u0026#39;D\u0026#39;, 10000, 14999);  INSERT INTO job_grades VALUES(\u0026#39;E\u0026#39;, 15000, 24999);  INSERT INTO job_grades VALUES(\u0026#39;F\u0026#39;, 25000, 40000); 查询员工的工资和工资级别 SELECT salary,grade_level FROM employees AS 员工表, job_grades 工资等级表 WHERE 员工表.salary BETWEEN 工资等级表.lowest_sal AND 工资等级表.","title":"MySQL 非等值链接"},{"content":"around 表示运动 around + 人或物的词语 表示围着\u0026hellip;环绕。\n The earth goes around the sun. We walk around the lake. The mouse ran around the room.  表示地点 around + 地点或位置的词语 表示在\u0026hellip;周围/附近。\n The man sells DVDs around the station. The children sat around the teacher. The banana trees are around the pond.  表示数量 around 修饰数词 表示大约\u0026hellip;。\n The number of listeners tonight is around 89.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/around/","summary":"around 表示运动 around + 人或物的词语 表示围着\u0026hellip;环绕。\n The earth goes around the sun. We walk around the lake. The mouse ran around the room.  表示地点 around + 地点或位置的词语 表示在\u0026hellip;周围/附近。\n The man sells DVDs around the station. The children sat around the teacher. The banana trees are around the pond.  表示数量 around 修饰数词 表示大约\u0026hellip;。\n The number of listeners tonight is around 89.  ","title":"English around"},{"content":"to 表示方向 表示动作位移的词语 + to + 地方的词语 表示向某个地方移动。\n I will to Chongqing tomorrow. I walk to the park every morning.  表示时间/程度/结果 from\u0026hellip;to 表示从\u0026hellip;到\u0026hellip;。\n He works from morning to night. He will fly from the moon to the earth.  表示目的 to + 一些词语 表示为了\u0026hellip;\n We sat down to dinner.  表示比较 by + 数词 + to + 数词 表示几比几。\n We won the game by 5 to 3.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/to/","summary":"to 表示方向 表示动作位移的词语 + to + 地方的词语 表示向某个地方移动。\n I will to Chongqing tomorrow. I walk to the park every morning.  表示时间/程度/结果 from\u0026hellip;to 表示从\u0026hellip;到\u0026hellip;。\n He works from morning to night. He will fly from the moon to the earth.  表示目的 to + 一些词语 表示为了\u0026hellip;\n We sat down to dinner.  表示比较 by + 数词 + to + 数词 表示几比几。\n We won the game by 5 to 3.","title":"English to"},{"content":"under 表示位置 under + 位置的词语 表示在\u0026hellip;下方。强调的是垂直 90 度的下方。\n The are palying mahjong under the tree. The man under the bridge is Jeff.  表示年龄 under + 年龄/数量/重量的词语 表示不到\u0026hellip;/在\u0026hellip;以下。\n He is under ten years old.  表示过程 under + 某些词语 表示在\u0026hellip;过程中。\n The road is under repair.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/under/","summary":"under 表示位置 under + 位置的词语 表示在\u0026hellip;下方。强调的是垂直 90 度的下方。\n The are palying mahjong under the tree. The man under the bridge is Jeff.  表示年龄 under + 年龄/数量/重量的词语 表示不到\u0026hellip;/在\u0026hellip;以下。\n He is under ten years old.  表示过程 under + 某些词语 表示在\u0026hellip;过程中。\n The road is under repair.  ","title":"English under"},{"content":"up 表示运动方向 运动趋势的词语 +up + 位置或地点名词 表示向\u0026hellip;上/沿着\u0026hellip;。\n He ran up the hill. We went up the house.  表示位置 up + 位置的名词 表示在\u0026hellip;上面\n They live up the street. The cath fish up the river.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/up/","summary":"up 表示运动方向 运动趋势的词语 +up + 位置或地点名词 表示向\u0026hellip;上/沿着\u0026hellip;。\n He ran up the hill. We went up the house.  表示位置 up + 位置的名词 表示在\u0026hellip;上面\n They live up the street. The cath fish up the river.  ","title":"English up"},{"content":"二叉树的最大深度 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }  //二叉树的最大深度 int max_depth(node *p) {  int left = 0;  int right = 0;  if (p-\u0026gt;lchild)  {  left = max_depth(p-\u0026gt;lchild);  }  if (p-\u0026gt;rchild)  {  right = max_depth(p-\u0026gt;rchild);  }  if (left \u0026gt; right)  return left + 1;  else  return right + 1; }  int main(void) {  // 构建树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);   // 二叉树的最大深度  int depth = max_depth(t);  printf(\u0026#34;二叉树的深度为：%d\\n\u0026#34;,depth);  return 0; } ","permalink":"https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","summary":"二叉树的最大深度 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }  //二叉树的最大深度 int max_depth(node *p) {  int left = 0;  int right = 0;  if (p-\u0026gt;lchild)  {  left = max_depth(p-\u0026gt;lchild);  }  if (p-\u0026gt;rchild)  {  right = max_depth(p-\u0026gt;rchild);  }  if (left \u0026gt; right)  return left + 1;  else  return right + 1; }  int main(void) {  // 构建树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);   // 二叉树的最大深度  int depth = max_depth(t);  printf(\u0026#34;二叉树的深度为：%d\\n\u0026#34;,depth);  return 0; } ","title":"二叉树的最大深度"},{"content":"判断是否为完全二叉树 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct node {  int data;  struct node *lchild, *rchild; } n;  //创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }  /* //5 判断一棵树是否是完全二叉树，如果是返回1，如果否返回0 int is_complete(node *p){ //请完善这里 } */ int main(void) {  //构建一棵树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);   return 0; } ","permalink":"https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"判断是否为完全二叉树 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct node {  int data;  struct node *lchild, *rchild; } n;  //创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }  /* //5 判断一棵树是否是完全二叉树，如果是返回1，如果否返回0 int is_complete(node *p){ //请完善这里 } */ int main(void) {  //构建一棵树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);   return 0; } ","title":"判断是否为完全二叉树"},{"content":"判断是否为对称二叉树 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }  bool isSymHeper(node* left,node* right); //3 判断是否是对称的二叉树，如果是返回1，如果否返回0 bool isSym(node* p) {  if(p == NULL)  return true;  return isSymHeper(p-\u0026gt;lchild,p-\u0026gt;rchild); } bool isSymHeper(node* left,node* right) {  if(left == NULL \u0026amp;\u0026amp; right == NULL)  return true;  if(left == NULL || right == NULL || left-\u0026gt;data != right-\u0026gt;data)  return false;  return isSymHeper(left-\u0026gt;lchild,right-\u0026gt;rchild) \u0026amp;\u0026amp; isSymHeper(left-\u0026gt;rchild,right-\u0026gt;lchild); }   int main(void) {  //构建一棵树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);   // 判断是否为对称二叉树  int re = isSym(t);  if(re == 0)  printf(\u0026#34;不对称二叉树：%d\\n\u0026#34;,re);  else  printf(\u0026#34;是对称二叉树：%d\\n\u0026#34;,re);  return 0; } ","permalink":"https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"判断是否为对称二叉树 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }  bool isSymHeper(node* left,node* right); //3 判断是否是对称的二叉树，如果是返回1，如果否返回0 bool isSym(node* p) {  if(p == NULL)  return true;  return isSymHeper(p-\u0026gt;lchild,p-\u0026gt;rchild); } bool isSymHeper(node* left,node* right) {  if(left == NULL \u0026amp;\u0026amp; right == NULL)  return true;  if(left == NULL || right == NULL || left-\u0026gt;data !","title":"判断是否为对称二叉树"},{"content":"翻转二叉树 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt;  typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }  //4 翻转二叉树，返回树根 node *node_reverse(node* p) {  if (p == NULL)  return NULL;  node_reverse(p-\u0026gt;lchild);  node_reverse(p-\u0026gt;rchild);  node * t = p-\u0026gt;lchild;  p-\u0026gt;lchild = p-\u0026gt;rchild;  p-\u0026gt;rchild = t;   return p; }  int main(void) {  //构建一棵树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);    // 翻转二叉树  node* newt = node_reverse(t);  printf(\u0026#34;翻转后的二叉树根节点：%d\\n\u0026#34;,newt-\u0026gt;lchild-\u0026gt;lchild-\u0026gt;rchild-\u0026gt;data );    return 0; } ","permalink":"https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"翻转二叉树 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt;  typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }  //4 翻转二叉树，返回树根 node *node_reverse(node* p) {  if (p == NULL)  return NULL;  node_reverse(p-\u0026gt;lchild);  node_reverse(p-\u0026gt;rchild);  node * t = p-\u0026gt;lchild;  p-\u0026gt;lchild = p-\u0026gt;rchild;  p-\u0026gt;rchild = t;   return p; }  int main(void) {  //构建一棵树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);    // 翻转二叉树  node* newt = node_reverse(t);  printf(\u0026#34;翻转后的二叉树根节点：%d\\n\u0026#34;,newt-\u0026gt;lchild-\u0026gt;lchild-\u0026gt;rchild-\u0026gt;data );    return 0; } ","title":"翻转二叉树"},{"content":"near 表示时间、空间 near + 地点或位置的词语 表示接近某个地方，对于 beside 和 by 来说，near 更加强调空间上的靠近或接近，而不是单一的在\u0026hellip;旁边。\n另外 near 还表示相对的近。比如广西和广东，相对于中国来说，就他们离得很近，但是如果相对于人来说，依旧离得很远。\n You sit near me. I live near a river. The lake near my house is very big.  near + 具体时间点的词语 表示快要接近某个时间点了。\n It is near 2023. It is near 19:00. It is near spring festival.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/near/","summary":"near 表示时间、空间 near + 地点或位置的词语 表示接近某个地方，对于 beside 和 by 来说，near 更加强调空间上的靠近或接近，而不是单一的在\u0026hellip;旁边。\n另外 near 还表示相对的近。比如广西和广东，相对于中国来说，就他们离得很近，但是如果相对于人来说，依旧离得很远。\n You sit near me. I live near a river. The lake near my house is very big.  near + 具体时间点的词语 表示快要接近某个时间点了。\n It is near 2023. It is near 19:00. It is near spring festival.  ","title":"English near"},{"content":"of 表示\u0026hellip;的 of + 无生命的名词所有格/动名词短语/代词/数词 表示**\u0026hellip;的**\n The price of this coat. The color of my shirt.  of + 比较长的生命的名词 表示.\u0026hellip;的\n It is the story of my lady Mary, Queen of Scots. She is the daughter of my English teacher, Nick.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/of/","summary":"of 表示\u0026hellip;的 of + 无生命的名词所有格/动名词短语/代词/数词 表示**\u0026hellip;的**\n The price of this coat. The color of my shirt.  of + 比较长的生命的名词 表示.\u0026hellip;的\n It is the story of my lady Mary, Queen of Scots. She is the daughter of my English teacher, Nick.  ","title":"English of"},{"content":"off 表示离开 固定搭配 off 作介词短时候，用法跟 from、out、of 很相似。\noff 大多数情况都要跟一些特定的动词搭配，构成一个介词短语。\n Keep off the grass He fell the ladder She fell off the roof  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/off/","summary":"off 表示离开 固定搭配 off 作介词短时候，用法跟 from、out、of 很相似。\noff 大多数情况都要跟一些特定的动词搭配，构成一个介词短语。\n Keep off the grass He fell the ladder She fell off the roof  ","title":"English off"},{"content":"past 表示时间 数词（几分钟） + past + 几点钟 表示几点过了几分钟，而且，只能表示半小时以及半小时之内的时间。\n 30 past 7 = 7:30 = half past 7（表示 7 点过了 30 分钟）  但这种结构，不能作介词短语，因为它仅仅只是一个表示时间的数词。想要作时间状语造句，必须跟其他介词构成介词短语。\n I begin my class at 25 past 7.  有时候 past 构成的数词也可以直接作表语。\nIt is + 数词 + past +几点 表示现在是几点钟。\n It is 20 past 8. It is half past ten  表示超过 past + 数量或年龄的词语 表示超过某个年龄或超过某个数量。\n He is past sixty year old.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/past/","summary":"past 表示时间 数词（几分钟） + past + 几点钟 表示几点过了几分钟，而且，只能表示半小时以及半小时之内的时间。\n 30 past 7 = 7:30 = half past 7（表示 7 点过了 30 分钟）  但这种结构，不能作介词短语，因为它仅仅只是一个表示时间的数词。想要作时间状语造句，必须跟其他介词构成介词短语。\n I begin my class at 25 past 7.  有时候 past 构成的数词也可以直接作表语。\nIt is + 数词 + past +几点 表示现在是几点钟。\n It is 20 past 8. It is half past ten  表示超过 past + 数量或年龄的词语 表示超过某个年龄或超过某个数量。\n He is past sixty year old.  ","title":"English past"},{"content":"COUNT COUNT(*) 统计表的行数，在统计结果的时候，不会忽略字段值为 NULL 的行。\n这种写法用的比较多，因为在一般的存储引擎下，COUNT(*)的效率通常比较高。\nCOUNT(1) 忽略所有字段，1 表示一个固定值，也可以用 COUNT(2)、COUNT(3) 代替，在统计结果的时候，不会忽略字段值为 NULL 的行。\nCOUNT(字段名) 统计指定字段名的值有多少行，字段值为 NULL 的行会被忽略统计。\nCOUNT(DISTINCT 字段名) 统计指定字段名的值有多少行，，字段值为 NULL 或重复的行会被忽略统计。\n","permalink":"https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/count/","summary":"COUNT COUNT(*) 统计表的行数，在统计结果的时候，不会忽略字段值为 NULL 的行。\n这种写法用的比较多，因为在一般的存储引擎下，COUNT(*)的效率通常比较高。\nCOUNT(1) 忽略所有字段，1 表示一个固定值，也可以用 COUNT(2)、COUNT(3) 代替，在统计结果的时候，不会忽略字段值为 NULL 的行。\nCOUNT(字段名) 统计指定字段名的值有多少行，字段值为 NULL 的行会被忽略统计。\nCOUNT(DISTINCT 字段名) 统计指定字段名的值有多少行，，字段值为 NULL 或重复的行会被忽略统计。","title":"MySQL COUNT"},{"content":"分组查询 通过一定的规则将一个数据集划分为若干个小组，然后对这些小组中的数据进行处理。\n语法 SELECT 字段名 FROM 表名 WHERE 分组前的筛选条件 GROUP BY 依照哪个字段进行分组 ORDER BY 排序列表 HAVING 分组后的筛选条件 查询列表必须特殊，必须实分组函数和 GROUP BY后面出现的字段。\n分组查询的筛选条件被分为分组前的筛选和分组后的筛选\nWHERE 和 HAVING WHERE，分组之前的筛选条件，数据来源是原始表。\nHAVING，分组之后的筛选条件，数据来源是经过 WHERE 筛选后的表。\n用先用 WHERE 来进行筛选的，优先考虑先用 WHERE 来进行筛选。\n按单个字段分组 查询每个工种的最高工资 SELECT MAX(salary),job_id FROM employees GROUP BY job_id 查询每个部门，邮箱中包含 a 字符的平均工资 SELECT AVG(salary), department_id FROM employees WHERE email LIKE \u0026#39;%a%\u0026#39; GROUP BY department_id 查询每个领导手下有奖金的员工的最高工资 SELECT MAX(salary),manager_id FROM employees WHERE commission_pct IS NOT NULL GROUP BY manager_id 查询哪些部门的员工数 \u0026gt; 2 SELECT COUNT(*) AS 员工个数, department_id FROM employees GROUP BY department_id HAVING 员工个数 \u0026gt;2; 查询哪些工种编号的最高工资 \u0026gt; 12000 SELECT MAX(salary) AS 最高工资, job_id FROM employees WHERE commission_pct IS NOT NULL GROUP BY job_id HAVING 最高工资 \u0026gt;12000; 查询哪些领导编号 \u0026gt;102 ，且最低工资 \u0026gt; 5000 SELECT MIN(salary) AS 最低工资,manager_id FROM employees WHERE manager_id \u0026gt; 102 GROUP BY manager_id HAVING 最低工资 \u0026gt; 5000; 按表达式或函数分组 按员工姓的长度分组，查询每组员工个数 \u0026gt;5 的组 SELECT COUNT(*) AS 员工个数,LENGTH(last_name) AS 这些员工的姓名长度 FROM employees GROUP BY LENGTH(last_name) HAVING 员工个数 \u0026gt; 5 按多个字段分组 将GROUP BY后面的多个字段用,隔开即可。\n查询每个部门和每个工种的员工的平均工资 SELECT AVG(salary) AS 平均工资 ,department_id,job_id FROM employees GROUP BY department_id,job_id; 查询每个不为 NULL 的部门和每个工种的 \u0026gt; 10000 的平均工资，并且按平均工资的高低显示 SELECT AVG(salary) AS 平均工资, department_id, job_id FROM employees WHERE department_id IS NOT NULL GROUP BY job_id,department_id HAVING 平均工资 \u0026gt; 10000 ORDER BY 平均工资 DESC; ","permalink":"https://note.yxzi.xyz/note/technology/mysql/dql/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/","summary":"分组查询 通过一定的规则将一个数据集划分为若干个小组，然后对这些小组中的数据进行处理。\n语法 SELECT 字段名 FROM 表名 WHERE 分组前的筛选条件 GROUP BY 依照哪个字段进行分组 ORDER BY 排序列表 HAVING 分组后的筛选条件 查询列表必须特殊，必须实分组函数和 GROUP BY后面出现的字段。\n分组查询的筛选条件被分为分组前的筛选和分组后的筛选\nWHERE 和 HAVING WHERE，分组之前的筛选条件，数据来源是原始表。\nHAVING，分组之后的筛选条件，数据来源是经过 WHERE 筛选后的表。\n用先用 WHERE 来进行筛选的，优先考虑先用 WHERE 来进行筛选。\n按单个字段分组 查询每个工种的最高工资 SELECT MAX(salary),job_id FROM employees GROUP BY job_id 查询每个部门，邮箱中包含 a 字符的平均工资 SELECT AVG(salary), department_id FROM employees WHERE email LIKE \u0026#39;%a%\u0026#39; GROUP BY department_id 查询每个领导手下有奖金的员工的最高工资 SELECT MAX(salary),manager_id FROM employees WHERE commission_pct IS NOT NULL GROUP BY manager_id 查询哪些部门的员工数 \u0026gt; 2 SELECT COUNT(*) AS 员工个数, department_id FROM employees GROUP BY department_id HAVING 员工个数 \u0026gt;2; 查询哪些工种编号的最高工资 \u0026gt; 12000 SELECT MAX(salary) AS 最高工资, job_id FROM employees WHERE commission_pct IS NOT NULL GROUP BY job_id HAVING 最高工资 \u0026gt;12000; 查询哪些领导编号 \u0026gt;102 ，且最低工资 \u0026gt; 5000 SELECT MIN(salary) AS 最低工资,manager_id FROM employees WHERE manager_id \u0026gt; 102 GROUP BY manager_id HAVING 最低工资 \u0026gt; 5000; 按表达式或函数分组 按员工姓的长度分组，查询每组员工个数 \u0026gt;5 的组 SELECT COUNT(*) AS 员工个数,LENGTH(last_name) AS 这些员工的姓名长度 FROM employees GROUP BY LENGTH(last_name) HAVING 员工个数 \u0026gt; 5 按多个字段分组 将GROUP BY后面的多个字段用,隔开即可。","title":"MySQL 分组查询"},{"content":"链接查询 当需要从多张表中查询数据，而这些表之间有关联字段的时候，需要使用连接查询。\n","permalink":"https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/","summary":"链接查询 当需要从多张表中查询数据，而这些表之间有关联字段的时候，需要使用连接查询。","title":"MySQL 链接查询"},{"content":"创建表 mysql\u0026gt; create table rainy(  -\u0026gt; id int,  -\u0026gt; name varchar(20)); Query OK, 0 rows affected (0.01 sec) ","permalink":"https://note.yxzi.xyz/note/technology/mysql/ddl/create/","summary":"创建表 mysql\u0026gt; create table rainy(  -\u0026gt; id int,  -\u0026gt; name varchar(20)); Query OK, 0 rows affected (0.01 sec) ","title":"MySQL CREATE"},{"content":"其他函数 查询 MySQL 版本号 SELECT VERSION(); 查询当前处于哪个数据库 SELECT DATABASE(); 查询当前用户 SELECT USER() ","permalink":"https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0/","summary":"其他函数 查询 MySQL 版本号 SELECT VERSION(); 查询当前处于哪个数据库 SELECT DATABASE(); 查询当前用户 SELECT USER() ","title":"MySQL 其他函数"},{"content":"INSERT 用于向数据库中的表插入数据。\n插入数据 使用insert into TableName;来插入一些数据，TableName 是要插入数据的表的名称。\nmysql\u0026gt; insert into rainy (id,name) values(1,\u0026#39;su\u0026#39;); Query OK, 1 row affected (0.00 sec) 我们插入数据后重新查询表中的数据：\nmysql\u0026gt; select * from rainy; +------+------+ | id | name | +------+------+ | 1 | su | | 1 | su | +------+------+ 2 rows in set (0.00 sec) ","permalink":"https://note.yxzi.xyz/note/technology/mysql/dml/insert/","summary":"INSERT 用于向数据库中的表插入数据。\n插入数据 使用insert into TableName;来插入一些数据，TableName 是要插入数据的表的名称。\nmysql\u0026gt; insert into rainy (id,name) values(1,\u0026#39;su\u0026#39;); Query OK, 1 row affected (0.00 sec) 我们插入数据后重新查询表中的数据：\nmysql\u0026gt; select * from rainy; +------+------+ | id | name | +------+------+ | 1 | su | | 1 | su | +------+------+ 2 rows in set (0.00 sec) ","title":"MySQL INSERT"},{"content":"SHOW SHOW ENGINES 查看 MySQL 支持的存储引擎。\nSHOW ENGINES; # 显示二进制文件以及文件大小（需要开启二进制日志记录功能） SHOW {BINARY | MASTER} LOGS  # 显示二进制文件的执行过程 SHOW BINLOG EVENTS [IN \u0026#39;log_name\u0026#39;] [FROM pos] [LIMIT [offset,] row_count]  # 显示MySQL当前支持哪些字符集 SHOW CHARACTER SET [like_or_where]  # 显示MySQL支持字符集的排序规则 SHOW COLLATION [like_or_where]  # 显示表的列信息（等同于DESC，需要先创建表） SHOW [FULL] COLUMNS FROM tbl_name [FROM db_name] [like_or_where]  # 显示已经创建的库，创建时的语句 SHOW CREATE DATABASE db_name  # 显示已经创建的事件，创建时的语句 SHOW CREATE EVENT event_name  # 显示已经创建的函数，创建时的语句 SHOW CREATE FUNCTION func_name  # 显示已经创建的存储过程，创建时的语句 SHOW CREATE PROCEDURE proc_name  # 显示已经创建的表，创建时的语句 SHOW CREATE TABLE tbl_name  # 显示已经创建的触发器，创建时的语句 SHOW CREATE TRIGGER trigger_name  # 显示已经创建的视图，创建时的语句 SHOW CREATE VIEW view_name  # 显示mysql中所有数据库的名称 SHOW DATABASES [like_or_where]  # 显示存储引擎的详细信息 SHOW ENGINE engine_name {STATUS | MUTEX}  # 显示数据库支持的存储引擎和默认存储引擎 SHOW [STORAGE] ENGINES  # 显示最后一个执行语句所产生的错误信息 SHOW ERRORS [LIMIT [offset,] row_count]  # 显示事件信息 SHOW EVENTS  # 服务器内部调试，显示一个指定存储的内部实现的表示形式过程 SHOW FUNCTION CODE func_name  # 显示存储函数信息（需要先创建存储函数） SHOW FUNCTION STATUS [like_or_where]  # 显示指定用户拥有的权限 SHOW GRANTS FOR user  # 显示表索引信息（需要先创建索引） SHOW INDEX FROM tbl_name [FROM db_name]  # 显示Master当前正在使用的二进制信息 SHOW MASTER STATUS  # 列举在表缓存中当前被打开的非TEMPORARY表 SHOW OPEN TABLES [FROM db_name] [like_or_where]  # 显示MySQL插件信息 SHOW PLUGINS  # 服务器内部调试，显示一个指定存储的内部实现的表示形式过程 SHOW PROCEDURE CODE proc_name  # 显示存储过程信息（需要先创建存储过程） SHOW PROCEDURE STATUS [like_or_where]  # 显示MySQL所支持的所有权限，及权限可操作的对象 SHOW PRIVILEGES  # 显示系统中正在运行的所有进程，普通用户只能查看自己的进行信息 SHOW [FULL] PROCESSLIST  # 显示当前会话执行语句资源使用情况 SHOW PROFILE [types] [FOR QUERY n] [OFFSET n] [LIMIT n]  # 显示当前会话执行语句资源使用情况 SHOW PROFILES  # 显示relaylog事件信息（需要先做主从复制） SHOW RELAYLOG EVENTS [IN \u0026#39;log_name\u0026#39;] [FROM pos] [LIMIT [offset,] row_count]  # 显示Master主机上已注册的复制主机列表（需要先做主从复制） SHOW SLAVE HOSTS  # 显示Slave主机状态信息（需要先做主从复制） SHOW SLAVE STATUS [FOR CHANNEL channel]  # 显示MySQL状态信息 SHOW [GLOBAL | SESSION] STATUS [like_or_where]  # 显示表属性信息 SHOW TABLE STATUS [FROM db_name] [like_or_where]  # 显示当前数据库中所有表的名称 SHOW [FULL] TABLES [FROM db_name] [like_or_where]  # 显示触发器信息（需要先创建触发器） SHOW TRIGGERS [FROM db_name] [like_or_where]  # 显示MySQL变量信息 SHOW [GLOBAL | SESSION] VARIABLES [like_or_where]  # 显示最后一个执行语句所产生的警告信息 SHOW WARNINGS [LIMIT [offset,] row_count] ","permalink":"https://note.yxzi.xyz/note/technology/mysql/show/","summary":"SHOW SHOW ENGINES 查看 MySQL 支持的存储引擎。\nSHOW ENGINES; # 显示二进制文件以及文件大小（需要开启二进制日志记录功能） SHOW {BINARY | MASTER} LOGS  # 显示二进制文件的执行过程 SHOW BINLOG EVENTS [IN \u0026#39;log_name\u0026#39;] [FROM pos] [LIMIT [offset,] row_count]  # 显示MySQL当前支持哪些字符集 SHOW CHARACTER SET [like_or_where]  # 显示MySQL支持字符集的排序规则 SHOW COLLATION [like_or_where]  # 显示表的列信息（等同于DESC，需要先创建表） SHOW [FULL] COLUMNS FROM tbl_name [FROM db_name] [like_or_where]  # 显示已经创建的库，创建时的语句 SHOW CREATE DATABASE db_name  # 显示已经创建的事件，创建时的语句 SHOW CREATE EVENT event_name  # 显示已经创建的函数，创建时的语句 SHOW CREATE FUNCTION func_name  # 显示已经创建的存储过程，创建时的语句 SHOW CREATE PROCEDURE proc_name  # 显示已经创建的表，创建时的语句 SHOW CREATE TABLE tbl_name  # 显示已经创建的触发器，创建时的语句 SHOW CREATE TRIGGER trigger_name  # 显示已经创建的视图，创建时的语句 SHOW CREATE VIEW view_name  # 显示mysql中所有数据库的名称 SHOW DATABASES [like_or_where]  # 显示存储引擎的详细信息 SHOW ENGINE engine_name {STATUS | MUTEX}  # 显示数据库支持的存储引擎和默认存储引擎 SHOW [STORAGE] ENGINES  # 显示最后一个执行语句所产生的错误信息 SHOW ERRORS [LIMIT [offset,] row_count]  # 显示事件信息 SHOW EVENTS  # 服务器内部调试，显示一个指定存储的内部实现的表示形式过程 SHOW FUNCTION CODE func_name  # 显示存储函数信息（需要先创建存储函数） SHOW FUNCTION STATUS [like_or_where]  # 显示指定用户拥有的权限 SHOW GRANTS FOR user  # 显示表索引信息（需要先创建索引） SHOW INDEX FROM tbl_name [FROM db_name]  # 显示Master当前正在使用的二进制信息 SHOW MASTER STATUS  # 列举在表缓存中当前被打开的非TEMPORARY表 SHOW OPEN TABLES [FROM db_name] [like_or_where]  # 显示MySQL插件信息 SHOW PLUGINS  # 服务器内部调试，显示一个指定存储的内部实现的表示形式过程 SHOW PROCEDURE CODE proc_name  # 显示存储过程信息（需要先创建存储过程） SHOW PROCEDURE STATUS [like_or_where]  # 显示MySQL所支持的所有权限，及权限可操作的对象 SHOW PRIVILEGES  # 显示系统中正在运行的所有进程，普通用户只能查看自己的进行信息 SHOW [FULL] PROCESSLIST  # 显示当前会话执行语句资源使用情况 SHOW PROFILE [types] [FOR QUERY n] [OFFSET n] [LIMIT n]  # 显示当前会话执行语句资源使用情况 SHOW PROFILES  # 显示relaylog事件信息（需要先做主从复制） SHOW RELAYLOG EVENTS [IN \u0026#39;log_name\u0026#39;] [FROM pos] [LIMIT [offset,] row_count]  # 显示Master主机上已注册的复制主机列表（需要先做主从复制） SHOW SLAVE HOSTS  # 显示Slave主机状态信息（需要先做主从复制） SHOW SLAVE STATUS [FOR CHANNEL channel]  # 显示MySQL状态信息 SHOW [GLOBAL | SESSION] STATUS [like_or_where]  # 显示表属性信息 SHOW TABLE STATUS [FROM db_name] [like_or_where]  # 显示当前数据库中所有表的名称 SHOW [FULL] TABLES [FROM db_name] [like_or_where]  # 显示触发器信息（需要先创建触发器） SHOW TRIGGERS [FROM db_name] [like_or_where]  # 显示MySQL变量信息 SHOW [GLOBAL | SESSION] VARIABLES [like_or_where]  # 显示最后一个执行语句所产生的警告信息 SHOW WARNINGS [LIMIT [offset,] row_count] ","title":"MySQL SHOW"},{"content":"UPDATE 用于修改或更新数据库中表的数据。\n修改表中的数据 mysql\u0026gt; update rainy set name=\u0026#39;zhu\u0026#39;where id=1; Query OK, 2 rows affected (0.03 sec) Rows matched: 2 Changed: 2 Warnings: 0 修改后重新查询表中的数据：\nmysql\u0026gt; select * from rainy; +------+------+ | id | name | +------+------+ | 1 | zhu | | 1 | zhu | +------+------+ 2 rows in set (0.00 sec) ","permalink":"https://note.yxzi.xyz/note/technology/mysql/dml/update/","summary":"UPDATE 用于修改或更新数据库中表的数据。\n修改表中的数据 mysql\u0026gt; update rainy set name=\u0026#39;zhu\u0026#39;where id=1; Query OK, 2 rows affected (0.03 sec) Rows matched: 2 Changed: 2 Warnings: 0 修改后重新查询表中的数据：\nmysql\u0026gt; select * from rainy; +------+------+ | id | name | +------+------+ | 1 | zhu | | 1 | zhu | +------+------+ 2 rows in set (0.00 sec) ","title":"MySQL UPDATE"},{"content":"函数 函数之间可以嵌套\n语法 SELECT 函数名(实参列表,表名) 单行函数 主要用于处理数据，传入一个参数，返回一个值。\n 字符函数，传入的参数为字符串类型。 数学函数，传入的参数为数字类型。 日期函数，传入的参数为日期类型。 其他函数 流程控制函数，可以实现一些分支结构。  分组函数 主要用于统计数据，传入一组参数，并返回一个值，也叫统计函数、组函数、聚合函数。\n","permalink":"https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/","summary":"函数 函数之间可以嵌套\n语法 SELECT 函数名(实参列表,表名) 单行函数 主要用于处理数据，传入一个参数，返回一个值。\n 字符函数，传入的参数为字符串类型。 数学函数，传入的参数为数字类型。 日期函数，传入的参数为日期类型。 其他函数 流程控制函数，可以实现一些分支结构。  分组函数 主要用于统计数据，传入一组参数，并返回一个值，也叫统计函数、组函数、聚合函数。","title":"MySQL 函数"},{"content":"数学函数 用于对数字进行处理，或者返回一个数值。\nROUND(X,D) 计算将 X 四舍五入后，保留 D 位小数后的值。\nSELECT ROUND(45.4) CEIL(X) 计算将 X 向上取整后的值，这个值 \u0026gt;= X 的最小整数。\nSELECT CEIL(1.52) # 返回 1 SELECT CEIL(1) FLOOR(X) 计算将 X 向下取整后的值，这个值 \u0026lt;= X 的最大整数。\nSELECT FLOOR(1.2) # 返回 1 SELECT FLOOR(9.9) TRUNCATE(X,D) 不将 X 进行四舍五入，直接保留 D 位小数，或者说是直接截断。\nSELECT TRUNCATE(1.69999,2) MOD(N,M) 计算用 N 除以 M 的余数，相当于 N % M。\n但%实际上的计算过程是N - (N/M*M)。\nSELECT MOD(10,3) # 相当于 SELECT 10 % 3 ","permalink":"https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/","summary":"数学函数 用于对数字进行处理，或者返回一个数值。\nROUND(X,D) 计算将 X 四舍五入后，保留 D 位小数后的值。\nSELECT ROUND(45.4) CEIL(X) 计算将 X 向上取整后的值，这个值 \u0026gt;= X 的最小整数。\nSELECT CEIL(1.52) # 返回 1 SELECT CEIL(1) FLOOR(X) 计算将 X 向下取整后的值，这个值 \u0026lt;= X 的最大整数。\nSELECT FLOOR(1.2) # 返回 1 SELECT FLOOR(9.9) TRUNCATE(X,D) 不将 X 进行四舍五入，直接保留 D 位小数，或者说是直接截断。\nSELECT TRUNCATE(1.69999,2) MOD(N,M) 计算用 N 除以 M 的余数，相当于 N % M。\n但%实际上的计算过程是N - (N/M*M)。\nSELECT MOD(10,3) # 相当于 SELECT 10 % 3 ","title":"MySQL 数学函数"},{"content":"日期函数 用于对日期进行处理，或者返回一个日期的值。\n日期格式符号    格式符 功能     %Y 四位的年份   %y 两位的年份   %m 月份(01 - 12)   %c 月份(1 - 12)   %d 日(01, 02, …)   %H 小时(24 小时制)   %h 小时(12 小时制)   %i 分钟(00 - 59)   %s 秒(00 - 59)   %U 星期(0 - 52)，星期天为第一天   %u 星期(0 - 52)，星期一为第一天   %W 星期英文(Sunday — Saturday)   %M 月份英文(January — December)    NOW() 返回系统当前的日期和时间。\nSELECT NOW() CURDATE() 返回系统当前的日期，不包含时间。\nSELECT CURDATE() CURTIME() 返回系统当前的时间，不包含日期。\nSELECT CURTIME() 年月日时分秒 # 返回系统当前的年份 SELECT YEAR(\u0026#39;2001-12-18\u0026#39;) # 返回系统当前的月份，月份用数字显示 SELECT MONTH(\u0026#39;2001-12-18\u0026#39;) # 返回系统当前的月份，月份用英文显示 SELECT MONTHNAME(\u0026#39;2001-12-18\u0026#39;) # 返回系统当前的日份 SELECT DAY(\u0026#39;2001-12-18\u0026#39;) # 返回系统当前的小时数 SELECT HOUR(\u0026#39;19:23:33\u0026#39;) # 返回系统当前的分钟数 SELECT MINUTE(\u0026#39;19:23:33\u0026#39;) # 返回系统当前的秒数 SELECT SECOND(\u0026#39;19:23:33\u0026#39;) STR_TO_DATE(str,format) 通过指定的 format 将 str 转换为日期。\nSELECT STR_TO_DATE(\u0026#39;2001-12-18\u0026#39;,\u0026#39;%Y-%c-%d\u0026#39;); 查询入职日期为 1992-4-3 的员工 SELECT * FROM employees WHERE # 通过指定的格式将字符串转换为日期 hiredate = STR_TO_DATE(\u0026#39;1992.4.3\u0026#39;,\u0026#39;%Y.%c.%d\u0026#39;); DATE_FORMAT(date,format) 将日期以特定的格式转换为字符。\nSELECT DATE_FORMAT(\u0026#39;1992-12-18\u0026#39;,\u0026#39;%Y年%c月%d日\u0026#39;) 查询有奖金的员工名和入职日期，日期格式为：xx 月/xx 日 xx 年 SELECT last_name,DATE_FORMAT(hiredate,\u0026#39;%c月%d日 %y年\u0026#39;) FROM employees WHERE commission_pct IS NOT NULL ","permalink":"https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0/","summary":"日期函数 用于对日期进行处理，或者返回一个日期的值。\n日期格式符号    格式符 功能     %Y 四位的年份   %y 两位的年份   %m 月份(01 - 12)   %c 月份(1 - 12)   %d 日(01, 02, …)   %H 小时(24 小时制)   %h 小时(12 小时制)   %i 分钟(00 - 59)   %s 秒(00 - 59)   %U 星期(0 - 52)，星期天为第一天   %u 星期(0 - 52)，星期一为第一天   %W 星期英文(Sunday — Saturday)   %M 月份英文(January — December)    NOW() 返回系统当前的日期和时间。","title":"MySQL 日期函数"},{"content":"模糊查询 LIKE 查询某个字段中所有包含单个或多个字符的数据\n查询员工名中第三个字符为 n，第五个字符为 l 的员工名和工资 _通配符，表示匹配任意单个字符。\nSELECT last_name, salary FROM employees WHERE last_name LIKE # 第三个字符为 n，第五个字符为 l 的数据 \u0026#39;__n_l%\u0026#39;; 查询员工名中第二个字符为 _ 的员工名 \\转义字符，表示特殊的控制意义，一般用于格式控制。\nSELECT last_name, salary FROM employees WHERE last_name LIKE \u0026#39;_\\_%\u0026#39;; ESCAPE关键字可以让我们自定义转义字符。\nSELECT last_name, salary FROM employees WHERE last_name LIKE \u0026#39;_$_%\u0026#39; # 自定义一个转义字符 $ ESCAPE \u0026#39;$\u0026#39;; 查询员工名中包含字符 a 的员工信息 %通配符，表示匹配任意多个字符，且包含 0 个字符。\nSELECT * FROM employees WHERE last_name LIKE # % 表示匹配任意内容的意思 # 这里的 % 表示匹配 a 字符前面和后面都有任意字符的数据 \u0026#39;%a%\u0026#39;; BETWEEN AND 查询某个字段中所有在\u0026hellip;和\u0026hellip;之间的数据。\n可以提高语句简洁度。\n包含两个临界值。\n查询员工编号在 100 - 120 之间的员工信息 方式一（推荐）\nSELECT * FROM employees WHERE employee_id BETWEEN 100 AND 120; 方式二\nSELECT * FROM employees WHERE employee_id \u0026gt;= 100 AND employee_id \u0026lt;= 120; IN 查询某个字段中所有等于 in 列表中指定字符串的数据。\n可以提高语句简洁的。\nin 列表中的值的类型必须统一。\nin 列表中的字符串不支持通配符。\n查询员工的工种编号是 IT _PROG、AD_VP、AD_PRES 中的一个员工名和工种编号 方式一（推荐）\nSELECT last_name, job_id FROM employees WHERE job_id in (\u0026#39;IT_PROT\u0026#39;,\u0026#39;AD_VP\u0026#39;,\u0026#39;AD_PRES\u0026#39;); 方式二\nSELECT last_name, job_id FROM employees WHERE job_id = \u0026#39;IT_PROT\u0026#39; OR job_id = \u0026#39;AD_VP\u0026#39; OR job_id = \u0026#39;AD_PRES\u0026#39;; IS NULL 查询某个字段中所有等于 Null 的数据。\n因为在 MySQL 中， = 和\u0026lt;\u0026gt; 不能判断Null，也就是不能写成= Null或 \u0026lt;\u0026gt; Null，\n所以只能用is Null来判断某个字段中的数据是否等于Null\n查询没有奖金的员工名和奖金率 SELECT last_name, commission_pct FROM employees WHERE commission_pct IS NULL # 安全等于 # commission_pct \u0026lt;=\u0026gt; NULL IS NOT NULL 查询某个字段中所有不等于 Null 的数据。\nSELECT last_name, commission_pct FROM employees WHERE commission_pct IS NOT NULL \u0026lt;=\u0026gt;（不推荐使用） 安全等于，它既可以判断 NULL 值，又可以判断普通的数值。但是该运算符的可读性较差，\nSELECT last_name, commission_pct FROM employees WHERE commission_pct \u0026lt;=\u0026gt; NULL ","permalink":"https://note.yxzi.xyz/note/technology/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/","summary":"模糊查询 LIKE 查询某个字段中所有包含单个或多个字符的数据\n查询员工名中第三个字符为 n，第五个字符为 l 的员工名和工资 _通配符，表示匹配任意单个字符。\nSELECT last_name, salary FROM employees WHERE last_name LIKE # 第三个字符为 n，第五个字符为 l 的数据 \u0026#39;__n_l%\u0026#39;; 查询员工名中第二个字符为 _ 的员工名 \\转义字符，表示特殊的控制意义，一般用于格式控制。\nSELECT last_name, salary FROM employees WHERE last_name LIKE \u0026#39;_\\_%\u0026#39;; ESCAPE关键字可以让我们自定义转义字符。\nSELECT last_name, salary FROM employees WHERE last_name LIKE \u0026#39;_$_%\u0026#39; # 自定义一个转义字符 $ ESCAPE \u0026#39;$\u0026#39;; 查询员工名中包含字符 a 的员工信息 %通配符，表示匹配任意多个字符，且包含 0 个字符。\nSELECT * FROM employees WHERE last_name LIKE # % 表示匹配任意内容的意思 # 这里的 % 表示匹配 a 字符前面和后面都有任意字符的数据 \u0026#39;%a%\u0026#39;; BETWEEN AND 查询某个字段中所有在\u0026hellip;和\u0026hellip;之间的数据。","title":"MySQL 模糊查询"},{"content":"流程控制函数 IF IF(expr1,expr2,expr3) 如果 expr1 为 true，则返回 expr2 的值，否则返回 expr3 的值。\nSELECT IF(10\u0026gt;5,\u0026#39;大\u0026#39;,\u0026#39;小\u0026#39;) 查询所有员工是否都有奖金 SELECT last_name,commission_pct,IF(commission_pct IS NOT NULL,\u0026#39;有奖金\u0026#39;,\u0026#39;无奖金\u0026#39;) AS 有无奖金 FROM employees CASE 它可以当成语句用，也可以当作表达式用。\n他有两种用法，第一种用法类似于 switch 语句；第二种用法类似于 多重 if 语句。\n查询员工的工资，要求： 部门号 = 30，显示原工资的 1.1 倍。\n部门号 = 40，显示原工资的 1.2 倍。\n部门号 = 50，显示原工资的 1.3 倍。\n其他部门，显示原工资。\nSELECT salary, department_id, # 如果 department_id 等于下面 WHEN 后面的任意值，则执行这个值对应的 THEN 后面的语句。 CASE department_id \tWHEN 30\tTHEN salary * 1.1 \tWHEN 40 THEN salary * 1.2 \tWHEN 50 THEN salary * 1.3 \t# department_id 不等于 以上值的数据，则执行 ELSE 后面的语句 \tELSE salary END AS 新工资 FROM employees; 查询员工工资的情况 如果部门工资 \u0026gt; 20000，则显示 A 等级\n如果部门工资 \u0026gt; 15000，则显示 B 等级\n如果部门工资 \u0026gt; 10000，则显示 C 等级\nSELECT salary, CASE WHEN salary \u0026gt; 20000 THEN \u0026#39;A\u0026#39; WHEN salary \u0026gt; 15000 THEN \u0026#39;B\u0026#39; WHEN salary \u0026gt; 10000 THEN \u0026#39;C\u0026#39; ELSE \u0026#39;D\u0026#39; END AS 工资等级 FROM employees; ","permalink":"https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0/","summary":"流程控制函数 IF IF(expr1,expr2,expr3) 如果 expr1 为 true，则返回 expr2 的值，否则返回 expr3 的值。\nSELECT IF(10\u0026gt;5,\u0026#39;大\u0026#39;,\u0026#39;小\u0026#39;) 查询所有员工是否都有奖金 SELECT last_name,commission_pct,IF(commission_pct IS NOT NULL,\u0026#39;有奖金\u0026#39;,\u0026#39;无奖金\u0026#39;) AS 有无奖金 FROM employees CASE 它可以当成语句用，也可以当作表达式用。\n他有两种用法，第一种用法类似于 switch 语句；第二种用法类似于 多重 if 语句。\n查询员工的工资，要求： 部门号 = 30，显示原工资的 1.1 倍。\n部门号 = 40，显示原工资的 1.2 倍。\n部门号 = 50，显示原工资的 1.3 倍。\n其他部门，显示原工资。\nSELECT salary, department_id, # 如果 department_id 等于下面 WHEN 后面的任意值，则执行这个值对应的 THEN 后面的语句。 CASE department_id \tWHEN 30\tTHEN salary * 1.1 \tWHEN 40 THEN salary * 1.","title":"MySQL 流程控制函数"},{"content":"ALTER 修改数据表名或者修改数据表的字段.\n修改表名 ALTER TABLE 旧表名 RENAME 新表名。\nALTER TABLE rainy RENAME Su; 修改字段 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型。\nALTER TABLE su CHANGE rainy apple VARCHAR(20); 修改字段的排列位置 ALTER TABLE 表名 MODIFY 字段名 1 VARCHAR(20) AFTER 字段名 2;\nALTER TABLE su MODIFY rainy VARCHAR(20) AFTER two; 删除字段 ","permalink":"https://note.yxzi.xyz/note/technology/mysql/ddl/alter/","summary":"ALTER 修改数据表名或者修改数据表的字段.\n修改表名 ALTER TABLE 旧表名 RENAME 新表名。\nALTER TABLE rainy RENAME Su; 修改字段 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型。\nALTER TABLE su CHANGE rainy apple VARCHAR(20); 修改字段的排列位置 ALTER TABLE 表名 MODIFY 字段名 1 VARCHAR(20) AFTER 字段名 2;\nALTER TABLE su MODIFY rainy VARCHAR(20) AFTER two; 删除字段 ","title":"MySQL ALTER"},{"content":"分组函数 与分组函数一同查询的字段要求是GROUP BY后的字段。\nSUM 统计表中字段的和。\n一般用于处理数值类型，计算时会忽略 NULL 值。\nSELECT SUM(salary) FROM employees; AVG 统计表中字段的平均值。\n一般用于处理数值类型，计算时会忽略 NULL 值。\nSELECT AVG(salary) FROM employees; MAX 统计表中字段的最大值，可以处理任何数据类型，计算时会忽略 NULL 值。\nSELECT MAX(salary) FROM employees; MIN 统计表中字段的最小值，可以处理任何数据类型，计算时会忽略 NULL 值。\nSELECT MIN(salary) FROM employees; COUNT 统计表的行数，可以处理任何数据类型，计算时会忽略 NULL 值。\n查询总行数 SELECT COUNT(*)FROM employees ","permalink":"https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/","summary":"分组函数 与分组函数一同查询的字段要求是GROUP BY后的字段。\nSUM 统计表中字段的和。\n一般用于处理数值类型，计算时会忽略 NULL 值。\nSELECT SUM(salary) FROM employees; AVG 统计表中字段的平均值。\n一般用于处理数值类型，计算时会忽略 NULL 值。\nSELECT AVG(salary) FROM employees; MAX 统计表中字段的最大值，可以处理任何数据类型，计算时会忽略 NULL 值。\nSELECT MAX(salary) FROM employees; MIN 统计表中字段的最小值，可以处理任何数据类型，计算时会忽略 NULL 值。\nSELECT MIN(salary) FROM employees; COUNT 统计表的行数，可以处理任何数据类型，计算时会忽略 NULL 值。\n查询总行数 SELECT COUNT(*)FROM employees ","title":"MySQL 分组函数"},{"content":"字符函数 用于对字符进行处理，并返回一个字符串值。\n字符串的索引都是从 1 开始的。\nLENGTH(str) 返回 str 的字节长度。\n在不同的字符集中，一个汉字和一个英文字母的字节长度都是不一样的。\nSELECT # 在 uft-8 字符集中，一个英文和一个空格只占一个字符，一个汉字占三个字节 LENGTH(\u0026#39;Rainy 是憨憨\u0026#39;) AS 字符长度; CONCAT(str1,str2,\u0026hellip;) 将 str 1 与 str2 拼接起来，支持多个字符串。\nSELECT CONCAT(last_name,\u0026#39;-\u0026#39;,first_name) AS 姓名 FROM employees; UPPER(str) 将 str 中的小写字母转为大写字母。\nSELECT UPPER(\u0026#39;rainy\u0026#39;) AS 转大写 LOWER(str) 将 str 中的大写字母转为小写字母。\nSELECT LOWER(\u0026#39;RAINY\u0026#39;) AS 转小写 SUBSTR(str FROM pos FOR len) 指定一个 str，从索引为 pot 的字符开始截取，一直截取到索引 len 的字符为止。若只有 pot ，则截取到最后，\nSELECT SUBSTR(\u0026#39;臣世雨是个憨憨\u0026#39;,6) AS 截取至最后, SUBSTR(\u0026#39;臣世雨是个憨憨\u0026#39;,4,6) AS 截取至指定位置 INSTR(str,substr) 返回 substr 在 str 中第一次出现的索引，如果 str 中不存在 substr，则返回 0。\nSELECT INSTR(\u0026#39;臣世雨是个憨憨\u0026#39;,\u0026#39;憨憨\u0026#39;); TRIM([remstr FROM] str) 过滤 str 中的 remstr 字符串，默认过滤的是首尾的空格。\nLEADING 是过滤首字符。\nBOTH 过滤首尾字符。\nTRAILING 过滤 尾字符。\n# 默认过滤空格 SELECT TRIM(\u0026#39; 臣世雨 \u0026#39;);  # 相当于： # 过滤指定的首字符 a SELECT TRIM(LEADING \u0026#39;a\u0026#39; FROM \u0026#39;aaaRainybbb\u0026#39;);  # 过滤指定的首尾字符 a SELECT TRIM(BOTH \u0026#39;a\u0026#39; FROM \u0026#39;aaaRainyaaa\u0026#39;); # 也可以省去 BOTH 关键字，也是去掉前后的字符。 SELECT TRIM(\u0026#39;a\u0026#39; FROM \u0026#39;aaaRainyaaa\u0026#39;);  # 过滤指定的尾字符 b SELECT TRIM(TRAILING \u0026#39;b\u0026#39; FROM \u0026#39;aaaRainybbb\u0026#39;); LPAD(str,len,padstr) 在 str 的左侧重复插入 padstr，直到字符串总长度达到 len 为止。\n# 总字符长度未达到 len ，则重复插入 padstr SELECT LPAD(\u0026#39;原字符\u0026#39;,5,\u0026#39;新的\u0026#39;)  # 插入 padstr 后，总字符长度达到len 就停止了 SELECT LPAD(\u0026#39;原字符\u0026#39;,5,\u0026#39;这是新的\u0026#39;) RPAD(str,len,padstr) 在 str 的右侧重复插入 padstr，直到字符串总长度达到 len 为止。\nSELECT RPAD(\u0026#39;原字符\u0026#39;,5,\u0026#39;是新的\u0026#39;)  SELECT RPAD(\u0026#39;原字符\u0026#39;,5,\u0026#39;是很新的\u0026#39;) REPLACE(str,from_str,to_str) 将 str 中的 from_str 替换 to_str\nSELECT REPLACE(\u0026#39;字符呀\u0026#39;,\u0026#39;呀\u0026#39;,\u0026#39;串\u0026#39;) ","permalink":"https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0/","summary":"字符函数 用于对字符进行处理，并返回一个字符串值。\n字符串的索引都是从 1 开始的。\nLENGTH(str) 返回 str 的字节长度。\n在不同的字符集中，一个汉字和一个英文字母的字节长度都是不一样的。\nSELECT # 在 uft-8 字符集中，一个英文和一个空格只占一个字符，一个汉字占三个字节 LENGTH(\u0026#39;Rainy 是憨憨\u0026#39;) AS 字符长度; CONCAT(str1,str2,\u0026hellip;) 将 str 1 与 str2 拼接起来，支持多个字符串。\nSELECT CONCAT(last_name,\u0026#39;-\u0026#39;,first_name) AS 姓名 FROM employees; UPPER(str) 将 str 中的小写字母转为大写字母。\nSELECT UPPER(\u0026#39;rainy\u0026#39;) AS 转大写 LOWER(str) 将 str 中的大写字母转为小写字母。\nSELECT LOWER(\u0026#39;RAINY\u0026#39;) AS 转小写 SUBSTR(str FROM pos FOR len) 指定一个 str，从索引为 pot 的字符开始截取，一直截取到索引 len 的字符为止。若只有 pot ，则截取到最后，\nSELECT SUBSTR(\u0026#39;臣世雨是个憨憨\u0026#39;,6) AS 截取至最后, SUBSTR(\u0026#39;臣世雨是个憨憨\u0026#39;,4,6) AS 截取至指定位置 INSTR(str,substr) 返回 substr 在 str 中第一次出现的索引，如果 str 中不存在 substr，则返回 0。","title":"MySQL 字符函数"},{"content":"排序查询 语法 SELECT 查询列表 FROM 表名 WHERE 筛选条件 ORDER BY 排序列表 ASC DESC 升序/降序 特点  ASC 代表升序，DESC 代表降序，如果不写，则默认是升序。 支持单个字段、多个字段、表达式、函数、别名等。 一般放在查询语句的最后面，limit 语句除外。  按字段排序 查询员工信息，并按工资从高至低排序 SELECT * FROM employees WHERE salary # 降序 用 DESC ，升序用 ASC ORDER BY salary DESC; 按多个字段排序 查询员工信息，并先按工资升序，再按员工编号降序 如果有两种排序规则，若第一种排序规则中有相同的数据，那么这两个数据应该哪个在前，哪个在后呢？这时候会按照第二种排序规则进行排序，决定第一种排序规则中的相同数据的先后顺序。\nSELECT *, salary AS 工资, employee_id AS 员工编号 FROM employees ORDER BY salary ASC,employee_id DESC; 按表达式排序 查询部门编号 \u0026gt;= 90 的员工信息，并按入职的先后顺序排序 SELECT * FROM employees WHERE department_id \u0026gt;= 90 # 降序 用 DESC ，升序用 ASC ORDER BY salary ASC; 按表达式排序 SELECT *, # 因为表中没有年薪这个字段，所以我们需要用表达式来计算每个员工的年薪 salary * 12*(1 + IFNULL(commission_pct,0)) AS 年薪 FROM employees ORDER BY salary * 12*(1 + IFNULL(commission_pct,0)) DESC; 按别名排序 查询员工的信息和年薪，并按年薪的高低排序 SELECT *, # 因为表中没有年薪这个字段，所以我们需要用表达式来计算每个员工的年薪 salary * 12*(1 + IFNULL(commission_pct,0)) AS 年薪 FROM employees # 用表达式所对应的别名来替代表达式，使得语句更好理解 ORDER BY 年薪 DESC; 按函数排序 查询远东的姓名和工资，并按姓的字节长度从多到少排序 SELECT LENGTH(last_name) AS 字节长度, last_name,salary FROM employees ORDER BY LENGTH(last_name) DESC;  ","permalink":"https://note.yxzi.xyz/note/technology/mysql/dql/%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/","summary":"排序查询 语法 SELECT 查询列表 FROM 表名 WHERE 筛选条件 ORDER BY 排序列表 ASC DESC 升序/降序 特点  ASC 代表升序，DESC 代表降序，如果不写，则默认是升序。 支持单个字段、多个字段、表达式、函数、别名等。 一般放在查询语句的最后面，limit 语句除外。  按字段排序 查询员工信息，并按工资从高至低排序 SELECT * FROM employees WHERE salary # 降序 用 DESC ，升序用 ASC ORDER BY salary DESC; 按多个字段排序 查询员工信息，并先按工资升序，再按员工编号降序 如果有两种排序规则，若第一种排序规则中有相同的数据，那么这两个数据应该哪个在前，哪个在后呢？这时候会按照第二种排序规则进行排序，决定第一种排序规则中的相同数据的先后顺序。\nSELECT *, salary AS 工资, employee_id AS 员工编号 FROM employees ORDER BY salary ASC,employee_id DESC; 按表达式排序 查询部门编号 \u0026gt;= 90 的员工信息，并按入职的先后顺序排序 SELECT * FROM employees WHERE department_id \u0026gt;= 90 # 降序 用 DESC ，升序用 ASC ORDER BY salary ASC; 按表达式排序 SELECT *, # 因为表中没有年薪这个字段，所以我们需要用表达式来计算每个员工的年薪 salary * 12*(1 + IFNULL(commission_pct,0)) AS 年薪 FROM employees ORDER BY salary * 12*(1 + IFNULL(commission_pct,0)) DESC; 按别名排序 查询员工的信息和年薪，并按年薪的高低排序 SELECT *, # 因为表中没有年薪这个字段，所以我们需要用表达式来计算每个员工的年薪 salary * 12*(1 + IFNULL(commission_pct,0)) AS 年薪 FROM employees # 用表达式所对应的别名来替代表达式，使得语句更好理解 ORDER BY 年薪 DESC; 按函数排序 查询远东的姓名和工资，并按姓的字节长度从多到少排序 SELECT LENGTH(last_name) AS 字节长度, last_name,salary FROM employees ORDER BY LENGTH(last_name) DESC;  ","title":"MySQL 排序查询"},{"content":"二叉树的节点数量 递归法  判断根节点是否有左右子节点，有则递归调用NodeNum()，则子节点 + 1。 左右子节点数量加上根节点数量。  ·include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 定义节点 typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }   // *p：根节点 int NodeNum(node *p) {  // 节点总数  int nums;   // 左节点数量  int left = 0;   // 右节点数量  int right = 0;   // 有左节点  if (p-\u0026gt;lchild)  {  // 左节点 + 1  left = NodeNum(p-\u0026gt;lchild);  }  // 有右节点  if (p-\u0026gt;rchild)  {  // 右节点 + 1  right = NodeNum(p-\u0026gt;rchild);  }  // 左右节点数量加上根节点数量  // 这个 + 1 很重要，因为每次调用 NodeNum()，就说明有节点，则 nums + 1。  nums = left + right + 1;  return nums; }   int main(void) {  // 构建二叉树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);   int num = NodeNum(t);  printf(\u0026#34;二叉树的结点个数为：%d\\n\u0026#34;,num);  return 0; } ","permalink":"https://note.yxzi.xyz/note/technology/datastructure/algorithm/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E9%87%8F/","summary":"二叉树的节点数量 递归法  判断根节点是否有左右子节点，有则递归调用NodeNum()，则子节点 + 1。 左右子节点数量加上根节点数量。  ·include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 定义节点 typedef struct node {  int data;  struct node *lchild, *rchild; } n;  // 创建一个节点 node * get_a_node(int data) {  node *c = (node *)malloc(sizeof(node));  c-\u0026gt;data = data;  c-\u0026gt;lchild = 0;  c-\u0026gt;rchild = 0;  return c; }   // *p：根节点 int NodeNum(node *p) {  // 节点总数  int nums;   // 左节点数量  int left = 0;   // 右节点数量  int right = 0;   // 有左节点  if (p-\u0026gt;lchild)  {  // 左节点 + 1  left = NodeNum(p-\u0026gt;lchild);  }  // 有右节点  if (p-\u0026gt;rchild)  {  // 右节点 + 1  right = NodeNum(p-\u0026gt;rchild);  }  // 左右节点数量加上根节点数量  // 这个 + 1 很重要，因为每次调用 NodeNum()，就说明有节点，则 nums + 1。  nums = left + right + 1;  return nums; }   int main(void) {  // 构建二叉树  node *t = get_a_node(1);  t-\u0026gt;lchild = get_a_node(2);  t-\u0026gt;rchild = get_a_node(3);  t-\u0026gt;lchild-\u0026gt;rchild = get_a_node(5);  t-\u0026gt;rchild-\u0026gt;rchild = get_a_node(7);  t-\u0026gt;rchild-\u0026gt;rchild-\u0026gt;lchild = get_a_node(14);   int num = NodeNum(t);  printf(\u0026#34;二叉树的结点个数为：%d\\n\u0026#34;,num);  return 0; } ","title":"二叉树的节点数量"},{"content":"启动 MySQL 使用命令行 Window 操作系统中 Ctrl + Alt 打开 CMD，通过下面两条命令启动或关闭 MySQL\nnet start mysql # 启动 MySQL net stop mysql # 关闭 MySQL 提示服务名无效 C:\\Windows\\system32\u0026gt;net start mysql 服务名无效。  请键入 NET HELPMSG 2185 以获得更多的帮助。 在 MySQL 安装目录下的 bin 目录下打开管理员的 cmd，并输入命令**.\\mysqld.exe install**，回车即可：\nD:\\AppInstallPath\\PhpStudy\\phpstudy_pro\\Extensions\\MySQL5.7.26\\bin\u0026gt;.\\mysqld.exe install Service successfully installed. 使用 PHPStudy 首页，直接启动 MySQL 即可，如果提示端口被占用，修改端口号即可。\n登录服务端 隐藏密码登录 MySQL -h localhost -P 3306 -u root -p -h表示主机。\n-P表示端口号。\n-u表示用户名。\n-p表示密码。\n输入命令后 Enter。\nMySQL -h localhost -P 3306 -u root -p Enter password: 输入密码，登录成功。\nMySQL -h localhost -P 3306 -u root -p Enter password: ****** Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 3 Server version: 5.7.26 MySQL Community Server (GPL) ....... 显示密码登录 当然，我们也可以直接以显示密码的方式登录：\nMySQL -h localhost -P 3306 -u root -p123456 上面的命令可以简写为：\nMySQL -u root -p123456 注意，这里的-p123456是不能有空格的。\n\u0026gt;MySQL -h localhost -P 3306 -u root -p123456 MySQL: [Warning] Using a password on the command line interface can be insecure. Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 4 Server version: 5.7.26 MySQL Community Server (GPL) MySQL 会提示我们用这种方式登录服务端是不安全的，所以还是建议使用第一种方式登录服务端。\n退出服务端 使用exit命令或者 Ctrl + C。\nmysql\u0026gt; exit Bye ","permalink":"https://note.yxzi.xyz/note/technology/mysql/%E5%90%AF%E5%8A%A8-mysql-/","summary":"启动 MySQL 使用命令行 Window 操作系统中 Ctrl + Alt 打开 CMD，通过下面两条命令启动或关闭 MySQL\nnet start mysql # 启动 MySQL net stop mysql # 关闭 MySQL 提示服务名无效 C:\\Windows\\system32\u0026gt;net start mysql 服务名无效。  请键入 NET HELPMSG 2185 以获得更多的帮助。 在 MySQL 安装目录下的 bin 目录下打开管理员的 cmd，并输入命令**.\\mysqld.exe install**，回车即可：\nD:\\AppInstallPath\\PhpStudy\\phpstudy_pro\\Extensions\\MySQL5.7.26\\bin\u0026gt;.\\mysqld.exe install Service successfully installed. 使用 PHPStudy 首页，直接启动 MySQL 即可，如果提示端口被占用，修改端口号即可。\n登录服务端 隐藏密码登录 MySQL -h localhost -P 3306 -u root -p -h表示主机。\n-P表示端口号。\n-u表示用户名。\n-p表示密码。\n输入命令后 Enter。\nMySQL -h localhost -P 3306 -u root -p Enter password: 输入密码，登录成功。","title":"启动 MySQL"},{"content":"Null 二进制全部为零时有几种含义，为什么会有几种含义呢，这是因为解码的方式不同：\n 数值零。（数值解码） 字符串结束标记符'\\0'（字母解码） 空指针Null，此时的Null本质也是零，但这个零不代表数字 0：int i = 0，而表示某个内存单元的地址为零（地址解码）  另外，我们计算机规定，以零（Null）为地址的储存单元的内容不可读，也不可写。\n","permalink":"https://note.yxzi.xyz/note/technology/language/c/null/","summary":"Null 二进制全部为零时有几种含义，为什么会有几种含义呢，这是因为解码的方式不同：\n 数值零。（数值解码） 字符串结束标记符'\\0'（字母解码） 空指针Null，此时的Null本质也是零，但这个零不代表数字 0：int i = 0，而表示某个内存单元的地址为零（地址解码）  另外，我们计算机规定，以零（Null）为地址的储存单元的内容不可读，也不可写。","title":"C Null"},{"content":"分配内存和释放内存 分配内存 操作系统会将某一块内存空间的控制权限，交给程序。\n释放内存 释放内存，可以用 C 语言中的free();函数来实现。\n程序会将某一块内存空间的控制权限，交还给操作系统，使得这个程序无法对这块区域进行操作。而不是将这一块内存空间中的数据清空。\n","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E5%92%8C%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98/","summary":"分配内存和释放内存 分配内存 操作系统会将某一块内存空间的控制权限，交给程序。\n释放内存 释放内存，可以用 C 语言中的free();函数来实现。\n程序会将某一块内存空间的控制权限，交还给操作系统，使得这个程序无法对这块区域进行操作。而不是将这一块内存空间中的数据清空。","title":"C 分配内存和释放内存"},{"content":"变量为什么要初始化 初始化，也叫赋值，变量不进行初始化，那么这个变量中所存放的数据就是垃圾值。\n垃圾值 垃圾值（随机值）指的是其他程序使用某个内存空间所遗留下来的值。\nVC++ 若发现某个变量的内存空间内有垃圾值（即该变量没进行初化），那么它会将该垃圾值替换为填充值。目的是为了避免开发者将垃圾值当做一个正常值来使用，也就是提醒开发者这个变量没有进行初始化。因此，变量若未进行初始化，该变量的内存空间内存放的是一个垃圾值。\n","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96/","summary":"变量为什么要初始化 初始化，也叫赋值，变量不进行初始化，那么这个变量中所存放的数据就是垃圾值。\n垃圾值 垃圾值（随机值）指的是其他程序使用某个内存空间所遗留下来的值。\nVC++ 若发现某个变量的内存空间内有垃圾值（即该变量没进行初化），那么它会将该垃圾值替换为填充值。目的是为了避免开发者将垃圾值当做一个正常值来使用，也就是提醒开发者这个变量没有进行初始化。因此，变量若未进行初始化，该变量的内存空间内存放的是一个垃圾值。","title":"C 变量为什么要初始化"},{"content":"变量的定义和赋值 系统是如何执行 int i = 5; 这个语句的  程序请求操作系统为 i 分配存储空间。 操作系统会在内存中寻找一块空闲的内存空间，将这个内存空间当作 i 来使用。 程序会将 i 和这块内存空间关联起来，也就是将 i 当作这块内存空间的名字，使得以后对 i 这个字母进行操作，就相当于对这块内存空间进行，操作。 最后将 5 存储到 i 中，也就是存储到这块空闲的区域中。  ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B5%8B%E5%80%BC/","summary":"变量的定义和赋值 系统是如何执行 int i = 5; 这个语句的  程序请求操作系统为 i 分配存储空间。 操作系统会在内存中寻找一块空闲的内存空间，将这个内存空间当作 i 来使用。 程序会将 i 和这块内存空间关联起来，也就是将 i 当作这块内存空间的名字，使得以后对 i 这个字母进行操作，就相当于对这块内存空间进行，操作。 最后将 5 存储到 i 中，也就是存储到这块空闲的区域中。  ","title":"C 变量的定义和赋值"},{"content":"for 表示目的、目标、用途  为了\u0026hellip; 替代\u0026hellip; 对于\u0026hellip; 帮\u0026hellip; 给\u0026hellip;  为了\u0026hellip; for + 一个人/物，表示为了某个目标或为了某个人。\n Many people learn English for work. Girls make up for men. I run every morning for health.  给\u0026hellip; 需要，当 for 表示“给\u0026hellip;”的意思的时候，这时候的 for 不是动词“给”的意思。\n The letter is for you. The apple is for you. The packet is for me.  对于\u0026hellip; for + 一些词语构成固定搭配，可以表示“对于\u0026hellip;”的意思。\n Tea is good for your health.  表示时间、距离、数量  厉经  for + 冠词/数词 + 表示时间的名词 表示时间延续了多久。\n I have stayed here for five years.  表示交换、补偿 与\u0026hellip; 交换\nfor 的这种用法，主要出现在一个固定词组：\n Exchange A for B  表示支持、赞成 for + 表示计划、方案的词构成一个介词短语，表示支持某个计划的意思。\n Are you for this plan?  表示因为、由于 for + 动名词，可以表示因为\u0026hellip;的意思。\n This place is famous for its hot springs. Thank you for helping me. Thank you for your gift.  表示当作、作为 这种用法一般用在这种句型：\n主语 + Have/eat + 表示食物的名词 + for/as + 餐名\n What did you have for lunch? What did you eat for supper? I eat rice and vegetable for lunch?  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/for/","summary":"for 表示目的、目标、用途  为了\u0026hellip; 替代\u0026hellip; 对于\u0026hellip; 帮\u0026hellip; 给\u0026hellip;  为了\u0026hellip; for + 一个人/物，表示为了某个目标或为了某个人。\n Many people learn English for work. Girls make up for men. I run every morning for health.  给\u0026hellip; 需要，当 for 表示“给\u0026hellip;”的意思的时候，这时候的 for 不是动词“给”的意思。\n The letter is for you. The apple is for you. The packet is for me.  对于\u0026hellip; for + 一些词语构成固定搭配，可以表示“对于\u0026hellip;”的意思。\n Tea is good for your health.  表示时间、距离、数量  厉经  for + 冠词/数词 + 表示时间的名词 表示时间延续了多久。","title":"English for"},{"content":"from 表示时间和地点的起点  从\u0026hellip; 自\u0026hellip;  From +时间点 + to/till + 另一个时间点，这个句型表示从一个时间点到另一个时间点。\n We have a class from 20:00 to 22:00 every evening.  from + 一个地点 + to + 另外一个地点，这个句型表示从一个地方到林另外一个地方。\n The beggar asks for food from door to door. I run from my house ro the school. She walked from her house to the park yesterday.  from 是一个非常特别的介词，一般的介词后面不能跟地点副词，但是 from 可以。\n from here. from abroad.  从\u0026hellip;  She just came back from the school.  表示距离和间隔 from + 一个表示地点的名词，表示离某个地方有多远。\n How far is your hometown from here？ My home is 200 meters from the river. My home is 10 kilometers from the city.  表示来源和出处  从\u0026hellip; 由\u0026hellip; 来自\u0026hellip;  from + 表示地方的名词，可以表示来自某个地方。\n I am form Guizhou.  表示原因、动机、理由  出于 由于  from 表示原因的时候基本上都是固定的搭配或动词短语。\n he is tired from overwork. He died from an accident.  表示区别  \u0026hellip;和\u0026hellip;  from 的这种用法主要用在固定句型：\n主语 + tell + A + from + B（区分 A 和 B）\n Can you tell a wolf from a dog? I can\u0026rsquo;t tell Sichuan dialect from Chonging dialect.  表示原料材料  用\u0026hellip;制成  from 的这种用法主要用在固定句型：\nbe made from（由\u0026hellip;所做成）\n The sauce is made from hair. The glass is made from sand. The chair is made of wood.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/from/","summary":"from 表示时间和地点的起点  从\u0026hellip; 自\u0026hellip;  From +时间点 + to/till + 另一个时间点，这个句型表示从一个时间点到另一个时间点。\n We have a class from 20:00 to 22:00 every evening.  from + 一个地点 + to + 另外一个地点，这个句型表示从一个地方到林另外一个地方。\n The beggar asks for food from door to door. I run from my house ro the school. She walked from her house to the park yesterday.  from 是一个非常特别的介词，一般的介词后面不能跟地点副词，但是 from 可以。\n from here. from abroad.  从\u0026hellip;  She just came back from the school.","title":"English from"},{"content":"inside in 和 inside 的区别主要有两个。\ninside 一般不能表示时间概念，特殊情况除外，in 经常可以表示时间的概念。inside 一般不能 + 大地方名词，而 in 可以 + 大地方名词/小地方的名词。\n表示时间、地点 inside + 小地方 inside + 表示地点的词构成介词短语作地点状语，表示在某个地方里。\n They played inside the yard.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/inside/","summary":"inside in 和 inside 的区别主要有两个。\ninside 一般不能表示时间概念，特殊情况除外，in 经常可以表示时间的概念。inside 一般不能 + 大地方名词，而 in 可以 + 大地方名词/小地方的名词。\n表示时间、地点 inside + 小地方 inside + 表示地点的词构成介词短语作地点状语，表示在某个地方里。\n They played inside the yard.  ","title":"English inside"},{"content":"like 表示像某个东西 like + 表示人或物的词语 表示像某个人或某个物一样。\n The leaf is like a heart. She is like her mother. You should marry a man like me.  固定搭配 look like + 名词/代词宾格 表示看起来某个事物。\n She looks like a singer. The moom looks likes a silver plate. It looks like rain today.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/like/","summary":"like 表示像某个东西 like + 表示人或物的词语 表示像某个人或某个物一样。\n The leaf is like a heart. She is like her mother. You should marry a man like me.  固定搭配 look like + 名词/代词宾格 表示看起来某个事物。\n She looks like a singer. The moom looks likes a silver plate. It looks like rain today.  ","title":"English like"},{"content":"启动服务器时报错 今天，我在 PHPStudy 中启动 Apache 和 Nginx 的时候，启动失败，提示 AH\u0026hellip;\n这是因为 PHPStudy 不能被安装到带有空格的文件夹中，否则 Apache 或 Nginx 就会会无法启动。\n","permalink":"https://note.yxzi.xyz/note/technology/softwareuse/phpstudy/%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E6%8A%A5%E9%94%99/","summary":"启动服务器时报错 今天，我在 PHPStudy 中启动 Apache 和 Nginx 的时候，启动失败，提示 AH\u0026hellip;\n这是因为 PHPStudy 不能被安装到带有空格的文件夹中，否则 Apache 或 Nginx 就会会无法启动。","title":"启动服务器时报错"},{"content":"提示 hosts 不同步 大概率是C:\\Windows\\System32\\drivers\\etc 路径中的 hosts 出现了一下问题：\n hosts 文件的后缀名不对，hosts 文件没有后缀名。 hosts 中的内容为空。 hosts 内容底部没有添加网站域名  # Copyright (c) 1993-1999 Microsoft Corp.  # This is a sample HOSTS file used by Microsoft TCP/IP for Windows.  # This file contains the mappings of IP addresses to host names. Each  # entry should be kept on an individual line. The IP address should  # be placed in the first column followed by the corresponding host name.  # The IP address and the host name should be separated by at least one  # space.  # Additionally, comments (such as these) may be inserted on individual  # lines or following the machine name denoted by a \u0026#39;#\u0026#39; symbol.  # For example:  # 102.54.94.97 rhino.acme.com # source server  # 38.25.63.10 x.acme.com # x client host  # 网站域名 127.0.0.1 localhost  127.0.0.1 a.com ","permalink":"https://note.yxzi.xyz/note/technology/softwareuse/phpstudy/%E6%8F%90%E7%A4%BA-hosts-%E4%B8%8D%E5%90%8C%E6%AD%A5/","summary":"提示 hosts 不同步 大概率是C:\\Windows\\System32\\drivers\\etc 路径中的 hosts 出现了一下问题：\n hosts 文件的后缀名不对，hosts 文件没有后缀名。 hosts 中的内容为空。 hosts 内容底部没有添加网站域名  # Copyright (c) 1993-1999 Microsoft Corp.  # This is a sample HOSTS file used by Microsoft TCP/IP for Windows.  # This file contains the mappings of IP addresses to host names. Each  # entry should be kept on an individual line. The IP address should  # be placed in the first column followed by the corresponding host name.","title":"提示 hosts 不同步"},{"content":"无法启动 MySQL 错误一 打开 PHPStudy，启动 MySQL 失败，但用 CMD 可以正常启动 MySQL。\n5.7.26 解决方案 管理员运行 CMD 输入：\nnet stop mysql\rsc delete mysql 提示[SC] DeleteService 成功后，重新打开 PHPStudy，会发现 MySQL 可以正常启动了。\n错误二 提示错误信息：\n1045 access denied for user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; using password yes 5.7.26 解决方案   停用 MySQL 服务 没启动的可以省略\nnet stop mysql   找到 MySQL 安装路径下的 my.ini\n  打开 my.ini 找到 [mysqld] 然后在下面加上 skip_grant_tables，表示启动 MySQL 服务的时候跳过权限表认证\n  启动数据库修改密码\n  刷新权限 flush privileges\n  再将的my.ini里的skip_grant_tables 去掉，因为启动 MySQL 服务的时候不能让它跳过权限表认证\n  最后重启 MySQL 即可。\n  ","permalink":"https://note.yxzi.xyz/note/technology/softwareuse/phpstudy/%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8-mysql/","summary":"无法启动 MySQL 错误一 打开 PHPStudy，启动 MySQL 失败，但用 CMD 可以正常启动 MySQL。\n5.7.26 解决方案 管理员运行 CMD 输入：\nnet stop mysql\rsc delete mysql 提示[SC] DeleteService 成功后，重新打开 PHPStudy，会发现 MySQL 可以正常启动了。\n错误二 提示错误信息：\n1045 access denied for user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; using password yes 5.7.26 解决方案   停用 MySQL 服务 没启动的可以省略\nnet stop mysql   找到 MySQL 安装路径下的 my.ini\n  打开 my.ini 找到 [mysqld] 然后在下面加上 skip_grant_tables，表示启动 MySQL 服务的时候跳过权限表认证\n  启动数据库修改密码\n  刷新权限 flush privileges","title":"无法启动 MySQL"},{"content":"三目运算符 a ? b : c 相当于 if 语句\nif (a);  b; else  c; return 0; ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E8%BF%90%E7%AE%97%E7%AC%A6/%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6/","summary":"三目运算符 a ? b : c 相当于 if 语句\nif (a);  b; else  c; return 0; ","title":"C 三目运算符"},{"content":"逗号表达式 (a,b,c,d) 从左向右执行，表达式最终的值是 d 的值。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.h\u0026gt; int main() {  int i;  int c = 2;  i = (c++, ++c, c + 2, c - 3);  // 执行了 c++ 与 ++c 后，c 变为了 4，然后执行 c + 2，  // 但此时并没有将 c + 2 的结果赋给 c，因此此时的 c 依旧为 4，  // 再 c - 3，则 i = 1.  printf(\u0026#34;%d\u0026#34;, i);  // return 1  return 0; } ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E8%BF%90%E7%AE%97%E7%AC%A6/%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"逗号表达式 (a,b,c,d) 从左向右执行，表达式最终的值是 d 的值。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.h\u0026gt; int main() {  int i;  int c = 2;  i = (c++, ++c, c + 2, c - 3);  // 执行了 c++ 与 ++c 后，c 变为了 4，然后执行 c + 2，  // 但此时并没有将 c + 2 的结果赋给 c，因此此时的 c 依旧为 4，  // 再 c - 3，则 i = 1.  printf(\u0026#34;%d\u0026#34;, i);  // return 1  return 0; } ","title":"C 逗号表达式"},{"content":"反转链表 // * pHead 头指针 struct ListNode* ReverseList(struct ListNode* pHead ) { \t// pHead 头结点 \t// 当为空、或者 只有一个元素时直接退出  if(pHead == NULL)  return NULL;  if(pHead-\u0026gt;next == NULL)  return pHead;   //至少两个元素时  //定义两个空指针  struct ListNode *p = NULL;  struct ListNode *temp = NULL;  // p ：首结点，断开头结点指向空  p = pHead-\u0026gt;next;  pHead-\u0026gt;next = NULL;  // 首结点的下一个结点不为空  while(p-\u0026gt;next != NULL)  {  // 记录首结点的下一个结点  temp = p-\u0026gt;next;   // 头删  p-\u0026gt;next = pHead;   // 将首结点设置为头结点  pHead = p;   // 将当前节点的下一个结点  p = temp;  } \t//退出时 p 是最后一个结点 也是最终目标链表头结点   //p 指向头结点  p-\u0026gt;next = pHead; \t//p设置为头结点  pHead = p;  //返回 pHead  return pHead; } ","permalink":"https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","summary":"反转链表 // * pHead 头指针 struct ListNode* ReverseList(struct ListNode* pHead ) { \t// pHead 头结点 \t// 当为空、或者 只有一个元素时直接退出  if(pHead == NULL)  return NULL;  if(pHead-\u0026gt;next == NULL)  return pHead;   //至少两个元素时  //定义两个空指针  struct ListNode *p = NULL;  struct ListNode *temp = NULL;  // p ：首结点，断开头结点指向空  p = pHead-\u0026gt;next;  pHead-\u0026gt;next = NULL;  // 首结点的下一个结点不为空  while(p-\u0026gt;next != NULL)  {  // 记录首结点的下一个结点  temp = p-\u0026gt;next;   // 头删  p-\u0026gt;next = pHead;   // 将首结点设置为头结点  pHead = p;   // 将当前节点的下一个结点  p = temp;  } \t//退出时 p 是最后一个结点 也是最终目标链表头结点   //p 指向头结点  p-\u0026gt;next = pHead; \t//p设置为头结点  pHead = p;  //返回 pHead  return pHead; } ","title":"C 反转"},{"content":"链表 链表主要是便于管理长度或数量不确定的数据，相对于数组，链表处理这种数据时比较节省内存。\n链表靠节点的指针域中存放的指针地址来寻找下一个元素。\n确定一个链表，只需要知道头指针即可。\n优点 存取数据效率高。\n不需要一个太大的内存。\n缺点 查找某个位置的元素时，效率很低。\n结点 链表由一个个的结点组成，每个节点左侧是数据域，右侧是指针域，数据域用来存放当前节点的有效数据，指针域用来存放下一个节点的指针地址。\n链表中一个个的元素，被称之为结点，每个结点都有数据域和指针域。\n首结点 链表中存放第一个有效数据的节点。\n尾结点 链表中存放最后一个有效数据的节点，尾节点的指针域为 Null。\n头结点 头结点的数据类型和首节点的类型一模一样。\n头结点是首节点前面的那个节点。\n头结点的数据域通常不存放任何有效数据，但头结点的指针域存放的是首节点的地址。\n设置头结点的目的是为了方便对链表的操作。\n任何一个链表都有一个头结点\n空链表，指的是头结点的指针域为 Null 的链表，非空链表，指的是头结点的指针域有指向的链表。\n头指针 它不是链表的节点，只是一个指针变量，用于存放头结点的指针地址。\n链表实例 # include \u0026lt;stdio.h\u0026gt; # include \u0026lt;malloc.h\u0026gt; # include \u0026lt;stdlib.h\u0026gt;  // 定义一个链表 struct Node {  // 定义链表中节点的数据域  int data;  // 定义链表中节点的指针域。  // 指针域是一个 struct Node *类型的 pNext，其中 pNext 中存放的是 struct Node 变量的地址  struct Node * pNext; };  struct Node * CreateList(void); void TraverseList(struct Node *);  int main(void) {  // 定义头指针 pHead，用来存放链表的头结点的地址，  // 也就是我们可以通过 pHead 中存放中的地址，找到链表的头结点.  // 也就是，pHead 就是头结点，  // pHead -\u0026gt; pNext 是头结点的指针域，pHead -\u0026gt; pData 是头结点的数据域，通常不存放任何有效数据  struct Node *pHead;  // 调用 CreateList() 函数来创建一个链表 ，  // 因为 CreateList() reture 了该链表的头指针，  // 所以最终会将这个链表的头指针（头结点的地址）保存到 pHead 中。  pHead = CreateList();  // 遍历链表中的节点  TraverseList(pHead);  return 0; } // 定义一个链表 struct Node *CreateList(void) {  // 用于存放有效节点的个数  int len;  //  int i;  // 用于临时存放用户输入的节点的值  int val;  // 动态分配了一个不存放有效数据的头结点  struct Node * pHead = (struct Node * )malloc(sizeof(struct Node));  if(NULL == pHead)  {  printf(\u0026#34;分配失败，程序终止！\\n\u0026#34;);  exit(-1);  }  struct Node * pTail = pHead;  pTail-\u0026gt;pNext = NULL;   // 输入链表个数  printf(\u0026#34;请输入需要生成的链表节点的个数：\u0026#34;);  scanf(\u0026#34;%d\u0026#34;,\u0026amp;len);   for(i = 0; i\u0026lt;len; i++)  {  // 输入每个节点的值  printf(\u0026#34;请输入第%d个节点的值：\u0026#34;,i+1);  scanf(\u0026#34;%d\u0026#34;,\u0026amp;val);   struct Node *pNew = (struct Node *)malloc(sizeof(struct Node));  if(NULL == pNew)  {  printf(\u0026#34;分配失败，程序终止！\\n\u0026#34;);  exit(-1);  }  pNew -\u0026gt;data = val;  pTail -\u0026gt;pNext = pNew;  pNew -\u0026gt;pNext = NULL;  pTail = pNew;  }  // pHead 中存放的是头结点的地址，pHead 变量也是头指针  return pHead; };  // 定一个 EmptyList() 来判断一个链表是否为空链表 // 函数形参为头结点的指针地址，也就是头指针 bool EmptyList (struct Node * pHead) {  // 判断一个链表是否为扣空链表  // 如果头指针（pHead）所指向的头结点 pNext 的指针域为 Null  if(pHead -\u0026gt;pNext == NULL)  {  // 为空链表则 reture true  return true;  }  else  {  // 不为空链表则 reture false  return false;  } }  // 定义一个遍历链表的函数， // 函数参数是头结点的地址，也就是头指针 void TraverseList(struct Node * pHead) {  // 判断 pHead 链表是否是空链表  if (EmptyList(pHead))  {  // 是空链表则直接提示  printf(\u0026#34;链表为空！\\n\u0026#34;);  }  else  {  // 不为空链表则用 while 循环遍历链表中的节点，从首节点开始遍历  // 定义 struct Node * 类型的指针变量 p，  // 将头结点的指针域（首节点的地址）赋给 p，所以，p 就是首节点  struct Node * p = pHead-\u0026gt;pNext;  // 判断 p 这个指针变量中所存放的节点地址是否存在，是否为 Null，  // 存在则不为Null，则可以开始遍历当前节点，直到没有节点（p 为 Null）停止遍历。  while( p != NULL )  {  // 输出当前节点中数据域中的数据  printf(\u0026#34;链表中有：%d\\n\u0026#34;,p -\u0026gt;data);  // 此时，p 中所存放的地址所指向的节点，我们已经遍历了，  // 在这之后，我们需要遍历 p 这个节点的指针域所指向的下一个节点，也就是第 N 个节点。  p = p -\u0026gt;pNext;  }   }  return; } ","permalink":"https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8/","summary":"链表 链表主要是便于管理长度或数量不确定的数据，相对于数组，链表处理这种数据时比较节省内存。\n链表靠节点的指针域中存放的指针地址来寻找下一个元素。\n确定一个链表，只需要知道头指针即可。\n优点 存取数据效率高。\n不需要一个太大的内存。\n缺点 查找某个位置的元素时，效率很低。\n结点 链表由一个个的结点组成，每个节点左侧是数据域，右侧是指针域，数据域用来存放当前节点的有效数据，指针域用来存放下一个节点的指针地址。\n链表中一个个的元素，被称之为结点，每个结点都有数据域和指针域。\n首结点 链表中存放第一个有效数据的节点。\n尾结点 链表中存放最后一个有效数据的节点，尾节点的指针域为 Null。\n头结点 头结点的数据类型和首节点的类型一模一样。\n头结点是首节点前面的那个节点。\n头结点的数据域通常不存放任何有效数据，但头结点的指针域存放的是首节点的地址。\n设置头结点的目的是为了方便对链表的操作。\n任何一个链表都有一个头结点\n空链表，指的是头结点的指针域为 Null 的链表，非空链表，指的是头结点的指针域有指向的链表。\n头指针 它不是链表的节点，只是一个指针变量，用于存放头结点的指针地址。\n链表实例 # include \u0026lt;stdio.h\u0026gt; # include \u0026lt;malloc.h\u0026gt; # include \u0026lt;stdlib.h\u0026gt;  // 定义一个链表 struct Node {  // 定义链表中节点的数据域  int data;  // 定义链表中节点的指针域。  // 指针域是一个 struct Node *类型的 pNext，其中 pNext 中存放的是 struct Node 变量的地址  struct Node * pNext; };  struct Node * CreateList(void); void TraverseList(struct Node *);  int main(void) {  // 定义头指针 pHead，用来存放链表的头结点的地址，  // 也就是我们可以通过 pHead 中存放中的地址，找到链表的头结点.","title":"C 链表"},{"content":"数据结构 数据结构是指计算机存储和组织数据的一种的结构。\n将现实中大量而复杂的问题以特定的数据类型和特定的存储结构存储到内存中，以此来实现某个功能（删除、查找、排序）而执行相应的操作，这个相应的操作也叫算法。\n数据结构定义数据将以什么样的形式存储到内存中，而算法定义的是我们如何对内存中的数据结构进行操作。\n程序 = 数据的存储（数据结构） + 数据的操作（算法） + 可以被程序执行的语言（变成语言）\n","permalink":"https://note.yxzi.xyz/note/technology/datastructure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","summary":"数据结构 数据结构是指计算机存储和组织数据的一种的结构。\n将现实中大量而复杂的问题以特定的数据类型和特定的存储结构存储到内存中，以此来实现某个功能（删除、查找、排序）而执行相应的操作，这个相应的操作也叫算法。\n数据结构定义数据将以什么样的形式存储到内存中，而算法定义的是我们如何对内存中的数据结构进行操作。\n程序 = 数据的存储（数据结构） + 数据的操作（算法） + 可以被程序执行的语言（变成语言）","title":"数据结构"},{"content":"算法 算法是为了解决一个问题而设计的一种操作。\n算法目的就是为了解决问题，它是一系列解题步骤，一个计算过程。因此，我们描述算法，通常可以使用伪代码。\n定义 通俗定义 解题的方法和步骤。\n狭义定义 对存储数据的操作。\n对不同的数据结构，要完成某一个功能所执行的操作是不一样的。\n比如，输出数组所有的元素和输出链表中所有的元素的操作是不一样的。这说明，算法是依附于数据结构，不同的数据结构，所执行的算法是不一样的。\n广义定义 广义的算法也叫泛型。无论数据是如何存储的，对该数据的操作都是一样的。\n我们至少可以通过两种结构来存储数据：\n 数组 链表  衡量算法的标准 时间复杂度 程序执行的大概次数，而非执行时间。\n为什么不是执行呢？\n 这是因为在不同的机器上，同一个程序的执行时间是不同的（机器的性能不一样）。  空间复杂度 算法的执行过程中，大概所占用的最大内存。\n可读性 算法是否容易让人理解。\n健壮性 一个算法对不合理数据输入的反应能力和处理能力，也称为算法容错性。\n","permalink":"https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E7%AE%97%E6%B3%95/","summary":"算法 算法是为了解决一个问题而设计的一种操作。\n算法目的就是为了解决问题，它是一系列解题步骤，一个计算过程。因此，我们描述算法，通常可以使用伪代码。\n定义 通俗定义 解题的方法和步骤。\n狭义定义 对存储数据的操作。\n对不同的数据结构，要完成某一个功能所执行的操作是不一样的。\n比如，输出数组所有的元素和输出链表中所有的元素的操作是不一样的。这说明，算法是依附于数据结构，不同的数据结构，所执行的算法是不一样的。\n广义定义 广义的算法也叫泛型。无论数据是如何存储的，对该数据的操作都是一样的。\n我们至少可以通过两种结构来存储数据：\n 数组 链表  衡量算法的标准 时间复杂度 程序执行的大概次数，而非执行时间。\n为什么不是执行呢？\n 这是因为在不同的机器上，同一个程序的执行时间是不同的（机器的性能不一样）。  空间复杂度 算法的执行过程中，大概所占用的最大内存。\n可读性 算法是否容易让人理解。\n健壮性 一个算法对不合理数据输入的反应能力和处理能力，也称为算法容错性。","title":"算法"},{"content":"补码 在计算机中，数值一律用补码来表示和存储。\n补码是现代计算机使用的编码格式，同时解决了原码和反码的瑕疵。\n已知十进制求二进制的补码 求正整数的二进制补码 除 2 取余，直至商为 0，余数倒序即可\n求负整数的二进制补码 先求与该负数的相反数的二进制数，然后将所有位取反，末尾位加 1，不够位数，左侧补 1。\n（-3）—\u0026gt; 011 —\u0026gt; 100 —\u0026gt; 101 — 11111111,11111111,11111111,11111101 — \u0026gt; FFFFFFFD\n求零的二进制补码 全是 0。\n已知二进制补码求十进制 如果二进制补码首位是 0，则表示这个数是正整数。\n直接转十进制即可。\n如果二进制补码首位是 1，则表示这个数是负整数。\n将所有位取反，末位加 1，所得数字就是该负数的绝对值加 1。\n1001010 —\u0026gt; 0110101 —\u0026gt; 0110110 —\u0026gt; 57 —\u0026gt; -54\n如果二进制补码全是零，则表示这个数字是 0。\n原码 原码不能直接参加运算\n首位是 0 表示这个数是正整数，首位是 1 表示这个数是负整数，\n其余二进制位是该数字的绝对值的二进制位。\n（+35）00100011，就是 35 的二进制，不足位补零，0 表示负；\n（-35）10100011，最高位放符号位，1 表示负。\n反码 在计算机中不常用。\n（+35）—\u0026gt; 00100011，和原码补码都相同\n（-35）—\u0026gt; 11011100，+ 35 的原码全部取反即可求出 -35 的反码。或者 35 的补码最低位减去 1 获得。\n移码 移码表示数值平移动 N 位，N 称为 移码量。\n移码主要用于浮点数的阶码的存储。\n（+35）10100011，补码符号位取反\n（-35）01011101，补码符号位取反\n","permalink":"https://note.yxzi.xyz/note/technology/computer/%E8%A1%A5%E7%A0%81/","summary":"补码 在计算机中，数值一律用补码来表示和存储。\n补码是现代计算机使用的编码格式，同时解决了原码和反码的瑕疵。\n已知十进制求二进制的补码 求正整数的二进制补码 除 2 取余，直至商为 0，余数倒序即可\n求负整数的二进制补码 先求与该负数的相反数的二进制数，然后将所有位取反，末尾位加 1，不够位数，左侧补 1。\n（-3）—\u0026gt; 011 —\u0026gt; 100 —\u0026gt; 101 — 11111111,11111111,11111111,11111101 — \u0026gt; FFFFFFFD\n求零的二进制补码 全是 0。\n已知二进制补码求十进制 如果二进制补码首位是 0，则表示这个数是正整数。\n直接转十进制即可。\n如果二进制补码首位是 1，则表示这个数是负整数。\n将所有位取反，末位加 1，所得数字就是该负数的绝对值加 1。\n1001010 —\u0026gt; 0110101 —\u0026gt; 0110110 —\u0026gt; 57 —\u0026gt; -54\n如果二进制补码全是零，则表示这个数字是 0。\n原码 原码不能直接参加运算\n首位是 0 表示这个数是正整数，首位是 1 表示这个数是负整数，\n其余二进制位是该数字的绝对值的二进制位。\n（+35）00100011，就是 35 的二进制，不足位补零，0 表示负；\n（-35）10100011，最高位放符号位，1 表示负。\n反码 在计算机中不常用。\n（+35）—\u0026gt; 00100011，和原码补码都相同\n（-35）—\u0026gt; 11011100，+ 35 的原码全部取反即可求出 -35 的反码。或者 35 的补码最低位减去 1 获得。","title":"补码"},{"content":"枚举 将一个事物所有可能的取值给一一列举出来。\n优点 使代码更加安全。\n使代码更加直观。\n缺点 书写麻烦。\n# include \u0026lt;stdio.h\u0026gt; # include \u0026lt;malloc.h\u0026gt; // 定义一个数据类型，并没有定义变量，该数据类型的名字为 enum WeekDay enum WeekDay{  // 每一个元素，实际上都是数字，并且第一个元素默认是从 0 开始的，  // 当然，也可以指定首个元素是多少：MonDay = 1;那么此时的 Monday 就是 1，不再是 0 了  // 那么第二个元素就是 2，不再是 1 了，  // 这样写的好处是，WeekDay 的取值只能是下面的这些枚举常量，也就是将 WeekDay 的取值范围给限制了。  // 这样会让代码更加安全，也更加直观。  MonDay, TuesDay,WednesDay,ThursDay,FriDay,SaturDay,SunDay };  int main(void) {  // 因为一个周实际上只能有 7 天，因此这个 int week 只能取1 - 7，且不能是负数或则大于7 的数  // 但默认情况下，int week 的取值大概率会超出这个范围，但我们又不能强制要求 int 的 week 的取值范围是多少  // 所以，我们就需要用到枚举  int week;  // 虽然 WednesDay = 2，但是不能写成：  // enum WeekDay newWeek = 2;  // newWeek 的值只能是枚举常量  enum WeekDay newWeek = WednesDay;  // 实际上返回的是 2  printf(\u0026#34;%d\u0026#34;,newWeek); } ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%9E%9A%E4%B8%BE/","summary":"枚举 将一个事物所有可能的取值给一一列举出来。\n优点 使代码更加安全。\n使代码更加直观。\n缺点 书写麻烦。\n# include \u0026lt;stdio.h\u0026gt; # include \u0026lt;malloc.h\u0026gt; // 定义一个数据类型，并没有定义变量，该数据类型的名字为 enum WeekDay enum WeekDay{  // 每一个元素，实际上都是数字，并且第一个元素默认是从 0 开始的，  // 当然，也可以指定首个元素是多少：MonDay = 1;那么此时的 Monday 就是 1，不再是 0 了  // 那么第二个元素就是 2，不再是 1 了，  // 这样写的好处是，WeekDay 的取值只能是下面的这些枚举常量，也就是将 WeekDay 的取值范围给限制了。  // 这样会让代码更加安全，也更加直观。  MonDay, TuesDay,WednesDay,ThursDay,FriDay,SaturDay,SunDay };  int main(void) {  // 因为一个周实际上只能有 7 天，因此这个 int week 只能取1 - 7，且不能是负数或则大于7 的数  // 但默认情况下，int week 的取值大概率会超出这个范围，但我们又不能强制要求 int 的 week 的取值范围是多少  // 所以，我们就需要用到枚举  int week;  // 虽然 WednesDay = 2，但是不能写成：  // enum WeekDay newWeek = 2;  // newWeek 的值只能是枚举常量  enum WeekDay newWeek = WednesDay;  // 实际上返回的是 2  printf(\u0026#34;%d\u0026#34;,newWeek); } ","title":"C 枚举"},{"content":"before 表示在某个时间点以前 before + 表示几点钟的数词  I get up before 7:00 every day.  before + 表示具体的时间或具体时间点的词  We must finish our lessons before this year.  before + 表示几岁的词  Rainy will marry a good man before 40 years old.  before + 表示年份的词  We sill be very rich before 2030.  before 后面不能加一段时间：before three days。\n如果要表示”三天之前“，可以用 ago 这个副词：three days ago。\n表示位置 before + 地点/场所/人 这种情况表示在某个地点或某个人的前面。\n He boasts before Rainy. We should not mention love before Pandora. I teach English before the computer.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/before/","summary":"before 表示在某个时间点以前 before + 表示几点钟的数词  I get up before 7:00 every day.  before + 表示具体的时间或具体时间点的词  We must finish our lessons before this year.  before + 表示几岁的词  Rainy will marry a good man before 40 years old.  before + 表示年份的词  We sill be very rich before 2030.  before 后面不能加一段时间：before three days。\n如果要表示”三天之前“，可以用 ago 这个副词：three days ago。\n表示位置 before + 地点/场所/人 这种情况表示在某个地点或某个人的前面。\n He boasts before Rainy.","title":"English before"},{"content":"behind 表示时间 behind + 时间点 这种情况表示晚于某个时间点。\n your idea is behind the times.  表示位置 behind + 地点 这种情况表示在某个地方都后面或在某个人的后面。\n The cat is behind the door. The tree behind my house is very big.  表示力量、能力 behind + 表示能力的词 这种情况表示能力落后/不如或低于某人。\n I am far behind you in English.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/behind/","summary":"behind 表示时间 behind + 时间点 这种情况表示晚于某个时间点。\n your idea is behind the times.  表示位置 behind + 地点 这种情况表示在某个地方都后面或在某个人的后面。\n The cat is behind the door. The tree behind my house is very big.  表示力量、能力 behind + 表示能力的词 这种情况表示能力落后/不如或低于某人。\n I am far behind you in English.  ","title":"English behind"},{"content":"below 表示位置 below + 表示地点的词语 这种情况表示在某个地点的下面。\n Your cellphone is below the wall.  表示数量、年龄、价值 below + 表示数量、程度、价值、年龄、温度的词语 这种情况表示低于某个临界点或在某个临界点等。\n She is below 20 years old. It is below 20 ℃. The people below 18 years old cant attend my course.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/below/","summary":"below 表示位置 below + 表示地点的词语 这种情况表示在某个地点的下面。\n Your cellphone is below the wall.  表示数量、年龄、价值 below + 表示数量、程度、价值、年龄、温度的词语 这种情况表示低于某个临界点或在某个临界点等。\n She is below 20 years old. It is below 20 ℃. The people below 18 years old cant attend my course.  ","title":"English below"},{"content":"beside 表示位置 beside + 表示地点的名词 表示在这个某个地点的旁边或者附近。\n  The room beside the bathroom is mine.\n  She is beside the bathroom.\n  My student drink tea beside the sea every afternoon.\n  表示对比 beside + 名词或代词 表示与某人相比。\n Beside his, my trouble is nothing.  表示无关  That is beside the question.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/beside/","summary":"beside 表示位置 beside + 表示地点的名词 表示在这个某个地点的旁边或者附近。\n  The room beside the bathroom is mine.\n  She is beside the bathroom.\n  My student drink tea beside the sea every afternoon.\n  表示对比 beside + 名词或代词 表示与某人相比。\n Beside his, my trouble is nothing.  表示无关  That is beside the question.  ","title":"English beside"},{"content":"between 表示时间、位置、数量  在\u0026hellip;之间。  between + 两个事物/两个人 表示在两者之间。\n注意，Among 才是表示三者以上，包括三者。\n He does busines between America and China. They don\u0026rsquo;t know the secret between you and me.  between + 两个时间点 表示在两个时间点之内的这段时间。\n We have a class between 20:00 and 22:00. I will rich between 30 and 50 years old.  表示关系、比较、分配  在\u0026hellip;之间。  between + 名词 这种情况，一般作后置定语，表示两者之间的关系/比较两者等。\n What is the difference between American English an British English.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/between/","summary":"between 表示时间、位置、数量  在\u0026hellip;之间。  between + 两个事物/两个人 表示在两者之间。\n注意，Among 才是表示三者以上，包括三者。\n He does busines between America and China. They don\u0026rsquo;t know the secret between you and me.  between + 两个时间点 表示在两个时间点之内的这段时间。\n We have a class between 20:00 and 22:00. I will rich between 30 and 50 years old.  表示关系、比较、分配  在\u0026hellip;之间。  between + 名词 这种情况，一般作后置定语，表示两者之间的关系/比较两者等。\n What is the difference between American English an British English.","title":"English between"},{"content":"二分查找 #include \u0026lt;stdio.h\u0026gt;void main(){ \tint arr[] ={1,3,7,10,12,14,17,20,21,23}; \tint num = 50; \tint left = 0, right = 10; \tint flag = 0; \twhile(left \u0026lt; right){ \tint middle = (left + right)/2; \tif(arr[middle] \u0026gt; num){ \tright = middle; \t} \tif(arr[middle] \u0026lt; num){ \tleft = middle +1; \t} \tif(arr[middle] == num){ \tprintf(\u0026#34;%d\u0026#34;,middle); \tflag = 1; \tbreak; \t} \t} \tif(flag == 0 ){ \tprintf(\u0026#34;not found\\n\u0026#34;); \t} } ","permalink":"https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","summary":"二分查找 #include \u0026lt;stdio.h\u0026gt;void main(){ \tint arr[] ={1,3,7,10,12,14,17,20,21,23}; \tint num = 50; \tint left = 0, right = 10; \tint flag = 0; \twhile(left \u0026lt; right){ \tint middle = (left + right)/2; \tif(arr[middle] \u0026gt; num){ \tright = middle; \t} \tif(arr[middle] \u0026lt; num){ \tleft = middle +1; \t} \tif(arr[middle] == num){ \tprintf(\u0026#34;%d\u0026#34;,middle); \tflag = 1; \tbreak; \t} \t} \tif(flag == 0 ){ \tprintf(\u0026#34;not found\\n\u0026#34;); \t} } ","title":"二分查找"},{"content":"冒泡排序 流程   比较相邻的两个元素，升序则交换两个数的位置，降序则位置不变。\n  对每一对相邻元素作同样的操作，从开始第一对到结尾的最后一对。直到产生一个最大或者最小的数（这取决于你是升序还是降序）。升序是产生最大的数，降序是产生最小的数。\n  重新开始下一轮遍历，但无需遍历上轮遍历时所产生的最大数。\n  实现升序 # include \u0026lt;stdio.h\u0026gt;  // *arr 数组 // len 数组长度 void BubbleSort(int * arr, int len){   // 整体比较轮数  int i;   // 元素与元素的比较次数  int j;   // 媒介变量，用于交换两个元素的位置  int t;   // 整体比较轮数  // 需要b len-1 轮，每轮整体比较都需要进行元素与元素的比较。  for (i = 0; i \u0026lt; len-1;i ++){   // 元素与元素的比较次数  // 每进行一轮比较，都会在数组末尾产生一个最大元素。  // 下次比较时，这个最大元素将不再参与和其他元素的比较，因此，元素与元素的比较次数为 j \u0026lt; len - 1 - i。  for(j = 0;j \u0026lt; len - 1- i;j++){   // 元素与元素的比较 \t// 从第一个元素 a[j] 与第二个元素 a[j+1] 开始依次比较。  if (arr[j] \u0026gt; arr[j+1]){   // 交换两个元素的位置。  t = arr[j];  arr[j] = arr[j+1];  arr[j + 1] = t;  }  }  } }  int main(void) {  int arr[] = {10,2,8,-8,11,0};  BubbleSort(arr,6);  for(int i = 0; i \u0026lt; 6;i++){  printf(\u0026#34;%d \u0026#34;,arr[i]);  }  printf(\u0026#34;\\n\u0026#34;); ","permalink":"https://note.yxzi.xyz/note/technology/datastructure/algorithm/sort/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","summary":"冒泡排序 流程   比较相邻的两个元素，升序则交换两个数的位置，降序则位置不变。\n  对每一对相邻元素作同样的操作，从开始第一对到结尾的最后一对。直到产生一个最大或者最小的数（这取决于你是升序还是降序）。升序是产生最大的数，降序是产生最小的数。\n  重新开始下一轮遍历，但无需遍历上轮遍历时所产生的最大数。\n  实现升序 # include \u0026lt;stdio.h\u0026gt;  // *arr 数组 // len 数组长度 void BubbleSort(int * arr, int len){   // 整体比较轮数  int i;   // 元素与元素的比较次数  int j;   // 媒介变量，用于交换两个元素的位置  int t;   // 整体比较轮数  // 需要b len-1 轮，每轮整体比较都需要进行元素与元素的比较。  for (i = 0; i \u0026lt; len-1;i ++){   // 元素与元素的比较次数  // 每进行一轮比较，都会在数组末尾产生一个最大元素。  // 下次比较时，这个最大元素将不再参与和其他元素的比较，因此，元素与元素的比较次数为 j \u0026lt; len - 1 - i。  for(j = 0;j \u0026lt; len - 1- i;j++){   // 元素与元素的比较 \t// 从第一个元素 a[j] 与第二个元素 a[j+1] 开始依次比较。  if (arr[j] \u0026gt; arr[j+1]){   // 交换两个元素的位置。  t = arr[j];  arr[j] = arr[j+1];  arr[j + 1] = t;  }  }  } }  int main(void) {  int arr[] = {10,2,8,-8,11,0};  BubbleSort(arr,6);  for(int i = 0; i \u0026lt; 6;i++){  printf(\u0026#34;%d \u0026#34;,arr[i]);  }  printf(\u0026#34;\\n\u0026#34;); ","title":"冒泡排序"},{"content":"选择排序 流程  在未排序的元素中找到最小（或最大）元素，将其存放到该数组的起始位置， 跳过已排序数，从剩余未排序的元素中继续寻找最小（或最大）元素，放到已排序数组的末尾。 以此类推，直到所有元素均排序完毕。  实现升序 #include \u0026lt;stdio.h\u0026gt; void SelectionSort(int *arr,int len) {   // 已排序元素的末尾位置  int i;   // 未排序元素的起始位置  int j;   int k;   // 媒介变量，用于交换两个元素的位置  int t;   // 整体比较轮数  // 需要比较 len 轮  for(i = 0; i \u0026lt; len; i++)  {   // 跳过已排序的数  int k = i;   // 忽略已排序的数，直接从未排序的数开始比较，找出未排序数中的最小数  for(j = i; j \u0026lt; len; j++)  {  printf(\u0026#34;%d\\n\u0026#34;,i);  if(arr[j] \u0026lt; arr[k])  {  // 将一对数中较小的数的索引赋给 k  k = j;  }  }   // 将最小的那个数移到数组最前面  t = arr[k];  arr[k] = arr[i];  arr[i] = t;  } }  int main() {  int arr[] = {5,7,1,3,8,12,2,9};  SelectionSort(arr,8);  for(int j = 0; j \u0026lt; 8; j++)  {  printf(\u0026#34;%d \u0026#34;,arr[j]);  } } ","permalink":"https://note.yxzi.xyz/note/technology/datastructure/algorithm/sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","summary":"选择排序 流程  在未排序的元素中找到最小（或最大）元素，将其存放到该数组的起始位置， 跳过已排序数，从剩余未排序的元素中继续寻找最小（或最大）元素，放到已排序数组的末尾。 以此类推，直到所有元素均排序完毕。  实现升序 #include \u0026lt;stdio.h\u0026gt; void SelectionSort(int *arr,int len) {   // 已排序元素的末尾位置  int i;   // 未排序元素的起始位置  int j;   int k;   // 媒介变量，用于交换两个元素的位置  int t;   // 整体比较轮数  // 需要比较 len 轮  for(i = 0; i \u0026lt; len; i++)  {   // 跳过已排序的数  int k = i;   // 忽略已排序的数，直接从未排序的数开始比较，找出未排序数中的最小数  for(j = i; j \u0026lt; len; j++)  {  printf(\u0026#34;%d\\n\u0026#34;,i);  if(arr[j] \u0026lt; arr[k])  {  // 将一对数中较小的数的索引赋给 k  k = j;  }  }   // 将最小的那个数移到数组最前面  t = arr[k];  arr[k] = arr[i];  arr[i] = t;  } }  int main() {  int arr[] = {5,7,1,3,8,12,2,9};  SelectionSort(arr,8);  for(int j = 0; j \u0026lt; 8; j++)  {  printf(\u0026#34;%d \u0026#34;,arr[j]);  } } ","title":"冒泡排序"},{"content":"进制 进制也是进位计数制，是人为定义的带进位的计数方法。\n十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，N 进制就是逢 N 进位。\n用不同的进制表示同一个数，虽然使用的进制不一样，但内部依旧表示的同一个数，只是外部所表现形式不一样而已。\n进制的表示  B 表示二进制 O 表示八进制 D 表示十进制 H 表示十六进制  二进制的规律  1 = 1 10 = 21 100 = 22 1000 = 23 10000 = 24  ","permalink":"https://note.yxzi.xyz/note/technology/computer/%E8%BF%9B%E5%88%B6/%E8%BF%9B%E5%88%B6/","summary":"进制 进制也是进位计数制，是人为定义的带进位的计数方法。\n十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，N 进制就是逢 N 进位。\n用不同的进制表示同一个数，虽然使用的进制不一样，但内部依旧表示的同一个数，只是外部所表现形式不一样而已。\n进制的表示  B 表示二进制 O 表示八进制 D 表示十进制 H 表示十六进制  二进制的规律  1 = 1 10 = 21 100 = 22 1000 = 23 10000 = 24  ","title":"进制"},{"content":"进制转换 二进制与八进制的转换 二进制转八进制 从右向左，三位一段，分别转换，不够三位补零。\n0101110 —\u0026gt; 000, 101, 110，三位一段。\n（000 = 0）（101 = 5）（110 = 6），则最后得到八进制数56。\n八进制转二进制 将每一个八进制位转换为 3 个二进制位。\n27 —\u0026gt; （010）（111），最后得到二进制数10111。\n二进制与十六进制的转换 二进制转十六进制 从右向左，四位一段，分别转换，不够四位补零。\n因为一个十六进制位有 16 种状态，所以需要 4 个二进制位的排列组合来表示，即每个 16 进制位，都需要用 4 个二进制位来表示，所以，我们可以将一串二进制位划分为好几段，四位为一段，不够四位的在前方补零，最后再一段一段的进行转换。\n0101110 —\u0026gt; 0010, 1110，四位一段。\n（0010 = 2）（1110 = 14 = E），则最后得到十六进制数2E\n十六进制转二进制 将每一个十六进制位转换为 4 个二进制位。\n2E —\u0026gt; （0010）（1110），一段四位则最后得到二进制数101110\n十进制转 N 进制 **除 N 取余，直至商 0 ，余数倒序。**十六进制需要将余数转换\n十进制转二进制 除以二取余，并将余数倒过来，即可得出结果。\n比如 185：\n 18 / 2 = 92， 余 1\n92 / 2 = 46，余 0\n46 / 2 = 23，余 0\n23 / 2 = 11， 余 1\n11 / 2 = 5 ， 余 1\n5 / 2 = 2， 余 1\n2 / 2 = 1， 余 0\n1 / 2 = 1， 余 1\n 最后将余数倒过来，即可得到 185 的二进制数：10111001。\n十进制转八进制 除以八取余，并将余数倒过来，即可得出结果。\n比如 185：\n 185 / 8 = 23， 余 1\n23 / 8 = 2， 余 7\n2 / 8 = 0， 余 2\n 最后将余数倒过来，即可得到 185 的八进制数：271。\n十进制转十六进制 除以十六取余，并将余数倒过来，即可得出结果。\n比如 185：\n 185 / 16 = 11，余 9\n11 / 16 = 0， 余 11 —\u0026gt; B\n 然后因为 11 在十六进制中是 B，所以需要将 11 变为 B，\n最后将余数倒过来，即可得到 185 的十六进制数：B9。\nN 进制转十进制 给定一个 N 进制的数 25，转换为十进制为：5 + 2 * N。比如 5 进制的 32 转为十进制为：2 + 3 * 5 = 17。\n不存在十六进制与八进制的直接相互转化，都是以二进制为中间进制来进行转化。\n十进制转十进制 1234 —\u0026gt; 4 * 10º + 3 * 10¹ + 2 * 10² + 1 * 10³ = 1234\n二进制转十进制 10101 —\u0026gt; 1 * 2º + 0 * 2 ¹ + 1 * 2² + 0 *2³ + 1 * 2⁴ = 21\n八进制转十进制 371 —\u0026gt; 1 * 8º + 7 * 8¹ + 3 * 8² = 249\n十六进制转十进制 E01A —\u0026gt; 10 * 16º + 1 * 16¹ + 0 * 16² + 14 * 16³ = 4106\n","permalink":"https://note.yxzi.xyz/note/technology/computer/%E8%BF%9B%E5%88%B6/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/","summary":"进制转换 二进制与八进制的转换 二进制转八进制 从右向左，三位一段，分别转换，不够三位补零。\n0101110 —\u0026gt; 000, 101, 110，三位一段。\n（000 = 0）（101 = 5）（110 = 6），则最后得到八进制数56。\n八进制转二进制 将每一个八进制位转换为 3 个二进制位。\n27 —\u0026gt; （010）（111），最后得到二进制数10111。\n二进制与十六进制的转换 二进制转十六进制 从右向左，四位一段，分别转换，不够四位补零。\n因为一个十六进制位有 16 种状态，所以需要 4 个二进制位的排列组合来表示，即每个 16 进制位，都需要用 4 个二进制位来表示，所以，我们可以将一串二进制位划分为好几段，四位为一段，不够四位的在前方补零，最后再一段一段的进行转换。\n0101110 —\u0026gt; 0010, 1110，四位一段。\n（0010 = 2）（1110 = 14 = E），则最后得到十六进制数2E\n十六进制转二进制 将每一个十六进制位转换为 4 个二进制位。\n2E —\u0026gt; （0010）（1110），一段四位则最后得到二进制数101110\n十进制转 N 进制 **除 N 取余，直至商 0 ，余数倒序。**十六进制需要将余数转换\n十进制转二进制 除以二取余，并将余数倒过来，即可得出结果。\n比如 185：\n 18 / 2 = 92， 余 1","title":"进制转换"},{"content":"结构体 将一些基本类型数据组合在一起，形成一个新的复合数据类型，这个复合数据类型，就是结构体。\n为什么需要结构体 为了表示一些复杂的事物，而普通的基本类型无法满足我们的实际需求\n结构体的定义 结构体有三种定义方式，但最常用的定义方式是第一种，第二种和第三种都不常用，相较于第一种定义方式，第一种和第二种方式也不是特别好。\n需要注意的是，结构体最后的分号不能省去。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.h\u0026gt;// 第一种定义结构体的方式 // 只定义变量类型， 但不定义变量名， // 变量名由我们使用这个变量类型的时候定义。 struct Student{  int age;  float score;  char sex; }; // 第二种定义结构体的方式 // 定义的同时，也将变量名（Sts）定义了（变量名写死了）。 struct Students{  int age;  float score;  char sex; } Sts; // 第三种定义结构体的方式 // 没有定义变量类型，只定义了变量名。 struct{  int age;  float score;  char sex; }St;  int main(void) { } ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E7%BB%93%E6%9E%84%E4%BD%93/%E7%BB%93%E6%9E%84%E4%BD%93/","summary":"结构体 将一些基本类型数据组合在一起，形成一个新的复合数据类型，这个复合数据类型，就是结构体。\n为什么需要结构体 为了表示一些复杂的事物，而普通的基本类型无法满足我们的实际需求\n结构体的定义 结构体有三种定义方式，但最常用的定义方式是第一种，第二种和第三种都不常用，相较于第一种定义方式，第一种和第二种方式也不是特别好。\n需要注意的是，结构体最后的分号不能省去。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.h\u0026gt;// 第一种定义结构体的方式 // 只定义变量类型， 但不定义变量名， // 变量名由我们使用这个变量类型的时候定义。 struct Student{  int age;  float score;  char sex; }; // 第二种定义结构体的方式 // 定义的同时，也将变量名（Sts）定义了（变量名写死了）。 struct Students{  int age;  float score;  char sex; } Sts; // 第三种定义结构体的方式 // 没有定义变量类型，只定义了变量名。 struct{  int age;  float score;  char sex; }St;  int main(void) { } ","title":"C 结构体"},{"content":"结构体的使用 初始化和赋值   初始化一个结构体的时候，可以同时进行赋值。\n  先初始化一个结构体，后续再一个变量一个变量的进行赋值。\n  #include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.h\u0026gt; struct Student{  int age;  float score;  char sex; };  int main(void) {  // 初始化结构体，同时进行赋值  struct Student Rainy = {18,98.3,\u0026#39;N\u0026#39;};  // 初始化结构体，后续再一个变量一个变量的进行赋值  struct Student Rainys;  Rainys.age = 21;  Rainys.score = 95.6;  Rainys.sex = \u0026#39;V\u0026#39;;  printf(\u0026#34;%d %f %c\\n\u0026#34;,Rainy.age,Rainy.score,Rainy.sex);  printf(\u0026#34;%d %f %c\u0026#34;,Rainys.age,Rainys.score,Rainys.sex);  } 访问结构体中的变量  通过结构体变量名.成员变量名的方式去访问结构体中的变量 通过指针变量名-\u0026gt;成员变量名 = (*指针变量名).成员变量名  虽然这两种访问方式不一样，但是本质上是一样的。但是第二种方式更常用。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.h\u0026gt; struct Student{  int age;  float score;  char sex; };  int main(void) {  // 初始化结构体，同时进行赋值  struct Student Rainy = {18,98.3,\u0026#39;N\u0026#39;};  // 定义一个指针变量 Student，变量名为 Rainys，  // 用来存放 Rainy 的地址  struct Student *Rainys = \u0026amp;Rainy;  // 下面的代码其实就是将 Rainy 的成员变量都修改了  // 因为Rainys 中存放的其实是 Rainy 的地址，即Rainys就是Rainy  // 因此，最后的输出才都是相同的，  Rainys -\u0026gt; age = 21;  Rainys -\u0026gt; score = 95.6;  Rainys-\u0026gt; sex = \u0026#39;V\u0026#39;;  // 输出内容一样，因为Rainy中的成员变量被我们通过 Rainy 修改了  printf(\u0026#34;%d %f %c\\n\u0026#34;,Rainy.age,Rainy.score,Rainy.sex);  printf(\u0026#34;%d %f %c\u0026#34;,Rainys -\u0026gt; age,Rainys -\u0026gt; score,Rainys -\u0026gt; sex);  // Rainys -\u0026gt; age 在计算机内部会被转换成(*Rainys).age。这是一种规定。  // 所以 Rainys -\u0026gt; age 等价于 (*Rainys).age 也等价于 Rainy.age } 结构体变量和结构体指针变量作为函数参数传递的问题 用函数修改结构体的成员或给结构体的成员赋值，传入函数的实参必须是结构体变量的地址。\n用函数输出结构体中的成员，可以直接将结构体变量作为函数的实参，也可以使用结构体变量的指针作为函数的实参。但是，我依旧推荐你将结构体的指针地址作为实参，因为这会让你节省内存地占用，并且还能提高你的程序的执行效率。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;string.h\u0026gt; struct Student{  int age;  float score;  char sex[100]; }; // 声明函数的参数为指针变量 void InputStudent(struct Student *); void OutStudent(struct Student); void OutPStudent(struct Student *); int main(void) {  struct Student st;  // 输出 st 所占的字节总数 108。  printf(\u0026#34;%d\\n\u0026#34;,sizeof(st));  // 给 st 中的成员赋值，因为需要修改结构体中的成员，  // 所以该函数的实参必须是 st 的地址  InputStudent(\u0026amp;st);  // 直接传入 st，输出 st 中的成员，只输出，不修改，所以该函数的实参可以不是 st 的指针地址。  // 当然， 也可以 是 st 的地址  OutStudent(st);  // 也可以传入 st 的指针地址，输出 st 中的成员，我们推荐你使用这种方式。  OutPStudent(\u0026amp;st);  return 0; } // pstu 只占 4 个字节，因为它是指针变量 // * pstu = st // pstu = st 的地址 void InputStudent(struct Student * pstu){  // (*pstu).age = pstu-\u0026gt;age =10;  (*pstu).age = 10;  // 将指定字符串\u0026#34;女\u0026#34;赋值到指定地址的内存空间，返回值为char  strcpy(pstu-\u0026gt;sex,\u0026#34;女\u0026#34;);  // pstu-\u0026gt;score = 100 = (*pstu).score = 100;  pstu-\u0026gt;score = 100; } // 直接传入 st，输出 st 中的成员，不推荐这种方法，因为这相当于重新定义了一个 out 结构体， // 并将 st 中的内容复制到 out 中，即：相当于多用了 108 个字节的内存空间 void OutStudent(struct Student out){  // 输出 out 所占字节数， 和 st 所占字节数是一样的。  printf(\u0026#34;%d\\n\u0026#34;,sizeof(out));  printf(\u0026#34;传入 st 内容的输出方式：%d %.2f %s\\n\u0026#34;,out.age,out.score,out.sex); }  // 传入 st 的指针地址，输出 st 中的成员 void OutPStudent(struct Student *outP){  // 输出 outP 所占字节数，只占 8 个字节（指针变量只占 8 个字节。32 位系统占 4 个字节，64 位系统占 8个字节）  // 用这种方式输出，比上面那种直接传入 st 的内容要节约所占的内存空间，  // 因为这样就不用将 st 中的所有内容都赋值到 * out，只需要将 st 第一个字节的地址赋值到 * out 就可以了。  printf(\u0026#34;%d\\n\u0026#34;,sizeof(outP));  printf(\u0026#34;传入 st 地址的输出方式：%d %.2f %s\\n\u0026#34;,(*outP).age,(*outP).score,(*outP).sex); } 结构体变量的运算 结构体成员不能相加、不能相减，也不能相互乘除。\n但结构体成员可以互相赋值。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;string.h\u0026gt; struct Student{  int age;  char sex;  char name[10]; }; int main(void) {  struct Student st1,st2;  // st1 + st2  // st1 * st2  // st1 / st2  // st1 = st2 或 st2 = st1 都是正确的 } 动态构造存放学生信息的结构体数组 动态的构造一个存放学生信息（姓名、成绩、年龄）的数组。\n用冒泡排序对这个数组中的学生进行升序，升序规则依照的是学生的成绩。\n# include \u0026lt;stdio.h\u0026gt; # include \u0026lt;malloc.h\u0026gt; // 构造储存学生信息的变量 struct Student {  char name[100];  int age;  float score; }; void sort(int * a, int len){  int i,j,t;  for (i = 0; i \u0026lt; len-1;i ++){  for(j = 0;j \u0026lt; len - 1- i;j++){  if (a[j] \u0026gt; a[j+1]){  t = a[j];  a[j] = a [j+1];  a[j + 1] = t;  }  }  } } int main(void) {  int len;  struct Student * pArr;  int i,j;  struct Student t;   printf(\u0026#34;请输入学生的个数：\\n\u0026#34;);  printf(\u0026#34;学生个数为： \u0026#34;);  scanf(\u0026#34;%d\u0026#34;,\u0026amp;len);  // 动态构造一维数组来存放每个 Student 的信息，并将第一个 Student 的地址存放到 pArr 中  pArr = (struct Student *)malloc(len * sizeof(struct Student));   // 输入学生信息  for(int i = 0; i \u0026lt; len; ++i){  printf(\u0026#34;请输入第 %d 个学生的信息：\\n\u0026#34;,i + 1);   printf(\u0026#34;name = \u0026#34;);  // name 是数组名，本身就已经是数组首元素的地址，所以不需要加 \u0026amp;  scanf(\u0026#34;%s\u0026#34;,pArr[i].name);   printf(\u0026#34;age = \u0026#34;);  scanf(\u0026#34;%d\u0026#34;,\u0026amp;pArr[i].age);   printf(\u0026#34;score = \u0026#34;);  scanf(\u0026#34;%f\u0026#34;,\u0026amp;pArr[i].score);  }  // 对学生的成绩进行升序  for (i = 0; i \u0026lt; len-1;i ++){  for(j = 0;j \u0026lt; len - 1- i;j++){  // 以 pArr 中的成绩来比较，并进行升序，将 \u0026gt; 改为 \u0026lt; 就进行降序  if (pArr[j].score \u0026gt; pArr[j+1].score){  t = pArr[j];  pArr[j] = pArr[j+1];  pArr[j + 1] = t;  }  }  }  // 输出学生信息  for(int i = 0; i \u0026lt; len; ++i){  printf(\u0026#34;%s的信息是：\\n\u0026#34;,pArr[i].name);  printf(\u0026#34;name = %s\\n\u0026#34;,pArr[i].name);  printf(\u0026#34;age = %d\\n\u0026#34;,pArr[i].age);  printf(\u0026#34;score = %.0f\\n\u0026#34;,pArr[i].score);  }  printf(\u0026#34;\\n\u0026#34;); } ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E7%BB%93%E6%9E%84%E4%BD%93/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"结构体的使用 初始化和赋值   初始化一个结构体的时候，可以同时进行赋值。\n  先初始化一个结构体，后续再一个变量一个变量的进行赋值。\n  #include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.h\u0026gt; struct Student{  int age;  float score;  char sex; };  int main(void) {  // 初始化结构体，同时进行赋值  struct Student Rainy = {18,98.3,\u0026#39;N\u0026#39;};  // 初始化结构体，后续再一个变量一个变量的进行赋值  struct Student Rainys;  Rainys.age = 21;  Rainys.score = 95.6;  Rainys.sex = \u0026#39;V\u0026#39;;  printf(\u0026#34;%d %f %c\\n\u0026#34;,Rainy.age,Rainy.score,Rainy.sex);  printf(\u0026#34;%d %f %c\u0026#34;,Rainys.age,Rainys.score,Rainys.sex);  } 访问结构体中的变量  通过结构体变量名.成员变量名的方式去访问结构体中的变量 通过指针变量名-\u0026gt;成员变量名 = (*指针变量名).","title":"C 结构体的使用"},{"content":"at 表示地点 at + 小地方 at + 小地方容易和 in + 小地方混淆，前者表示在某个地方的范围或附近，而后者表示在某个地方的内部或里面。\n They met me at the station. They are at the balcony. My mother planted some flowers at the balcony.  需要注意的是 at 不能加大地方。\n表示时间 在\u0026hellip;时刻 at 都是加一个基数词，表示在几点钟。\n I got up at six this morning. I get up at six every morning.  表示状态或从事与  they are at meeting.  表示速度/价格  I bought it at a low price. The pen was sold at three dollars. He drove his car at 60 miles an hour.  表示动作方向  The girl is smiling at me.  跟一个集体性名词构成介词短语  She met a handsome man at her friend\u0026rsquo;s birthday party.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/at/","summary":"at 表示地点 at + 小地方 at + 小地方容易和 in + 小地方混淆，前者表示在某个地方的范围或附近，而后者表示在某个地方的内部或里面。\n They met me at the station. They are at the balcony. My mother planted some flowers at the balcony.  需要注意的是 at 不能加大地方。\n表示时间 在\u0026hellip;时刻 at 都是加一个基数词，表示在几点钟。\n I got up at six this morning. I get up at six every morning.  表示状态或从事与  they are at meeting.  表示速度/价格  I bought it at a low price.","title":"English at"},{"content":"实义动词 表示有实际意义的动词，除了系动词、助动词、情态动词，剩下的就是实义动词。\n任何一个实义动词都有五种形式（原型、过去式、过去分词、现在分词、第三人称单数格式）。\n虽然一个实义动词有五种格式，但是这五种格式都是同一个意思，比如 work、worked、works，都是工作的意思。\n为什么一个单词会有五种不同的形式？这是因为英语有时态的变化，即不同的时态，使用不同的形式。\n一般来说，过去式、过去分词、现在分词和第三人称单数格式都是通过原型变化而成的。在单词的原型后面增加字母组合，这叫词尾变化。\n不及物动词 可以独立完成的动词叫做不及物动词，动词后面不需要物，也不能有物，因为不加物的情况下，这个句子的意思已经完整了\n因为，一个单词有不同的意思，因此，一个单词也有可能又是及物动词，又是不及物动词。\n Rainy sleeping. I work.  单及物动词 只有一个动作承受者，单及物动词后面只能跟着一个物。\n Rainy like you. Rainy buy water.  双及物动词  有两个动作承受者，即动词后有两个“物”，一个“动物”，一个“物体”。 Rainy teaches you English。 一般句型为：主语 + 双及物动词 + 间接宾语 + 直接宾语。  复杂及物动词  只有一个动作承受者，动词后面要有一个“物”，这个物后面还要有一个对这个“物”的补充说明 Rainy consider you smart。 一般句型为：主语 + 复杂及物动词 + 宾语 + 宾补。  复合动词 由动词和另一个单词或几个单词所构成的词组。\n动词短语虽然由几个词构成，但实际上它只表示一个动作。\n Look after Look forward to Look at Git up  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E5%AE%9E%E4%B9%89%E5%8A%A8%E8%AF%8D/","summary":"实义动词 表示有实际意义的动词，除了系动词、助动词、情态动词，剩下的就是实义动词。\n任何一个实义动词都有五种形式（原型、过去式、过去分词、现在分词、第三人称单数格式）。\n虽然一个实义动词有五种格式，但是这五种格式都是同一个意思，比如 work、worked、works，都是工作的意思。\n为什么一个单词会有五种不同的形式？这是因为英语有时态的变化，即不同的时态，使用不同的形式。\n一般来说，过去式、过去分词、现在分词和第三人称单数格式都是通过原型变化而成的。在单词的原型后面增加字母组合，这叫词尾变化。\n不及物动词 可以独立完成的动词叫做不及物动词，动词后面不需要物，也不能有物，因为不加物的情况下，这个句子的意思已经完整了\n因为，一个单词有不同的意思，因此，一个单词也有可能又是及物动词，又是不及物动词。\n Rainy sleeping. I work.  单及物动词 只有一个动作承受者，单及物动词后面只能跟着一个物。\n Rainy like you. Rainy buy water.  双及物动词  有两个动作承受者，即动词后有两个“物”，一个“动物”，一个“物体”。 Rainy teaches you English。 一般句型为：主语 + 双及物动词 + 间接宾语 + 直接宾语。  复杂及物动词  只有一个动作承受者，动词后面要有一个“物”，这个物后面还要有一个对这个“物”的补充说明 Rainy consider you smart。 一般句型为：主语 + 复杂及物动词 + 宾语 + 宾补。  复合动词 由动词和另一个单词或几个单词所构成的词组。\n动词短语虽然由几个词构成，但实际上它只表示一个动作。\n Look after Look forward to Look at Git up  ","title":"English 实义动词"},{"content":"非实义动词 助动词 它没有意思的，且不能单独使用，只能用于协助系动词或实义动词构成复合谓语。\n注意不要将助动词与它本身的实义弄混淆。\n比如 Might eat，助动词 might，协助谓语动词 eat 表示可能吃，但 might 也可以表示力量，注意别将助动词与其本身的实义弄混淆。\n助动词有：be、do、have、will、would、shall、should.\n Do you love me. I do not love you. I did not love you. She does not love you.  情态动词 它是语气助动词，情态动词本身有意义，但是意义不完整。比如can、should、need、have、dare、had better.\n情态动词后面必须跟一个动词原型，才能构成一个复合谓语使用。\n情态动词一般不能跟助动词连用。\n I must earn money every day. I should help you. You must be hungry. I can speak English. I have to do.  系动词 不单是动作，将动词之后的信息赋给在动词之前信息。也叫连系动词，即连系表语的词。\n系动词不能单独使用，必须跟表语一起用。\n系动词大部分都是 be 动词，它有八种形式：\n be（原型） is（第一人称单数） am（第三人称单数） are（You 和复数） was（单数的过去式） were（复数的过去式） being（过去分词） been（现在分词）  be 动词都是是的意思，但有有些时候并不用在一句话中被翻译出来。\n Rainy is tall. Rainy is in the room. Rainy looks tall.  除了 be，还有少数的实义动词可以充当系动词。这些系动词虽然是实义动词充当的，但是作系动词的意思和作实义动词的意思是不同的。\n You look beautifu.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E5%AE%9E%E4%B9%89%E5%8A%A8%E8%AF%8D/","summary":"非实义动词 助动词 它没有意思的，且不能单独使用，只能用于协助系动词或实义动词构成复合谓语。\n注意不要将助动词与它本身的实义弄混淆。\n比如 Might eat，助动词 might，协助谓语动词 eat 表示可能吃，但 might 也可以表示力量，注意别将助动词与其本身的实义弄混淆。\n助动词有：be、do、have、will、would、shall、should.\n Do you love me. I do not love you. I did not love you. She does not love you.  情态动词 它是语气助动词，情态动词本身有意义，但是意义不完整。比如can、should、need、have、dare、had better.\n情态动词后面必须跟一个动词原型，才能构成一个复合谓语使用。\n情态动词一般不能跟助动词连用。\n I must earn money every day. I should help you. You must be hungry. I can speak English. I have to do.  系动词 不单是动作，将动词之后的信息赋给在动词之前信息。也叫连系动词，即连系表语的词。\n系动词不能单独使用，必须跟表语一起用。\n系动词大部分都是 be 动词，它有八种形式：\n be（原型） is（第一人称单数） am（第三人称单数） are（You 和复数） was（单数的过去式） were（复数的过去式） being（过去分词） been（现在分词）  be 动词都是是的意思，但有有些时候并不用在一句话中被翻译出来。","title":"English 非实义动词"},{"content":"about 表示有关，关于 about + 名词  about Rainy. about Chongqing. about English.  about + 代词的宾格  about + me.  about 动名词短语  about haveing a party. about buying a ship.  当 about 表示关于的时候，只能作后置定语和表语，一般情况不能作状语。\nThe news about Rainy is not true.\nThe story is about Susu and Rainy.\n表示在附近 about 有时候可以表示在\u0026hellip;附近。\n表示在身边 about 表示在身边的时候，一般都用在固定结构里面：Have sth about sb.\n I have a cellphone about me. Jack had a gun about him. Do you have your id card about you?  表示大概，大约 about + 数词 about 可以跟表示几点钟的数词，表示大概几点。\n we begin our class at about 20:00. Please come about 5:00. I finish my work at about 6:00.  另外，about 也可以修饰数词（主要是基数词），专门修饰和限定数词。表示大概\u0026hellip;的意思。\n I have about 20 students.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/about/","summary":"about 表示有关，关于 about + 名词  about Rainy. about Chongqing. about English.  about + 代词的宾格  about + me.  about 动名词短语  about haveing a party. about buying a ship.  当 about 表示关于的时候，只能作后置定语和表语，一般情况不能作状语。\nThe news about Rainy is not true.\nThe story is about Susu and Rainy.\n表示在附近 about 有时候可以表示在\u0026hellip;附近。\n表示在身边 about 表示在身边的时候，一般都用在固定结构里面：Have sth about sb.\n I have a cellphone about me. Jack had a gun about him.","title":"English about"},{"content":"after 表示时间/顺序 after + 时间点 after 可以放在一个表示具体时间点的词语的前面，表示在\u0026hellip;之后。\n I sleep after 10:00 every day. I Fitness after work. She Play the game after class. I will retire after 35 years old . I born after 2001. I class after Sunday.  after + 一段时间 after 跟表示时间段的词语 。\n He come back after a week. after an hour. after three years.  after + 动名词短语  After getting up every morning, I turn on my computer.  after + 句子 这种情况表示由于\u0026hellip;/鉴于\u0026hellip;的意思。\n After failing in the test,he decided to work hard.  表示追赶/追求/追寻 after + 名词或人称代词宾格 虽然种用法有表示动作的意义，但是这个是介词短语，不能当动词用。\n The police are after the thief. The cat is after a mouse.  表示依照/仿照  read after me  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/after/","summary":"after 表示时间/顺序 after + 时间点 after 可以放在一个表示具体时间点的词语的前面，表示在\u0026hellip;之后。\n I sleep after 10:00 every day. I Fitness after work. She Play the game after class. I will retire after 35 years old . I born after 2001. I class after Sunday.  after + 一段时间 after 跟表示时间段的词语 。\n He come back after a week. after an hour. after three years.  after + 动名词短语  After getting up every morning, I turn on my computer.","title":"English after"},{"content":"as 表示当作/作为 as + 一个表示人的名词  As a good wife, you should know how to cook. As a good husband, I must earn much money. As a Englishs teacher, I am happy.  as + 名词 这个时候 as + 名词是放在句尾作状语，这个时候 as 后面的名词不一定是表示人的名词。\n I eat rice gruel as breakfast.（把稀饭当作早餐） I chose the novel as my textbook. Don’t treat me as  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/as/","summary":"as 表示当作/作为 as + 一个表示人的名词  As a good wife, you should know how to cook. As a good husband, I must earn much money. As a Englishs teacher, I am happy.  as + 名词 这个时候 as + 名词是放在句尾作状语，这个时候 as 后面的名词不一定是表示人的名词。\n I eat rice gruel as breakfast.（把稀饭当作早餐） I chose the novel as my textbook. Don’t treat me as  ","title":"English as"},{"content":"by by 有时候是介词，有时候也会和其他的词组成一些介词短语。\n stand by pass by  这里主要说一些 by 作普通介词短情况。\n表示时间  到\u0026hellip;为止。  By + 表示时间的词语，表示到某个时间点为止。\n He ought to be here by now. by the end of this term, I had learned 300 words. Rainy has made a lot of money by now.  表示位置  强调靠近 在\u0026hellip;旁边。 在\u0026hellip;身边。  by 可以表示位置，与 beside 是同义词。区别就是 beside 用的多，by 用的少，后者更强调靠近的意思。\n She lives by the sea. The house by the sea is beautiful. Come and sit by me.  表示方法、手段 靠，用，以，通过，乘。\nby + 表示交通工具的名词，表示乘坐\u0026hellip;交通工具。\n I go to home by bike. My friend go to work by subway.  另外，by + 动名词，表示通过什么动作/方式。\n I increased my words by reading more novele.  表示运动方向  沿着、经过、经由  by + 动词短语，可以表示经过某个地方。\n They came through the fields, not by the hill road. I go to school by his house.  表示某种标准  以\u0026hellip; 按\u0026hellip; 根据  by + 某些词语构成介词短语，表示根据某种标去做某事。\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/by/","summary":"by by 有时候是介词，有时候也会和其他的词组成一些介词短语。\n stand by pass by  这里主要说一些 by 作普通介词短情况。\n表示时间  到\u0026hellip;为止。  By + 表示时间的词语，表示到某个时间点为止。\n He ought to be here by now. by the end of this term, I had learned 300 words. Rainy has made a lot of money by now.  表示位置  强调靠近 在\u0026hellip;旁边。 在\u0026hellip;身边。  by 可以表示位置，与 beside 是同义词。区别就是 beside 用的多，by 用的少，后者更强调靠近的意思。\n She lives by the sea. The house by the sea is beautiful.","title":"English by"},{"content":"during 表示时间  在\u0026hellip;期间 在\u0026hellip;的时候  during + 表示特定时间的名词构成介词短语，但是 during 后面这个名词必须在意义上含有一段时间，又不能是表示时间点的词语，所以不能直接跟数词.\n during 5:10 She eared one million dollars during the ten days. He came during your absence.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/during/","summary":"during 表示时间  在\u0026hellip;期间 在\u0026hellip;的时候  during + 表示特定时间的名词构成介词短语，但是 during 后面这个名词必须在意义上含有一段时间，又不能是表示时间点的词语，所以不能直接跟数词.\n during 5:10 She eared one million dollars during the ten days. He came during your absence.  ","title":"English during"},{"content":"in 表示在某个地方。 in + 大地方 这种情况，表示在某个地方，没有里面的意思。\n We live in the world. The people in Asia are poor. She is in Shanghai.  in + 小地方 这种情况，表示在某个地方内部。\n They are making shoes in the factory. They make shoes in the factory every. The girl in the factory are young.  另外，还有一些含有 in 的固定介词短语，这些固定的介词短语，有固定的意思和用法。\n表示时间 in + 年份/月份  I set up my website in 2021. I met my wife in 2021. We are busy in summer.  in + 时间长度 时间长度可以理解为一段时间。\nin 2020这个介词短语表示在 2020 年，而in 2020 years表示2020 年之后（一段时间之后）\n I will be a rich man in five years. Jeff will buy a big house in five years. He will come bake in a week.  表示状态/情况/服饰 in + 表示颜色的名词 这种情况，主要表示穿什么颜色的衣服。\n He was in black yesterday. The girl in red is my student.  in + 衣服的名词 这种情况，表示穿什么衣服。需要加定冠词。\n The girl in a rad coat is my student.  in 构成的固定介词短语 这种情况，表示处于某种状态。\n His life is in danger. You are in trouble.  表示语言/方法/语调/笔墨 in + 表示语言的名词 这种情况表示用\u0026hellip;语言。\n He wrote the composition in English. It is written in ink.  表示运动或者动作的方向  He put a pen in his bag. I keep my books in the box.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/in/","summary":"in 表示在某个地方。 in + 大地方 这种情况，表示在某个地方，没有里面的意思。\n We live in the world. The people in Asia are poor. She is in Shanghai.  in + 小地方 这种情况，表示在某个地方内部。\n They are making shoes in the factory. They make shoes in the factory every. The girl in the factory are young.  另外，还有一些含有 in 的固定介词短语，这些固定的介词短语，有固定的意思和用法。\n表示时间 in + 年份/月份  I set up my website in 2021. I met my wife in 2021.","title":"English in"},{"content":"on 表示位置 在\u0026hellip;上面 on 加一个表示物体的名词，表示在这个物体的上面，并且强调跟物体的表面接触。\n Children are playing a game on the floor, The picture on the wall is expensive. My book is one the bed.  表示时间 在..时候 on + 表示时间的名词构成介词短语的时候，一般表示一天之内的时间（具体某一天），比如某日、星期几、日期、或某日的上午/中午/下午/晚上等等。\n The handsome man met Pandora on the morning of May 10,2003. We will have a party on July 15. He came on the morning of My 1st.  表示状态 处于\u0026hellip;状态  Who is on duty today? The house is on fire. My father went to Guangzhou on business.  表示关系 当 on 表示这种意思的时候，on 跟 about 是同义词。区别就是 on 是正式用语，书面语中会出现，about 是普通用语，口语和书面语都很常见。\n I bought a book on/about health.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/on/","summary":"on 表示位置 在\u0026hellip;上面 on 加一个表示物体的名词，表示在这个物体的上面，并且强调跟物体的表面接触。\n Children are playing a game on the floor, The picture on the wall is expensive. My book is one the bed.  表示时间 在..时候 on + 表示时间的名词构成介词短语的时候，一般表示一天之内的时间（具体某一天），比如某日、星期几、日期、或某日的上午/中午/下午/晚上等等。\n The handsome man met Pandora on the morning of May 10,2003. We will have a party on July 15. He came on the morning of My 1st.  表示状态 处于\u0026hellip;状态  Who is on duty today? The house is on fire.","title":"English on"},{"content":"多级指针 其实就是指针的指针int**，或指针的指针的指针int***，或者指针的指针的指针的指针int****。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.h\u0026gt; int main() {  // i 存放的是 int 类型  int i = 10;  // p 存放 i 的地址，且这个地址只能是 int 类型的地址，因为 p 是 int 类型的指针变量。  int * p = \u0026amp;i;  // q 存放 p 的地址，且这个地址只能是 int * 类型的地址，不能存放 int 类型的地址，因为 q 是 int* 类型的指针变量。  int ** q = \u0026amp;p;  // r 存放 q 的地址,且这个地址只能int**的地址，不能存放 int * 类型的地址，因为 r 是 int **类型的指针变量。  int *** r = \u0026amp;q;  printf(\u0026#34;%d\u0026#34;,***r); } #include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.h\u0026gt;void f(int **q) {  // *q = p } int main() {  int i = 10;  // p 是 int * 类型，\u0026amp;p 是 int ** 类型。  int * p = \u0026amp;i;  f(\u0026amp;p); } ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88/","summary":"多级指针 其实就是指针的指针int**，或指针的指针的指针int***，或者指针的指针的指针的指针int****。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.h\u0026gt; int main() {  // i 存放的是 int 类型  int i = 10;  // p 存放 i 的地址，且这个地址只能是 int 类型的地址，因为 p 是 int 类型的指针变量。  int * p = \u0026amp;i;  // q 存放 p 的地址，且这个地址只能是 int * 类型的地址，不能存放 int 类型的地址，因为 q 是 int* 类型的指针变量。  int ** q = \u0026amp;p;  // r 存放 q 的地址,且这个地址只能int**的地址，不能存放 int * 类型的地址，因为 r 是 int **类型的指针变量。  int *** r = \u0026amp;q;  printf(\u0026#34;%d\u0026#34;,***r); } #include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.","title":"C 多级指针"},{"content":"跨函数使用变量 静态内存不能跨函数使用 当静态函数终止之后，这个静态函数中的数据就不能被其他函数访问，因为这个静态函数的内存空间已经被释放了。就算可以使用，也是非法访问，这样是不对的。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.h\u0026gt;// q 是指针变量，无论 q 是什么类型的指针变量，都只占 4 个字节 // 将实参 *p 传入 fun 函数的形参，则**q = *p, 则*q = p，q 存放的是 p 的地址， void fun(int **q){  int i = 5;  // ** q = i  // *q = p  //q = p 的地址  // **q = *p  // 因为 *q = p，所以这里相当于 p = \u0026amp;1，  *q = \u0026amp;i; } int main(void) {  int *p;  // 取 p（*p） 的地址，传入函数 fun，实际传入的是 *p，则 **q = *p  fun(\u0026amp;p);  // 下面代码语法没问题，但是逻辑上有问题。  // 这是因为当 fun 函数执行完毕后，fun 函数中的 i 变量已经被释放，  // 因此，p 虽然可以存放 i 的地址， 但是却不能访问 i 。  // 就算能够访问 i ，这也是非法的访问，没 error 是因为编译器的问题。  printf(\u0026#34;%d\\n\u0026#34;,*p); } 动态内存可以跨函数使用 因为当一个函数执行完毕，动态内存分配的变量不会随着fun()的自动释放而释放，所以，当fun()被系统自动释放后，我们依旧可以访问变量*p\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.h\u0026gt;// **q = *p 的地址 // *q = p // q = p 的地址 void fun(int **q) {  // * q 变量的空间是动态分配的  // 因为 *q = p，则 p = (int *)malloc(sizeof(int));  // 所以 *p 的内存是动态分配的  *q = (int *)malloc(sizeof(int));  // 因为 **q = *p 的地址，则*p = 5，  // 所以这里是将 5 放入动态分配的 * p 中  **q = 5; }  int main(void) {  int *p;  fun(\u0026amp;p);  // 返回 *p，这次不会造成非法访问，这是因为 *p 的内存是动态分配的  // 动态分配的内存不会被系统自动释放，所以就算 f 函数被系统自动释放了，  // 但我们依旧可以访问 *p （动态变量）中的数据，  // 这个动态变量只能由我们使用free() 函数来手动释放  printf(\u0026#34;%d\\n\u0026#34;,*p); } ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E8%B7%A8%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98/","summary":"跨函数使用变量 静态内存不能跨函数使用 当静态函数终止之后，这个静态函数中的数据就不能被其他函数访问，因为这个静态函数的内存空间已经被释放了。就算可以使用，也是非法访问，这样是不对的。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.h\u0026gt;// q 是指针变量，无论 q 是什么类型的指针变量，都只占 4 个字节 // 将实参 *p 传入 fun 函数的形参，则**q = *p, 则*q = p，q 存放的是 p 的地址， void fun(int **q){  int i = 5;  // ** q = i  // *q = p  //q = p 的地址  // **q = *p  // 因为 *q = p，所以这里相当于 p = \u0026amp;1，  *q = \u0026amp;i; } int main(void) {  int *p;  // 取 p（*p） 的地址，传入函数 fun，实际传入的是 *p，则 **q = *p  fun(\u0026amp;p);  // 下面代码语法没问题，但是逻辑上有问题。  // 这是因为当 fun 函数执行完毕后，fun 函数中的 i 变量已经被释放，  // 因此，p 虽然可以存放 i 的地址， 但是却不能访问 i 。  // 就算能够访问 i ，这也是非法的访问，没 error 是因为编译器的问题。  printf(\u0026#34;%d\\n\u0026#34;,*p); } 动态内存可以跨函数使用 因为当一个函数执行完毕，动态内存分配的变量不会随着fun()的自动释放而释放，所以，当fun()被系统自动释放后，我们依旧可以访问变量*p","title":"C 跨函数使用内存"},{"content":"专用名词 专有名词，就是人名、地名、专门机构等。\n大多数的专有名词是不可数名词，在某些情况下可以复数使用，或者转换为普通名词的单数/复数使用。\n专有名词的首字母必须大写。\n Rainy is student. Beijing is beautiful China is so large. FBI is very famous  一个可数名词的单数是不能单独再句子或短语里面出现的，需要加限定词（形容词性物主代词，指示代词、数词等等）、冠词或变直接复数。比如 she is teacher这句话就是不对的，应该改为 she is a teacher 或者she is my teacher或 She is Nick\u0026rsquo;s teacher\n特殊的 当Mother的首字母大写后，它表示称呼语，相当于一个专有名词，可以单独使用；如果是小写的mother，那么则表示可数名词单数，不能单独使用\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D/","summary":"专用名词 专有名词，就是人名、地名、专门机构等。\n大多数的专有名词是不可数名词，在某些情况下可以复数使用，或者转换为普通名词的单数/复数使用。\n专有名词的首字母必须大写。\n Rainy is student. Beijing is beautiful China is so large. FBI is very famous  一个可数名词的单数是不能单独再句子或短语里面出现的，需要加限定词（形容词性物主代词，指示代词、数词等等）、冠词或变直接复数。比如 she is teacher这句话就是不对的，应该改为 she is a teacher 或者she is my teacher或 She is Nick\u0026rsquo;s teacher\n特殊的 当Mother的首字母大写后，它表示称呼语，相当于一个专有名词，可以单独使用；如果是小写的mother，那么则表示可数名词单数，不能单独使用","title":"English 专有名词"},{"content":"普通名词 普通名词 除了专业名词以外的词都是普通名词。\n普通名词被分为可数名词和不可数名词。\n专有名词复数使用，专业名词转换普通名词  There are two Jacks in our class Millions of Lei Fengs have emerged in China Hey, Tom, have a Mrs. Carl is waiting for you  可数名词 可数名词（单数复数都可以，可以用数词计算）\n可数名词能加不定冠词（a/an）和数词（one、two）\n可数名词可以加定冠词（the）\n比如 apple、egg、boy、tree、family、class、police、team 等等\n可数名词单数不能单独作主语使用：Book is expensive.\n正确的应该是：\n The Book is expensive. My books are good.  单数和复数 单数指的就是一个事物。复数指的是两个及以上的事物。\n单数变复数规则  大部分可数名词可以直接在词尾 + s. 以字母 s、sh、x、ch 结尾时，在词尾 +es. 以辅音字母 +y 结尾的时候，把 y 变为 i 后，再 +es。如果以元音字母 + y 结尾时，就不用变化，直接在词尾 +s 即可。 以字母 f 或 fe 结尾的时候，把 f 或 fe 变为 v 后，再＋ es。 以辅音字母 + o 结尾的时候，在词尾 +es 以**元音字母 + o **结尾的可数名词或以 o 结尾的简写词，在词尾 +s.  部分可数名词的单数和复数形式是一样的，比如 deer、sheep、Chinese、Japanese 等等。\n有些可数名词，只有复数形式，没有单数形式，这种词被称为复数名词，比如 people、police、public、clothes、cattle 等等。因为这些词所指的事物都不够具体，哪一个人？什么样的衣服？什么样的牛？\n不可数名词 不可数名词（只能单数，不可以用数词计算）\n比如 water、fire、、time、hope、knowledge、intelligence 等等。\n不可数名词不能加不定冠词（a/an）和数词（one、two）\n不可数名词可以加定冠词（the）\n不可数名词可以单独作主语。\n Water is beautiful.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E6%99%AE%E9%80%9A%E5%90%8D%E8%AF%8D/","summary":"普通名词 普通名词 除了专业名词以外的词都是普通名词。\n普通名词被分为可数名词和不可数名词。\n专有名词复数使用，专业名词转换普通名词  There are two Jacks in our class Millions of Lei Fengs have emerged in China Hey, Tom, have a Mrs. Carl is waiting for you  可数名词 可数名词（单数复数都可以，可以用数词计算）\n可数名词能加不定冠词（a/an）和数词（one、two）\n可数名词可以加定冠词（the）\n比如 apple、egg、boy、tree、family、class、police、team 等等\n可数名词单数不能单独作主语使用：Book is expensive.\n正确的应该是：\n The Book is expensive. My books are good.  单数和复数 单数指的就是一个事物。复数指的是两个及以上的事物。\n单数变复数规则  大部分可数名词可以直接在词尾 + s. 以字母 s、sh、x、ch 结尾时，在词尾 +es. 以辅音字母 +y 结尾的时候，把 y 变为 i 后，再 +es。如果以元音字母 + y 结尾时，就不用变化，直接在词尾 +s 即可。 以字母 f 或 fe 结尾的时候，把 f 或 fe 变为 v 后，再＋ es。 以辅音字母 + o 结尾的时候，在词尾 +es 以**元音字母 + o **结尾的可数名词或以 o 结尾的简写词，在词尾 +s.","title":"English 普通名词"},{"content":"量词 我们可以用量词来表示不可数名词的数量。但不是每一个量词都可以修饰每一个不可数名词。\n当不可数名词的单复数变化时，只需将量词从单数变为复数。\n量词中的 of 时没有意思的，它主要就是为了修饰不可数名词，作前置定语，另外，量词也可以修饰可数名词的复数形式，但不能修饰可数名词的的单数形式。毕竟一个名词用量词修饰，说明这个名词不止一个，如果这个名词还用单数形式的话，就不合理了。\n a glass of water. two bottle of milk. a kilograms of meat. a basket of apples  量词的构成 a/an/one + 可数名词单数 + of  a cup of a bucket of a glass of a box of  数词 + 可数名词的复数 + of  two bottles of three tins of the boxes of  并不是所有可数名词都能构成量词，只有那种有内部空间或表示容器或一些符合逻辑的可数名词才能构成量词。\n不要用中文的量词思维来判断英文的量词使用。比如不能 a table of food，因为 table 没有内部空间或表示容器的意思。\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E9%87%8F%E8%AF%8D/","summary":"量词 我们可以用量词来表示不可数名词的数量。但不是每一个量词都可以修饰每一个不可数名词。\n当不可数名词的单复数变化时，只需将量词从单数变为复数。\n量词中的 of 时没有意思的，它主要就是为了修饰不可数名词，作前置定语，另外，量词也可以修饰可数名词的复数形式，但不能修饰可数名词的的单数形式。毕竟一个名词用量词修饰，说明这个名词不止一个，如果这个名词还用单数形式的话，就不合理了。\n a glass of water. two bottle of milk. a kilograms of meat. a basket of apples  量词的构成 a/an/one + 可数名词单数 + of  a cup of a bucket of a glass of a box of  数词 + 可数名词的复数 + of  two bottles of three tins of the boxes of  并不是所有可数名词都能构成量词，只有那种有内部空间或表示容器或一些符合逻辑的可数名词才能构成量词。\n不要用中文的量词思维来判断英文的量词使用。比如不能 a table of food，因为 table 没有内部空间或表示容器的意思。","title":"English 量词"},{"content":"介词短语的构成 要学好介词短语，先要掌握一个概念：介词宾语。\n介词和介词宾语在一起构成的短语叫作介词短语：介词 + 介词宾语 = 介词短语\n介词短语可以被分成四种类型。\n介词宾语 介词后面的词语叫介词宾语。\n介词宾语和宾语是不一样的，千万不要混淆。\n宾语是动作的承受。\n介词宾语仅仅只是放在介词后面的词语。\n介词 + 名词 这是最常见、最普通、最容易的介词短语形式。绝大部分介词后面都可以跟一个名词构成一个介词短语。一个介词短语，不管这个名词是专有名词还是普通名词，当然如果是普通名词，要注意可数名词单复数的问题。\n in China. under the tree. behind my house. beside Rainy.  介词 + 人称代词宾格  beside me. before you. behind him.  介词 +数词 需要注意的是，并不是每一个介词后面都能跟数词。\n in 2023. at 5 : 30.  介词 +动词短语 虽然部分介词的后面可以跟动动词短语构成介词短语，但是这种介词短语的出现频率非常高。\n before having dinner. about learning English. by watching TV.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E7%9F%AD%E8%AF%AD%E7%9A%84%E6%9E%84%E6%88%90/","summary":"介词短语的构成 要学好介词短语，先要掌握一个概念：介词宾语。\n介词和介词宾语在一起构成的短语叫作介词短语：介词 + 介词宾语 = 介词短语\n介词短语可以被分成四种类型。\n介词宾语 介词后面的词语叫介词宾语。\n介词宾语和宾语是不一样的，千万不要混淆。\n宾语是动作的承受。\n介词宾语仅仅只是放在介词后面的词语。\n介词 + 名词 这是最常见、最普通、最容易的介词短语形式。绝大部分介词后面都可以跟一个名词构成一个介词短语。一个介词短语，不管这个名词是专有名词还是普通名词，当然如果是普通名词，要注意可数名词单复数的问题。\n in China. under the tree. behind my house. beside Rainy.  介词 + 人称代词宾格  beside me. before you. behind him.  介词 +数词 需要注意的是，并不是每一个介词后面都能跟数词。\n in 2023. at 5 : 30.  介词 +动词短语 虽然部分介词的后面可以跟动动词短语构成介词短语，但是这种介词短语的出现频率非常高。\n before having dinner. about learning English. by watching TV.  ","title":"English 介词短语的构成"},{"content":"介词短语的用法 作状语 介词短语作状语的时候，可以在主谓宾或主系表中充当时间状语和地点状语，有时候还可以充当方式状语。\n作地点状语 当介词作地点状语的时候，这个介词就可以在句子中充当地点状语的作用\n主系表 + 介词短语作地点状语\n I am happy in Guangxi. I was sad in Guangxi. They are busy in Beijing.  主谓宾 + 介词短语作地点状语\n I work in China.  作时间状语 当介词作时间状语的时候，这个介词就可以在句子中充当时间状语的作用\n I was young in 2023. I get up at six. We will be famous in 2020.  作方式状语 少数的介词短语，还能表达动作的方式。\n Can you write in English. I tell stories in English.  作后置定语 介词短语作后置定语，跟前置定语一样，只能修饰普通名词。\n凡是有后置定语修饰的名词，大部分都需要加一个定冠词 the，当然，如果想要表达泛指的意思，那么可以不用加 the。\n The center of the city. The air in Beijing. The table under the tree.  以上三个都是介词短语，不属于句子，仅仅只是一个名词 + 后置定语\n I like the mountains in Guangxi. The air in Beijing is dirty. The table under the tree is very big.  表示地点的介词短语作后置定语的时候，还可以修饰表示人的名词。\n The people in Guangxi. The girls from Sichuan. The girl under the tree.  同样，可以拿上面的介词短语来造句。\n The people in Guangxi are hard-working. The girl from Sichuan are beautiful. He likes the girls from Sichuan. I like the girl with a book.  表示地点的介词短语才可以作后置定语，表示时间或方式的介词短语，一般不能作后置定语\n如何分清介词短语是作后置定语还是地点地点状语 有时候，我们会分不清一个介词短语到底是作地点状语还是后置定语：\n I like the girl under the tree.  这句话里面的under the tree到底是作地点状语翻译为：我在树下喜欢这个女孩子。\n还是作后置定语翻译为：我喜欢树下的这个女孩子 ？\n这个时候我们应该根据逻辑来判断，很明显，当under the tree作后置定语的时候才符合逻辑，因此，这里的under the tree是作后置定语，而不是地点状语。\n作表语 大部分表示位置的介词短语，都可以作表语。\n介词短语作表语直接放在主系表句型里面的系动词后面就可以了。\n当然， 有时候少数表示时间的介词短语也可以作表语。\n  They are behind my car.\n  My birthday is on Feb 22.\n  I will be in Beijing in the future.\n  She is under the tree.\n  The computer is on the table.\n  作宾补 能作宾补的介词短语，大多数都是表示位置的介词短语，特殊情况除外。\n I put my money in my drawer. I put my coat on the bed. They must keep these machines in good condition.  作主补  My coat was put on the bed by me.  one the bed补充说明主语my cota的情况。\n主语补足语就是宾语补足语，因为被动语态本来就是把宾语变成主语，它们本质上是一样的，意义也差不多，只是结构和作用不一样，因此，叫法也不一样。\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E7%9F%AD%E8%AF%AD%E7%9A%84%E7%94%A8%E6%B3%95/","summary":"介词短语的用法 作状语 介词短语作状语的时候，可以在主谓宾或主系表中充当时间状语和地点状语，有时候还可以充当方式状语。\n作地点状语 当介词作地点状语的时候，这个介词就可以在句子中充当地点状语的作用\n主系表 + 介词短语作地点状语\n I am happy in Guangxi. I was sad in Guangxi. They are busy in Beijing.  主谓宾 + 介词短语作地点状语\n I work in China.  作时间状语 当介词作时间状语的时候，这个介词就可以在句子中充当时间状语的作用\n I was young in 2023. I get up at six. We will be famous in 2020.  作方式状语 少数的介词短语，还能表达动作的方式。\n Can you write in English. I tell stories in English.  作后置定语 介词短语作后置定语，跟前置定语一样，只能修饰普通名词。","title":"English 介词短语的用法"},{"content":"CDN 使网址的加载速度变快。\n","permalink":"https://note.yxzi.xyz/note/technology/internet/cdn/","summary":"CDN 使网址的加载速度变快。","title":"CDN"},{"content":"Vue Vue 是一套用于构建用户界面的渐进式 JavaScript 框架。\n它主要解决了前端开发中的核心痛点 —— 复杂的 DOM 操作。\n特点 渐进式 可以只将网站中的一个页面或网站中的某一个区域使用 Vue 来开发。当然，也可以整个网站都用 Vue 来开发。\n组件化 采用组件化开发模式，将一个复杂的网站，简化为一个个的组件，独立开发，能提高代码复用率，且让代码更好维护。\n响应式 数据响应式，即后台数据（model）发生变化，前台的内容（View），也会相应的变化。\n其他 不在使用传统的命令式编码，在 Vue 中，使用声明式编码，让我们无需直接操作 DOM，提高开发效率。\n. 使用虚拟 DOM + 优秀的 Diff 算法，尽量复用 DOM 节点。\nVue 应用场景 前台部分页面，用户看到的网站页面。\n中台全部页面，网站给某些额非官方人员提供的管理页面。比如淘宝卖家的管理后台等。\n后台全部页面，网站官方的后台管理页面。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/vue/","summary":"Vue Vue 是一套用于构建用户界面的渐进式 JavaScript 框架。\n它主要解决了前端开发中的核心痛点 —— 复杂的 DOM 操作。\n特点 渐进式 可以只将网站中的一个页面或网站中的某一个区域使用 Vue 来开发。当然，也可以整个网站都用 Vue 来开发。\n组件化 采用组件化开发模式，将一个复杂的网站，简化为一个个的组件，独立开发，能提高代码复用率，且让代码更好维护。\n响应式 数据响应式，即后台数据（model）发生变化，前台的内容（View），也会相应的变化。\n其他 不在使用传统的命令式编码，在 Vue 中，使用声明式编码，让我们无需直接操作 DOM，提高开发效率。\n. 使用虚拟 DOM + 优秀的 Diff 算法，尽量复用 DOM 节点。\nVue 应用场景 前台部分页面，用户看到的网站页面。\n中台全部页面，网站给某些额非官方人员提供的管理页面。比如淘宝卖家的管理后台等。\n后台全部页面，网站官方的后台管理页面。","title":"Vue"},{"content":"Vue 实例 new 一个 Vue 实例，并将其赋给一个配置对象 ：\nvar vm = new Vue({}) 该配置对象vm中有非常多的属性，大部分属性都是以$和_开头，这是为了避免与我们定义的属性重名。\n以$开头的属性，都是供开发者使用的；而以_开头的属性，是内置属性，不供我们使用。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/vue-%E5%AE%9E%E4%BE%8B/","summary":"Vue 实例 new 一个 Vue 实例，并将其赋给一个配置对象 ：\nvar vm = new Vue({}) 该配置对象vm中有非常多的属性，大部分属性都是以$和_开头，这是为了避免与我们定义的属性重名。\n以$开头的属性，都是供开发者使用的；而以_开头的属性，是内置属性，不供我们使用。","title":"Vue 实例"},{"content":"使用 Vue  引入 Vue.js。  本地 js 文件。 Vue CDN。   脚手架。  官方脚手架vue-cli。 其他民间脚手架，如webpack-simple。 手动搭建，灵活性高。    第一个 Vue 程序 创建 Vue 实例，并传给一个配置对象。\nroot 容器里的代码被称为 Vue 模板，模板中是插值语法{{}}，其中只能写 JavaScrip 表达式。\n一个 Vue 实例，只能控制一个容器，它们之间只能一一对应。\nHTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \t\u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;!-- {{}}插值语法 --\u0026gt; \t\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;{{ message }}\u0026lt;/div\u0026gt; \t\u0026lt;/body\u0026gt; \t\u0026lt;script src=\u0026#34;./main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; JavaScript // new 一个 名为 app 的 vue 实例 var app = new Vue({  // 选择一个在页面上已存在的 DOM 元素作为操作元素  el: \u0026#39;#app\u0026#39;,  // 将数据内容 message 插入到 el 所选择的元素  data: {  message: \u0026#39;vue 加载成功!\u0026#39;,  }, });  // 设置为 false 以阻止 vue 在启动时生成生产提示。 Vue.config.productionTip = false; ","permalink":"https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E4%BD%BF%E7%94%A8-vue/","summary":"使用 Vue  引入 Vue.js。  本地 js 文件。 Vue CDN。   脚手架。  官方脚手架vue-cli。 其他民间脚手架，如webpack-simple。 手动搭建，灵活性高。    第一个 Vue 程序 创建 Vue 实例，并传给一个配置对象。\nroot 容器里的代码被称为 Vue 模板，模板中是插值语法{{}}，其中只能写 JavaScrip 表达式。\n一个 Vue 实例，只能控制一个容器，它们之间只能一一对应。\nHTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \t\u0026lt;head\u0026gt; \t\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \t\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \t\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \t\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  \t\u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \t\u0026lt;/head\u0026gt;  \t\u0026lt;body\u0026gt; \t\u0026lt;!","title":"使用 Vue"},{"content":"前端和后端 前端 前端是链接终端设备与人的技术。行的网页，并配合后端做网页的数据显示和交互等可视方面的工作内容。 后端是指用户看不见的东西，通常是与前端工程师进行数据交互及网站数据的保存和读取，相对来说后端涉及到的逻辑代码比前端要多的多，后端考虑的是底层业务逻辑的实现，平台的稳定性与性能等。\n所用技术 前端开发用到的技术包括但不限于 html5、css3、javascript、jquery、Bootstrap、Node.js 、Webpack，AngularJs，ReactJs，VueJs 等技术。 后端开发 以 java 为例 主要用到的 是包括但不限于 Struts spring springmvc Hibernate Http 协议 Servlet Tomcat 服务器等技术。\n工作职责 前端工程师主要的工作职责分为三大部分，分别是传统的 Web 前端开发，移动端开发和大数据呈现端开发。Web 前端开发主要针对的是 PC 端开发任务；移动端开发则包括 Android 开发、iOS 开发和各种小程序开发，在移动互联网迅速发展的带动下，移动端的开发任务量是比较大的，随着 5G 标准的落地，未来移动端的开发任务将得到进一步的拓展；大数据呈现则主要是基于已有的平台完成最终分析结果的呈现，呈现方式通常也有多种选择，比如大屏展示等。 后端工程师的主要职责也集中在三大部分，分别是平台设计、接口设计和功能实现。平台设计主要是搭建后端的支撑服务容器；接口设计主要针对于不同行业进行相应的功能接口设计，通常一个平台有多套接口，就像卫星导航平台设有民用和军用两套接口一样；功能实现则是完成具体的业务逻辑实现。\n知识结构 在知识结构方面，前端开发涉及到的内容包括 Html、CSS、JavaScript、Android 开发（采用 Java 或者 kotlin）、iOS 开发（采用 OC 或者 Swift）、各种小程序开发技术（类 Html），随着前端开发任务的不断拓展，前端开发后端化也是一个较为明显的趋势，比如 Nodejs 的应用。 后端开发通常需要根据业务场景进行不同语言的选择，另外后端开发的重点在于算法设计、数据结构、性能优化等方面，在具体的功能实现部分可以采用 Java、Python 或者 PHP 等编程语言来实现。对于不少中小企业来说，后端开发通常都会采用开源的开发平台，这样就可以把精力集中在业务处理上，通常应用级程序员就可以解决问题，相应的开发成本也会有大幅度的下降。\n应用范围 从应用范围来看，前端开发不仅被常人所知、且应用场景也要比后端广泛的太多太多。 一是 PC (Personal Computer) 即个人电脑。目前电脑端仍是前端一个主要的领域，主要分为面向大众的各类网站，如新闻媒体、社交、电商、论坛等和面向管理员的各种 CMS (内容管理系统)和其它的后台管理系统。 二 Web App 是指使用 Web 开发技术，实现的有较好用户体验的 Web 应用程序。它是运行在手机和桌面端浏览中，随着移动端网络速度的提升，Web App 为我们提供了很大的便利。此外近两年 Google 提出了一种新的 Web App 形态，即 PWA(渐进增强 Web APP) 。三 WeChat (微信) 这个平台，拥有大量的用户群体，因此它也是我们前端开发另一个重要的领域。微信的公众号与订阅号为市场营销和自媒体从业者，打造了一个新的天地。 四 Hybrid App (混合应用) 是指介于 Web App、原生 App (主要是 Android 或 iOS )之间的 App，它兼具原生 App 良好用户交互体验的优势和 Web App 跨平台开发的优势。 五 Game（游戏），HTML5 游戏从 2014 年 Egret 引擎开发的神经猫引爆朋友圈之后，就开始一发不可收拾。不过现在游戏开发变得越来越复杂，需要制作各种炫丽炫丽的效果，还要制作各炫丽于 2D 或者 3D 的场景。 六 Desktop 桌面应用软件，就是我们日常生活中电脑中安装的各类软件。早期要开发桌面应用程序，就需要有专门的语言 UI (界面) 库支持，如 C++ 中的 Qt 库、MFC 库，Java 的 Swing、Python 的 PyQT 等，否则语言是没办法进行快速界面开发。 七 Server Node.js 一发布，立刻在前端工程师中引起了轩然大波，前端工程师们几乎立刻对这一项技术表露出了相当大的热情和期待。看到 Node.js 这个名字，初学者可能会误以为这是一个 Java 应用，事实上，Node.js 采用 C++ 语言编写而成，是一个 Java 的运行环境。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF/","summary":"前端和后端 前端 前端是链接终端设备与人的技术。行的网页，并配合后端做网页的数据显示和交互等可视方面的工作内容。 后端是指用户看不见的东西，通常是与前端工程师进行数据交互及网站数据的保存和读取，相对来说后端涉及到的逻辑代码比前端要多的多，后端考虑的是底层业务逻辑的实现，平台的稳定性与性能等。\n所用技术 前端开发用到的技术包括但不限于 html5、css3、javascript、jquery、Bootstrap、Node.js 、Webpack，AngularJs，ReactJs，VueJs 等技术。 后端开发 以 java 为例 主要用到的 是包括但不限于 Struts spring springmvc Hibernate Http 协议 Servlet Tomcat 服务器等技术。\n工作职责 前端工程师主要的工作职责分为三大部分，分别是传统的 Web 前端开发，移动端开发和大数据呈现端开发。Web 前端开发主要针对的是 PC 端开发任务；移动端开发则包括 Android 开发、iOS 开发和各种小程序开发，在移动互联网迅速发展的带动下，移动端的开发任务量是比较大的，随着 5G 标准的落地，未来移动端的开发任务将得到进一步的拓展；大数据呈现则主要是基于已有的平台完成最终分析结果的呈现，呈现方式通常也有多种选择，比如大屏展示等。 后端工程师的主要职责也集中在三大部分，分别是平台设计、接口设计和功能实现。平台设计主要是搭建后端的支撑服务容器；接口设计主要针对于不同行业进行相应的功能接口设计，通常一个平台有多套接口，就像卫星导航平台设有民用和军用两套接口一样；功能实现则是完成具体的业务逻辑实现。\n知识结构 在知识结构方面，前端开发涉及到的内容包括 Html、CSS、JavaScript、Android 开发（采用 Java 或者 kotlin）、iOS 开发（采用 OC 或者 Swift）、各种小程序开发技术（类 Html），随着前端开发任务的不断拓展，前端开发后端化也是一个较为明显的趋势，比如 Nodejs 的应用。 后端开发通常需要根据业务场景进行不同语言的选择，另外后端开发的重点在于算法设计、数据结构、性能优化等方面，在具体的功能实现部分可以采用 Java、Python 或者 PHP 等编程语言来实现。对于不少中小企业来说，后端开发通常都会采用开源的开发平台，这样就可以把精力集中在业务处理上，通常应用级程序员就可以解决问题，相应的开发成本也会有大幅度的下降。\n应用范围 从应用范围来看，前端开发不仅被常人所知、且应用场景也要比后端广泛的太多太多。 一是 PC (Personal Computer) 即个人电脑。目前电脑端仍是前端一个主要的领域，主要分为面向大众的各类网站，如新闻媒体、社交、电商、论坛等和面向管理员的各种 CMS (内容管理系统)和其它的后台管理系统。 二 Web App 是指使用 Web 开发技术，实现的有较好用户体验的 Web 应用程序。它是运行在手机和桌面端浏览中，随着移动端网络速度的提升，Web App 为我们提供了很大的便利。此外近两年 Google 提出了一种新的 Web App 形态，即 PWA(渐进增强 Web APP) 。三 WeChat (微信) 这个平台，拥有大量的用户群体，因此它也是我们前端开发另一个重要的领域。微信的公众号与订阅号为市场营销和自媒体从业者，打造了一个新的天地。 四 Hybrid App (混合应用) 是指介于 Web App、原生 App (主要是 Android 或 iOS )之间的 App，它兼具原生 App 良好用户交互体验的优势和 Web App 跨平台开发的优势。 五 Game（游戏），HTML5 游戏从 2014 年 Egret 引擎开发的神经猫引爆朋友圈之后，就开始一发不可收拾。不过现在游戏开发变得越来越复杂，需要制作各种炫丽炫丽的效果，还要制作各炫丽于 2D 或者 3D 的场景。 六 Desktop 桌面应用软件，就是我们日常生活中电脑中安装的各类软件。早期要开发桌面应用程序，就需要有专门的语言 UI (界面) 库支持，如 C++ 中的 Qt 库、MFC 库，Java 的 Swing、Python 的 PyQT 等，否则语言是没办法进行快速界面开发。 七 Server Node.","title":"前端和后端"},{"content":"动态一维数组 动态一维数组可以被当作静态一维数组来来用，换言之，静态数组可以实现的，动态数组都可以实现，不同的是，动态一维数组可以被我们使用free()函数助动释放掉，而且可以用realloc()动态的缩小或扩充。\n而静态一维数组只能等当前函数执行完毕后，才会被系统自动释放。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.h\u0026gt; int main() {  // 静态创建一维数组，数组大小为 20个字节  // 静态数组只能等它自己所在的函数 main 执行完毕后，才会被系统助动释放。  int a[5];   // 动态创建一维数组  // 数组长度  int len;  // 数组名  int * pArr;  //自定义数组长度  printf(\u0026#34;请输入你要存放的元素个数：\u0026#34;);  scanf(\u0026#34;%d\u0026#34;,\u0026amp;len);// 5  // 动态创建一维数组，数组大小为 20个字节，类似于 int pArr[len];  pArr = (int *)malloc(4 * len);   // 向动态数组里面添加元素  for(int i = 0; i \u0026lt; len; i++)  {  scanf(\u0026#34;%d\u0026#34;,\u0026amp;pArr[i]);  printf(\u0026#34;你向数组中添加了：%d\\n\u0026#34;,pArr[i]);  }   // 输出动态数组中所有的元素  printf(\u0026#34;pArr 数组中的元素有：\u0026#34;);  for(int i = 0; i \u0026lt; len; i++)  {  printf(\u0026#34;%d、\u0026#34;,pArr[i]);  } } ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E5%8A%A8%E6%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/","summary":"动态一维数组 动态一维数组可以被当作静态一维数组来来用，换言之，静态数组可以实现的，动态数组都可以实现，不同的是，动态一维数组可以被我们使用free()函数助动释放掉，而且可以用realloc()动态的缩小或扩充。\n而静态一维数组只能等当前函数执行完毕后，才会被系统自动释放。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.h\u0026gt; int main() {  // 静态创建一维数组，数组大小为 20个字节  // 静态数组只能等它自己所在的函数 main 执行完毕后，才会被系统助动释放。  int a[5];   // 动态创建一维数组  // 数组长度  int len;  // 数组名  int * pArr;  //自定义数组长度  printf(\u0026#34;请输入你要存放的元素个数：\u0026#34;);  scanf(\u0026#34;%d\u0026#34;,\u0026amp;len);// 5  // 动态创建一维数组，数组大小为 20个字节，类似于 int pArr[len];  pArr = (int *)malloc(4 * len);   // 向动态数组里面添加元素  for(int i = 0; i \u0026lt; len; i++)  {  scanf(\u0026#34;%d\u0026#34;,\u0026amp;pArr[i]);  printf(\u0026#34;你向数组中添加了：%d\\n\u0026#34;,pArr[i]);  }   // 输出动态数组中所有的元素  printf(\u0026#34;pArr 数组中的元素有：\u0026#34;);  for(int i = 0; i \u0026lt; len; i++)  {  printf(\u0026#34;%d、\u0026#34;,pArr[i]);  } } ","title":"C 动态一维数组"},{"content":"静态变量和动态变量 如果一个变量所对应的内存空间是静态分配的，那么这个变量就是静态变量。\n如果一个变量所对应的内存空间是动态分配的，那么这个变量就是动态变量。\n静态变量 静态变量在栈内存中分配。由程序自动分配，也由程序自动释放。在函数运行的过程中，无法被使用者手动释放，必须等函数执行完毕。\n动态变量 动态变量在堆内存中分配。由使用者手动分配，也由使用者手动释放。在函数的运行的过程中，可以被使用者手动释放，不需要等待函数执行完毕。\n","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F/","summary":"静态变量和动态变量 如果一个变量所对应的内存空间是静态分配的，那么这个变量就是静态变量。\n如果一个变量所对应的内存空间是动态分配的，那么这个变量就是动态变量。\n静态变量 静态变量在栈内存中分配。由程序自动分配，也由程序自动释放。在函数运行的过程中，无法被使用者手动释放，必须等函数执行完毕。\n动态变量 动态变量在堆内存中分配。由使用者手动分配，也由使用者手动释放。在函数的运行的过程中，可以被使用者手动释放，不需要等待函数执行完毕。","title":"C 静态变量和动态变量"},{"content":"副词 用于修饰动词或形容词，有时也可以修饰数词、介词、连词、名词或一整个句子。\n副词是表示行为或状态特征的词，主要作状语、也可以作表语、定语、补足语或介词宾语。\n I ate two apple quickly  当一个句子中同时出现多个不同的副词的时候，书写顺序如下：方式副词 —— 地点副词 —— 时间副词\n特殊副词 在英语中，很多单词都有多重词性，比如一些单词，可以作副词，也可以作形容词，有些还有其他词性。\n High Deep Hard Early  high  The mountain is high.（形容词） The kite is flying high.（方式副词）  副词的比较级和最高级 副词也有比较级和最高级，但是注意了，一般情况下，只有方式副词才有比较级和最高级，其他副词一般没有，比较级和最高级的构成方式和形容词是一样的。\n I run faster than he. She speaks more slowly than than me. She did her homework more carefully than me.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E5%89%AF%E8%AF%8D/","summary":"副词 用于修饰动词或形容词，有时也可以修饰数词、介词、连词、名词或一整个句子。\n副词是表示行为或状态特征的词，主要作状语、也可以作表语、定语、补足语或介词宾语。\n I ate two apple quickly  当一个句子中同时出现多个不同的副词的时候，书写顺序如下：方式副词 —— 地点副词 —— 时间副词\n特殊副词 在英语中，很多单词都有多重词性，比如一些单词，可以作副词，也可以作形容词，有些还有其他词性。\n High Deep Hard Early  high  The mountain is high.（形容词） The kite is flying high.（方式副词）  副词的比较级和最高级 副词也有比较级和最高级，但是注意了，一般情况下，只有方式副词才有比较级和最高级，其他副词一般没有，比较级和最高级的构成方式和形容词是一样的。\n I run faster than he. She speaks more slowly than than me. She did her homework more carefully than me.  ","title":"English 副词"},{"content":"地点副词 大部分表示地点、方位的词语都是用介词短语来表示。地点副词也是主要作地点状语，当然，也不是每一个地点副词都可以作地点状语的。\n here there upstairs  地点副词和时间副词不同的，地点副词作地点状语的时候通常不受时态的影响，只要符合逻辑，基本大部分时态都可以用地点副词作状语。\n一般情况，当一句话中同时出现地点状语和时间状语，那么，地点状语通常在前面，时间副词在后面\n I am visiting a friend here. I learn English here every day. They are having a party outside. They are safe abroad. We see ads everywhere.  少数地点副词可以作后置定语修饰名词。  The house here are expensive. The house abroad are expensive. We girl ustairs likes joe.  少数地点副词可以作表语。 作表语的时候，直接将地点副词放到系动词 be 后面。\n I am here. I was here last night. They are there. My wifi is here. I am back. Time is up.  少数地点副词可以作宾补。 不是所有的及物动词都可以加宾补。\n Let him out Put it dawn. I put my money here. I keep money here. I left my book there  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E5%9C%B0%E7%82%B9%E5%89%AF%E8%AF%8D/","summary":"地点副词 大部分表示地点、方位的词语都是用介词短语来表示。地点副词也是主要作地点状语，当然，也不是每一个地点副词都可以作地点状语的。\n here there upstairs  地点副词和时间副词不同的，地点副词作地点状语的时候通常不受时态的影响，只要符合逻辑，基本大部分时态都可以用地点副词作状语。\n一般情况，当一句话中同时出现地点状语和时间状语，那么，地点状语通常在前面，时间副词在后面\n I am visiting a friend here. I learn English here every day. They are having a party outside. They are safe abroad. We see ads everywhere.  少数地点副词可以作后置定语修饰名词。  The house here are expensive. The house abroad are expensive. We girl ustairs likes joe.  少数地点副词可以作表语。 作表语的时候，直接将地点副词放到系动词 be 后面。\n I am here. I was here last night. They are there.","title":"English 地点副词"},{"content":"方式副词 表示动作的方式的词语。\n Very much Loudly. fast.  方式副词只能作方式状语，并且只能修饰实义动词，所以方式副词只能用在动作的句子里面。\n方式副词绝大部分放在句尾，少数情况可以放在中间和句首。\n大部分的方式副词都是形容词 + ly 构成的，也有一部分是独立的。所以不能单看 ly 来判断某个单词是否是方式副词。比如 hard、fast 这两个没有 ly 结尾，但都是方式副词，而 friendly、lovely 这两个都有 ly 结尾，但是属于形容词，不是方式副词。\n I love you very much. I like your book very much. She cried suddenly. He always does his homework carefully. I speak English slowly.  当一个句子中同时出现多个不同的副词的时候，书写顺序如下：方式副词 —— 地点副词 —— 时间副词\n She did her homework carefully upstairs last night. He is working hard outside now. My borther reads English loudly upstairs every day.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E6%96%B9%E5%BC%8F%E5%89%AF%E8%AF%8D/","summary":"方式副词 表示动作的方式的词语。\n Very much Loudly. fast.  方式副词只能作方式状语，并且只能修饰实义动词，所以方式副词只能用在动作的句子里面。\n方式副词绝大部分放在句尾，少数情况可以放在中间和句首。\n大部分的方式副词都是形容词 + ly 构成的，也有一部分是独立的。所以不能单看 ly 来判断某个单词是否是方式副词。比如 hard、fast 这两个没有 ly 结尾，但都是方式副词，而 friendly、lovely 这两个都有 ly 结尾，但是属于形容词，不是方式副词。\n I love you very much. I like your book very much. She cried suddenly. He always does his homework carefully. I speak English slowly.  当一个句子中同时出现多个不同的副词的时候，书写顺序如下：方式副词 —— 地点副词 —— 时间副词\n She did her homework carefully upstairs last night. He is working hard outside now. My borther reads English loudly upstairs every day.","title":"English 方式副词"},{"content":"时间副词 表示时间的副词，就是时间副词。\n just now early before recently already just  时间副词数量比较少，副词数量少的原因主要是，表示时间的词语大部分由介词短语构成。\n同一句话，其实可以跟两个或两个以上的时间状语，但是要注意逻辑和顺序。通常是短（小范围）的时间状语在前，长（大范围—）的间状语在后。\n I get up early every morning. She goes to bed at 10:30 every night.  时间状语主要作时间状语，大部分在情况放在句尾。\n时间副词作时间状语的时候，要特别的注意时态的问题，不同的时间副词，能用在不同的时态里面，有些时间副词不能用在特定的时态。比如\n I am learning English now.  Now Now 主要用在现在进行时态里面，当然，也可以用在其他时态，但当 now 用在其他时态的时候，通常有其他的意思。\n I am busy now. She is tired now. Joe is tired now.  Soon Soon 主要用在一般将来时态。\n I will go home soon. I will be rich soon.  Ago 主要用在一般过去时态。\n不能单独用，前面需要加表示时间长度的词语。\n I was a middle school student. Rainy was a pupil.  Everyday 主要用在一般现在时态，有时也可以用在一般将来时态和过去时态。\n I am busy everyday.  Eevery/Last/Next/This/That + 表示时间名词的单数 这种叫作名词作状语，一般用在一般现在时态。\n every night. Last month. This evening.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E6%97%B6%E9%97%B4%E5%89%AF%E8%AF%8D/","summary":"时间副词 表示时间的副词，就是时间副词。\n just now early before recently already just  时间副词数量比较少，副词数量少的原因主要是，表示时间的词语大部分由介词短语构成。\n同一句话，其实可以跟两个或两个以上的时间状语，但是要注意逻辑和顺序。通常是短（小范围）的时间状语在前，长（大范围—）的间状语在后。\n I get up early every morning. She goes to bed at 10:30 every night.  时间状语主要作时间状语，大部分在情况放在句尾。\n时间副词作时间状语的时候，要特别的注意时态的问题，不同的时间副词，能用在不同的时态里面，有些时间副词不能用在特定的时态。比如\n I am learning English now.  Now Now 主要用在现在进行时态里面，当然，也可以用在其他时态，但当 now 用在其他时态的时候，通常有其他的意思。\n I am busy now. She is tired now. Joe is tired now.  Soon Soon 主要用在一般将来时态。\n I will go home soon. I will be rich soon.","title":"English 时间副词"},{"content":"程度副词 表示某种程度的词语。\n比如表示“很、非常、特别、超好、超、相当好、如此、格外的、真正的、完全”的单词。\n程度副词相当于一种限定词的作用，主要修饰形容词和方式副词，放在被修饰的形容词和方式副词的前面。\n vary good. so good. too bad. pretty good. almost dead.  Much 这个词语很特使，作程度副词的时候，必须修饰形容词的比较级或方式副词的比较级，表示“\u0026hellip;的多”。\n Much better. Much bigger. Much harder.  程度副词也可以修饰方式副词。\n He is running very quickly. He sings very well. The snail walks pretty.  程度副词只与被修饰的词语有关系，跟句子的关系不大，因此，只要句子中出现形容词和方式副词，都可以根据语境加上程度副词，哪里有形容词和方式副词，哪里就可以又程副词。\n We need a very good teacher. My book is very good. A very rich man married her.  少部分程度副词还可以修饰动词或数词，甚至是名词。\n He nearly died four yeary ago, The man almost dropped his gun,  Very 这个程度副词，不喜欢修饰动词，所以 I very lik you 这个句子不地道，也不太好。应该用 I like you very\nmuch 或 i quite like you.\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E7%A8%8B%E5%BA%A6%E5%89%AF%E8%AF%8D/","summary":"程度副词 表示某种程度的词语。\n比如表示“很、非常、特别、超好、超、相当好、如此、格外的、真正的、完全”的单词。\n程度副词相当于一种限定词的作用，主要修饰形容词和方式副词，放在被修饰的形容词和方式副词的前面。\n vary good. so good. too bad. pretty good. almost dead.  Much 这个词语很特使，作程度副词的时候，必须修饰形容词的比较级或方式副词的比较级，表示“\u0026hellip;的多”。\n Much better. Much bigger. Much harder.  程度副词也可以修饰方式副词。\n He is running very quickly. He sings very well. The snail walks pretty.  程度副词只与被修饰的词语有关系，跟句子的关系不大，因此，只要句子中出现形容词和方式副词，都可以根据语境加上程度副词，哪里有形容词和方式副词，哪里就可以又程副词。\n We need a very good teacher. My book is very good. A very rich man married her.  少部分程度副词还可以修饰动词或数词，甚至是名词。\n He nearly died four yeary ago, The man almost dropped his gun,  Very 这个程度副词，不喜欢修饰动词，所以 I very lik you 这个句子不地道，也不太好。应该用 I like you very","title":"English 程度副词"},{"content":"频度副词 频度副词也作状语只是位置不同。频度副词放在实义动词前面，放在系动词、助动词、情态动词后面。\n I often eat rice. I always busy. He usually gets up at six.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E9%A2%91%E5%BA%A6%E5%89%AF%E8%AF%8D/","summary":"频度副词 频度副词也作状语只是位置不同。频度副词放在实义动词前面，放在系动词、助动词、情态动词后面。\n I often eat rice. I always busy. He usually gets up at six.  ","title":"English 频度副词"},{"content":"现在完成时态 由助动词 + have/has + 过去分词构成。\n用法一 表示从过去某一时间开始一直延续到现在并还可能继续延续下去的动作。不能用非延续性的动词，比如 die、begin、 buy。\n I have been here for two days. He has been an English teacher for 2 years.  表示过去的动作，对现在产生的影响。\n I have already known the story. She has nerver seen the sea. He has died. I have found her money. She has bought a car.  用法二 第三人称单数 + has + 过去分词\n非第三人称单数 + have + 过去分词\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E7%8E%B0%E5%9C%A8%E5%AE%8C%E6%88%90%E6%97%B6%E6%80%81/","summary":"现在完成时态 由助动词 + have/has + 过去分词构成。\n用法一 表示从过去某一时间开始一直延续到现在并还可能继续延续下去的动作。不能用非延续性的动词，比如 die、begin、 buy。\n I have been here for two days. He has been an English teacher for 2 years.  表示过去的动作，对现在产生的影响。\n I have already known the story. She has nerver seen the sea. He has died. I have found her money. She has bought a car.  用法二 第三人称单数 + has + 过去分词\n非第三人称单数 + have + 过去分词","title":"English 现在完成时态"},{"content":"现在进行时态 表示主语此时此刻正在进行的动作。一般情况，这个时态没有状态的句子，只有动作的句子。\n现在进行时态的注意事项 有一部分动词是不可以用在现在进行时态里面的。\n比如表示知觉、结果、态度、情感的词语。\nsee 表示“看到、看见”的意思，而“看到”是一个结果，没有“我正在看到你”这种逻辑。\n所以在英语中，不能说\n I am seeing you.  如果要表示“看”，那可以用 look at. 可以说\n I am looking at you.  同样的，hear（听到）和 listen to（听）也是不能混用的。\n现在进行时态的特殊用法 表示目前一段时间内正在进行的动作  What\u0026rsquo;s he doing this week? He is writing a book.（强调这个周一直再写一本书）  表示反复出现或习惯性的动作 现在进行时态常与 always constantly 连用，来表示反复出现或习惯性的动作，类似于一般现在时态的作用。\n一般情况，用现在进行时态来表达反复出现或习惯性的动作的时候，主要是强调感情色彩，比如抱怨、表扬、厌倦等等。\n She is always helping her friend.（表扬） You mother is always giving you money.（羡慕或嫉妒） You mother is always gives you money.（没有感情色彩，仅仅表示经常性的动作） You are always borrowing money from me.（抱怨或厌倦）  这种特殊的用法，实际上只是结果上属于现在进行时态，但是是意义上已经不属于了，因此，这里的动词不一定是“能表达正在进行的动作”的动词，其他的动词也可以，比如上面的 give、borrow.\n She is buying apples.（错误） She is always buying apples.（正确）  表示按计划安排即将发生的动作 有时候，现在进行时态，还可以用来表示按计 划安排即将发生的动作，强调一定发生，马上发 生，而且谓语动词必须是那种不能表达此时此刻的动词。比如 Die 不能说正在死，但英语可以这么说：\n She is dying.  这句话并非表示她正在死，而是**强调她马上要死了，处于垂死状态。**类似的情况还有：\n She is leaving for Chongqing. They are coming. The train is arriving.  表示正在表现某种状态 主语 + be + being +表语\n She is being in love with a boss.（强调此时正在恋爱状态） I am being in love with a girl.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E7%8E%B0%E5%9C%A8%E8%BF%9B%E8%A1%8C%E6%97%B6%E6%80%81/","summary":"现在进行时态 表示主语此时此刻正在进行的动作。一般情况，这个时态没有状态的句子，只有动作的句子。\n现在进行时态的注意事项 有一部分动词是不可以用在现在进行时态里面的。\n比如表示知觉、结果、态度、情感的词语。\nsee 表示“看到、看见”的意思，而“看到”是一个结果，没有“我正在看到你”这种逻辑。\n所以在英语中，不能说\n I am seeing you.  如果要表示“看”，那可以用 look at. 可以说\n I am looking at you.  同样的，hear（听到）和 listen to（听）也是不能混用的。\n现在进行时态的特殊用法 表示目前一段时间内正在进行的动作  What\u0026rsquo;s he doing this week? He is writing a book.（强调这个周一直再写一本书）  表示反复出现或习惯性的动作 现在进行时态常与 always constantly 连用，来表示反复出现或习惯性的动作，类似于一般现在时态的作用。\n一般情况，用现在进行时态来表达反复出现或习惯性的动作的时候，主要是强调感情色彩，比如抱怨、表扬、厌倦等等。\n She is always helping her friend.（表扬） You mother is always giving you money.（羡慕或嫉妒） You mother is always gives you money.（没有感情色彩，仅仅表示经常性的动作） You are always borrowing money from me.","title":"English 现在进行时态"},{"content":"基础查询 我们用的是名为 MyEmployees.sql 和 Girls.sql 的 SQL 文件。\n语法 select 查询列表 from 表名 特点  查询列表可以是表中的字段、常量、表达式、函数。 查询的结果是一个虚拟的表格。  查询表中的单个字段 SELECT last_name FROM employees; 查询表中的多个字段 会以特定的顺序显示我们查询的字段。\nSELECT last_name,first_name,email FROM employees; 查询表中的所有字段 会以表原本的字段顺序显示我们查询的字段\nSELECT * FROM employees; 区分关键字和字段名 MySQL 中，我们可以用一对着重号**``**来区 MySQL 中的分字段和关键字\nSELECT `NAME` FROM rainy; 查询常量 SELECT \u0026#39;john\u0026#39;; 查询表达式 SELECT 100 * 57; 起别名 自定义字段名（列名），起别名可以使我们更好的理解表。\n有时候，字段名可能会是一些表达式，会让输出的虚拟表达中的字段名难以理解，这时候，我们可以为其设置一个便于理解的字段名。\n表达式可以用这个表达式的别名来代替该表达式 当我们为一个表达式定义了一个别名，如果后续我们需要用到这个表达式，那么我们可以不用再重复书写表达式，直接写别名即可。\nSELECT *, # 因为表中没有年薪这个字段，所以我们需要用表达式来计算每个员工的年薪 salary * 12*(1 + IFNULL(commission_pct,0)) AS 年薪 FROM employees # 用表达式所对应的别名来替代表达式，使得语句更好理解 ORDER BY 年薪 DESC; 如果要查询的字段中有重名的情况，也可以使用别名来区分。\nAS 关键字 SELECT 100-2 AS 计算结果; SELECT last_name AS 姓,first_name AS 名 FROM employees; 空格 SELECT last_name 姓,first_name 名 FROM employees; 去掉重复字段 查询员工表中涉及到的所有部门的编号 SELECT DISTINCT department_id FROM employees; + 号的作用 两个操作数都为数值型，则做加法运算。\nSELECT 520 + 250; 其中一方为字符型，试图将字符型数值转换成数值型。 如果转换成功，则继续做加法运算。 如果转换失败，则将字符型数值转换成 0。\nSELECT \u0026#34;john\u0026#34; + 90; 只要其中一方为 Null，则结果肯定为 Null。\nSELECT \u0026#34;john\u0026#34; + null; ","permalink":"https://note.yxzi.xyz/note/technology/mysql/dql/%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/","summary":"基础查询 我们用的是名为 MyEmployees.sql 和 Girls.sql 的 SQL 文件。\n语法 select 查询列表 from 表名 特点  查询列表可以是表中的字段、常量、表达式、函数。 查询的结果是一个虚拟的表格。  查询表中的单个字段 SELECT last_name FROM employees; 查询表中的多个字段 会以特定的顺序显示我们查询的字段。\nSELECT last_name,first_name,email FROM employees; 查询表中的所有字段 会以表原本的字段顺序显示我们查询的字段\nSELECT * FROM employees; 区分关键字和字段名 MySQL 中，我们可以用一对着重号**``**来区 MySQL 中的分字段和关键字\nSELECT `NAME` FROM rainy; 查询常量 SELECT \u0026#39;john\u0026#39;; 查询表达式 SELECT 100 * 57; 起别名 自定义字段名（列名），起别名可以使我们更好的理解表。\n有时候，字段名可能会是一些表达式，会让输出的虚拟表达中的字段名难以理解，这时候，我们可以为其设置一个便于理解的字段名。\n表达式可以用这个表达式的别名来代替该表达式 当我们为一个表达式定义了一个别名，如果后续我们需要用到这个表达式，那么我们可以不用再重复书写表达式，直接写别名即可。\nSELECT *, # 因为表中没有年薪这个字段，所以我们需要用表达式来计算每个员工的年薪 salary * 12*(1 + IFNULL(commission_pct,0)) AS 年薪 FROM employees # 用表达式所对应的别名来替代表达式，使得语句更好理解 ORDER BY 年薪 DESC; 如果要查询的字段中有重名的情况，也可以使用别名来区分。","title":"MySQL 基础查询"},{"content":"条件查询 语法 select # 3、查询 \tQueryList from # 1、寻找库中有无指定名 TableName WHERE # 2、筛选满足条件的字段 \tConditional Expression; 分类  按条件表达式查询，主要用条件运算符 按逻辑表达式查询，主要用逻辑运算符 模糊查询，主要用模糊关键字  \u0026gt; 大于。\n查询工资大于 12000 的员工信息 SELECT * FROM employees WHERE salary \u0026gt; 12000; \u0026lt; 小于。\n= 等于。\n\u0026lt;\u0026gt; 不等于，也可以用 !=，但是在 MySQL 中 建议中 \u0026lt;\u0026gt;。\n查询部门编号不等于 90 号的员工名和部门编号 SELECT last_name, department_id FROM employees WHERE department_id \u0026lt;\u0026gt; 90; \u0026gt;= 大于等于。\n\u0026lt;= 小于等于。\n","permalink":"https://note.yxzi.xyz/note/technology/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/","summary":"条件查询 语法 select # 3、查询 \tQueryList from # 1、寻找库中有无指定名 TableName WHERE # 2、筛选满足条件的字段 \tConditional Expression; 分类  按条件表达式查询，主要用条件运算符 按逻辑表达式查询，主要用逻辑运算符 模糊查询，主要用模糊关键字  \u0026gt; 大于。\n查询工资大于 12000 的员工信息 SELECT * FROM employees WHERE salary \u0026gt; 12000; \u0026lt; 小于。\n= 等于。\n\u0026lt;\u0026gt; 不等于，也可以用 !=，但是在 MySQL 中 建议中 \u0026lt;\u0026gt;。\n查询部门编号不等于 90 号的员工名和部门编号 SELECT last_name, department_id FROM employees WHERE department_id \u0026lt;\u0026gt; 90; \u0026gt;= 大于等于。\n\u0026lt;= 小于等于。","title":"MySQL 条件查询"},{"content":"语法规范   MySQL 的 SQL 语法不区分大小写，但建议关键 i 大写，表名，列名小写。\n  每条命令结尾必须使用英文的分号;结尾，当然也可以用其他的，比如\\g。\n  每条命令根据需要，可以进行缩进或换行。\nmysql\u0026gt; show  -\u0026gt; databases;   注释\n# 单行注释 -- 单行注释 /* 多行注释 */覆   ","permalink":"https://note.yxzi.xyz/note/technology/mysql/%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/","summary":"语法规范   MySQL 的 SQL 语法不区分大小写，但建议关键 i 大写，表名，列名小写。\n  每条命令结尾必须使用英文的分号;结尾，当然也可以用其他的，比如\\g。\n  每条命令根据需要，可以进行缩进或换行。\nmysql\u0026gt; show  -\u0026gt; databases;   注释\n# 单行注释 -- 单行注释 /* 多行注释 */覆   ","title":"MySQL 语法规范"},{"content":"逻辑查询 AND 与运算符，也可以用 \u0026amp;\u0026amp;，但是在 MySQL 中，建议用 and。\n当表达式都为 true 时，结果才为 true，否则结果为 false。\n查询工资在 10000-20000 之间的员工名、工资以及奖金 SELECT last_name, salary, commission_pct FROM employees WHERE salary \u0026gt;= 12000 AND  salary \u0026lt;= 20000; OR 或运算符，但也可以用 ||，但是在 MySQL 中，建议用 or。\n当表达式都为 false 时，结果才为 false，否则结果为 true。\n查询部门编号不在 90 - 100 之间，或者工资高于 15000 的员工信息 SELECT * FROM employees WHERE # 筛选部门 id 小于 90 或 大于 100 d department_id \u0026lt; 90 OR department_id \u0026gt; 110 OR  salary \u0026gt; 15000; NOT 非运算符，但也可以用 !，但是在 MySQL 中，建议用 not。\n表达式的结果取反。\n查询部门编号不在 90 - 100 之间，或者工资高于 15000 的员工信息 SELECT * FROM employees WHERE # 筛选部门 id 不在 90 - 110 之间的数据 NOT(department_id \u0026gt;= 90 AND department_id \u0026lt;= 110) OR  salary \u0026gt; 15000; ","permalink":"https://note.yxzi.xyz/note/technology/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E9%80%BB%E8%BE%91%E6%9F%A5%E8%AF%A2/","summary":"逻辑查询 AND 与运算符，也可以用 \u0026amp;\u0026amp;，但是在 MySQL 中，建议用 and。\n当表达式都为 true 时，结果才为 true，否则结果为 false。\n查询工资在 10000-20000 之间的员工名、工资以及奖金 SELECT last_name, salary, commission_pct FROM employees WHERE salary \u0026gt;= 12000 AND  salary \u0026lt;= 20000; OR 或运算符，但也可以用 ||，但是在 MySQL 中，建议用 or。\n当表达式都为 false 时，结果才为 false，否则结果为 true。\n查询部门编号不在 90 - 100 之间，或者工资高于 15000 的员工信息 SELECT * FROM employees WHERE # 筛选部门 id 小于 90 或 大于 100 d department_id \u0026lt; 90 OR department_id \u0026gt; 110 OR  salary \u0026gt; 15000; NOT 非运算符，但也可以用 !","title":"MySQL 逻辑查询"},{"content":"一般将来时态 表示未来即将要发生的动作和状态，也就是说，这些动作和状态还没有发生，但是在将来的某个时间点肯定要发生。\n一般将来时态有两种构成方式，will 和 be going to，这两个都是助动词，没有中文意思。虽然它们写法不一样，但是作用是一样的。\n一般将来时态的时间状语 一般情况，一般将来时态都需要加上表示将来的时间状语。\n tomorrow. tonight. the day ater tomorrow  大部分表示将来的时间状语，都是由介词或副词 + 其他词语构成。\nNext + 表示时间名词的单数  I will travel next year.  After + 具体时间点（\u0026hellip;之后） 这里的具体时间点表示的是特定或规定的时间。\n比如：几岁之后、几个月以后、清明节之后、三月之后等等。\n After work Afer school After two days old. After 2030. After May. Afer Ching ming festival. I will buy a house after 2030.  after + 一段时间（之后）\n注意 after + 一段时间，比如 after + one/a/an + 表示是时间名词的单数，也可以构成时间状语，但是这种介词短语不能用在一般将来时态，用在一般过去时态。\n比如 I will be after three days 这个句子是错误的，\n正确的应该是 I will be in three days.（用 in three days）\n因为这种介词短语 after three days 只能用在一般过去时态：\n I bought a house after three years.  所以 after + 一段时间，这种介词短语，主要用在一般过去时态。\nin + 一段时间（\u0026hellip;之后） 这个介词短语才能用在一把将来时态。\nafter five days.（用在一般过去时态）\nIn five days.（用在一般将来时态）\nIn an hour.\nWe will buy the house in 2030.\nLater（之后） Later 是副词，不同于介词 after、in，介词通常是前置词，放到数词之前，而 later 是副词，副词通常是后置词，放到数词之后。\n Three days later.  Three days latar 和 after three days 一样，一般都用在一般过去时态，在一般将来时态中用的很少。\n主系表 只要把 be 变成 will be，然后再加上表示将来的时间状语就可以了。另外，不管主语是什么人称，都是用 will be + 表语。\n我们把主语 + will be + 表语分成四个更具体的小句型。\nBe + 职业的时候，这里的 be 表示“成为，做”的意思。\n在英式英语中，当主语是 I 或 we 的时候，可以使用 shall be 代替 will be，因为它们俩的意思是一样的，当然，也可以代替。\nbe going to 和 will 一般情况，助动词 will 和 be going to 几乎没有区别，可以互换使用，但是在特殊情况下，will 强调的是一种“意志、意愿”，而 be going to 只是纯粹的表示将来或比较确定即将要发生的动作或状态。\n比如：\n I am going to master English in three yeares（be going to） I will master English in three years.  这两句话平时没有区别，都表示“我要在三年后掌握英语”，但是如果在特定的情况下或有前提的情况下，可能需要用 I will master English 来表示“我一定会掌握英语”，这时候强调的是一种意志或意愿，且一般不加时间状语。而 I am going to master english 就无法表达出这种意义，依旧是纯粹的表示将来。\nwill 本身可以作名词，表示“意志、意愿”。\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E4%B8%80%E8%88%AC%E5%B0%86%E6%9D%A5%E6%97%B6%E6%80%81/","summary":"一般将来时态 表示未来即将要发生的动作和状态，也就是说，这些动作和状态还没有发生，但是在将来的某个时间点肯定要发生。\n一般将来时态有两种构成方式，will 和 be going to，这两个都是助动词，没有中文意思。虽然它们写法不一样，但是作用是一样的。\n一般将来时态的时间状语 一般情况，一般将来时态都需要加上表示将来的时间状语。\n tomorrow. tonight. the day ater tomorrow  大部分表示将来的时间状语，都是由介词或副词 + 其他词语构成。\nNext + 表示时间名词的单数  I will travel next year.  After + 具体时间点（\u0026hellip;之后） 这里的具体时间点表示的是特定或规定的时间。\n比如：几岁之后、几个月以后、清明节之后、三月之后等等。\n After work Afer school After two days old. After 2030. After May. Afer Ching ming festival. I will buy a house after 2030.  after + 一段时间（之后）\n注意 after + 一段时间，比如 after + one/a/an + 表示是时间名词的单数，也可以构成时间状语，但是这种介词短语不能用在一般将来时态，用在一般过去时态。","title":"English 一般将来时态"},{"content":"为什么男人在一些事情上得忍让女人 因为这些事情根本就是些和切身利益无关的无足轻重的事情。比如，女生发小脾气忍让之类的。\n我可没见过发国家奖学金的时候男生让了，公司提拔谁时男性让了，父母有一儿一女，分配财产也没见儿子让。\n天天听人喊现在本科硕士博士女生比例太高了，要降分录取男生。家庭财产也会向儿子倾斜。至今，各种高管高官，90% 以上都是男性。\n","permalink":"https://note.yxzi.xyz/note/view/bisexual/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%B7%E4%BA%BA%E5%9C%A8%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85%E4%B8%8A%E5%BE%97%E5%BF%8D%E8%AE%A9%E5%A5%B3%E4%BA%BA/","summary":"为什么男人在一些事情上得忍让女人 因为这些事情根本就是些和切身利益无关的无足轻重的事情。比如，女生发小脾气忍让之类的。\n我可没见过发国家奖学金的时候男生让了，公司提拔谁时男性让了，父母有一儿一女，分配财产也没见儿子让。\n天天听人喊现在本科硕士博士女生比例太高了，要降分录取男生。家庭财产也会向儿子倾斜。至今，各种高管高官，90% 以上都是男性。","title":"为什么男人在一些事情上得忍让女人"},{"content":"DOM DOM （文档对象模型）中提供了一系列的方法，DOM 是这一些列方法的统称。这些方法使得我们可以操作 HTML 和 XML。\nDOM 就像一棵节点树一样，从文档的根（document），依次分支展开，每一个元素，都可以看作是树的一个节点，每一个元素都是一个对象。\n使用 DOM 操作文档中的元素时，必须先加载整个 HTML 文档（body 之前的代码 ），再加载 JS 文件；因为没有完整的 DOM 模型，DOM 的一些操作就无法完成，会导致报错。\ngraph TD;\rNode --\u0026gt; Document;\rNode --\u0026gt; CharacterData;\rNode --\u0026gt; Element;\rNode --\u0026gt; Atrr;\rDocument --\u0026gt; HTMLDocument;\rDocument --\u0026gt; XMLDocument;\rCharacterData --\u0026gt; Text\rCharacterData --\u0026gt; Comment\rElement --\u0026gt; HTMLElement\rAttr\rHTMLElement --\u0026gt; HTMLHeadElement\rHTMLElement --\u0026gt; HTMLBodyElement\rHTMLElement --\u0026gt; HTMLTitleElement\rHTMLElement --\u0026gt; HTMLParagraphlement Node 最终指向 Object.prototype。\ngetElementById() getElementById() 定义在了 Document.prototype 上，这说明 XMLDocument 和 HTMLDocument 都能使用 getElementById()，但 Element 不能使用 getElementById()。\ngetElementsByName() getElementsByName() 定义在了 HTMLDocument.prototype 上，这说明 XMLDocument 和 Element 不能使用 getElementsByName()。\ngetElementsByTagName() getElementsByTagName() 定义在了 Docunment.prototype 和 Element.prototype 上，这说明 getElementsByTagName() 的兼容性最好，即文档中的元素也可以调用 getElementsByTagName()。\n像这样：\n// document 可以调用 getElementsByTagName()，表示选择 document 中的 body 元素 var body = document.getElementsByTagName(\u0026#39;body\u0026#39;)[0] // 同样的，body 也可以调用 getElementsByTagName()，表示选择 body 元素中的 div 元素 var div = body.getElementsByTagName(\u0026#39;div\u0026#39;)[0] HTMLBodyElement 与元素的关系 // 只有 body 元素的方法继承自 HTMLBodyElement.prototype HTMLBodyElement.prototype.fun = \u0026#39;自定义方法\u0026#39; // 通过 body.fun 可以调用我们自定义的 fun 方法 var body = document.getElementsByTagName(\u0026#39;body\u0026#39;)[0] // 而 head 元素并没有 head.fun 方法，因为 head 元素不属于 HTMLBodyElement var head = document.getElementsByTagName(\u0026#39;head\u0026#39;)[0] HTMLElement 与元素的关系 // 任何元素的方法都继承自 HTMLElement.prototype HTMLElement.prototype.fun = \u0026#39;自定义方法\u0026#39; // head 和 body 元素都可以使用 fun() var body = document.getElementsByTagName(\u0026#39;body\u0026#39;)[0] var head = document.getElementsByTagName(\u0026#39;head\u0026#39;)[0] ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/dom/dom/","summary":"DOM DOM （文档对象模型）中提供了一系列的方法，DOM 是这一些列方法的统称。这些方法使得我们可以操作 HTML 和 XML。\nDOM 就像一棵节点树一样，从文档的根（document），依次分支展开，每一个元素，都可以看作是树的一个节点，每一个元素都是一个对象。\n使用 DOM 操作文档中的元素时，必须先加载整个 HTML 文档（body 之前的代码 ），再加载 JS 文件；因为没有完整的 DOM 模型，DOM 的一些操作就无法完成，会导致报错。\ngraph TD;\rNode --\u0026gt; Document;\rNode --\u0026gt; CharacterData;\rNode --\u0026gt; Element;\rNode --\u0026gt; Atrr;\rDocument --\u0026gt; HTMLDocument;\rDocument --\u0026gt; XMLDocument;\rCharacterData --\u0026gt; Text\rCharacterData --\u0026gt; Comment\rElement --\u0026gt; HTMLElement\rAttr\rHTMLElement --\u0026gt; HTMLHeadElement\rHTMLElement --\u0026gt; HTMLBodyElement\rHTMLElement --\u0026gt; HTMLTitleElement\rHTMLElement --\u0026gt; HTMLParagraphlement Node 最终指向 Object.prototype。\ngetElementById() getElementById() 定义在了 Document.prototype 上，这说明 XMLDocument 和 HTMLDocument 都能使用 getElementById()，但 Element 不能使用 getElementById()。","title":"JavaScript DOM"},{"content":"ES5 严格模式 ECMAScript 是 JavaScript 的一个标准。\nES5 严格模式指的是：我们应该对 ES3 和 ES5 产生冲突的部分使用哪个版本的规则？\n当我们开启 ES5 严格模式后，那么 ES3 和 ES5 产生冲突的部分会遵循 ES5 的规则，否则会使用 ES3（浏览器默认遵循 ES3 的规则）\n\u0026ldquo;use strict\u0026rdquo; 使某一作用域内的代码不在兼容 ES3 中的一些不规则的语法，使用全新的 ES5 的语法。\n如何启用 ES5 严格模式 在作用域顶端添加语句\u0026quot;use strict\u0026quot;即可，启用之后，ES3 中的一些方法就无法使用了。比如arguments的callee属性：\n\u0026#39;use strict\u0026#39;; function test() { \tconsole.log(arguments.callee); } test(); 浏览器会出现以下错误：\nUncaught TypeError: \u0026#39;caller\u0026#39;, \u0026#39;callee\u0026#39;, and \u0026#39;arguments\u0026#39; properties may not be accessed on strict mode functions or the arguments objects for calls to them 同样，也可以使某一局部作用域支持 ES5，而其他作用域支持 ES3：\n// 支持 ES3 模式，可以使用 arguments 的 callee 属性 function demo() { \tconsole.log(arguments.callee); } demo();  function test() { \t// 支持 ES5 模式，所以无法使用 ES3 中 arguments 的 callee 属性 \t\u0026#39;use strict\u0026#39;; \tconsole.log(arguments.callee); } test(); 为什么用字符串启用 ES5 严格模式 为什么启用 ES5 要使用\u0026quot;use strict\u0026quot;这种字符串的方式来启用 ES5 严格模式？而不、使用一个函数strict()？\n这是因为如果使用的是一个函数的话，就会导致不支持 ES5 的浏览器使用strict()直接报错，导致后面的代码无法执行。而字符串\u0026quot;use strict\u0026quot;却不会导致程序报错，因为单独的字符串或者数字是无意义的，仅仅只是一个表达式。\n\u0026#39;use strict\u0026#39;; \u0026#39;无意义，不会导致程序报错\u0026#39;; 1971438937; 直接点说，就是为了兼容那些老版本浏览器（不支持 ES5 的浏览器）\nES5 不支持的操作 with\narguments.caller\nfunction.caller\n声明变量之前必须声明。\n\u0026#39;use strict\u0026#39;; // Uncaught ReferenceError: b is not defined var a = (b = 4); 局部 this 必须被赋值，而且是赋什么就是什么，不赋值的情况下是 undefined。\n严格模式下，全局 this 依旧指向 window。\nfunction rainy() { \t// 非严格模式下，局部 this 默认指向 window \tconsole.log(this); } rainy();  function test() { \t\u0026#39;use strict\u0026#39;; \t// 严格模式下，局部this 默认指向 undefined \tconsole.log(this); } test();  function demo() { \t\u0026#39;use strict\u0026#39;; \t// 此时的 this 指向函数 demo 本身 \tconsole.log(this); } new demo(); 拒绝重复属性（重复后不会报错）和参数（重复后会报错）。\n// 重复属性，但不会报错 var obj = { \t// 后面的 name 属性会覆盖前面的 name 属性 \t// 返回 456 \tname: \u0026#39;123\u0026#39;, \tname: \u0026#39;456\u0026#39;, }; console.log(obj.name);  //重复参数，会报错 // Uncaught SyntaxError: Duplicate parameter name not allowed in this context function test(name, name) { \t\u0026#39;use strict\u0026#39;; \tconsole.log(name); } test(1, 2); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/es5-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","summary":"ES5 严格模式 ECMAScript 是 JavaScript 的一个标准。\nES5 严格模式指的是：我们应该对 ES3 和 ES5 产生冲突的部分使用哪个版本的规则？\n当我们开启 ES5 严格模式后，那么 ES3 和 ES5 产生冲突的部分会遵循 ES5 的规则，否则会使用 ES3（浏览器默认遵循 ES3 的规则）\n\u0026ldquo;use strict\u0026rdquo; 使某一作用域内的代码不在兼容 ES3 中的一些不规则的语法，使用全新的 ES5 的语法。\n如何启用 ES5 严格模式 在作用域顶端添加语句\u0026quot;use strict\u0026quot;即可，启用之后，ES3 中的一些方法就无法使用了。比如arguments的callee属性：\n\u0026#39;use strict\u0026#39;; function test() { \tconsole.log(arguments.callee); } test(); 浏览器会出现以下错误：\nUncaught TypeError: \u0026#39;caller\u0026#39;, \u0026#39;callee\u0026#39;, and \u0026#39;arguments\u0026#39; properties may not be accessed on strict mode functions or the arguments objects for calls to them 同样，也可以使某一局部作用域支持 ES5，而其他作用域支持 ES3：","title":"JavaScript ES5 严格模式"},{"content":"Try Catch 为了容错，防止程序报错后引起整个程序的终止运行\ntry 中有错误信息 就会执行 catch 中的代码，没有这不会执行 catch 之中的代码\ncatch 有一个参数，参数名自定义 比如 e\n那么这个 e 就会有两个参数 e.name 和 e.message\nError.name EvalError：eval()的使用与定义不一致\nRangeError：数值越界\nReferenceError：非法或不能识别的引用数值，比如当一个变量未经声明就使用或者一个函数未定义就调用的时候，会出现 ReferenceError。\nSyntaxError：语法解析错误\nTypeError：操作数类型错误\nURlError：URI 处理函数使用不当\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%8E%A7%E5%88%B6%E6%B5%81/try-catch/","summary":"Try Catch 为了容错，防止程序报错后引起整个程序的终止运行\ntry 中有错误信息 就会执行 catch 中的代码，没有这不会执行 catch 之中的代码\ncatch 有一个参数，参数名自定义 比如 e\n那么这个 e 就会有两个参数 e.name 和 e.message\nError.name EvalError：eval()的使用与定义不一致\nRangeError：数值越界\nReferenceError：非法或不能识别的引用数值，比如当一个变量未经声明就使用或者一个函数未定义就调用的时候，会出现 ReferenceError。\nSyntaxError：语法解析错误\nTypeError：操作数类型错误\nURlError：URI 处理函数使用不当","title":"JavaScript Try Catch"},{"content":"with with(ogj)函数可以改变自身代码块中的代码的作用域链，它会将 obj 放到它自己代码块中的代码的作用域链的最顶端，也就是会先去 obj 的作用域中去寻找变量。\nES5 中不支持 with 函数。\n var obj = {  age: \u0026#34;456\u0026#34;,  name: \u0026#34;your\u0026#34;, }  function test() {  var age = \u0026#39;123\u0026#39;;  var name = \u0026#39;my\u0026#39;;  with (obj) {  // 下面的输出不会返回自身作用域（test 函数的作用域）下的 age 和 name。  // 只会返回全局作用域下的 obj 对象的 age 和 name，因为作用域被 with 函数改变了。  console.log(age);  console.log(name);  } } test(); 替代链式调用 with (document) {  write(\u0026#34;with 调用\u0026#34; + \u0026#34;\u0026lt;br/\u0026gt;\u0026#34;) }  //等同于 document.write(\u0026#34;链式调用\u0026#34;) with 的缺点 with 的缺点就是因为太强大了，可以更改原型链，这会导致程序运行变慢。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/other/with/","summary":"with with(ogj)函数可以改变自身代码块中的代码的作用域链，它会将 obj 放到它自己代码块中的代码的作用域链的最顶端，也就是会先去 obj 的作用域中去寻找变量。\nES5 中不支持 with 函数。\n var obj = {  age: \u0026#34;456\u0026#34;,  name: \u0026#34;your\u0026#34;, }  function test() {  var age = \u0026#39;123\u0026#39;;  var name = \u0026#39;my\u0026#39;;  with (obj) {  // 下面的输出不会返回自身作用域（test 函数的作用域）下的 age 和 name。  // 只会返回全局作用域下的 obj 对象的 age 和 name，因为作用域被 with 函数改变了。  console.log(age);  console.log(name);  } } test(); 替代链式调用 with (document) {  write(\u0026#34;with 调用\u0026#34; + \u0026#34;\u0026lt;br/\u0026gt;\u0026#34;) }  //等同于 document.","title":"JavaScript with"},{"content":"MySQL MySQL 属于 Oracle。\nMySQL 的优点  成本低：开源数据库，完全免费，社区庞大。 性能高：执行速度快。 简单：体积小，简单易用。 跨平台：支持多种操作系统。  ","permalink":"https://note.yxzi.xyz/note/technology/mysql/mysql/","summary":"MySQL MySQL 属于 Oracle。\nMySQL 的优点  成本低：开源数据库，完全免费，社区庞大。 性能高：执行速度快。 简单：体积小，简单易用。 跨平台：支持多种操作系统。  ","title":"MySQL"},{"content":"DBMS 数据库管理系统（Datebase Management System），我们可以通过 DBMS 来创建或操作数据库。\n常见的数据库管理系统：MySQL、Oracle、DB2、SqlServer\n基于共享文件系统 比如微软的 Access\n基于 C/S 架构 基于客户机/服务器的 DBMS。需要安装客户端和服务端\n比如 MySQL、Oracle、SqlSever。\n","permalink":"https://note.yxzi.xyz/note/technology/mysql/dbms/","summary":"DBMS 数据库管理系统（Datebase Management System），我们可以通过 DBMS 来创建或操作数据库。\n常见的数据库管理系统：MySQL、Oracle、DB2、SqlServer\n基于共享文件系统 比如微软的 Access\n基于 C/S 架构 基于客户机/服务器的 DBMS。需要安装客户端和服务端\n比如 MySQL、Oracle、SqlSever。","title":"MySql DBMS"},{"content":"SQL 结构化查询语言（Structure Query Language），专门用来对数据库进行一些操作的语言。\nSQL 的优点 SQL 语言不是某个特定 DBMS 所专有的语言，相反，近乎所有的 DBMS 都支持 SQL。\nSQL 的语言分类 DQL 数据查询语言 select。\nDML 数据操作语言，用于对数据库表中的数据进行操作。\nSELECT、INSERT、UPDATE、DELETE、CALL、EXPLAIN PLAN、LOCK TABLE\nDDL 数据定义语言，用于对数据库、表层面进行操作。\nCREATE、ALTER、DROP、TRUNCATE、COMMENT、GRANT、REVOKE\nDCL 事务控制语言 COMMIT、SAVEPOINT、ROLLBACK、SET TRANSACTION\n","permalink":"https://note.yxzi.xyz/note/technology/mysql/sql/","summary":"SQL 结构化查询语言（Structure Query Language），专门用来对数据库进行一些操作的语言。\nSQL 的优点 SQL 语言不是某个特定 DBMS 所专有的语言，相反，近乎所有的 DBMS 都支持 SQL。\nSQL 的语言分类 DQL 数据查询语言 select。\nDML 数据操作语言，用于对数据库表中的数据进行操作。\nSELECT、INSERT、UPDATE、DELETE、CALL、EXPLAIN PLAN、LOCK TABLE\nDDL 数据定义语言，用于对数据库、表层面进行操作。\nCREATE、ALTER、DROP、TRUNCATE、COMMENT、GRANT、REVOKE\nDCL 事务控制语言 COMMIT、SAVEPOINT、ROLLBACK、SET TRANSACTION","title":"MySQL SQL"},{"content":"安装 去官方下载PHPStudy并安装，这玩意自带 MySQL 和 Apache。\n配置环境变量 赋值 MySQL 目录下的 bin 路径，然后将这个路径添加到系统环境变量 Path 中。\n我这里添加环境变量是的是：D:\\AppInstallPath\\PhpStudy\\phpstudy_pro\\Extensions\\MySQL5.7.26\\bin*\n","permalink":"https://note.yxzi.xyz/note/technology/mysql/%E5%AE%89%E8%A3%85/","summary":"安装 去官方下载PHPStudy并安装，这玩意自带 MySQL 和 Apache。\n配置环境变量 赋值 MySQL 目录下的 bin 路径，然后将这个路径添加到系统环境变量 Path 中。\n我这里添加环境变量是的是：D:\\AppInstallPath\\PhpStudy\\phpstudy_pro\\Extensions\\MySQL5.7.26\\bin*","title":"MySQL 安装"},{"content":"常用命令 查询 MySQL 版本号 打开 cmd，直接使用 DOS 命令查看：\n# 第一种命令查询 C:\\Windows\\system32\u0026gt;mysql --version mysql Ver 14.14 Distrib 5.7.26, for Win64 (x86_64) # 第二种命令查询 C:\\Windows\\system32\u0026gt;mysql -V mysql Ver 14.14 Distrib 5.7.26, for Win64 (x86_64) 显示数据库 使用show databases;命令来查看数据库，需要注意的是 database 后面的 s 和;符号。\nmysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | study | | sys | | typecho | | wordpress | +--------------------+ 7 rows in set (0.02 sec) 打开数据库 使用use DatabaseName;命令来打开 typecho 数据库，DatabaseName 是数据库的名称。\nmysql\u0026gt; use typecho; Database changed 查看表 使用show tables;命令来查看 typecho 数据库中的表。\nmysql\u0026gt; show tables; +-----------------------+ | Tables_in_typecho | +-----------------------+ | typecho_comments | | typecho_contents | | typecho_fields | | typecho_metas | | typecho_options | | typecho_relationships | | typecho_users | +-----------------------+ 7 rows in set (0.00 sec) 还可以使用show tables from DatabaseName;命令来查看表，更加方便。\nDatabaseName 是数据库的名称。\nmysql\u0026gt; show tables from typecho; +-----------------------+ | Tables_in_typecho | +-----------------------+ | typecho_comments | | typecho_contents | | typecho_fields | | typecho_metas | | typecho_options | | typecho_relationships | | typecho_users | +-----------------------+ 7 rows in set (0.00 sec) 查看表结构 使用 DESCRIBE TableName;来查看数据库中的表结构，TableName 是要查询的表的名称，DESCRIBE 可以缩写为 DSEC。\nmysql\u0026gt; desc rainy; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ 2 rows in set (0.00 sec) ","permalink":"https://note.yxzi.xyz/note/technology/mysql/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","summary":"常用命令 查询 MySQL 版本号 打开 cmd，直接使用 DOS 命令查看：\n# 第一种命令查询 C:\\Windows\\system32\u0026gt;mysql --version mysql Ver 14.14 Distrib 5.7.26, for Win64 (x86_64) # 第二种命令查询 C:\\Windows\\system32\u0026gt;mysql -V mysql Ver 14.14 Distrib 5.7.26, for Win64 (x86_64) 显示数据库 使用show databases;命令来查看数据库，需要注意的是 database 后面的 s 和;符号。\nmysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | study | | sys | | typecho | | wordpress | +--------------------+ 7 rows in set (0.","title":"MySQL 常用命令"},{"content":"配置文件 在 MySQL 根目录中，有一个my.ini配置文件。\n客户端配置 [mysql]是 MySQL 客户端的配置。\n[mysql] default-character-set=utf8 服务端配置 [mysqld] port=3306 # MySQL 服务运行时的端口号 basedir=D:/AppInstallPath/PhpStudy/phpstudy_pro/Extensions/MySQL5.7.26/ # MySQL 程序所存放路径,常用于存放 MySQL 启动、配置文件、日志等 datadir=D:/AppInstallPath/PhpStudy/phpstudy_pro/Extensions/MySQL5.7.26/data/ # MySQL数据存放文件(极其重要) character-set-server=utf8 # 数据库和数据库表的默认字符集。(推荐utf8,以免导致乱码) default-storage-engine=MyIsam # MySQL 的存储引擎 # ...... ","permalink":"https://note.yxzi.xyz/note/technology/mysql/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","summary":"配置文件 在 MySQL 根目录中，有一个my.ini配置文件。\n客户端配置 [mysql]是 MySQL 客户端的配置。\n[mysql] default-character-set=utf8 服务端配置 [mysqld] port=3306 # MySQL 服务运行时的端口号 basedir=D:/AppInstallPath/PhpStudy/phpstudy_pro/Extensions/MySQL5.7.26/ # MySQL 程序所存放路径,常用于存放 MySQL 启动、配置文件、日志等 datadir=D:/AppInstallPath/PhpStudy/phpstudy_pro/Extensions/MySQL5.7.26/data/ # MySQL数据存放文件(极其重要) character-set-server=utf8 # 数据库和数据库表的默认字符集。(推荐utf8,以免导致乱码) default-storage-engine=MyIsam # MySQL 的存储引擎 # ...... ","title":"MySQL 配置文件"},{"content":"What is 数据库 数据库（Database），通俗的说，它存储了一系列有组织的数据，像一个“仓库”，简称 DB。\n为什么要学习数据库？ 数据库可以实现数据的持久化。\n使用完整的管理系统对数据进行同意管理，易于查询。\n数据库的特点  数据不是直接放到数据库中的，而是先将数据放到表中，再将表放到库中。 一个数据库中可以有多个表，每个表都有一个的名字，用来标识自已，且表名具有唯一性。 表具有一些特性，这些特性定义了数据在表中如何存储。 表由列（字段）组成，每个表都有一个或多个列组成。 表中的数据是按行储存的。  ","permalink":"https://note.yxzi.xyz/note/technology/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"What is 数据库 数据库（Database），通俗的说，它存储了一系列有组织的数据，像一个“仓库”，简称 DB。\n为什么要学习数据库？ 数据库可以实现数据的持久化。\n使用完整的管理系统对数据进行同意管理，易于查询。\n数据库的特点  数据不是直接放到数据库中的，而是先将数据放到表中，再将表放到库中。 一个数据库中可以有多个表，每个表都有一个的名字，用来标识自已，且表名具有唯一性。 表具有一些特性，这些特性定义了数据在表中如何存储。 表由列（字段）组成，每个表都有一个或多个列组成。 表中的数据是按行储存的。  ","title":"数据库"},{"content":"for 执行 1，判断 2，当 2 为 true 时则执行 A，之后再执行 3，此后一直判断 2，直到 2 为 false 时并结束循环；如果 2 为 false，则直接结束循环。\nfor(1; 2; 3) {  A; } 其中：\n1 只执行一次。\n3 执行完后才意味着一次 for 循环执行完毕。\n3 执行完后一定会再执行一次 2，且不管表达式 2 的结果为 true 或 false 都会执行一次 2。\n#include \u0026lt;stdio.h\u0026gt;int main(void) { \tint sum = 0; \tfor (int i = 1;i \u0026lt; 10;i++) \tprintf(\u0026#34;%d\\n\u0026#34;, i); \t//0 - 10 的自然数。 } 1 - 10 所有奇数之和 #include \u0026lt;stdio.h\u0026gt;int main(void) { \tint sum = 0; \tfor (int i = 1;i \u0026lt; 10;i += 2) \tsum += i; \tprintf(\u0026#34;%d\\n\u0026#34;, sum); } 1 - 10 所有能被 3 整除的数的和 #include \u0026lt;stdio.h\u0026gt;int main(void) { \tint sum = 0; \tfor (int i = 0;i \u0026lt; 10;i++) { \tif (i % 3 == 0) { \tsum += i; \t} \t} \tprintf(\u0026#34;%d\\n\u0026#34;, sum); } 1 - 10 所有奇数的个数 #include \u0026lt;stdio.h\u0026gt;int main(void) { \tint num = 0; \tfor (int i = 1;i \u0026lt; 10;i += 2) \tnum++; \tprintf(\u0026#34;奇数个数 = %d\\n\u0026#34;, num); } 1 - 10 所有奇数的平均值 #include \u0026lt;stdio.h\u0026gt;int main(void) { \tint sum = 0; \tint num = 0; \tint mean = 0; \tfor (int i = 1;i \u0026lt; 10;i += 2) { \tsum += i; \tnum++; \tmean = sum / num; \t} \tprintf(\u0026#34;奇数之和 = %d\\n\u0026#34;, sum); \tprintf(\u0026#34;奇数个数 = %d\\n\u0026#34;, num); \tprintf(\u0026#34;平均值= %d\\n\u0026#34;, mean); } 1 - 10 所有奇数和偶数的和 #include \u0026lt;stdio.h\u0026gt;int main(void) { \tint OddSum = 0; \tint EvenSum = 0; \tfor (int i = 1;i \u0026lt; 10;i += 2) { \tOddSum += i; \tprintf(\u0026#34;%d\\n\u0026#34;, i); \t} \tfor (int j = 0;j \u0026lt; 10;j += 2) { \tEvenSum += j; \tprintf(\u0026#34;%d\\n\u0026#34;, j); \t} \tprintf(\u0026#34;奇数和 = %d\\n\u0026#34;, OddSum); \tprintf(\u0026#34;偶数和 = %d\\n\u0026#34;, EvenSum); } 强制类型转换 将表达式的值转换为指定的数据类型。\n(指定的数据类型)(表达式) 降序 #include \u0026lt;stdio.h\u0026gt;int main(void) { \tfloat sum = 1; \tfor (int i = 1;i \u0026lt; 10;i++) { \t//sum = 1 / (float)(i);//使用强制类型转换 \tsum = 1.0 / i; \t//这样也可以 \tprintf(\u0026#34;%d\\n\u0026#34;, sum); \t} \tprintf(\u0026#34;和 = %f\\n\u0026#34;, sum); \t//float 必须用 %f 输出 } 浮点数的储存问题 float 和 double 类型的数据不能保证可以精确的存储某个小数，也就是你将 5.5 赋给 x，此时变量 x 中，实际储存的可能是 5.49999999999，即 x 中可能储存的是一个近似值。\n//有一个浮点型变量 x，如何判断 x 的值是否为零？ float x = 0; if (| x - 0.000001 | \u0026lt; 0.000001)//该行有错，2021年2月8日17:20:53 无法解决 printf(\u0026#34;是零\\n\u0026#34;); else  printf(\u0026#34;不是零\\n\u0026#34;); //循环中更新的变量不能定义成浮点型（i++ 或 ++i） for (float i = 1;i \u0026lt; 1000;i++)  printf(\u0026#34;%0.99f\\n\u0026#34;,i); //该行有可能会返回近似值 for 循环嵌套 执行 1，判断 2，2 为 true，执行 4，判断 5，5 为 true，执行 A，再执行 6，判断 5，5 为 false，执行 3，判断 2，2 为 false，执行 B。\n#include \u0026lt;stdio.h\u0026gt;int main(void) { \tfor (1; 2; 3) \tfor (4; 5; 6) \tA; \tB; } #include \u0026lt;stdio.h\u0026gt;int main(void) { \tint i, j; \tfor (i = 0; i \u0026lt; 10; i++)//该循环执行了 10 次 \tfor (j = 0; j \u0026lt; 10; j++)//该循环被外层循环执行了 10 次 \tprintf(\u0026#34;内层 %d\\n\u0026#34;, j); \t//每次循环返回 0 - 9 \tprintf(\u0026#34;i = %d\\n\u0026#34;, i); \t//最终 i 为 10 \tprintf(\u0026#34;j = %d\\n\u0026#34;, j); \t//最终 j 为 10 } ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/for/","summary":"for 执行 1，判断 2，当 2 为 true 时则执行 A，之后再执行 3，此后一直判断 2，直到 2 为 false 时并结束循环；如果 2 为 false，则直接结束循环。\nfor(1; 2; 3) {  A; } 其中：\n1 只执行一次。\n3 执行完后才意味着一次 for 循环执行完毕。\n3 执行完后一定会再执行一次 2，且不管表达式 2 的结果为 true 或 false 都会执行一次 2。\n#include \u0026lt;stdio.h\u0026gt;int main(void) { \tint sum = 0; \tfor (int i = 1;i \u0026lt; 10;i++) \tprintf(\u0026#34;%d\\n\u0026#34;, i); \t//0 - 10 的自然数。 } 1 - 10 所有奇数之和 #include \u0026lt;stdio.","title":"C for"},{"content":"if 在程序当中,并不是所有的语句都是自上而下依次的执行，有时候会依据条件来选择性的执行某段代码，这个时候就需要用到 if 语句。\n如果 1 为真，则执行 A；如果 1 为假，则不执行 A。\n#include \u0026lt;stdio.h\u0026gt;int main(void) { \tif (1) \tA； } #include \u0026lt;stdio.h\u0026gt;int main(void) { \tif (2 \u0026gt; 1) \tprintf(\u0026#34;if 语句为 true\\n\u0026#34;); } if 语句默认只能控制 A，不能控制 B（即无论 1 为 true 还是 false， B 都会执行）。\n#include \u0026lt;stdio.h\u0026gt;int main(void) { \tif (1) \tA; \tB; } #include \u0026lt;stdio.h\u0026gt;int main(void) { \tif (2 \u0026gt; 1) \tprintf(\u0026#34;被 if 语句控制\\n\u0026#34;); \tprintf(\u0026#34;不被 if 语句控制\\n\u0026#34;); } if 语句默认只能控制一个 A，如果想控制多个语句（A 和 B），就必须将 A 和 B 用 {} 括起来。\n#include \u0026lt;stdio.h\u0026gt;int main(void) { \tif(1) { \tA; \tB; \t} } #include \u0026lt;stdio.h\u0026gt;int main(void) { \tif (2 \u0026gt; 1) { \tprintf(\u0026#34;被 if 语句控制\\n\u0026#34;); \tprintf(\u0026#34;被 if 语句控制\\n\u0026#34;); \t} } if else if else 语句会判定 1 的真假，表达式为 true 则执行 A 和 B；1 为 false 则执行 C；D 为必须执行的语句（D 不受 if 语句控制）。\n#include \u0026lt;stdio.h\u0026gt;int main(void) { \tif (1) { \tA; \tB; \t} else \tC; \tD; } #include \u0026lt;stdio.h\u0026gt;int main(void) { \tif (4 \u0026gt; 2) { \tprintf(\u0026#34;正确\\n\u0026#34;); \tprintf(\u0026#34;二次确认也正确\\n\u0026#34;); \t} else \tprintf(\u0026#34;不正确\\n\u0026#34;); \tprintf(\u0026#34;必定会执行\\n\u0026#34;); } if else 连续 使用 if else 语句连续判断 1、2、4，若某个表达式为 true 则返回其对应的 A、B、C、D，若 1、2、3 全部为 false，则返回 D。\n#include \u0026lt;stdio.h\u0026gt;int main(void) { \tif (1) \tprintf(\u0026#34;A\\n\u0026#34;); else if (2) \tprintf(\u0026#34;B\\n\u0026#34;); else if (3) \tprintf(\u0026#34;C\\n\u0026#34;); else \tprintf(\u0026#34;D\\n\u0026#34;); } #include \u0026lt;stdio.h\u0026gt;int main(void) { \tif (4 == 2) \tprintf(\u0026#34;表达式一为假\\n\u0026#34;); else if (2 == 5) \tprintf(\u0026#34;表达式二也为假\\n\u0026#34;); else if (3 == 7) \tprintf(\u0026#34;表达式三还是为假\\n\u0026#34;); else \tprintf(\u0026#34;三个表达式全部为假\\n\u0026#34;); } if else 被分割\n#include \u0026lt;stdio.h\u0026gt;int main(void) { \tif (4 == 2) \tprintf(\u0026#34;不正确\\n\u0026#34;); else if (2 == 5) \tprintf(\u0026#34;也不正确\\n\u0026#34;); \tprintf(\u0026#34;程序会因为该行报错\\n\u0026#34;); \t//该行将原本完整的 if else 语句分割了，导致下面的 if 语句不完整。 else if (3 == 7) \tprintf(\u0026#34;还是不正确\\n\u0026#34;); else \tprintf(\u0026#34;全部错误\\n\u0026#34;); } 互换两个值 #include \u0026lt;stdio.h\u0026gt;int main(void) { \tint i = 3; \tint j = 5; \tint t; \t//定义临时的变量 t。 \tt = i; \t//将变量 i 的值赋给变量 t，作为变量 i 值的备份。 \ti = j; \t//将变量 j 的值赋给变量 i，这时的变量 i 和变量 t 的值相同。 \tj = t; \t//将变量 t 中的值，也就是 i 的值赋给变量 j。 \tprintf(\u0026#34;i = %d\\nj = %d\\n\u0026#34;, i, j); } 返回最大值 #include \u0026lt;stdio.h\u0026gt;int main(void) { \tint a, b, c; \tprintf(\u0026#34;请输入三个数：\u0026#34;); \tscanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); \tif (a == b || b == c || c == a) \tprintf(\u0026#34;请勿输入相同的值！\\n\u0026#34;); else { \tif (a \u0026gt; b \u0026amp;\u0026amp; a \u0026gt; c) \tprintf(\u0026#34;a 最大!\\n\u0026#34;); else if (b \u0026gt; a \u0026amp;\u0026amp; b \u0026gt; c) \tprintf(\u0026#34;b 最大!\\n\u0026#34;); else if (c \u0026gt; a \u0026amp;\u0026amp; c \u0026gt; b) \tprintf(\u0026#34;c 最大!\\n\u0026#34;); \t} } 降序 #include \u0026lt;stdio.h\u0026gt;int main(void) { \tint a, b, c, t; \tprintf(\u0026#34;请输入三个值：\\n\u0026#34;); \tscanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); \tif (b \u0026gt; a) { \tt = a; \ta = b; \t// 将 b 赋给 a，使 b 代替 a 最大的位置 \tb = t; \t//使 a 代替 b 中间的位置 \t} \tif (c \u0026gt; a) { \tt = a; \ta = c; \t// 将 c 赋给 a，使 c 代替 a 最大的位置 \tc = t; \t// 使 a 代替 c 最小的位置 \t} \tif (c \u0026gt; b) { \tt = b; \tb = c; \t//将 c 赋给 b，使 c 代替 b 中间的位置 \tc = t; \t//使 b 代替 c 最小的位置 \t} \tprintf(\u0026#34;最大值：%d\\n中间值：%d\\n最小值：%d\\n\u0026#34;, a, b, c); \t//默认为 a 最大，b 次之，c 最小；比较三个值大小使得 a、b、c，交换最大、中间、最小的位置。 } ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/if/","summary":"if 在程序当中,并不是所有的语句都是自上而下依次的执行，有时候会依据条件来选择性的执行某段代码，这个时候就需要用到 if 语句。\n如果 1 为真，则执行 A；如果 1 为假，则不执行 A。\n#include \u0026lt;stdio.h\u0026gt;int main(void) { \tif (1) \tA； } #include \u0026lt;stdio.h\u0026gt;int main(void) { \tif (2 \u0026gt; 1) \tprintf(\u0026#34;if 语句为 true\\n\u0026#34;); } if 语句默认只能控制 A，不能控制 B（即无论 1 为 true 还是 false， B 都会执行）。\n#include \u0026lt;stdio.h\u0026gt;int main(void) { \tif (1) \tA; \tB; } #include \u0026lt;stdio.h\u0026gt;int main(void) { \tif (2 \u0026gt; 1) \tprintf(\u0026#34;被 if 语句控制\\n\u0026#34;); \tprintf(\u0026#34;不被 if 语句控制\\n\u0026#34;); } if 语句默认只能控制一个 A，如果想控制多个语句（A 和 B），就必须将 A 和 B 用 {} 括起来。","title":"C if"},{"content":"malloc malloc 是 memory（内存）allocate（分配）的缩写。\n可以让一个变量动态分配内存。\nmalloc 函数的使用 #include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.h\u0026gt; int main() {  int a = 5; // a 是一个 int 变量，它是静态分配的  int * p = (int *)malloc(4); // 动态分配  *p = 5;// *p 也是一个 int 变量，但它是动态分配的  free(p); // 手动释放动态分配的内存  printf(\u0026#34;%d\\n\u0026#34;,*p);  printf(\u0026#34;%d\\n\u0026#34;,p); }  使用 malloc 函数，需要添加头文件 malloc.h malloc 函数只有一个形参，并且形参是整型。 malloc(4)表示请求系统为我们分配 4 个字节 malloc 函数只能返回第一个字节的地址，即 p 只保存了第一个字节的整型地址 int * 是为了让系统知道我们分配这个 4 个字节的地址是整型地址。 int * p = (int *)malloc(4)这行代码总共分配了 8 个字节，int * p分配了 4 个字节，(int *)malloc(4)分配了 84 个字节一共 8 个字节。 p（int * p）本身所占的内存是静态分配的，但 p 所指向的内存(int *)malloc(4)是动态分配的。 free(p)表示将 p 所指向的内存给释放掉，使得 p 指向的内存无法被读写。但是，p 本身的内存是静态的，不能被我们用free()函数手动释放，p 本身的内存只能在 p 变量所在的函数运行结束后，被系统自动释放。 *p = 5和int a = 5的区别在于前者的内存分配方式是动态分配的，后者的内存分配方式是静态分配的。 *p = 5 中，其中*p指的是用(int *)malloc(4)动态分配了 4 个字节的内存空间，而*p = 5，则是将 5 这个 int 数值放入这动态分配的 4 个字节的内存中。而 p 则只保存了其中第 1 个字节的地址。  ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/malloc/","summary":"malloc malloc 是 memory（内存）allocate（分配）的缩写。\n可以让一个变量动态分配内存。\nmalloc 函数的使用 #include \u0026lt;iostream\u0026gt;#include \u0026lt;malloc.h\u0026gt; int main() {  int a = 5; // a 是一个 int 变量，它是静态分配的  int * p = (int *)malloc(4); // 动态分配  *p = 5;// *p 也是一个 int 变量，但它是动态分配的  free(p); // 手动释放动态分配的内存  printf(\u0026#34;%d\\n\u0026#34;,*p);  printf(\u0026#34;%d\\n\u0026#34;,p); }  使用 malloc 函数，需要添加头文件 malloc.h malloc 函数只有一个形参，并且形参是整型。 malloc(4)表示请求系统为我们分配 4 个字节 malloc 函数只能返回第一个字节的地址，即 p 只保存了第一个字节的整型地址 int * 是为了让系统知道我们分配这个 4 个字节的地址是整型地址。 int * p = (int *)malloc(4)这行代码总共分配了 8 个字节，int * p分配了 4 个字节，(int *)malloc(4)分配了 84 个字节一共 8 个字节。 p（int * p）本身所占的内存是静态分配的，但 p 所指向的内存(int *)malloc(4)是动态分配的。 free(p)表示将 p 所指向的内存给释放掉，使得 p 指向的内存无法被读写。但是，p 本身的内存是静态的，不能被我们用free()函数手动释放，p 本身的内存只能在 p 变量所在的函数运行结束后，被系统自动释放。 *p = 5和int a = 5的区别在于前者的内存分配方式是动态分配的，后者的内存分配方式是静态分配的。 *p = 5 中，其中*p指的是用(int *)malloc(4)动态分配了 4 个字节的内存空间，而*p = 5，则是将 5 这个 int 数值放入这动态分配的 4 个字节的内存中。而 p 则只保存了其中第 1 个字节的地址。  ","title":"C malloc"},{"content":"流程控制 流程控制也叫控制结构，控制程序应该如何执行代码。\n顺序控制 从上到下的执行代码，中间没有任何判断或跳转。\n选择控制 某些代码可能执行，也可能不执行，有选择的执行某些代码。\n循环控制 某些代码被重复执行。\n","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","summary":"流程控制 流程控制也叫控制结构，控制程序应该如何执行代码。\n顺序控制 从上到下的执行代码，中间没有任何判断或跳转。\n选择控制 某些代码可能执行，也可能不执行，有选择的执行某些代码。\n循环控制 某些代码被重复执行。","title":"C 流程控制"},{"content":"动词短语和介词短语 它们的区别 动词短语 动词短语虽然由多个词语构成，但它实际上是一个整体，只能将它当作一个词语看待，因为它与普通的动词是一样的。\n动词和介词构成的动词短语也叫复合动词，属于实义动词的范畴。\n look at get up look for  介词短语 介词短语的介词是放在开头的，后面跟一个名词/代词/数词/动名词/可以构成一个介词短语。\n介词可以根据自身的规则构成很多个意义不同的介词短语，而动词短语是一个固定的实义动词，有固定的意思和作用。\n介词短语是一个真正意义上的短语，\n动词短语不属于短语，只是一个动词。\n因为动词短语中的介词和介词短语中的介词看起来样的，所以，这很容易让我们将这两者混用。\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E5%92%8C%E4%BB%8B%E8%AF%8D%E7%9F%AD%E8%AF%AD/","summary":"动词短语和介词短语 它们的区别 动词短语 动词短语虽然由多个词语构成，但它实际上是一个整体，只能将它当作一个词语看待，因为它与普通的动词是一样的。\n动词和介词构成的动词短语也叫复合动词，属于实义动词的范畴。\n look at get up look for  介词短语 介词短语的介词是放在开头的，后面跟一个名词/代词/数词/动名词/可以构成一个介词短语。\n介词可以根据自身的规则构成很多个意义不同的介词短语，而动词短语是一个固定的实义动词，有固定的意思和作用。\n介词短语是一个真正意义上的短语，\n动词短语不属于短语，只是一个动词。\n因为动词短语中的介词和介词短语中的介词看起来样的，所以，这很容易让我们将这两者混用。","title":"English 动词短语和介词短语"},{"content":"就在今天，我的联想小新突然就没网了，点开右下角的网络标志一看，没想到 WIFI 的开关都直接消失了，直接给我干懵逼的了，转到设置一看，设置项的 WIFI 选项也很莫名的消失了，我也没更新系统，就用着用着就没 WIFI 了，属实是很怪。\n然后我打开设备管理器看了一下，发现网络适配器中的 Intel(R) Wireless-AC 9569居然提示报错无法启动（代码 10）。\n最后我在网上查了大概十分钟，就在知乎上找到了一个回答，很简单粗暴，也非常有用。\n 首先将你笔记本的电源给拔掉。 然后可以尝试长按电源键，使电脑强制关机。 最后再开机，Wireless 就恢复了。  ","permalink":"https://note.yxzi.xyz/note/technology/windows/window-%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8-wifi/","summary":"就在今天，我的联想小新突然就没网了，点开右下角的网络标志一看，没想到 WIFI 的开关都直接消失了，直接给我干懵逼的了，转到设置一看，设置项的 WIFI 选项也很莫名的消失了，我也没更新系统，就用着用着就没 WIFI 了，属实是很怪。\n然后我打开设备管理器看了一下，发现网络适配器中的 Intel(R) Wireless-AC 9569居然提示报错无法启动（代码 10）。\n最后我在网上查了大概十分钟，就在知乎上找到了一个回答，很简单粗暴，也非常有用。\n 首先将你笔记本的电源给拔掉。 然后可以尝试长按电源键，使电脑强制关机。 最后再开机，Wireless 就恢复了。  ","title":"Window 无法使用 WIFI"},{"content":"一般过去时态 表示的曾经发生的一些动作和状态，也就是已经过去的一些事物。\n一般过去时态的时间状语 一般情况，一般过去时态需要加上表示过去的时间状语。\n yesterday. just now. before.  大部分表示过去的时间状语，都是由介词或副词跟其他的词语构成的，一般有下面一种构成方式。\n在副词 ago（\u0026hellip;之前）加上表示时间的词语。 One/a/an + 表示时间名词的单数 + ago.\n数词（大于 1 的数词） + 表示时间名词的复数 的复数 + ago.\n a day ago. One year ago. Three days ago.  在 in 后面加上一个表示过去年份的数词。  I was run in 2022. I was study in 2022.  在副词 last 后面加上表示时间的名词。 Last（上一个） + 表示时间的名词的单数。\n Last hour. Last week. Last month. I was tired last night. She was busy last week.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E4%B8%80%E8%88%AC%E8%BF%87%E5%8E%BB%E6%97%B6%E6%80%81/","summary":"一般过去时态 表示的曾经发生的一些动作和状态，也就是已经过去的一些事物。\n一般过去时态的时间状语 一般情况，一般过去时态需要加上表示过去的时间状语。\n yesterday. just now. before.  大部分表示过去的时间状语，都是由介词或副词跟其他的词语构成的，一般有下面一种构成方式。\n在副词 ago（\u0026hellip;之前）加上表示时间的词语。 One/a/an + 表示时间名词的单数 + ago.\n数词（大于 1 的数词） + 表示时间名词的复数 的复数 + ago.\n a day ago. One year ago. Three days ago.  在 in 后面加上一个表示过去年份的数词。  I was run in 2022. I was study in 2022.  在副词 last 后面加上表示时间的名词。 Last（上一个） + 表示时间的名词的单数。\n Last hour. Last week. Last month. I was tired last night. She was busy last week.","title":"English 一般过去时态"},{"content":"一个指针变量占几个字节 在 64 位系统中，一个指针变量占 4 个字节，不管这个指针指向的是什么类型的变量。\n在 64 位系统中，一个指针变量占 8 个字节，不管这个指针指向的是什么类型的变量。\nsizeof() 此函数可以返回指定数据类型所占的字节。\n#include \u0026lt;stdio.h\u0026gt; int main () {  int a = 666;  char ch = \u0026#39;A\u0026#39;;  double dou = 99.9;  int*p = \u0026amp;a;  char *c = \u0026amp;ch;  double *x = \u0026amp;dou;  // 不过什么数据类型的指针变量，  // 所占字节都是 8 个（32 位系统占 4 个字节）  printf(\u0026#34;%d\\n\u0026#34;,sizeof(p));  printf(\u0026#34;%d\\n\u0026#34;,sizeof(c));  printf(\u0026#34;%d\\n\u0026#34;,sizeof(x)); } 虽然在 64 位系统中的指针变量占 8 个字节，但是一个变量的地址（指针变量）只会存放该变量首字节的地址。这样，指针变量通过首字节的地址，就能知道自己所指向的变量类型，也就知道了该指针变量所指向的变量到底占多少个字节。\n虽然一个指针变量所指向的变量的所占字节大小不一样，但是这个指针变量，无论它指向的变量占多少个字节，该指针变量本身只会且仅占 4 个字节。\n","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%8D%A0%E5%87%A0%E4%B8%AA%E5%AD%97%E8%8A%82/","summary":"一个指针变量占几个字节 在 64 位系统中，一个指针变量占 4 个字节，不管这个指针指向的是什么类型的变量。\n在 64 位系统中，一个指针变量占 8 个字节，不管这个指针指向的是什么类型的变量。\nsizeof() 此函数可以返回指定数据类型所占的字节。\n#include \u0026lt;stdio.h\u0026gt; int main () {  int a = 666;  char ch = \u0026#39;A\u0026#39;;  double dou = 99.9;  int*p = \u0026amp;a;  char *c = \u0026amp;ch;  double *x = \u0026amp;dou;  // 不过什么数据类型的指针变量，  // 所占字节都是 8 个（32 位系统占 4 个字节）  printf(\u0026#34;%d\\n\u0026#34;,sizeof(p));  printf(\u0026#34;%d\\n\u0026#34;,sizeof(c));  printf(\u0026#34;%d\\n\u0026#34;,sizeof(x)); } 虽然在 64 位系统中的指针变量占 8 个字节，但是一个变量的地址（指针变量）只会存放该变量首字节的地址。这样，指针变量通过首字节的地址，就能知道自己所指向的变量类型，也就知道了该指针变量所指向的变量到底占多少个字节。","title":"C 一个指针变量占几个字节"},{"content":"动态内存分配 传统数组的缺点 传统数组也叫静态数组，也属于静态内存\n  数组长度必须事先指定，且只能是长整数，不能是变量。\n  传统形式定义的数组，该数组的内存无法被我们手动释放。因为系统为该数组分配的储存空间就会一直存在，除非数组所在的函数运行完毕，数组的空间才会被系统释放。\n#include \u0026lt;stdio.h\u0026gt;void fun(void){  // 这 20 个字节（4 个 int ）的储存空间无法被我们手动的释放，  // 只能在本函数（fun 函数）运行完毕后由系统自动释放  int a[5] = {1,2,3,4,5}; } int main () {  }   数组的长度一旦定义，其长度就不能再被更改。也就是数组的长度不能在函数运行的过程中动态的扩充或缩小。\n  Ａ 函数中定义的数组，在 Ａ 函数运行期间可以被其他函数使用，但 A 函数运行完毕之后，A 函数中的数组将无法在被其他函数使用（A 函数在运行完毕后，就会被系统释放）。\n  动态数组（动态内存） 动态数组很好的解决了传统数组的 4 个缺点，传统数组也叫静态数组，\n","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98/","summary":"动态内存分配 传统数组的缺点 传统数组也叫静态数组，也属于静态内存\n  数组长度必须事先指定，且只能是长整数，不能是变量。\n  传统形式定义的数组，该数组的内存无法被我们手动释放。因为系统为该数组分配的储存空间就会一直存在，除非数组所在的函数运行完毕，数组的空间才会被系统释放。\n#include \u0026lt;stdio.h\u0026gt;void fun(void){  // 这 20 个字节（4 个 int ）的储存空间无法被我们手动的释放，  // 只能在本函数（fun 函数）运行完毕后由系统自动释放  int a[5] = {1,2,3,4,5}; } int main () {  }   数组的长度一旦定义，其长度就不能再被更改。也就是数组的长度不能在函数运行的过程中动态的扩充或缩小。\n  Ａ 函数中定义的数组，在 Ａ 函数运行期间可以被其他函数使用，但 A 函数运行完毕之后，A 函数中的数组将无法在被其他函数使用（A 函数在运行完毕后，就会被系统释放）。\n  动态数组（动态内存） 动态数组很好的解决了传统数组的 4 个缺点，传统数组也叫静态数组，","title":"C 动态分配内存"},{"content":"一般现在时态 指的是从过去到现在直至将来的一段时间内发生的动作或存在的状态\n一般现在时态的用法 当表示经常性、习惯性、有规律性的动作和状态的时候 另外，表示真理性、客观性的动作和状态也要使用一般现在时态。\n比如：地球是圆的，太阳从东边升起，1 + 1 = 2.\n表示不轻易改变的状态 什么叫不轻易改变的状态？比如：\n“他是一个男孩”，“是男的”这个状态不会轻易变成“是女的”这个状态。\n“这个房子很大”，因为大房子是不会轻易变小的，所以这也要用一般现在时态。\n表示此时此刻的状态  I am tired now. I am busy now.  一般现在时态的时间状语 一般现在时态的时间状语都是表示经常性、习惯性或有规律性的词语。比如：\n every day every week On Sunday In the Morning  以上都是一些时间状语。\n She gets up very late on Sunday. I get up at 9:00 every morning. I never drink wine. I often play basketball.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E4%B8%80%E8%88%AC%E7%8E%B0%E5%9C%A8%E6%97%B6%E6%80%81/","summary":"一般现在时态 指的是从过去到现在直至将来的一段时间内发生的动作或存在的状态\n一般现在时态的用法 当表示经常性、习惯性、有规律性的动作和状态的时候 另外，表示真理性、客观性的动作和状态也要使用一般现在时态。\n比如：地球是圆的，太阳从东边升起，1 + 1 = 2.\n表示不轻易改变的状态 什么叫不轻易改变的状态？比如：\n“他是一个男孩”，“是男的”这个状态不会轻易变成“是女的”这个状态。\n“这个房子很大”，因为大房子是不会轻易变小的，所以这也要用一般现在时态。\n表示此时此刻的状态  I am tired now. I am busy now.  一般现在时态的时间状语 一般现在时态的时间状语都是表示经常性、习惯性或有规律性的词语。比如：\n every day every week On Sunday In the Morning  以上都是一些时间状语。\n She gets up very late on Sunday. I get up at 9:00 every morning. I never drink wine. I often play basketball.  ","title":"English 一般现在时态"},{"content":"时态是什么 时态其实就是一个谓语动词随着时间的变化而发生不同形态的变化。\n不同的时态用来表示不同的时间状态。\n I bought a book yesterday. I will a book tomorrow. I buy a book ever day.  可以看出，英语的谓语动词发生了多种形式的变化：bought、will buy、buy，另外中文的时间状语放在中间，而英文的时间状语放在句尾（是少数情况下也会放在句尾，比如书面语）。\n英语中有 16 种时态。常用的有 10 种：\n 一般现在时态 一般过去时态 一般将 来时态 现在进行时态 现在完成时态 过去完成时态 过去将来时态 过去进行时态 现在完成进行时态 将来进行时态  其他的六种比较少用，主要出现在书面语中。\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E6%97%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88/","summary":"时态是什么 时态其实就是一个谓语动词随着时间的变化而发生不同形态的变化。\n不同的时态用来表示不同的时间状态。\n I bought a book yesterday. I will a book tomorrow. I buy a book ever day.  可以看出，英语的谓语动词发生了多种形式的变化：bought、will buy、buy，另外中文的时间状语放在中间，而英文的时间状语放在句尾（是少数情况下也会放在句尾，比如书面语）。\n英语中有 16 种时态。常用的有 10 种：\n 一般现在时态 一般过去时态 一般将 来时态 现在进行时态 现在完成时态 过去完成时态 过去将来时态 过去进行时态 现在完成进行时态 将来进行时态  其他的六种比较少用，主要出现在书面语中。","title":"English 时态是什么"},{"content":"一维数组 定义一个一维数组时：\n为 n 个变量连续分配储存空间。\n数组中的所有元素，数据类型必须一致。\n数组中所有变量所占的字节必须一样。\n定义一维数组 #include \u0026lt;iostream\u0026gt;int main(){  // 完全初始化  int arr[5] ={1,2,3,4,5};  // 不完全初始化，未初始化的元素的值为 0  int arr2[5] ={1,2,3};  // 打印索引为 4 的值，但 arr2 中没有索引为 3 的值，因此这里返回 0  printf(\u0026#34;%d\\n\u0026#34;,arr2[3]);  // 不初始化，所有元素都是垃圾值  int arr3[5];  printf(\u0026#34;%d\\n\u0026#34;,arr3[5]);  // 清零，将数组中的每个元素的值都变成 0  int arr4[5] = {0}; } 错误的定义 只有在定义数组的同时，才可以整体赋值，\n其他情况下整体复制都是错误的。\n#include \u0026lt;iostream\u0026gt;int main(){  int a[5];  // a[5] 表示 a 数组中索引为 5 的值。  a[5] = {1,2,3,4,5}; } 将数组 a 中的值全部复制到数组 b #include \u0026lt;iostream\u0026gt; int main() { // 错误的写法，因为一维数组名，d该数组中第一个元素的地址  b = a; // 正确的写法  for(int i = 0; i \u0026lt; 5; i++ )  {  b[i] = a[i];  } } ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/","summary":"一维数组 定义一个一维数组时：\n为 n 个变量连续分配储存空间。\n数组中的所有元素，数据类型必须一致。\n数组中所有变量所占的字节必须一样。\n定义一维数组 #include \u0026lt;iostream\u0026gt;int main(){  // 完全初始化  int arr[5] ={1,2,3,4,5};  // 不完全初始化，未初始化的元素的值为 0  int arr2[5] ={1,2,3};  // 打印索引为 4 的值，但 arr2 中没有索引为 3 的值，因此这里返回 0  printf(\u0026#34;%d\\n\u0026#34;,arr2[3]);  // 不初始化，所有元素都是垃圾值  int arr3[5];  printf(\u0026#34;%d\\n\u0026#34;,arr3[5]);  // 清零，将数组中的每个元素的值都变成 0  int arr4[5] = {0}; } 错误的定义 只有在定义数组的同时，才可以整体赋值，\n其他情况下整体复制都是错误的。\n#include \u0026lt;iostream\u0026gt;int main(){  int a[5];  // a[5] 表示 a 数组中索引为 5 的值。  a[5] = {1,2,3,4,5}; } 将数组 a 中的值全部复制到数组 b #include \u0026lt;iostream\u0026gt; int main() { // 错误的写法，因为一维数组名，d该数组中第一个元素的地址  b = a; // 正确的写法  for(int i = 0; i \u0026lt; 5; i++ )  {  b[i] = a[i];  } } ","title":"C 一维数组"},{"content":"二维数组 一个二维数组，在本质上，是一个一维数组的列表。它声明了一个 x 行 y 列的二维整型数组。\n#include \u0026lt;iostream\u0026gt; int main(){  // 该数组中总共有12个元素，可以当作 3 行(一)5 列（丨）来看  int arr[3][4];  // 这个二位数组以此为：  arr[0][0] arr[0][1] arr[0][2] arr[0][3]  arr[1][0] arr[1][1] arr[1][2] arr[1][3]  arr[2][0] arr[2][1] arr[2][2] arr[2][3] } 声明一个二维数组 #include \u0026lt;iostream\u0026gt; int main() {  int arr[3][4] = {1,2,3,4,6,7,8,9,10,11,12};   int arr2[3][4] =  {  {1, 2, 3, 4},  {5, 6, 7, 8},  {9,10,11,12}  }; } 输出二维数组的内容 #include \u0026lt;iostream\u0026gt; int main() {  int arr[3][4] =  {  {1, 2, 3, 4},  {5, 6, 7, 8},  {9,10,11,12}  };  int i,j;  for(i = 0; i \u0026lt; 3; ++i)  {  for(j = 0; j \u0026lt; 4; ++j)  { // 负号表示将输出的内容对其， // 3表示每个元素间隔3个光标到位置  printf(\u0026#34;%-3d \u0026#34;,arr[i][j]);  }  printf(\u0026#34;\\n\u0026#34;);  } } 关于多维数组 不存在多维数组，因为内存是线性的\nn 维数组都可以当作每个元素是 n - 1 维数组的一维数组。\n总的来说，n 维数组是可以被拆分的。\n比如int a[3][4]\n该数组是含有 3 个元素的一维数组，只不过这 3 个元素，每个元素都可以再分为 4 个小元素；\n","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/","summary":"二维数组 一个二维数组，在本质上，是一个一维数组的列表。它声明了一个 x 行 y 列的二维整型数组。\n#include \u0026lt;iostream\u0026gt; int main(){  // 该数组中总共有12个元素，可以当作 3 行(一)5 列（丨）来看  int arr[3][4];  // 这个二位数组以此为：  arr[0][0] arr[0][1] arr[0][2] arr[0][3]  arr[1][0] arr[1][1] arr[1][2] arr[1][3]  arr[2][0] arr[2][1] arr[2][2] arr[2][3] } 声明一个二维数组 #include \u0026lt;iostream\u0026gt; int main() {  int arr[3][4] = {1,2,3,4,6,7,8,9,10,11,12};   int arr2[3][4] =  {  {1, 2, 3, 4},  {5, 6, 7, 8},  {9,10,11,12}  }; } 输出二维数组的内容 #include \u0026lt;iostream\u0026gt; int main() {  int arr[3][4] =  {  {1, 2, 3, 4},  {5, 6, 7, 8},  {9,10,11,12}  };  int i,j;  for(i = 0; i \u0026lt; 3; ++i)  {  for(j = 0; j \u0026lt; 4; ++j)  { // 负号表示将输出的内容对其， // 3表示每个元素间隔3个光标到位置  printf(\u0026#34;%-3d \u0026#34;,arr[i][j]);  }  printf(\u0026#34;\\n\u0026#34;);  } } 关于多维数组 不存在多维数组，因为内存是线性的","title":"C 二维数组"},{"content":"指针和一维数组 一维数组名 一维数组的名字是一个指针常量，它存放的是数组一个元素的地址。\n#include \u0026lt;iostream\u0026gt; int main() {  int a[5];  // 打印一维数组 a 中，第一个元素的地址  printf(\u0026#34;%#x\\n\u0026#34;,\u0026amp;a[0]);  // 打印一维数组 a 的名字  printf(\u0026#34;%#x\\n\u0026#34;,a); } 下标和指针的关系 如果 p 是一个指针变量，则 p[n] 永远等价于 *（p + n）\nvoid DeterminesArray(int *arr, int lenght) {  for(int i = 0; i \u0026lt; lenght; i++)  {  printf(\u0026#34;%d\\n\u0026#34;,*(arr + i));  // *(arr + i) 等价于 arr[i]  printf(\u0026#34;%d\\n\u0026#34;,arr[i]);  } } 确定一个一维数组需要哪些参数 当一个函数要处理一个或多个一维数组时，我们需要接收该数组的那些信息。也就是如何让一个函数知道我们将要处理的是一个数组，而不是其他数据类型。\n  数组首个元素的地址\n  数组的长度\n#include \u0026lt;stdio.h\u0026gt; void DeterminesArray(int *arr, int lenght) {  for(int i = 0; i \u0026lt; lenght; i++)  {  printf(\u0026#34;%d\u0026#34;,*(arr + i));  printf(\u0026#34;\\n\u0026#34;);  } } int main () {  int a[5] = {1,20,300,4000,50000};  // a[3] ，因为数组名 a 是第一个元素的地址，  // 所以a[3] 的意思是从数组第一个元素的地址开始 + 1，  // 第二个元素就是*（a + 1），地址 + 4（因为 int 类型占 4 个字节）  // 第三个元素是*（a + 2）  printf(\u0026#34;数组 a 中第一个元素的地址：%d\\n\u0026#34;,a);  // a + 1，这个 1 在内存中占了四个字节，所以地址会向后数 4 个字节，  // 最后的才会返回数组中第二个元素的地址  printf(\u0026#34;数组 a 中第二个元素的地址：%d\\n\u0026#34;,a + 1);  printf(\u0026#34;数组 a 中第三个元素的地址：%d\\n\u0026#34;,a + 2);  printf(\u0026#34;数组 a 中第四个元素的地址：%d\\n\u0026#34;,a + 3);  printf(\u0026#34;数组 a 中第五个元素的地址：%d\\n\u0026#34;,a + 4);  printf(\u0026#34;数组 a 中第三个元素是：%d\\n\u0026#34;,a[3]);  printf(\u0026#34;for 循环输出数组：\\n\u0026#34;);  DeterminesArray(a,5); }   ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E5%92%8C%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/","summary":"指针和一维数组 一维数组名 一维数组的名字是一个指针常量，它存放的是数组一个元素的地址。\n#include \u0026lt;iostream\u0026gt; int main() {  int a[5];  // 打印一维数组 a 中，第一个元素的地址  printf(\u0026#34;%#x\\n\u0026#34;,\u0026amp;a[0]);  // 打印一维数组 a 的名字  printf(\u0026#34;%#x\\n\u0026#34;,a); } 下标和指针的关系 如果 p 是一个指针变量，则 p[n] 永远等价于 *（p + n）\nvoid DeterminesArray(int *arr, int lenght) {  for(int i = 0; i \u0026lt; lenght; i++)  {  printf(\u0026#34;%d\\n\u0026#34;,*(arr + i));  // *(arr + i) 等价于 arr[i]  printf(\u0026#34;%d\\n\u0026#34;,arr[i]);  } } 确定一个一维数组需要哪些参数 当一个函数要处理一个或多个一维数组时，我们需要接收该数组的那些信息。也就是如何让一个函数知道我们将要处理的是一个数组，而不是其他数据类型。","title":"C 指针和一维数组"},{"content":"指针的运算 指针变量不能相加不能相乘也不能相除。 如果两个指针变量指向的是同一块连续空间中的不同存储单元（比如数组），则这两个指针变量才可以相减（表示两个元素相隔多少个元素/字节）\n","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97/","summary":"指针的运算 指针变量不能相加不能相乘也不能相除。 如果两个指针变量指向的是同一块连续空间中的不同存储单元（比如数组），则这两个指针变量才可以相减（表示两个元素相隔多少个元素/字节）","title":"C 指针的运算"},{"content":"配置 trunk 和 Access 添加静态 mac\n改名，配置 IP 和子网掩码\n第一台 pc ping 其他 pc\n显示 mac 地址\n设置 mac 地址\n划分 vlan\n改名\n显示 vlan\n其中一台 pc ping 剩余 pc\n创建 vlan batch 1\n进入接口 1 和 2\nport link-type access\nport defult vlan 10\nquit\n进入接口 3 和 4\nport link-type access\nport defult vlan 20\nquit\n相同 vlan 互相 ping\n两台交换机分别有四台 pc\n第一台交换机下有 vlan 10 和 vlan 20\n第二台交换机下有 vlan 10 和 vlan 20\n","permalink":"https://note.yxzi.xyz/note/technology/internet/ensp/%E9%85%8D%E7%BD%AE-trunk-%E5%92%8C-access/","summary":"配置 trunk 和 Access 添加静态 mac\n改名，配置 IP 和子网掩码\n第一台 pc ping 其他 pc\n显示 mac 地址\n设置 mac 地址\n划分 vlan\n改名\n显示 vlan\n其中一台 pc ping 剩余 pc\n创建 vlan batch 1\n进入接口 1 和 2\nport link-type access\nport defult vlan 10\nquit\n进入接口 3 和 4\nport link-type access\nport defult vlan 20\nquit\n相同 vlan 互相 ping\n两台交换机分别有四台 pc\n第一台交换机下有 vlan 10 和 vlan 20","title":"eMSP 配置 trunk 和 Access"},{"content":"交换机端口模式 Access 接收，没有 vid 的帧打上 tag，有 vid 的帧则比较 vid 和 vpvid，相同，则剥离 vid 转发，不同则丢弃\n发送，vid 等于 pvid 剥离 vid 并发送，不等于 则丢弃\ntrunk 接收，没有 vid 的帧，打上 pvid 标签，查询是否在允许列表中，如果在，则转发，不在则丢弃。有 vid 的帧，直接查询是否在允许列表中，在则转发，不在则丢弃\n发送，vid 在允许列表内，vid 等于 pvid 剥离 vid 并发送，\nvid 不等于 pvid，保留 vid 并转发\nvid 不在运行列表，直接丢弃\nhybrid 接收，同 trunk，\n发送\nvid 不在允许列表中，直接丢弃\nvid 在运行列表中，不管 vid 是否等于 pvid，都需要通过命令决定是否保留这个 vid （tagged 和 untagged）\n启用 gvrp 必须是 trunk\n","permalink":"https://note.yxzi.xyz/note/technology/internet/ensp/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E6%A8%A1%E5%BC%8F/","summary":"交换机端口模式 Access 接收，没有 vid 的帧打上 tag，有 vid 的帧则比较 vid 和 vpvid，相同，则剥离 vid 转发，不同则丢弃\n发送，vid 等于 pvid 剥离 vid 并发送，不等于 则丢弃\ntrunk 接收，没有 vid 的帧，打上 pvid 标签，查询是否在允许列表中，如果在，则转发，不在则丢弃。有 vid 的帧，直接查询是否在允许列表中，在则转发，不在则丢弃\n发送，vid 在允许列表内，vid 等于 pvid 剥离 vid 并发送，\nvid 不等于 pvid，保留 vid 并转发\nvid 不在运行列表，直接丢弃\nhybrid 接收，同 trunk，\n发送\nvid 不在允许列表中，直接丢弃\nvid 在运行列表中，不管 vid 是否等于 pvid，都需要通过命令决定是否保留这个 vid （tagged 和 untagged）\n启用 gvrp 必须是 trunk","title":"eNSP 交换机端口模式"},{"content":"路由命令 system-view 系统界面\ncurrent- 当前配置\nundo info-center enable（删除或禁用 xx）\nsysname Namr 重命名设备\ndisplay vlan 查看 vlan\ndisplay interface 显示交换机的所有接口信息\ndisplay interface 接口名\ndisplay this 显示当前端口信息\ndisplay vlan 显示 vlan\nvlan\ndisplay port vlan 显示 vlan\nquit 退出\nsave 保存\nreboot 重启设备\nreset save-configuration 选择 y or n 重置设备配置\ndisplay mac-address 显示 mac 地址\ndisplay interface Ethernet brief 以太网摘要情况\nundo negotiation auto 开启接口自动协商功能\nduplex full 设置双工模式\nspeeed 100 修改接口速率\nmac-address static 0099-cd11-1111 Eth 接口 vlan 1\nport link-type access/trunk\nport trunk allow\u0026ndash;pass vlan vlan 名\nport link-type hybrid\nport hybrid tagged vlan 名/vlan 名 to vlan 名\nport hybrid untagged（剥离 vid） vlan 名\nport hybrid pvid vlan 10（送到一个没有 tag 的标签，打上 vlan 10 标签）\nvid 是 vlan id\npvid 是 port default vlan 10\n","permalink":"https://note.yxzi.xyz/note/technology/internet/ensp/%E8%B7%AF%E7%94%B1%E5%91%BD%E4%BB%A4/","summary":"路由命令 system-view 系统界面\ncurrent- 当前配置\nundo info-center enable（删除或禁用 xx）\nsysname Namr 重命名设备\ndisplay vlan 查看 vlan\ndisplay interface 显示交换机的所有接口信息\ndisplay interface 接口名\ndisplay this 显示当前端口信息\ndisplay vlan 显示 vlan\nvlan\ndisplay port vlan 显示 vlan\nquit 退出\nsave 保存\nreboot 重启设备\nreset save-configuration 选择 y or n 重置设备配置\ndisplay mac-address 显示 mac 地址\ndisplay interface Ethernet brief 以太网摘要情况\nundo negotiation auto 开启接口自动协商功能\nduplex full 设置双工模式\nspeeed 100 修改接口速率\nmac-address static 0099-cd11-1111 Eth 接口 vlan 1","title":"eNSP 路由命令"},{"content":"配置 Web 服务器 第一台客户机 10.0.1.10\n10.0.1.1\n域名服务器\n10.0.2.10\nServer\n10.0.2.10\n10.0.2.1\n域名服务器\n10.0.2.10\n配置 router\nsys\nint e 0/0/0\nip add 10.0.2.1 255.255.255.0\nquit\nint g0/0/0\nip add 10.0.1.1 255.255.255.0\nquit\nsave\n配置 lsw\nsys\nint g0/0/1\nport link type access\nquit\nint g0/0/2\nport link type trunk\n打开 client\n目的 10.0.2.10\n打开 Server\n目的 10.0.1.10\n新建本地\n创建文件夹 ftp 和 http\n新建 flag.txt\n新建 index.html\n分别启动\n打开 Server\n服务器信息\nftp 选择文件根目录\nhttp 选择文件目录\ndns\nyxz.com\n10.0.2.10\n启动\n打开路由器 开始抓包\n打开 client\n服务器地址 10.0.2.10\nftp client\nhttp yxz.com\n","permalink":"https://note.yxzi.xyz/note/technology/internet/ensp/%E9%85%8D%E7%BD%AE-web-%E6%9C%8D%E5%8A%A1%E5%99%A8/","summary":"配置 Web 服务器 第一台客户机 10.0.1.10\n10.0.1.1\n域名服务器\n10.0.2.10\nServer\n10.0.2.10\n10.0.2.1\n域名服务器\n10.0.2.10\n配置 router\nsys\nint e 0/0/0\nip add 10.0.2.1 255.255.255.0\nquit\nint g0/0/0\nip add 10.0.1.1 255.255.255.0\nquit\nsave\n配置 lsw\nsys\nint g0/0/1\nport link type access\nquit\nint g0/0/2\nport link type trunk\n打开 client\n目的 10.0.2.10\n打开 Server\n目的 10.0.1.10\n新建本地\n创建文件夹 ftp 和 http\n新建 flag.txt\n新建 index.html\n分别启动\n打开 Server\n服务器信息\nftp 选择文件根目录","title":"eNSP 配置 Web 服务器"},{"content":"私有地址 私有 IP 地址是一段保留的 IP 地址。只使用在局域网中，无法在 Internet 上使用。\nNAT－Network Address Translation 网络地址转换\n私有地址范围： A 类 10.0.0.0/8， 即 10.0.0.0\u0026ndash;10.255.255.255\nB 类 172.16.0.0/12， 即 172.16.0.0\u0026ndash;172.31.255.255\nC 类 192.168.0.0/ 16， 即 192.168.0.0\u0026ndash;192.168.255.255\n","permalink":"https://note.yxzi.xyz/note/technology/internet/%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80/","summary":"私有地址 私有 IP 地址是一段保留的 IP 地址。只使用在局域网中，无法在 Internet 上使用。\nNAT－Network Address Translation 网络地址转换\n私有地址范围： A 类 10.0.0.0/8， 即 10.0.0.0\u0026ndash;10.255.255.255\nB 类 172.16.0.0/12， 即 172.16.0.0\u0026ndash;172.31.255.255\nC 类 192.168.0.0/ 16， 即 192.168.0.0\u0026ndash;192.168.255.255","title":"私有地址"},{"content":"英语中的很多单词都有格式变化，喜欢用变化来表达一个词语的不同意义，这是英语的一大特点。\n时态是英语语法的一大特色，也是和中文语法最大的区别之一\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%8B%B1%E8%AF%AD/","summary":"英语中的很多单词都有格式变化，喜欢用变化来表达一个词语的不同意义，这是英语的一大特点。\n时态是英语语法的一大特色，也是和中文语法最大的区别之一","title":"English 英语"},{"content":"数据类型 在 PHP 中，指的是一个变量所存储的数据本身的类型，而不是变量的类型，即变量本身是没有数据类型的。\n基本数据类型 int/integer 占 4 个字节，表示整数类型，前提是存的下，当整型存不下的时候，将会变为 double 类型。\nPHP 中提供了四种整型的定义方式：十进制定义、二进制定义、八进制定义和十六进制定义。\n// 十进制 $decimal = 20;  // 二进制 $Binary = 10100;  // 八进制 $Octal = 1747;  // 十六进制 $HexaDecimal = 0x3E7;  echo $decimal . \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; echo $Binary . \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; echo $Octal . \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; echo $HexaDecimal . \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; float/double 占 8 个字节，表示小数或者是整型所存不下的整数。\nstring 所占字节根据长度分配，表示字符串。\nbool/boolean 表示 true 或 false.\n复合数据类型 object 存放对象。\narray 次性存放多个数据。\n特殊数据类型 resource 存放资源数据，比如 PHP 外部数据（数据库、文件等）\nNULL 只有一个值 Null，不能运算\n","permalink":"https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","summary":"数据类型 在 PHP 中，指的是一个变量所存储的数据本身的类型，而不是变量的类型，即变量本身是没有数据类型的。\n基本数据类型 int/integer 占 4 个字节，表示整数类型，前提是存的下，当整型存不下的时候，将会变为 double 类型。\nPHP 中提供了四种整型的定义方式：十进制定义、二进制定义、八进制定义和十六进制定义。\n// 十进制 $decimal = 20;  // 二进制 $Binary = 10100;  // 八进制 $Octal = 1747;  // 十六进制 $HexaDecimal = 0x3E7;  echo $decimal . \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; echo $Binary . \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; echo $Octal . \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; echo $HexaDecimal . \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; float/double 占 8 个字节，表示小数或者是整型所存不下的整数。\nstring 所占字节根据长度分配，表示字符串。\nbool/boolean 表示 true 或 false.\n复合数据类型 object 存放对象。\narray 次性存放多个数据。\n特殊数据类型 resource 存放资源数据，比如 PHP 外部数据（数据库、文件等）","title":"PHP 数据类型"},{"content":"常量 顾名思义，指的是不能被改变的变量。\n在 PHP 中，常量有两种定义方式（5.3 之后才有两种）\n定义 define() define(\u0026#39;PI\u0026#39;, 3.14); echo PI, \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; const() const PII = 18; echo PII; 定义特殊常量\ndefine(\u0026#39;-_-\u0026#39;, \u0026#39;smile\u0026#39;); // 输出失败 // echo -_-; // 输出成功 echo constant(\u0026#39;-_-\u0026#39;); 这种特殊符号的常量无法用 一般的方式来输出，必须使用 constant() 来输出。\n命名规则  常量不需要使用 $ 符号，因为一旦使用 $，系统就会认为这是变量。 常量的名字组成由字母、 数字和下划线组成，不能以数字开头。 常量的名字通常是以大写字母为主（主要是与变量以示区别）。 常量命名的规则比变量要松散， 可以使用一些特殊字符，但该方式只能使用 define 定义。  常量和变量的使用  数据可能变化的， 那么肯定是用变量。 数据不一定会变的，可以使用常量或者变量（变量居多） 数据不允许被修改的， 务必用常量。  系统常量 PHP_ VERSION：PHP 版本号。 PHP INT SIZE**：整型数据所占的字节数。 PHP_ INT_MAX：整型能表示的最大值（PHP 中整型是允许出现负数的）\n系统魔术常量 在 PHP 中，还有一些特殊的系统常量，他们由 __ 开始 + 常量名 + __，这种常量称之为系统魔术常量。\n魔术常量的值通常会跟着环境变化，但是用户改变不了。\n__DIR__：当前被执行的脚本所在电脑的绝对路径+ __FILE__：当前被执行的脚本所在的电脑的绝对路径(带自己文件的名字)。 __LINE__：当前所属的行数. __NAMESPACE__：当前所属的命名空间。 __CLASS__： 当前所属的类, __METHOD__：当前所属的方法。\necho __DIR__, \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;, __FILE__, \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;, __LINE__, \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; ","permalink":"https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/%E5%B8%B8%E9%87%8F/","summary":"常量 顾名思义，指的是不能被改变的变量。\n在 PHP 中，常量有两种定义方式（5.3 之后才有两种）\n定义 define() define(\u0026#39;PI\u0026#39;, 3.14); echo PI, \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; const() const PII = 18; echo PII; 定义特殊常量\ndefine(\u0026#39;-_-\u0026#39;, \u0026#39;smile\u0026#39;); // 输出失败 // echo -_-; // 输出成功 echo constant(\u0026#39;-_-\u0026#39;); 这种特殊符号的常量无法用 一般的方式来输出，必须使用 constant() 来输出。\n命名规则  常量不需要使用 $ 符号，因为一旦使用 $，系统就会认为这是变量。 常量的名字组成由字母、 数字和下划线组成，不能以数字开头。 常量的名字通常是以大写字母为主（主要是与变量以示区别）。 常量命名的规则比变量要松散， 可以使用一些特殊字符，但该方式只能使用 define 定义。  常量和变量的使用  数据可能变化的， 那么肯定是用变量。 数据不一定会变的，可以使用常量或者变量（变量居多） 数据不允许被修改的， 务必用常量。  系统常量 PHP_ VERSION：PHP 版本号。 PHP INT SIZE**：整型数据所占的字节数。 PHP_ INT_MAX：整型能表示的最大值（PHP 中整型是允许出现负数的）\n系统魔术常量 在 PHP 中，还有一些特殊的系统常量，他们由 __ 开始 + 常量名 + __，这种常量称之为系统魔术常量。","title":"PHP 常量"},{"content":"环境配置 下载 PHPStudy PHPStudy 是一个 windows 下的 Apache/Ngnix+PHP+MySQL 的集成开发环境\n 解压运行 选择安装目录，通常时 D 盘，我这里是D:\\AppInstallPath\\PhpStudy  安装完成后，打开 PHPStudy，会出现以下界面：\n![下载 PHPStudy](.assets/下载 PHPStudy.png)\n另外，PHPStudy 会在安装目录下的 phpstudy_pro\\Extensions 路径形成目录结构：\n![image-20220303002959290](E:\\Github\\MyBlog\\content\\mynote\\4 Specialty\\Language\\PHP\\PHP 环境配置.assets\\image-20220303002959290.png)\n在这里我们只需要注意 MySql 和 php 的路径，因为之后我们会用到这两个路径来配置环境变量。\n配置 MySQL 环境变量  此电脑 — 系统属性 — 高级系统设置 — 高级 — 环境变量 。 找到系统变量中名为 Path 的变量， 新建，将 MySql 目录下的 bin 文件的路径粘贴到这里，确定。 win + R 打开 cmd，输入 mysql，如果提示ERROR 2003 (HY000): Can't connect to MySQL server on 'localhost' (10061)就说明 MySQL 的环境变量配置完成。  ![image-20220303003228646](E:\\Github\\MyBlog\\content\\mynote\\4 Specialty\\Language\\PHP\\PHP 环境配置.assets\\image-20220303003228646.png)\n创建站点 回到 PHPStudy，启动 MySQL 和 Apache（或者是 Nginx），配置网站的域名和端口，以及根目录。通常默认就 OK。\n打开浏览器，在地址栏输入localhost:80，出现以下内容即为配置成功。\n![image-20220303002637668](E:\\Github\\MyBlog\\content\\mynote\\4 Specialty\\Language\\PHP\\PHP 环境配置.assets\\image-20220303002637668.png)\n我的第一个 PHP 程序 接下来，我就可以开始编写 PHP 代码了，注意，我这里用的是宇宙第一编辑器 VS Code。\n配置 PHP 环境变量 依旧是向之前那样找到名为 Path 的变量，然后添加 php 的安装路径，我这里的路径为D:\\AppInstallPath\\PhpStudy\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\n依旧打开我们的 cmd，输入php -v，出现以下内容即为配置成功：\n![image-20220303005755212](E:\\Github\\MyBlog\\content\\mynote\\4 Specialty\\Language\\PHP\\PHP 环境配置.assets\\image-20220303005755212.png)\n安装 VS Code 扩展 打开我们的 VsCode，安装名为 PHP Sever 的扩展：\n![image-20220303010013869](E:\\Github\\MyBlog\\content\\mynote\\4 Specialty\\Language\\PHP\\PHP 环境配置.assets\\image-20220303010013869.png)\n安装完插件后，我们新建一个后缀为 php 的文档，输入以下内容（内容随便）：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt;  \u0026lt;body\u0026gt;   \u0026lt;?php  echo \u0026#34;又是熬夜赶作业的一天！shit！\u0026#34;;  ?\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html 鼠标右击PHP Server: Serve project\n![image-20220303010824031](E:\\Github\\MyBlog\\content\\mynote\\4 Specialty\\Language\\PHP\\PHP 环境配置.assets\\image-20220303010824031.png)\n之后会跳转到电脑的默认浏览器，并打开一个页面，出现以下内容：\n![image-20220303010918612](E:\\Github\\MyBlog\\content\\mynote\\4 Specialty\\Language\\PHP\\PHP 环境配置.assets\\image-20220303010918612.png)\nOK，我们的第一个 PHP 程序就成功拿捏了！\n","permalink":"https://note.yxzi.xyz/note/technology/language/php/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","summary":"环境配置 下载 PHPStudy PHPStudy 是一个 windows 下的 Apache/Ngnix+PHP+MySQL 的集成开发环境\n 解压运行 选择安装目录，通常时 D 盘，我这里是D:\\AppInstallPath\\PhpStudy  安装完成后，打开 PHPStudy，会出现以下界面：\n![下载 PHPStudy](.assets/下载 PHPStudy.png)\n另外，PHPStudy 会在安装目录下的 phpstudy_pro\\Extensions 路径形成目录结构：\n![image-20220303002959290](E:\\Github\\MyBlog\\content\\mynote\\4 Specialty\\Language\\PHP\\PHP 环境配置.assets\\image-20220303002959290.png)\n在这里我们只需要注意 MySql 和 php 的路径，因为之后我们会用到这两个路径来配置环境变量。\n配置 MySQL 环境变量  此电脑 — 系统属性 — 高级系统设置 — 高级 — 环境变量 。 找到系统变量中名为 Path 的变量， 新建，将 MySql 目录下的 bin 文件的路径粘贴到这里，确定。 win + R 打开 cmd，输入 mysql，如果提示ERROR 2003 (HY000): Can't connect to MySQL server on 'localhost' (10061)就说明 MySQL 的环境变量配置完成。  !","title":"PHP 环境配置"},{"content":"《亿万富翁们的饕餮盛宴》 这天晚上，我看了两部纪录片，其中一部是《骄奢父母》，另一部就是现在这部《亿万富豪们的饕餮盛宴》了。\n看了这部纪录片后，其实也没啥好写的，影片中大多都是介绍一些富人们所吃过的一些食物，\n比如 5000 英镑一小口的古董酒、24000 英镑的鱼子酱等等等，虽然但是，\n影片中还是有一些有意思的观点的，其中让我印象深刻的观点就是：\n 这些人并不在意这些食物本身的价值，而在意的是这些食物背后的故事。\n亿万富翁们想享有独一无二的东西。\n重要的不是价格，而是你花钱买一些东西的感受。\n 说两个印象比较深的两样东西吧，\n第一种是一种长在海崖附近的什么狗爪螺来着，这玩意可能本事不是特别好吃，营养价值也一般，但为什么可以卖的这么贵？\n因为这玩意是很多人冒着生命危险才能弄到的食物，这就是它的价值，单论它背后的故事，就很让人热血澎湃了。\n另外一样就是一杯昂贵的古董酒，一杯 5000 英镑。酒瓶里，仅仅只剩下近乎是只有一下口的量，然而就是这一小口，值 5000 英镑，\n卖家是这样说的，能喝这杯酒的人，不仅要有钱，还要有不凡的身份地位，最后这一小口酒就被一个有钱有权的中年男子喝掉了。\n我这样的穷逼肯定是无法理解这些富人们的操作的，毕竟这确实是只有一小口，在高脚杯里近乎可以忽略\u0026hellip;\n","permalink":"https://note.yxzi.xyz/note/afterthought/movie/documentary/%E4%BA%BF%E4%B8%87%E5%AF%8C%E7%BF%81%E4%BB%AC%E7%9A%84%E9%A5%95%E9%A4%AE%E7%9B%9B%E5%AE%B4/","summary":"《亿万富翁们的饕餮盛宴》 这天晚上，我看了两部纪录片，其中一部是《骄奢父母》，另一部就是现在这部《亿万富豪们的饕餮盛宴》了。\n看了这部纪录片后，其实也没啥好写的，影片中大多都是介绍一些富人们所吃过的一些食物，\n比如 5000 英镑一小口的古董酒、24000 英镑的鱼子酱等等等，虽然但是，\n影片中还是有一些有意思的观点的，其中让我印象深刻的观点就是：\n 这些人并不在意这些食物本身的价值，而在意的是这些食物背后的故事。\n亿万富翁们想享有独一无二的东西。\n重要的不是价格，而是你花钱买一些东西的感受。\n 说两个印象比较深的两样东西吧，\n第一种是一种长在海崖附近的什么狗爪螺来着，这玩意可能本事不是特别好吃，营养价值也一般，但为什么可以卖的这么贵？\n因为这玩意是很多人冒着生命危险才能弄到的食物，这就是它的价值，单论它背后的故事，就很让人热血澎湃了。\n另外一样就是一杯昂贵的古董酒，一杯 5000 英镑。酒瓶里，仅仅只剩下近乎是只有一下口的量，然而就是这一小口，值 5000 英镑，\n卖家是这样说的，能喝这杯酒的人，不仅要有钱，还要有不凡的身份地位，最后这一小口酒就被一个有钱有权的中年男子喝掉了。\n我这样的穷逼肯定是无法理解这些富人们的操作的，毕竟这确实是只有一小口，在高脚杯里近乎可以忽略\u0026hellip;","title":"《亿万富翁们的饕餮盛宴》"},{"content":"递归 函数自身调用自身。\n","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E5%87%BD%E6%95%B0/%E9%80%92%E5%BD%92/","summary":"递归 函数自身调用自身。","title":"C 递归"},{"content":"钱，是体验这世界美好事物的必需品。\n这天晚上，因为四天没洗澡的原因，晚上就去洗了个澡，因此我就没锻炼和跑步，虽然已经快五天没跑步了，但确实是因为前几天的天气不太给力的原因——下雪\u0026hellip;\n洗完澡，我就打开电脑，心血来潮的点开之前知乎收藏的三个纪录片，这天晚上我只看了两个，\n因为剩下的那个没看的，需要开大会员我靠\u0026hellip;这玩意也是需要 15 块大洋的\u0026hellip;我又因为经济的原因止步于此了。\n现在我所写的是名为《骄奢父母》的这个纪录片，我觉得这个纪录片很适合穷人或者一些有经济水平的人观看，\n为什么这么说，因为我觉得这可以帮助我们了解上流社会，这里用上流社会可以还是有些不恰当，应该用顶流一词比较好。\n这个记录片让我有幸看到了那些亿万富翁是如何培养自己的小孩的。\n负责接送孩子上下学的司机、保镖，\n家庭保姆、厨师、、营养师，甚至还有专门教小孩使用坐便器的老师，\n世界顶尖的教授一对一教学，\n私人订制的鞋，\n职业的肖像画师，\n他们住的地方不是小区、公寓、高楼大厦。\n而是城堡或私人别墅，一个拥有几十个房间的城堡，而城堡之外、是广阔的草坪。\n这些富豪们的孩子，大部分都很有教养，长得很好看，兴趣很广，当然，也有调皮捣蛋的。\n孩子们穿的也都是我们尔等凡人能想象到的，一件貂皮大衣 5000 英镑，换算人民币就是四万两千多，高定的鞋子···\n","permalink":"https://note.yxzi.xyz/note/afterthought/movie/documentary/%E5%A8%87%E5%A5%A2%E7%88%B6%E6%AF%8D/","summary":"钱，是体验这世界美好事物的必需品。\n这天晚上，因为四天没洗澡的原因，晚上就去洗了个澡，因此我就没锻炼和跑步，虽然已经快五天没跑步了，但确实是因为前几天的天气不太给力的原因——下雪\u0026hellip;\n洗完澡，我就打开电脑，心血来潮的点开之前知乎收藏的三个纪录片，这天晚上我只看了两个，\n因为剩下的那个没看的，需要开大会员我靠\u0026hellip;这玩意也是需要 15 块大洋的\u0026hellip;我又因为经济的原因止步于此了。\n现在我所写的是名为《骄奢父母》的这个纪录片，我觉得这个纪录片很适合穷人或者一些有经济水平的人观看，\n为什么这么说，因为我觉得这可以帮助我们了解上流社会，这里用上流社会可以还是有些不恰当，应该用顶流一词比较好。\n这个记录片让我有幸看到了那些亿万富翁是如何培养自己的小孩的。\n负责接送孩子上下学的司机、保镖，\n家庭保姆、厨师、、营养师，甚至还有专门教小孩使用坐便器的老师，\n世界顶尖的教授一对一教学，\n私人订制的鞋，\n职业的肖像画师，\n他们住的地方不是小区、公寓、高楼大厦。\n而是城堡或私人别墅，一个拥有几十个房间的城堡，而城堡之外、是广阔的草坪。\n这些富豪们的孩子，大部分都很有教养，长得很好看，兴趣很广，当然，也有调皮捣蛋的。\n孩子们穿的也都是我们尔等凡人能想象到的，一件貂皮大衣 5000 英镑，换算人民币就是四万两千多，高定的鞋子···","title":"《娇奢父母》"},{"content":"函数 每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。\n函数还有很多叫法，比如方法、子例程或程序，等等。\n#include \u0026lt;iostream\u0026gt; // void 表示这个 max 函数没有返回值（但可以有 reture，但不能 reture 表达式） void max(int i,int j) {  if(i \u0026gt; j)  {  printf(\u0026#34;%d\\n\u0026#34;,i);  }  else  {  printf(\u0026#34;%d\\n\u0026#34;,j);  } }  // int 表示 main 函数返回一个整型的值 // 程序从 main 函数进入 void 表示该函数不能接收参数。 int main(void) {  int a = 1;  int b = 5;  max(a,b); } 优点  避免了重复性的操作。 有利于程序的模块化。  特点 能够接受参数，（但也可以不接收）\n能够对接收的参数进行处理\n有返回值（但也可以没有返回值）\n函数的返回值以函数名前面的关键字为准 // 函数名 fun 前面的 int 是该函数的类型，也是该函数返回值的类型 // 就算该函数 return 其他类型的值（比如 char 类型的 A），、 // 但最终这个 char A 也会以 int 类型返回（int 类型的 65，因为 A 的 ASCII 码是65）。 int fun(void) {  // 该函数最终的返回值不是 char A ，而是一个整形的 65  return \u0026#39;A\u0026#39;; } int main(void) {  int c;  c = fun();  printf(\u0026#34;%d\\n\u0026#34;,c); } return 的作用 reture 是用来终止函数的，如果有 reture 表达式，还会返回这个表达式的值；如果 return 空，则不会返回某个值，只终止被调函数。\n函数的分类  有参函数和无参函数 有返回值和无返回值 库函数和用户自定义函数 值传递函数和地址传递函数 普通函数和主函数（main）  一个程序必须且只能有一个主函数 主函数可以调用普通函数，但普通函数不能调用主函数，普通函数可以相互调用 主函数是程序的入口，也是程序的出口\n函数的调用和定义 如果先调用函数，后定义函数，则必须在调用该函数之前，加一个该函数的前置声明。\n函数的前置声明 告诉编译器即将出现一个这样的函数，以及这个函数是否有形参和返回值。\n对库函数的声明是通过**# include \u0026lt;库 函数所在的文件的名字. h\u0026gt;**来实现的\n#include \u0026lt;iostream\u0026gt;void fun(void);// 如果不在main 函数之前声明函数 fun，那么当在main 中调用 fun 时，会 error  int main(void){  fun();  return 0; }  void fun(void){  printf(\u0026#34;哈哈哈哈\\n\u0026#34;); } ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/","summary":"函数 每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。\n函数还有很多叫法，比如方法、子例程或程序，等等。\n#include \u0026lt;iostream\u0026gt; // void 表示这个 max 函数没有返回值（但可以有 reture，但不能 reture 表达式） void max(int i,int j) {  if(i \u0026gt; j)  {  printf(\u0026#34;%d\\n\u0026#34;,i);  }  else  {  printf(\u0026#34;%d\\n\u0026#34;,j);  } }  // int 表示 main 函数返回一个整型的值 // 程序从 main 函数进入 void 表示该函数不能接收参数。 int main(void) {  int a = 1;  int b = 5;  max(a,b); } 优点  避免了重复性的操作。 有利于程序的模块化。  特点 能够接受参数，（但也可以不接收）","title":"C 函数"},{"content":"数组 数组是用于储存多个相同类型数据的集合。\n在 C 语言中，与数组相关的方法很少，大部分操作，都只能自己去实现，比如排序，查找等等。\n#include \u0026lt;iostream\u0026gt; int main(void){ // arr 是数组的名字，5 表示数组中，元素的个数，  int arr[5] = {1,2,3,4,5};  printf(\u0026#34;%d\\n\u0026#34;,arr[4]); } 在 C 语言中，一个数组的名字是这个数组第一个元素的指针地址。\n特点 数组是连续的、线性的，在内存中亦是如此。\n数组的数量，一旦定义，无法修改。\n数组的类型取决于该数组存储的元素的类型。\n优点 存取速度快。\n缺点 需要一个连续的、很大的内存。\n插入和删除元素的效率很低。\n","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/","summary":"数组 数组是用于储存多个相同类型数据的集合。\n在 C 语言中，与数组相关的方法很少，大部分操作，都只能自己去实现，比如排序，查找等等。\n#include \u0026lt;iostream\u0026gt; int main(void){ // arr 是数组的名字，5 表示数组中，元素的个数，  int arr[5] = {1,2,3,4,5};  printf(\u0026#34;%d\\n\u0026#34;,arr[4]); } 在 C 语言中，一个数组的名字是这个数组第一个元素的指针地址。\n特点 数组是连续的、线性的，在内存中亦是如此。\n数组的数量，一旦定义，无法修改。\n数组的类型取决于该数组存储的元素的类型。\n优点 存取速度快。\n缺点 需要一个连续的、很大的内存。\n插入和删除元素的效率很低。","title":"C 数组"},{"content":"指针的使用 互换两个数字 #include \u0026lt;stdio.h\u0026gt;//*p = 1 *q = 5 void interchange(int * p,int * q) { // 将 t 作为两个值的互换媒介。  int t; // t = 1  t = *p; // *p = 5  *p = *q; // *q = 1  *q = t; } // 因为 *p 和 *q 分别指向于 a 和 b，所以，修改 *p 和 *q，就相当于修改 a 和 b， // 尽管 *p 和 *q 在函数指向完毕后已经被释放，但程序依旧通过 *p 和 *q，分别修改了 a 和b。 // 而 p 和 q，两者和 a 、b，并不一样，因为 p、q 中，存放的是指向 a、b 的地址。 // 由此可得出一个结论，函数的形参和实参， 永远不是一个 int main () {  int a = 1;  int b = 5; // 取 a、b 的地址  interchange(\u0026amp;a,\u0026amp;b);  printf(\u0026#34;a = %d,b = %d\u0026#34;,a,b); } 通过被调函数修改主调函数普通变量的值 函数的实参必须为该普通变量的地址。\n形参必须是指针变量。\n在被调函数中，通过***形参名 = n**的方式，就可以修改主调函数中，对应变量的值。因为此时的***形参名**的等同于主调函数中的普通变量\n","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"指针的使用 互换两个数字 #include \u0026lt;stdio.h\u0026gt;//*p = 1 *q = 5 void interchange(int * p,int * q) { // 将 t 作为两个值的互换媒介。  int t; // t = 1  t = *p; // *p = 5  *p = *q; // *q = 1  *q = t; } // 因为 *p 和 *q 分别指向于 a 和 b，所以，修改 *p 和 *q，就相当于修改 a 和 b， // 尽管 *p 和 *q 在函数指向完毕后已经被释放，但程序依旧通过 *p 和 *q，分别修改了 a 和b。 // 而 p 和 q，两者和 a 、b，并不一样，因为 p、q 中，存放的是指向 a、b 的地址。 // 由此可得出一个结论，函数的形参和实参， 永远不是一个 int main () {  int a = 1;  int b = 5; // 取 a、b 的地址  interchange(\u0026amp;a,\u0026amp;b);  printf(\u0026#34;a = %d,b = %d\u0026#34;,a,b); } 通过被调函数修改主调函数普通变量的值 函数的实参必须为该普通变量的地址。","title":"C 指针的使用"},{"content":"CodeBlocks 的使用 codebooks 快捷键 注释 使用Ctrl + Shift + C快速注释。\n使用Ctrl + Shift + X取消注释。\n汉化 CodeBlocks 将汉化文件zh_CN.mo放置到路径D:\\AppInstallPath\\CodeBlocks\\share\\CodeBlocks\\locale\\zh_CN（没有文件夹就自行创建）\n打开 CodeBlocks，Settings — Environment — View — Internationalization(勾选)，选择Chinese(Simplified)\n","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%B1%89%E5%8C%96-codeblocks/","summary":"CodeBlocks 的使用 codebooks 快捷键 注释 使用Ctrl + Shift + C快速注释。\n使用Ctrl + Shift + X取消注释。\n汉化 CodeBlocks 将汉化文件zh_CN.mo放置到路径D:\\AppInstallPath\\CodeBlocks\\share\\CodeBlocks\\locale\\zh_CN（没有文件夹就自行创建）\n打开 CodeBlocks，Settings — Environment — View — Internationalization(勾选)，选择Chinese(Simplified)","title":"CodeBlocks 的使用"},{"content":"CPU 如何对内存条进行处理 CUP 处理内存条中的数据时，需要通过控制线（只读或只写）、数据线（数据传输）和地址线（确定将要处理的是哪一个内存单元）处理内存条中的数据。\n32 位系统最大支持 4G 内存。\n64 位 系统最大支持 192G 内存。\n","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/cpu-%E5%A6%82%E4%BD%95%E5%AF%B9%E5%86%85%E5%AD%98%E6%9D%A1%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86/","summary":"CPU 如何对内存条进行处理 CUP 处理内存条中的数据时，需要通过控制线（只读或只写）、数据线（数据传输）和地址线（确定将要处理的是哪一个内存单元）处理内存条中的数据。\n32 位系统最大支持 4G 内存。\n64 位 系统最大支持 192G 内存。","title":"C CPU 如何对内存条进行处理"},{"content":"基本类型指针 #include \u0026lt;stdio.h\u0026gt; int main () { \tint * p; // 定义一个指针变量 p，且这个 p 只能存放 int 类型的地址， \tint i = 20; \tp = \u0026amp;i; // \u0026amp;i 表示获取变量 i 的内存地址 //这时候 p 中，存放的就是指向变量 i 的内存地址，则 p 完全等同于 i.  \tint j = * p; \tprintf(\u0026#34;i = %d ,j = %d \\n\u0026#34;,i,j);  \treturn 0; } 详解 *p #include \u0026lt;iostream\u0026gt;int main() {  int * p;  int i = 5;  p = \u0026amp;i; // p 保存了 i 的地址 // 修改 p 不会影响 i；修改 i 也不会影响 p，因为他们是不同的变量。 // *p = i，此时，修改 *p 就是修改 i，修改 i 就是修改 *p // 更准确的说，*p 是以 p 的内容为地址的变量。  *p = 99;  printf(\u0026#34;i = %d,p = %d \\n\u0026#34;,i,*p);  i = 88;  printf(\u0026#34;i = %d,p = %d \\n\u0026#34;,i,*p); } ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88/","summary":"基本类型指针 #include \u0026lt;stdio.h\u0026gt; int main () { \tint * p; // 定义一个指针变量 p，且这个 p 只能存放 int 类型的地址， \tint i = 20; \tp = \u0026amp;i; // \u0026amp;i 表示获取变量 i 的内存地址 //这时候 p 中，存放的就是指向变量 i 的内存地址，则 p 完全等同于 i.  \tint j = * p; \tprintf(\u0026#34;i = %d ,j = %d \\n\u0026#34;,i,j);  \treturn 0; } 详解 *p #include \u0026lt;iostream\u0026gt;int main() {  int * p;  int i = 5;  p = \u0026amp;i; // p 保存了 i 的地址 // 修改 p 不会影响 i；修改 i 也不会影响 p，因为他们是不同的变量。 // *p = i，此时，修改 *p 就是修改 i，修改 i 就是修改 *p // 更准确的说，*p 是以 p 的内容为地址的变量。  *p = 99;  printf(\u0026#34;i = %d,p = %d \\n\u0026#34;,i,*p);  i = 88;  printf(\u0026#34;i = %d,p = %d \\n\u0026#34;,i,*p); } ","title":"C 基本类型指针"},{"content":"指针 指针是 C 语言的灵魂。\n指针是一个地址，地址是内存单元的编号，它是一个从零开始的非负整数；比如在 32 位系统中，地址的取值范围是 0 — 4 G（4095）。\n指针本质就是一个操作受限的非负整数。\n指针只能进行减法运算，不能进行加乘除等运算。\n指针变量是存放编号的变量。\n八位（Bit）是一个字节，一个字节就是一个内存单元。\nint* 是 指向整型变量的指针，\n作用   表示一些复杂的数据结构（树、图）。\n  快速的传递数据，并且减少了内存的耗费。\n  使函数返回一个以上的值。\n  可以直接访问硬件。\n  更方便的处理字符串（\u0026rsquo;\\0\u0026rsquo;）。\n  ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88/","summary":"指针 指针是 C 语言的灵魂。\n指针是一个地址，地址是内存单元的编号，它是一个从零开始的非负整数；比如在 32 位系统中，地址的取值范围是 0 — 4 G（4095）。\n指针本质就是一个操作受限的非负整数。\n指针只能进行减法运算，不能进行加乘除等运算。\n指针变量是存放编号的变量。\n八位（Bit）是一个字节，一个字节就是一个内存单元。\nint* 是 指向整型变量的指针，\n作用   表示一些复杂的数据结构（树、图）。\n  快速的传递数据，并且减少了内存的耗费。\n  使函数返回一个以上的值。\n  可以直接访问硬件。\n  更方便的处理字符串（\u0026rsquo;\\0\u0026rsquo;）。\n  ","title":"C 指针"},{"content":"星号的含义 ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%98%9F%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/","summary":"星号的含义 ","title":"C 星号的含义"},{"content":"《永恒》 ","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E6%B0%B8%E6%81%92/","summary":"《永恒》 ","title":"《永恒》"},{"content":"程序员的酒后真言 美国最大的论坛 Reddit，曾经有一个热帖。\n一个程序员说自己喝醉了，软件工程师已经当了 10 年，心里有好多话想说：我可能会后悔今天说了这些话。\n他洋洋洒洒写了一大堆，获得 9700 多个赞。内容很有意思，值得一读。\n  职业发展的最好方法是换公司。\n  技术栈不重要。技术领域有大约 10-20 条核心原则，重要的是这些原则，技术栈只是落实它们的方法。你如果不熟悉某个技术栈，不需要过度担心。\n  工作和人际关系是两回事。有一些公司，我交到了好朋友，但是工作得并不开心；另一些公司，我没有与任何同事建立友谊，但是工作得很开心。\n  我总是对经理实话实说。怕什么？他开除我？我会在两周内找到一份新工作。\n  如果一家公司的工程师超过 100 人，它的期权可能在未来十年内变得很有价值。对于工程师人数很少的公司，期权一般都是毫无价值。\n  好的代码是初级工程师可以理解的代码。伟大的代码可以被第一年的 CS 专业的新生理解。\n  作为一名工程师，最被低估的技能是记录。说真的，如果有人可以教我怎么写文档，我会付钱，也许是 1000 美元。\n  网上的口水战，几乎都无关紧要，别去参与。\n  如果我发现自己是公司里面最厉害的工程师，那就该离开了。\n  我们应该雇佣更多的实习生，他们很棒。那些精力充沛的小家伙用他们的想法乱搞。如果他们公开质疑或批评某事，那就更好了。我喜欢实习生。\n  技术栈很重要。如果你使用 Python 或 C++ 语言，就会忍不住想做一些非常不同的事情。因为某些工具确实擅长某些工作。\n  如果你不确定自己想做什么东西，请使用 Java。这是一种糟糕的编程语言，但几乎无所不能。\n  对于初学者来说，最赚钱的编程语言是 SQL，干翻所有其他语言。你只了解 SQL 而不会做其他事情，照样赚钱。人力资源专家的年薪？也许 5 万美元。懂 SQL 的人力资源专家？9 万美元。\n  测试很重要，但 TDD （测试驱动的开发）几乎变成了一个邪教。\n  政府单位很轻松，但并不像人们说的那样好。对于职业生涯早期到中期的工程师，12 万美元的年薪 + 各种福利 + 养老金听起来不错，但是你将被禁锢在深奥的专用工具里面，离开政府单位以后，这些知识就没用了。我非常尊重政府工作人员，但说真的，这些地方的工程师，年龄中位数在 50 岁以上是有原因的。\n  再倒一杯酒。\n  大多数头衔都无关紧要，随便什么公司都可以有首席工程师。\n  手腕和背部的健康问题可不是开玩笑的，好的设备值得花钱。\n  当一个软件工程师，最好的事情是什么？你可以结识很多想法相同的人，大家互相交流，不一定有相同的兴趣，但是对方会用跟你相同的方式思考问题，这很酷。\n  有些技术太流行，我不得不用它。我心里就会很讨厌这种技术，但会把它推荐给客户，比如我恨 Jenkins，但把它推荐给新客户，我不觉得做错了。\n  成为一名优秀的工程师意味着了解最佳实践，成为高级工程师意味着知道何时打破最佳实践。\n  发生事故时，如果周围的人试图将责任归咎于外部错误或底层服务中断，那么是时候离开这家公司，继续前进了。\n  我遇到的最好的领导，同意我的一部分观点，同时耐心跟我解释，为什么不同意我的另一部分观点。我正在努力成为像他们一样的人。\n  算法和数据结构确实重要，但不应该无限夸大，尤其是面试的时候。我没见过药剂师面试时，还要测试有机化学的细节。这个行业的面试过程有时候很糟糕。\n  做自己喜欢的事情并不重要，不要让我做讨厌的事情更重要。\n  越接近产品，就越接近推动收入增长。无论工作的技术性如何，只要它接近产品，我都感到越有价值。\n  即使我平时用 Windows 工作，Linux 也很重要。为什么？因为服务器是 Linux 系统，你最终在 Linux 系统上工作。\n  人死了以后，你想让代码成为你的遗产吗？如果是那样，就花很多时间在代码上面吧，因为那是你的遗产。但是，如果你像我一样，更看重与家人、朋友和生活中其他人相处的时光，而不是写的代码，那就别对它太在意。\n  我挣的钱还不错，对此心存感激，但还是需要省钱。\n  糟糕，我没酒了。\n  ","permalink":"https://note.yxzi.xyz/note/view/society/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E9%85%92%E5%90%8E%E7%9C%9F%E8%A8%80/","summary":"程序员的酒后真言 美国最大的论坛 Reddit，曾经有一个热帖。\n一个程序员说自己喝醉了，软件工程师已经当了 10 年，心里有好多话想说：我可能会后悔今天说了这些话。\n他洋洋洒洒写了一大堆，获得 9700 多个赞。内容很有意思，值得一读。\n  职业发展的最好方法是换公司。\n  技术栈不重要。技术领域有大约 10-20 条核心原则，重要的是这些原则，技术栈只是落实它们的方法。你如果不熟悉某个技术栈，不需要过度担心。\n  工作和人际关系是两回事。有一些公司，我交到了好朋友，但是工作得并不开心；另一些公司，我没有与任何同事建立友谊，但是工作得很开心。\n  我总是对经理实话实说。怕什么？他开除我？我会在两周内找到一份新工作。\n  如果一家公司的工程师超过 100 人，它的期权可能在未来十年内变得很有价值。对于工程师人数很少的公司，期权一般都是毫无价值。\n  好的代码是初级工程师可以理解的代码。伟大的代码可以被第一年的 CS 专业的新生理解。\n  作为一名工程师，最被低估的技能是记录。说真的，如果有人可以教我怎么写文档，我会付钱，也许是 1000 美元。\n  网上的口水战，几乎都无关紧要，别去参与。\n  如果我发现自己是公司里面最厉害的工程师，那就该离开了。\n  我们应该雇佣更多的实习生，他们很棒。那些精力充沛的小家伙用他们的想法乱搞。如果他们公开质疑或批评某事，那就更好了。我喜欢实习生。\n  技术栈很重要。如果你使用 Python 或 C++ 语言，就会忍不住想做一些非常不同的事情。因为某些工具确实擅长某些工作。\n  如果你不确定自己想做什么东西，请使用 Java。这是一种糟糕的编程语言，但几乎无所不能。\n  对于初学者来说，最赚钱的编程语言是 SQL，干翻所有其他语言。你只了解 SQL 而不会做其他事情，照样赚钱。人力资源专家的年薪？也许 5 万美元。懂 SQL 的人力资源专家？9 万美元。\n  测试很重要，但 TDD （测试驱动的开发）几乎变成了一个邪教。","title":"程序员的酒后真言"},{"content":"printf 用于将变量的内容输出到显示器。\n直接输出 printf(\u0026#34;字符串\u0026#34;); print(\u0026ldquo;输出控制符\u0026rdquo;,参数) int i = 10;//将数值 10 的二进制代码储存到变量 i 中 。 printf(\u0026#34;%o\u0026#34;, a);//将变量 i（数值 10） 的二进制代码以八进制输出，a 为参数。 printf(\u0026ldquo;输出控制符 1 输出控制符 2\u0026rdquo;,参数 1,参数 2)  int a = 10;  int i = 15;  printf(\u0026#34;%d %d\\n\u0026#34;, a, i);//控制符和参数必须一一对应。 printf(\u0026ldquo;输出控制符 非输出控制符\u0026rdquo;,参数) int a = 10;//将数值 10 的二进制代码储存到变量 i 中 。 printf(\u0026#34;%o\\n\u0026#34;,a);//将变量 i（数值 10 的二进制代码以八进制输出；\\n 为非输出控制符。 C 语言中的所有基本类型以及对应的输出符  int，用%d输出。 long int，用%ld输出。 shot int， char，用%c输出。 float，用%f输出，另外，%.2f表示输出的数保留两位小数。 double，用%lf输出。  ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/printf/","summary":"printf 用于将变量的内容输出到显示器。\n直接输出 printf(\u0026#34;字符串\u0026#34;); print(\u0026ldquo;输出控制符\u0026rdquo;,参数) int i = 10;//将数值 10 的二进制代码储存到变量 i 中 。 printf(\u0026#34;%o\u0026#34;, a);//将变量 i（数值 10） 的二进制代码以八进制输出，a 为参数。 printf(\u0026ldquo;输出控制符 1 输出控制符 2\u0026rdquo;,参数 1,参数 2)  int a = 10;  int i = 15;  printf(\u0026#34;%d %d\\n\u0026#34;, a, i);//控制符和参数必须一一对应。 printf(\u0026ldquo;输出控制符 非输出控制符\u0026rdquo;,参数) int a = 10;//将数值 10 的二进制代码储存到变量 i 中 。 printf(\u0026#34;%o\\n\u0026#34;,a);//将变量 i（数值 10 的二进制代码以八进制输出；\\n 为非输出控制符。 C 语言中的所有基本类型以及对应的输出符  int，用%d输出。 long int，用%ld输出。 shot int， char，用%c输出。 float，用%f输出，另外，%.2f表示输出的数保留两位小数。 double，用%lf输出。  ","title":"C printf"},{"content":"scanf 通过键盘将数据输入到变量中。\n将从键盘输入的字符转化为输入控制符所规定类型的数据，然后存入以输入参数的值为地址的变量中。\n使用 scanf 之前先使用 printf 提示用户以什么样的方式输入内容。\nscanf 中使用非输入控制符时，尽量使用空格，不建议使用其他的符号。\nscanf(\u0026ldquo;输入控制符\u0026rdquo;,输入参数) int i; scanf(\u0026#34;%d\u0026#34;,\u0026amp;i);//i\u0026amp; 表示变量 i 的地址，\u0026amp; 是一个取地址符，也就是将输入的整数类型的值放入到变量 i 中。 printf(\u0026#34;%d\\n\u0026#34;,i); scanf(\u0026ldquo;非输入控制符 输入控制符\u0026rdquo;,输入参数) int i; scanf(\u0026#34;z%d\u0026#34;,\u0026amp;i);//非输入控制符 z （z 可以是任意值）必须同输入控制符一起输入 。 printf(\u0026#34;i = %d\\n\u0026#34;,i); ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/scanf/","summary":"scanf 通过键盘将数据输入到变量中。\n将从键盘输入的字符转化为输入控制符所规定类型的数据，然后存入以输入参数的值为地址的变量中。\n使用 scanf 之前先使用 printf 提示用户以什么样的方式输入内容。\nscanf 中使用非输入控制符时，尽量使用空格，不建议使用其他的符号。\nscanf(\u0026ldquo;输入控制符\u0026rdquo;,输入参数) int i; scanf(\u0026#34;%d\u0026#34;,\u0026amp;i);//i\u0026amp; 表示变量 i 的地址，\u0026amp; 是一个取地址符，也就是将输入的整数类型的值放入到变量 i 中。 printf(\u0026#34;%d\\n\u0026#34;,i); scanf(\u0026ldquo;非输入控制符 输入控制符\u0026rdquo;,输入参数) int i; scanf(\u0026#34;z%d\u0026#34;,\u0026amp;i);//非输入控制符 z （z 可以是任意值）必须同输入控制符一起输入 。 printf(\u0026#34;i = %d\\n\u0026#34;,i); ","title":"C scanf"},{"content":"switch 它是一种选择控制语句。\nswitch 是选择控制语句，而不是循环控制语句，如果在 switch 中出现了 berak 语句，该语句的功\n能只是退出 switch 语句并转去执行这个 switch 下面的语句。\n在 switch 中，出现 continue 是错误的，除非当前 switch 在 for 或 while 之中。\n当我们使用它时，它会去寻找与表达式结果所匹\n的子表达式（case），并执行子表达式后面的所有\n语句，直到遇到 break 停止执行。\n#include \u0026lt;stdio.h\u0026gt; int main () {  char fraction ; \tprintf(\u0026#34;请输入您的等级：\u0026#34;); \tscanf(\u0026#34;%c\u0026#34;, \u0026amp;fraction); \t// 测试请键入 A \tswitch(fraction) { \tcase \u0026#39;A\u0026#39; : \tprintf(\u0026#34;很棒！\\n\u0026#34; ); \tcase \u0026#39;B\u0026#39; : \tprintf(\u0026#34;还不错哦\\n\u0026#34; ); \tcase \u0026#39;C\u0026#39; : \tprintf(\u0026#34;做得好\\n\u0026#34; ); \tbreak; \tcase \u0026#39;D\u0026#39; : \tprintf(\u0026#34;您通过了\\n\u0026#34; ); \tbreak; \tcase \u0026#39;F\u0026#39; : \tprintf(\u0026#34;最好再试一下\\n\u0026#34; ); \tbreak; \tdefault : \tprintf(\u0026#34;无效的成绩\\n\u0026#34; ); \t} \tprintf(\u0026#34;您的等级是 %c\\n\u0026#34;, fraction);  \treturn 0;  } 当我们键入 A 时，会发现程序不仅仅执行了与主\n表达式匹配的子表达式 A 后面的代码块，连着后\n面的子表达式 B 和 C 后面的代码块也一起执行\n了。\n请输入您的等级：A 很棒！ 还不错哦 做得好 您的等级是 A 直到遇到了printf(\u0026quot;做得好\\n\u0026quot; );后面的break;，程序才停止执行。\nprintf(\u0026#34;做得好\\n\u0026#34; ); break; 原因是因为程序是从上往下执行的，而case后\n的子表达式只是一个入口，而当程序找到入口后，\n其他的入口就在进行判断了（相当于入口不存在\n了），因此，程序会继续执行下面的语句，直到遇\n到break终止整个程序。\n","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/switch/","summary":"switch 它是一种选择控制语句。\nswitch 是选择控制语句，而不是循环控制语句，如果在 switch 中出现了 berak 语句，该语句的功\n能只是退出 switch 语句并转去执行这个 switch 下面的语句。\n在 switch 中，出现 continue 是错误的，除非当前 switch 在 for 或 while 之中。\n当我们使用它时，它会去寻找与表达式结果所匹\n的子表达式（case），并执行子表达式后面的所有\n语句，直到遇到 break 停止执行。\n#include \u0026lt;stdio.h\u0026gt; int main () {  char fraction ; \tprintf(\u0026#34;请输入您的等级：\u0026#34;); \tscanf(\u0026#34;%c\u0026#34;, \u0026amp;fraction); \t// 测试请键入 A \tswitch(fraction) { \tcase \u0026#39;A\u0026#39; : \tprintf(\u0026#34;很棒！\\n\u0026#34; ); \tcase \u0026#39;B\u0026#39; : \tprintf(\u0026#34;还不错哦\\n\u0026#34; ); \tcase \u0026#39;C\u0026#39; : \tprintf(\u0026#34;做得好\\n\u0026#34; ); \tbreak; \tcase \u0026#39;D\u0026#39; : \tprintf(\u0026#34;您通过了\\n\u0026#34; ); \tbreak; \tcase \u0026#39;F\u0026#39; : \tprintf(\u0026#34;最好再试一下\\n\u0026#34; ); \tbreak; \tdefault : \tprintf(\u0026#34;无效的成绩\\n\u0026#34; ); \t} \tprintf(\u0026#34;您的等级是 %c\\n\u0026#34;, fraction);  \treturn 0;  } 当我们键入 A 时，会发现程序不仅仅执行了与主","title":"C switch"},{"content":"一个人的安全感源于 我想说一句特别扎心真实的话：所谓那些要让自己十分独立，强大到谁都不需要依赖的情况，根本不能带来安全感。\n这个逻辑真的超级简单——你让自己变得谁都不需要依赖，然后时刻靠着“我谁都不需要”的想法来支撑自己，\n就算进入到一段关系当中也不放心对方，依旧活的跟自己一个人生活一样\u0026hellip;这不就是一个很没有安全感的人，才会做出来的表现么？\n我相信和这样的人谈过恋爱的人，一定深有体会：\n这个人特别懂事，特别独立，有什么问题都自己解决，有什么负面情绪都自己消化，好像这个人没有你也可以过的很好。\n是，你的确省事了，这个人也的确懂事，可是问题就在于：\n你从来走不进这个人的内心，不是么？因为这人，一直在预设你离开了怎么办。\n所以我觉得过分强调自己的独立，过分让自己不需要和对方发生关系，难道不就是因为十分没有安全感，所以十分害怕对方的离开，\n因此才不和对方发生任何亲密接触，早早地关闭自己的内心么？\n那安全感来自哪里？\n我觉得安全感并不来自于“我不需要”，而是来自于“就算失去了，我还有从头再来的勇气”。\n不知道看过电影《1942》的朋友有没有印象，在大灾之年到来的时候，过去的老东家落魄成了要饭逃荒的人，但是他还有底气说出来：\n“我知道怎么从穷变富，再过上二十年，我还是东家。”\n这种失去了一切之后，依然有重头再来的自信的人，才是真正有安全感：失去痛苦么？太痛苦了。\n但是没关系，只要你让我站住脚，让我缓过来，我照样有本事和底气重头再来。\n所以我觉得对应在感情当中，一个真正有安全感的人应该是这个样子的：\n遇到喜欢的人，大胆追求，完全不在乎这样会不会显得自己太主动，\n完全不在乎自己会不会表现的太积极，反正就算被拒绝了也无所谓，不喜欢我未必一定是我的原因；\n在一起了之后，就好好相处，该依赖对方的依赖，该走心的就走心，完全和对方真心相处，无所保留；\n分开了之后，该哭就哭，该难受就难受，绝对不假装坚强，也不强撑着说自己没事，\n等到走出来了，缓过来之后，收拾好心态去找下一位。\n没有什么“再也不相信爱情了”“再也不会付出那么多了”“不要依赖任何人”的感慨，\n因为他们清楚的知道自己值得被爱，自己能够找到更好的，他们完全有能力开启一段新的感情。\n我们努力学习，努力工作，让自己的生活变得充实，绝对不是为了把别人排斥在外面，然后不停地告诉自己“我不需要”别人。\n我觉得我们这么努力的目的，是为了当我们遇到可以爱，值得爱的人的时候，我们能够大胆的行动；\n如果这段感情失败了，我们也完全可以从头再来。\n所以安全感其实来自于建立的从头再来的底气，安全感恰恰来自于足够的自信。\n “我有足够的实力，我可以东山再起”和“我有足够的实力，我不需要任何人”这两者之间，我觉得还是有本质上的差别的。\n所以请千万不要产生什么误解，把“我不需要别人”当做自己安全感的来源，我觉得这真的是很错误的想法：\n因为那不是安全感，那是在回避问题，那是用封闭自己内心的方式为自己建造了一个根本不属于自己的堡垒，\n自己躲在堡垒里面，自欺欺人的表示很安全。\n安全感应该来自于你实力带给自己的，高度的自我认同：\n你相信自己很好，你相信自己值得被肯定，值得被爱，你更明确的知道哪怕不好的事情发生在你身上，你也可以很快东山再起。\n所以，当一个人告诉我“我很强大，我不需要依赖任何人，我没有期望所以也不会失望”的时候，\n我不会觉得这个人有很强的安全感，我反而会很心疼这种人——这个人一定经历了什么不好的事情，所以戒备心这么重。\n我希望看到的是，大家可以特别轻松的表示“无所谓，逢山开路遇水搭桥，实在不行也当体验过程了，失败了重新开始就好”。\n所以，不要躲在那个自我封闭的堡垒当中了，走出来吧。\n当你不需要盔甲的时候，你才变得真正足够自信，足够强大，足够有安全感。\n","permalink":"https://note.yxzi.xyz/note/view/gam/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%AE%89%E5%85%A8%E6%84%9F%E6%BA%90%E4%BA%8E/","summary":"一个人的安全感源于 我想说一句特别扎心真实的话：所谓那些要让自己十分独立，强大到谁都不需要依赖的情况，根本不能带来安全感。\n这个逻辑真的超级简单——你让自己变得谁都不需要依赖，然后时刻靠着“我谁都不需要”的想法来支撑自己，\n就算进入到一段关系当中也不放心对方，依旧活的跟自己一个人生活一样\u0026hellip;这不就是一个很没有安全感的人，才会做出来的表现么？\n我相信和这样的人谈过恋爱的人，一定深有体会：\n这个人特别懂事，特别独立，有什么问题都自己解决，有什么负面情绪都自己消化，好像这个人没有你也可以过的很好。\n是，你的确省事了，这个人也的确懂事，可是问题就在于：\n你从来走不进这个人的内心，不是么？因为这人，一直在预设你离开了怎么办。\n所以我觉得过分强调自己的独立，过分让自己不需要和对方发生关系，难道不就是因为十分没有安全感，所以十分害怕对方的离开，\n因此才不和对方发生任何亲密接触，早早地关闭自己的内心么？\n那安全感来自哪里？\n我觉得安全感并不来自于“我不需要”，而是来自于“就算失去了，我还有从头再来的勇气”。\n不知道看过电影《1942》的朋友有没有印象，在大灾之年到来的时候，过去的老东家落魄成了要饭逃荒的人，但是他还有底气说出来：\n“我知道怎么从穷变富，再过上二十年，我还是东家。”\n这种失去了一切之后，依然有重头再来的自信的人，才是真正有安全感：失去痛苦么？太痛苦了。\n但是没关系，只要你让我站住脚，让我缓过来，我照样有本事和底气重头再来。\n所以我觉得对应在感情当中，一个真正有安全感的人应该是这个样子的：\n遇到喜欢的人，大胆追求，完全不在乎这样会不会显得自己太主动，\n完全不在乎自己会不会表现的太积极，反正就算被拒绝了也无所谓，不喜欢我未必一定是我的原因；\n在一起了之后，就好好相处，该依赖对方的依赖，该走心的就走心，完全和对方真心相处，无所保留；\n分开了之后，该哭就哭，该难受就难受，绝对不假装坚强，也不强撑着说自己没事，\n等到走出来了，缓过来之后，收拾好心态去找下一位。\n没有什么“再也不相信爱情了”“再也不会付出那么多了”“不要依赖任何人”的感慨，\n因为他们清楚的知道自己值得被爱，自己能够找到更好的，他们完全有能力开启一段新的感情。\n我们努力学习，努力工作，让自己的生活变得充实，绝对不是为了把别人排斥在外面，然后不停地告诉自己“我不需要”别人。\n我觉得我们这么努力的目的，是为了当我们遇到可以爱，值得爱的人的时候，我们能够大胆的行动；\n如果这段感情失败了，我们也完全可以从头再来。\n所以安全感其实来自于建立的从头再来的底气，安全感恰恰来自于足够的自信。\n “我有足够的实力，我可以东山再起”和“我有足够的实力，我不需要任何人”这两者之间，我觉得还是有本质上的差别的。\n所以请千万不要产生什么误解，把“我不需要别人”当做自己安全感的来源，我觉得这真的是很错误的想法：\n因为那不是安全感，那是在回避问题，那是用封闭自己内心的方式为自己建造了一个根本不属于自己的堡垒，\n自己躲在堡垒里面，自欺欺人的表示很安全。\n安全感应该来自于你实力带给自己的，高度的自我认同：\n你相信自己很好，你相信自己值得被肯定，值得被爱，你更明确的知道哪怕不好的事情发生在你身上，你也可以很快东山再起。\n所以，当一个人告诉我“我很强大，我不需要依赖任何人，我没有期望所以也不会失望”的时候，\n我不会觉得这个人有很强的安全感，我反而会很心疼这种人——这个人一定经历了什么不好的事情，所以戒备心这么重。\n我希望看到的是，大家可以特别轻松的表示“无所谓，逢山开路遇水搭桥，实在不行也当体验过程了，失败了重新开始就好”。\n所以，不要躲在那个自我封闭的堡垒当中了，走出来吧。\n当你不需要盔甲的时候，你才变得真正足够自信，足够强大，足够有安全感。","title":"一个人的安全感源于"},{"content":"跑步训练 冬天跑步，不问配速，不管里程，能坚持，就是万岁。\n在我的心目中，冬训，求稳，不受伤即可。\n如果放之任之，三天打鱼两天晒网，到了来年开春不仅身体发福，跑起来也够呛。\n那么，冬训我们该如何跑呢？\n适量 冬天多跑轻松有氧，适当地堆堆跑量是没有问题的，但一定要适量，遵循循序渐进的原则，\n平常日常拉练 10 - 15 公里，在身体的承受范围之内即可。\n跑量是基础，没有足够的跑量打底，全马是无从谈起的。\n稳速 业余爱好者，最大的问题是：快又快不上去，慢又慢不下来；时而快，时而慢，节奏混乱。\n不管半马还是全马，讲究个人节奏感，匀速为主；\n绝不是仗着体力充沛，肆意冲刺，以至于精疲力竭。\n今天有氧慢跑，速度绝不能快；明天间歇冲刺，就不能保存实力；该慢则慢，不硬撑；该快则快，不保留。\n我们进行速度训练的时候，假如我们一周跑四次，那么有三次都是以有氧慢跑为主，进行预热、调节、恢复，\n只为腾出足够的精力，进行速度训练，否则次次强度训练打底，身体肯定吃不消！\n有氧是主食，速度训练只是调味剂，一周一次，刚刚好。即便跑速度，也要稳速，绝不是有多快冲多快。\n拿 10 x 1000 米间歇举例，前 3 组，可以稍慢点儿，保存好体力，坚持跑完最后一组，\n否则跑到第 5 组，原本 400 配速的间歇，掉到了 430，这就失去了速度训练的意义。\n一定要稳，保存好体力，细水长流，才能坚持到最后。\n力量 力量训练是大多数业余爱好者的短板，我们很少安排时间进行力量的强化训练。\n专业跑者一般一周一次，45 分钟左右，像一般的业余跑者，习惯路跑，很少有练力量的习惯。\n如果你想提升成绩，首先要让腿部有劲，包括我们日常拉练，也是练腿，但效果远不如，针对性的强化训练。\n我们先进行徒手力量训练，深蹲、蛙跳、箭步蹲练腿；腰腹挺举练腰腹；单杆双杆练上肢；平板支撑练核心\u0026hellip;\n随着能力提升，可以借助器材进行强化，比如哑铃深蹲、哑铃箭步蹲等等，\n但务必不要用力过猛，操之过急。\n","permalink":"https://note.yxzi.xyz/note/view/grow/%E8%B7%91%E6%AD%A5%E8%AE%AD%E7%BB%83/","summary":"跑步训练 冬天跑步，不问配速，不管里程，能坚持，就是万岁。\n在我的心目中，冬训，求稳，不受伤即可。\n如果放之任之，三天打鱼两天晒网，到了来年开春不仅身体发福，跑起来也够呛。\n那么，冬训我们该如何跑呢？\n适量 冬天多跑轻松有氧，适当地堆堆跑量是没有问题的，但一定要适量，遵循循序渐进的原则，\n平常日常拉练 10 - 15 公里，在身体的承受范围之内即可。\n跑量是基础，没有足够的跑量打底，全马是无从谈起的。\n稳速 业余爱好者，最大的问题是：快又快不上去，慢又慢不下来；时而快，时而慢，节奏混乱。\n不管半马还是全马，讲究个人节奏感，匀速为主；\n绝不是仗着体力充沛，肆意冲刺，以至于精疲力竭。\n今天有氧慢跑，速度绝不能快；明天间歇冲刺，就不能保存实力；该慢则慢，不硬撑；该快则快，不保留。\n我们进行速度训练的时候，假如我们一周跑四次，那么有三次都是以有氧慢跑为主，进行预热、调节、恢复，\n只为腾出足够的精力，进行速度训练，否则次次强度训练打底，身体肯定吃不消！\n有氧是主食，速度训练只是调味剂，一周一次，刚刚好。即便跑速度，也要稳速，绝不是有多快冲多快。\n拿 10 x 1000 米间歇举例，前 3 组，可以稍慢点儿，保存好体力，坚持跑完最后一组，\n否则跑到第 5 组，原本 400 配速的间歇，掉到了 430，这就失去了速度训练的意义。\n一定要稳，保存好体力，细水长流，才能坚持到最后。\n力量 力量训练是大多数业余爱好者的短板，我们很少安排时间进行力量的强化训练。\n专业跑者一般一周一次，45 分钟左右，像一般的业余跑者，习惯路跑，很少有练力量的习惯。\n如果你想提升成绩，首先要让腿部有劲，包括我们日常拉练，也是练腿，但效果远不如，针对性的强化训练。\n我们先进行徒手力量训练，深蹲、蛙跳、箭步蹲练腿；腰腹挺举练腰腹；单杆双杆练上肢；平板支撑练核心\u0026hellip;\n随着能力提升，可以借助器材进行强化，比如哑铃深蹲、哑铃箭步蹲等等，\n但务必不要用力过猛，操之过急。","title":"跑步训练"},{"content":"库，框架，架构，平台的区别 库（Library） 库是一系列预先编写好的代码集合，供开发者在编程中调用，大大减少重复工作量。\n库的概念很宽泛。\n程序员第一次输出 Hello World 用的 printf 就来自 C 语言标准库；\n各种 SDK 都是库；\n从 npm、Maven、Nuget 下载的包都是库；\n你自己写一个字符串处理函数，包装好之后调用，也是库。\n框架（Framework） 框架是库的一种。很多人会把框架和普通库的区别仅仅理解为规模和复杂度，其实不然。\njQuery 的规模够大了，但仍然是库，不是框架。\n框架的最大特征是它会接管程序的主控制流，开发者只需编写业务逻辑代码，具体执行工作由框架来调用。实践中经常会用到控制反转（IoC）以及模板类继承等方式。\n比如用 Spring 开发 Web 项目，你只需编写 Controller 和配置文件。具体到项目如何启动、如何监听端口、每一次网络请求的响应处理，这些都由框架来实现。\n所以一般来说单个项目可以引入很多库，却不能用多个框架。\n同时用 jQuery 和 Vue 没问题，但同时用 Vue 和 React 就不行。\n因为主控制流只有一个。\n架构（Architecture） 架构与前面两个的区别不仅仅是规模更大，而且它是个抽象概念，不涉及具体语言和代码实现。\n它可以是编程模式，比如 MVC 架构、MVVM 架构，只是规定了代码如何进行逻辑分离。每种语言都有自己的 MVC 框架；\n也可以是客户端形式，比如多年前常谈的 B/S、C/S 架构；\n还可以是服务器端结构，比如分布式架构、微服务架构；\n再比如说数据库，为了让客户放心你可以吹自己用的是业内顶端的高可用高一致性弹性伸缩多机房异地容灾双活架构（实际是阿里云每月八百块买的）；\n等等等等。\n所以说架构师的价值并不在于写代码快、Bug 少、熟练使用某些库与框架，而是掌握并评估项目的什么地方适合用什么架构。\n大方向一旦出了问题，比写几处错误代码的影响可大多了。\n平台（Platform） 平台又是另一回事，区别就在于前三者属于技术领域的概念，平台则属于业务领域的概念。\n只要是运行中的程序通过本机或网络 API 对外提供服务，无论是小规模的单个接口、大规模的云端集群服务，都可以称为平台。\n操作系统是平台，它提供你的应用程序与硬件、软件、网络交互的渠道；\n浏览器是平台，与操作系统的主要区别在于开发语言单一、权限控制较严；\n各互联网服务商自然是平台，提供物理主机、虚拟主机、云主机、容器、Serverless 等等并通过网络进行部署和访问；\n以及常见的通知推送平台、短信平台、统计分析平台等等等。\n 当然，以上所有概念在网上经常出现混淆，但也不算什么严重的错误。\n某些较大规模的库经常被称为框架，一些框架也会自称平台来撑场面。\n就像罗老师做个手机 UI 也敢叫 OS 一样。\n有的领域不必太较真，严格揪着定义来看，所有 ORM 都只能是库而非框架，因为数据库的读写跟程序控制流无关。\n但你要说 MyBatis 不算框架还勉强能接受，难道 Hibernate 和 Entity Framework 都要开除出框架行列？\n这也未免太原教旨了。人家接管了全套数据库操作，连语法都大规模解耦，还能要求什么呢？\n我们分清这些概念是为了更好地开发和交流，最终目的还是让程序稳定高效地跑起来。\n有些东西单靠理论、举例和比喻没法彻底搞清楚，在实践中边学边思考就简单多了。\n","permalink":"https://note.yxzi.xyz/note/technology/frame/%E5%BA%93%E6%A1%86%E6%9E%B6%E6%9E%B6%E6%9E%84%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"库，框架，架构，平台的区别 库（Library） 库是一系列预先编写好的代码集合，供开发者在编程中调用，大大减少重复工作量。\n库的概念很宽泛。\n程序员第一次输出 Hello World 用的 printf 就来自 C 语言标准库；\n各种 SDK 都是库；\n从 npm、Maven、Nuget 下载的包都是库；\n你自己写一个字符串处理函数，包装好之后调用，也是库。\n框架（Framework） 框架是库的一种。很多人会把框架和普通库的区别仅仅理解为规模和复杂度，其实不然。\njQuery 的规模够大了，但仍然是库，不是框架。\n框架的最大特征是它会接管程序的主控制流，开发者只需编写业务逻辑代码，具体执行工作由框架来调用。实践中经常会用到控制反转（IoC）以及模板类继承等方式。\n比如用 Spring 开发 Web 项目，你只需编写 Controller 和配置文件。具体到项目如何启动、如何监听端口、每一次网络请求的响应处理，这些都由框架来实现。\n所以一般来说单个项目可以引入很多库，却不能用多个框架。\n同时用 jQuery 和 Vue 没问题，但同时用 Vue 和 React 就不行。\n因为主控制流只有一个。\n架构（Architecture） 架构与前面两个的区别不仅仅是规模更大，而且它是个抽象概念，不涉及具体语言和代码实现。\n它可以是编程模式，比如 MVC 架构、MVVM 架构，只是规定了代码如何进行逻辑分离。每种语言都有自己的 MVC 框架；\n也可以是客户端形式，比如多年前常谈的 B/S、C/S 架构；\n还可以是服务器端结构，比如分布式架构、微服务架构；\n再比如说数据库，为了让客户放心你可以吹自己用的是业内顶端的高可用高一致性弹性伸缩多机房异地容灾双活架构（实际是阿里云每月八百块买的）；\n等等等等。\n所以说架构师的价值并不在于写代码快、Bug 少、熟练使用某些库与框架，而是掌握并评估项目的什么地方适合用什么架构。\n大方向一旦出了问题，比写几处错误代码的影响可大多了。\n平台（Platform） 平台又是另一回事，区别就在于前三者属于技术领域的概念，平台则属于业务领域的概念。\n只要是运行中的程序通过本机或网络 API 对外提供服务，无论是小规模的单个接口、大规模的云端集群服务，都可以称为平台。\n操作系统是平台，它提供你的应用程序与硬件、软件、网络交互的渠道；\n浏览器是平台，与操作系统的主要区别在于开发语言单一、权限控制较严；\n各互联网服务商自然是平台，提供物理主机、虚拟主机、云主机、容器、Serverless 等等并通过网络进行部署和访问；\n以及常见的通知推送平台、短信平台、统计分析平台等等等。\n 当然，以上所有概念在网上经常出现混淆，但也不算什么严重的错误。","title":"库，框架，架构，平台的区别"},{"content":"IO 流 import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream;  public class ShuRuShuChu {  public static void main(String[]args) throws Exception { //写入  String str=\u0026#34;写入成功！\u0026#34;;  File xieru=new File(\u0026#34;C:\\\\Users\\\\admin\\\\Desktop\\\\期末考试\\\\李白.txt\u0026#34;);  FileOutputStream fos=new FileOutputStream(xieru,true);  byte[] words=str.getBytes();  fos.write(words,0,words.length);  //读取  File file2 = new File(\u0026#34;C:\\\\Users\\\\admin\\\\Desktop\\\\期末考试\\\\李白.txt\u0026#34;);  FileInputStream fis = new FileInputStream(file2);  byte[] b = new byte[1024];  int len = fis.read(b);  while (len != -1) {  String data = new String(b);  System.out.println(data);  len = fis.read(b);  }  } } ","permalink":"https://note.yxzi.xyz/note/technology/language/java/io-%E6%B5%81/","summary":"IO 流 import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream;  public class ShuRuShuChu {  public static void main(String[]args) throws Exception { //写入  String str=\u0026#34;写入成功！\u0026#34;;  File xieru=new File(\u0026#34;C:\\\\Users\\\\admin\\\\Desktop\\\\期末考试\\\\李白.txt\u0026#34;);  FileOutputStream fos=new FileOutputStream(xieru,true);  byte[] words=str.getBytes();  fos.write(words,0,words.length);  //读取  File file2 = new File(\u0026#34;C:\\\\Users\\\\admin\\\\Desktop\\\\期末考试\\\\李白.txt\u0026#34;);  FileInputStream fis = new FileInputStream(file2);  byte[] b = new byte[1024];  int len = fis.read(b);  while (len != -1) {  String data = new String(b);  System.","title":"Java IO 流"},{"content":"卖票 Ticket Class public class Ticket {  public static int chepiao = 1000;  public String name;  public String a = new String(\u0026#34;222\u0026#34;);   public Ticket(String name) {  this.name = name;  }   public void run() {  while (true) {  synchronized (a) {  if (chepiao \u0026gt; 0) {  System.out.println(this.name + \u0026#34;正在卖第\u0026#34; + (1001 - chepiao) + \u0026#34;张票\u0026#34;);  chepiao--;  } else {  break;  }  }   }  } } ThreadOne Class public class ThreadOne implements Runnable {  public static int chepiao = 1000;  public String name;  public static String aa = new String(\u0026#34;111\u0026#34;);   public ThreadOne(String name) {  this.name = name;  }   public void run() {  while (true) {  synchronized (aa) {  if (chepiao \u0026gt; 0) {  System.out.println(this.name + \u0026#34;车站正在卖票\u0026#34; + (1001 - chepiao) + \u0026#34;张车票\u0026#34;);  --chepiao;  } else {  break;  }  }  }  } } Test Class public class Test {  public static void main(String[] args) {  ThreadOne Gz=new ThreadOne(\u0026#34;贵州\u0026#34;);  ThreadOne Cq=new ThreadOne(\u0026#34;重庆\u0026#34;);  new Thread(Gz).start();  new Thread(Cq).start();  } } ","permalink":"https://note.yxzi.xyz/note/technology/language/java/%E5%8D%96%E7%A5%A8%E9%97%AE%E9%A2%98/","summary":"卖票 Ticket Class public class Ticket {  public static int chepiao = 1000;  public String name;  public String a = new String(\u0026#34;222\u0026#34;);   public Ticket(String name) {  this.name = name;  }   public void run() {  while (true) {  synchronized (a) {  if (chepiao \u0026gt; 0) {  System.out.println(this.name + \u0026#34;正在卖第\u0026#34; + (1001 - chepiao) + \u0026#34;张票\u0026#34;);  chepiao--;  } else {  break;  }  }   }  } } ThreadOne Class public class ThreadOne implements Runnable {  public static int chepiao = 1000;  public String name;  public static String aa = new String(\u0026#34;111\u0026#34;);   public ThreadOne(String name) {  this.","title":"Java 卖票问题"},{"content":"生产者消费者模式 工厂类 public class Factory {  int num=0;   //库存 // 开始生产  public synchronized void addProduct() throws InterruptedException {  if(num \u0026gt;= 10){  System.out.println(\u0026#34;库存已满，不能再生产了!\u0026#34;);  //强制当前线程等待，知道其他线程在同一个对象调用notify()方法后释放  this.wait();  }else {  Thread.sleep(1000);  num++; //生产出商品  System.out.println(\u0026#34;生产者生产了一个商品，当前库存为: \u0026#34; + num);  //唤醒消费商品的线程  this.notify();  }  }  //开始消费  public synchronized void subProduct() throws InterruptedException {  if(num == 0){  System.out.println(\u0026#34;商品已经被抢光了！请等待补货...\u0026#34;);  this.wait();//强制当前线程等待  }else{  Thread.sleep( 1000);  //消费商品  num--;  System.out.println(\u0026#34;消费者们购买了一个商品，现在库存为:\u0026#34; + num);  //唤醒生产商品的线程  this.notify();  }  } } 生产者类 public class Productor implements Runnable{  Factory factory;  public Productor(Factory factory) {  this.factory = factory;  }  public void run() {  //生产者不停生产商品  int time = 0;  while(time\u0026lt;=9){  try {  this.factory.addProduct();  time++;  }  catch (InterruptedException e) {  e.printStackTrace();  }  if(time==9){  System.out.println(\u0026#34;生产第九个商品失败，产业链已经破损！！！但商品还能正常购买。\u0026#34;);  break;  }  }  } } 消费者类 public class Customer implements Runnable{  Factory factory;  public Customer(Factory factory) {  this.factory = factory;  }  @Override  public void run() {  //消费者不停消费商品  int time = 1;  while(time \u0026lt;= 9) {  try {  this.factory.subProduct();  time++;  } catch (InterruptedException e) {  e.printStackTrace();  }  if (time == 9) {  System.out.println(\u0026#34;产业链已经破损，无法消费了，换下一家吧！\u0026#34;);  break;   }  }  } } 测试类  Factory factory = new Factory();  Productor productor = new Productor(factory);//生产者线程对象  Customer customer = new Customer(factory);  //道费者线程对象  System.out.println(\u0026#34;当前库存为：0\u0026#34;);  new Thread(productor).start();  new Thread(customer).start(); ","permalink":"https://note.yxzi.xyz/note/technology/language/java/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/","summary":"生产者消费者模式 工厂类 public class Factory {  int num=0;   //库存 // 开始生产  public synchronized void addProduct() throws InterruptedException {  if(num \u0026gt;= 10){  System.out.println(\u0026#34;库存已满，不能再生产了!\u0026#34;);  //强制当前线程等待，知道其他线程在同一个对象调用notify()方法后释放  this.wait();  }else {  Thread.sleep(1000);  num++; //生产出商品  System.out.println(\u0026#34;生产者生产了一个商品，当前库存为: \u0026#34; + num);  //唤醒消费商品的线程  this.notify();  }  }  //开始消费  public synchronized void subProduct() throws InterruptedException {  if(num == 0){  System.out.println(\u0026#34;商品已经被抢光了！请等待补货...\u0026#34;);  this.","title":"Java 生产者消费者模式"},{"content":"继承 Phone Class public class Phone extends Dianhua implements Mp3 {  public void playmusic(){  System.out.println(\u0026#34;播放音乐\u0026#34;);  }  public void call(){  System.out.println(\u0026#34;可以打电话\u0026#34;);  }  public void dh(){  System.out.println(\u0026#34;可以高得地图导航\u0026#34;);  } } Telephone Class public abstract class Telephone {  public abstract void call();  public abstract void dh(); } Mp3 Interface public interface Mp3 {  abstract void playmusic(); } Test Class public class Test {  public static void main(String[] args) {  Phone c=new Phone();  c.call();  c.dh();  c.playmusic();  } } ","permalink":"https://note.yxzi.xyz/note/technology/language/java/%E7%BB%A7%E6%89%BF/","summary":"继承 Phone Class public class Phone extends Dianhua implements Mp3 {  public void playmusic(){  System.out.println(\u0026#34;播放音乐\u0026#34;);  }  public void call(){  System.out.println(\u0026#34;可以打电话\u0026#34;);  }  public void dh(){  System.out.println(\u0026#34;可以高得地图导航\u0026#34;);  } } Telephone Class public abstract class Telephone {  public abstract void call();  public abstract void dh(); } Mp3 Interface public interface Mp3 {  abstract void playmusic(); } Test Class public class Test {  public static void main(String[] args) {  Phone c=new Phone();  c.","title":"Java 继承"},{"content":"配置单区域 OSPFv2 配置 R1 enable\rconfigure terminal\rrouter ospf 10\rrouter-id 1.1.1.1\rnetwork 172.16.1.0 0.0.0.255 area 0\rnetwork 172.16.3.0 0.0.0.3 area 0\rnetwork 192.168.10.4 0.0.0.3 area 0\rpassive-interface GigabitEthernet0/0 配置 R2 enable\rconfigure terminal\rrouter ospf 10\rrouter-id 2.2.2.2\rnetwork 172.16.2.0 0.0.0.255 area 0\rnetwork 172.16.3.0 0.0.0.3 area 0\rnetwork 192.168.10.8 0.0.0.3 area 0\rpassive-interface GigabitEthernet0/0 配置 R3 enable\rconfigure terminal\rrouter ospf 10\rrouter-id 3.3.3.3\rnetwork 192.168.1.0 0.0.0.255 area 0\rnetwork 192.168.10.4 0.0.0.3 area 0\rnetwork 192.168.10.8 0.0.0.3 area 0\rpassive-interface GigabitEthernet0/0 ","permalink":"https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E5%8D%95%E5%8C%BA%E5%9F%9F-ospfv2/","summary":"配置单区域 OSPFv2 配置 R1 enable\rconfigure terminal\rrouter ospf 10\rrouter-id 1.1.1.1\rnetwork 172.16.1.0 0.0.0.255 area 0\rnetwork 172.16.3.0 0.0.0.3 area 0\rnetwork 192.168.10.4 0.0.0.3 area 0\rpassive-interface GigabitEthernet0/0 配置 R2 enable\rconfigure terminal\rrouter ospf 10\rrouter-id 2.2.2.2\rnetwork 172.16.2.0 0.0.0.255 area 0\rnetwork 172.16.3.0 0.0.0.3 area 0\rnetwork 192.168.10.8 0.0.0.3 area 0\rpassive-interface GigabitEthernet0/0 配置 R3 enable\rconfigure terminal\rrouter ospf 10\rrouter-id 3.3.3.3\rnetwork 192.168.1.0 0.0.0.255 area 0\rnetwork 192.","title":"Cisco 配置单区域 OSPFv2"},{"content":"选择器 ID 选择器，尽量少用，\n","permalink":"https://note.yxzi.xyz/note/technology/language/css/%E9%80%89%E6%8B%A9%E5%99%A8/","summary":"选择器 ID 选择器，尽量少用，","title":"Css 选择器"},{"content":"OSPF 协议 OSPF 是目前网络界耳熟能详的协议了。\n用带宽来判断路径的优劣弥补了 RIP 的缺陷（光凭带宽也不是很好），同时使用划分区域网络，可以更好的控制管理和扩展网络。\n还有各种小特点比如 DR、BDR 机制，和适合不同网络类型机制，以及使用不同 LSA 传递各种信息，各种 LSA 的特性也不通。\n所有综合来讲 OSPF 是比较适合大众选择的一款路由协议\nrouter ospf 10 配置 OSPF 路由，进程 ID 为 10\nrouter-id 1.1.1.1 配置路由器的路由器 ID\n子网掩码的反掩码 IP 地址：192.168.10.8/30，那么它的子网掩码为 255.255.255.252\n则它的子网掩码的反掩码为 255.255.255.255 减去 255.255.255.252 等于 0.0.0.3，\n即配置 OSPFv2 的网络通告为：\nnetwork 192.168.10.8 0.0.0.3 area 0 其中 area 是自治系统区域的标识\n","permalink":"https://note.yxzi.xyz/note/technology/internet/cisco/ospf-%E5%8D%8F%E8%AE%AE/","summary":"OSPF 协议 OSPF 是目前网络界耳熟能详的协议了。\n用带宽来判断路径的优劣弥补了 RIP 的缺陷（光凭带宽也不是很好），同时使用划分区域网络，可以更好的控制管理和扩展网络。\n还有各种小特点比如 DR、BDR 机制，和适合不同网络类型机制，以及使用不同 LSA 传递各种信息，各种 LSA 的特性也不通。\n所有综合来讲 OSPF 是比较适合大众选择的一款路由协议\nrouter ospf 10 配置 OSPF 路由，进程 ID 为 10\nrouter-id 1.1.1.1 配置路由器的路由器 ID\n子网掩码的反掩码 IP 地址：192.168.10.8/30，那么它的子网掩码为 255.255.255.252\n则它的子网掩码的反掩码为 255.255.255.255 减去 255.255.255.252 等于 0.0.0.3，\n即配置 OSPFv2 的网络通告为：\nnetwork 192.168.10.8 0.0.0.3 area 0 其中 area 是自治系统区域的标识","title":"OSPF 协议"},{"content":"交换机 Trunk 和 Access trunk 行通过多个 VLAN。\naccess 只允许通通过单个 VLAN。\n","permalink":"https://note.yxzi.xyz/note/technology/internet/cisco/%E4%BA%A4%E6%8D%A2%E6%9C%BA/","summary":"交换机 Trunk 和 Access trunk 行通过多个 VLAN。\naccess 只允许通通过单个 VLAN。","title":"交换机"},{"content":"静态和动态路由的优缺点 静态路由的优点：  占用资源较多。 便于管理员了解路由。 易于配置。  静态路由的缺点：  配置和维护耗费时间。 配置容易出错，尤其对于大型网络。 需要管理员维护变化的路由信息。 不能随着网络的增长而扩展；维护会越来越麻烦。 需要完全了解整个网络的情况才能进行操作。  动态路由的优点  增加或删除网络时，管理员维护路由配置的工作量较少。 网络拓扑结构发生变化时，协议可以自动做出调整。 配置不容易出错。 扩展性好，网络增长时不会出现问题。  动态路由的缺点  需要占用路由器资源（CPU 时间、内存和链路带宽）。 管理员需要掌握更多的网络知识才能进行配置、验证和故障排除工作。  ","permalink":"https://note.yxzi.xyz/note/technology/internet/cisco/%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/","summary":"静态和动态路由的优缺点 静态路由的优点：  占用资源较多。 便于管理员了解路由。 易于配置。  静态路由的缺点：  配置和维护耗费时间。 配置容易出错，尤其对于大型网络。 需要管理员维护变化的路由信息。 不能随着网络的增长而扩展；维护会越来越麻烦。 需要完全了解整个网络的情况才能进行操作。  动态路由的优点  增加或删除网络时，管理员维护路由配置的工作量较少。 网络拓扑结构发生变化时，协议可以自动做出调整。 配置不容易出错。 扩展性好，网络增长时不会出现问题。  动态路由的缺点  需要占用路由器资源（CPU 时间、内存和链路带宽）。 管理员需要掌握更多的网络知识才能进行配置、验证和故障排除工作。  ","title":"Cisco 静态和动态路由的优缺点"},{"content":"配置 Rip V2 配置 R1 enable\rconfigure terminal\rip route 0.0.0.0 0.0.0.0 s0/0/1\rrouter rip\rversion 2\rno auto-summary\rnetwork 192.168.1.0\rnetwork 192.168.2.0\rpassive-interface gig 0/0\rdefault-information originate 配置 R2 enable\rconf t\rrouter rip\rversion 2\rno auto-summary\rnetwork 192.168.2.0\rnetwork 192.168.3.0\rnetwork 192.168.4.0\rpassive-interface gig 0/0 配置 R3 enable\rconf t\rrouter rip\rversion 2\rno auto-summary\rnetwork 192.168.4.0\rnetwork 192.168.5.0\rpassive-interface gig 0/0 ","permalink":"https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE-rip-v2/","summary":"配置 Rip V2 配置 R1 enable\rconfigure terminal\rip route 0.0.0.0 0.0.0.0 s0/0/1\rrouter rip\rversion 2\rno auto-summary\rnetwork 192.168.1.0\rnetwork 192.168.2.0\rpassive-interface gig 0/0\rdefault-information originate 配置 R2 enable\rconf t\rrouter rip\rversion 2\rno auto-summary\rnetwork 192.168.2.0\rnetwork 192.168.3.0\rnetwork 192.168.4.0\rpassive-interface gig 0/0 配置 R3 enable\rconf t\rrouter rip\rversion 2\rno auto-summary\rnetwork 192.168.4.0\rnetwork 192.168.5.0\rpassive-interface gig 0/0 ","title":"Cisco 配置 Rip V2"},{"content":"配置静态路由 配置 R1 enable\rconfigure terminal\rip route 172.31.0.0 255.255.255.0 172.31.1.193\rip route 172.31.1.196 255.255.255.252 172.31.1.193\rip route 172.31.1.128 255.255.255.192 172.31.1.193 配置 R2 enable\rconfigure terminal\rip route 172.31.1.0 255.255.255.128 172.31.1.194\rip route 172.31.1.0 255.255.255.192 172.31.1.198\rip route 172.31.1.128 255.255.255.192 172.31.1.198 配置 R3 enable\rconfigure terminal\rip route 0.0.0.0 0.0.0.0 172.31.1.197 ","permalink":"https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/","summary":"配置静态路由 配置 R1 enable\rconfigure terminal\rip route 172.31.0.0 255.255.255.0 172.31.1.193\rip route 172.31.1.196 255.255.255.252 172.31.1.193\rip route 172.31.1.128 255.255.255.192 172.31.1.193 配置 R2 enable\rconfigure terminal\rip route 172.31.1.0 255.255.255.128 172.31.1.194\rip route 172.31.1.0 255.255.255.192 172.31.1.198\rip route 172.31.1.128 255.255.255.192 172.31.1.198 配置 R3 enable\rconfigure terminal\rip route 0.0.0.0 0.0.0.0 172.31.1.197 ","title":"Cisco 配置静态路由"},{"content":"路由 ipv6 unicast-routing 全局开启 IPV6 路由功能\nshow ip route static 显示该路由器路由表中的静态路由\n其他概念 PC 的默认网关必须和路由器对应接口（比如 g0/0 和 g0/1）的 ip 地址相同。\n路由表中没有目标 ip，要么丢弃 ip，要么发给默认网关\n直连网络 指的是与当前路由器直接相链接的网络。\n远程网络 对于一个路由器来说，除了直连网络之外的网络都是远程网络。\n主机位和网络位 一个 IP 地址的网络位是该地址的前三位。\n一个 IP 地址的主机位是该地址的第四位。\n当一个 IP 地址的主机位全为 0 的时候，这个 IP 地址为网络地址\n当一个 IP 地址的主机位全为 1 的时候，这个 IP 地址为广播地址\n下一跳路由 仅指定下一个目标路由器的接口的 IP 地址，也叫递归静态路由\n直连静态路由 仅指定当前路由器的送出接口的端口号\n默认静态路由 指定下一跳 IP 地址或当前路由器送出接口\nip route 0.0.0.0 0.0.0.0 192.168.1.2\rip route 0.0.0.0 0.0.0.0 s0/0/0 完全指定静态路由 指定下一跳 IP 地址和当前路由器送出接口，\nip route 0.0.0.0 0.0.0.0 192.168.1.2 s0/0/1 末节路由 指的是只有一个与之相连的路由器，\n对于一个末节路由器来说，它的默认静态路由的送出端口和下一跳的接口的 IP 地址是固定不变的。\n","permalink":"https://note.yxzi.xyz/note/technology/internet/cisco/%E8%B7%AF%E7%94%B1/","summary":"路由 ipv6 unicast-routing 全局开启 IPV6 路由功能\nshow ip route static 显示该路由器路由表中的静态路由\n其他概念 PC 的默认网关必须和路由器对应接口（比如 g0/0 和 g0/1）的 ip 地址相同。\n路由表中没有目标 ip，要么丢弃 ip，要么发给默认网关\n直连网络 指的是与当前路由器直接相链接的网络。\n远程网络 对于一个路由器来说，除了直连网络之外的网络都是远程网络。\n主机位和网络位 一个 IP 地址的网络位是该地址的前三位。\n一个 IP 地址的主机位是该地址的第四位。\n当一个 IP 地址的主机位全为 0 的时候，这个 IP 地址为网络地址\n当一个 IP 地址的主机位全为 1 的时候，这个 IP 地址为广播地址\n下一跳路由 仅指定下一个目标路由器的接口的 IP 地址，也叫递归静态路由\n直连静态路由 仅指定当前路由器的送出接口的端口号\n默认静态路由 指定下一跳 IP 地址或当前路由器送出接口\nip route 0.0.0.0 0.0.0.0 192.168.1.2\rip route 0.0.0.0 0.0.0.0 s0/0/0 完全指定静态路由 指定下一跳 IP 地址和当前路由器送出接口，","title":"Cisco 路由"},{"content":"配置 R2 进入全局模式\nenable\rconfigure terminal 故障一 no ip route 172.31.1.0 255.255.255.128 172.31.1.198\rip route 172.31.1.0 255.255.255.128 172.31.1.194 故障二 no ip route 172.31.1.128 255.255.255.192 172.31.1.194\rip route 172.31.1.128 255.255.255.192 172.31.1.198 配置 R3 进入全局模式\nenable\rconfigure terminal 故障三 ip route 172.31.1.0 255.255.255.128 172.31.1.197 ","permalink":"https://note.yxzi.xyz/note/technology/internet/cisco/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/","summary":"配置 R2 进入全局模式\nenable\rconfigure terminal 故障一 no ip route 172.31.1.0 255.255.255.128 172.31.1.198\rip route 172.31.1.0 255.255.255.128 172.31.1.194 故障二 no ip route 172.31.1.128 255.255.255.192 172.31.1.194\rip route 172.31.1.128 255.255.255.192 172.31.1.198 配置 R3 进入全局模式\nenable\rconfigure terminal 故障三 ip route 172.31.1.0 255.255.255.128 172.31.1.197 ","title":"Cisco 静态路由故障排除"},{"content":"npm npm 是Node.js的开放式模块登记和管理系统，是Node.js包的标准发布平台，用于Node.js包的发布、传播、依赖控制。\nnpm 提供了命令行工具，可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。\nNPM 官网\n安装 安装 Node.js自带 npm，所以安装 Node.js\n","permalink":"https://note.yxzi.xyz/note/technology/packagemanager/npm/npm/","summary":"npm npm 是Node.js的开放式模块登记和管理系统，是Node.js包的标准发布平台，用于Node.js包的发布、传播、依赖控制。\nnpm 提供了命令行工具，可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。\nNPM 官网\n安装 安装 Node.js自带 npm，所以安装 Node.js","title":"npm"},{"content":"为什么要使用 npm 网上的 npm 教程主要都在讲怎么安装、配置和使用 npm，却不告诉新人「为什么要使用 npm」。今天我就来讲讲这个话题。\n本文目标读者是「不太了解 npm 的新人」，大神您别看了，不然又说我啰嗦了 。\n社区 程序员自古以来就有社区文化：\n社区的意思是：拥有共同职业或兴趣的人们，自发组织在一起，通过分享信息和资源进行合作。\n虚拟社区的参与者经常会在线讨论相关话题，或访问某些网站。\n前端程序员也有社区，世界上最大的前端社区应该就是 GitHub 了。\n前端通过 GitHub ：\n 分享源代码（线上代码仓库） 讨论问题（Issue 列表） 收集学习资源和常去的网站（比如我收集的优质中文前端博客）  加入社区最大的好处之一是，你可以使用别人贡献的代码，你也可以贡献代码给别人用。\n共享代码 前端是怎么共享代码的呢？\n在 GitHub 还没有兴起的年代，前端是通过网址来共享代码\n比如你想使用 jQuery，那么你点击 jQuery 网站上提供的链接就可以下载 jQuery，放到自己的网站上使用\nGItHub 兴起之后，社区中也有人使用 GitHub 的下载功能，但这很麻烦。\n比如，当一个网站依赖的代码越来越多，程序员们发现这是一件很麻烦的事情：\n去 jQuery 官网下载 jQuery。\n去 BootStrap 官网下载 BootStrap。\n去 Underscore 官网下载 Underscore。 ……\n有些程序员就受不鸟了，一个拥有三大美德的程序员 Isaac Z. Schlueter （以下简称 Isaaz）给出一个解决方案：\n用一个工具把这些代码集中到一起来管理吧。\n这个工具就是他用 JavaScript （运行在 Node.js 上）写的 npm，全称是 Node Package Manager。\nNPM 的思路大概是这样的：\n  买个服务器作为代码仓库（registry），在里面放所有需要被共享的代码\n  发邮件通知 jQuery、Bootstrap、Underscore 作者使用 npm publish 把代码提交到 registry 上，分别取名 jquery、bootstrap 和 underscore（注意大小写）\n  社区里的其他人如果想使用这些代码，就把 jquery、bootstrap 和 underscore 写到 package.json 里，然后运行 npm install ，npm 就会帮他们下载代码\n  下载完的代码出现在 node_modules 目录里，可以随意使用了。\n  这些可以被使用的代码被叫做「包」（package），这就是 NPM 名字的由来：Node（Node.js ） Package（包） Manager（管理器）。\n发展 Isaaz 通知 jQuery 作者 John Resig，他会答应吗？这事儿不一定啊，对不对。\n只有社区里的人都觉得 「npm 是个好东西」的时候，John Resig 才会考虑使用 npm。\n那么 npm 是怎么火的呢？\nnpm 的发展是跟 Node.js 的发展相辅相成的。\nNode.js 是由一个在德国工作的美国程序员 Ryan Dahl 写的。\n他写了 Node.js，但是 Node.js 缺少一个包管理器，于是他和 npm 的作者一拍即合、抱团取暖，最终 Node.js 中就内置了 npm。\n后来的事情大家都知道，Node.js 火了。\n随着 Node.js 的火爆，大家开始用 npm 来共享 JS 代码了，于是 jQuery 作者也将 jQuery 发布到 npm 了。\n所以现在，你可以使用 npm install jquery 来下载 jQuery 代码。\n现在用 npm 来分享代码已经成了前端的标配。\n后续 Node.js 目前由 Ryan Dahl 当时所在的公司 joyent 继续开发。\nRyan Dahl 现在已经去研究 AI 和机器学习了，并且他把 Node.js 的维护权交给了 Isaaz。\n而 Isaaz 维护了一段时间后，辞职了，成立了一个公司专门维护 npm 的 registry，\n公司名叫做 npm 股份有限公司……谁说开源不能赚钱的！\n社区的力量 回顾前端的发展是你会发现，都是社区里的某个人，发布了一份代码，最终影响前端几年的走向。\n比如 jQuery，比如 Node.js，比如 npm。\n其实其他语言也是这样的。\n所以，社区的力量是巨大的。\n","permalink":"https://note.yxzi.xyz/note/technology/packagemanager/npm/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-npm-/","summary":"为什么要使用 npm 网上的 npm 教程主要都在讲怎么安装、配置和使用 npm，却不告诉新人「为什么要使用 npm」。今天我就来讲讲这个话题。\n本文目标读者是「不太了解 npm 的新人」，大神您别看了，不然又说我啰嗦了 。\n社区 程序员自古以来就有社区文化：\n社区的意思是：拥有共同职业或兴趣的人们，自发组织在一起，通过分享信息和资源进行合作。\n虚拟社区的参与者经常会在线讨论相关话题，或访问某些网站。\n前端程序员也有社区，世界上最大的前端社区应该就是 GitHub 了。\n前端通过 GitHub ：\n 分享源代码（线上代码仓库） 讨论问题（Issue 列表） 收集学习资源和常去的网站（比如我收集的优质中文前端博客）  加入社区最大的好处之一是，你可以使用别人贡献的代码，你也可以贡献代码给别人用。\n共享代码 前端是怎么共享代码的呢？\n在 GitHub 还没有兴起的年代，前端是通过网址来共享代码\n比如你想使用 jQuery，那么你点击 jQuery 网站上提供的链接就可以下载 jQuery，放到自己的网站上使用\nGItHub 兴起之后，社区中也有人使用 GitHub 的下载功能，但这很麻烦。\n比如，当一个网站依赖的代码越来越多，程序员们发现这是一件很麻烦的事情：\n去 jQuery 官网下载 jQuery。\n去 BootStrap 官网下载 BootStrap。\n去 Underscore 官网下载 Underscore。 ……\n有些程序员就受不鸟了，一个拥有三大美德的程序员 Isaac Z. Schlueter （以下简称 Isaaz）给出一个解决方案：\n用一个工具把这些代码集中到一起来管理吧。\n这个工具就是他用 JavaScript （运行在 Node.js 上）写的 npm，全称是 Node Package Manager。","title":"为什么要使用 npm"},{"content":"挑剔是一种控制人的手段 挑剔衣服的质量，可以得到更便宜的价格。\n挑剔员工的工作，可以得到更好的品质。\n女人对男人的挑剔是无处不在的。\n什么碗没洗干净啦，什么鞋子没放好啦，什么房间乱七八糟啦……\n都是些小事，但通过这些小事可以让你明白，\n不管你在外面多么人模狗样的，在家这一亩三分地，你不行，你得听我的。\n","permalink":"https://note.yxzi.xyz/note/view/bisexual/%E6%8C%91%E5%89%94%E6%98%AF%E4%B8%80%E7%A7%8D%E6%8E%A7%E5%88%B6%E4%BA%BA%E7%9A%84%E6%89%8B%E6%AE%B5/","summary":"挑剔是一种控制人的手段 挑剔衣服的质量，可以得到更便宜的价格。\n挑剔员工的工作，可以得到更好的品质。\n女人对男人的挑剔是无处不在的。\n什么碗没洗干净啦，什么鞋子没放好啦，什么房间乱七八糟啦……\n都是些小事，但通过这些小事可以让你明白，\n不管你在外面多么人模狗样的，在家这一亩三分地，你不行，你得听我的。","title":"挑剔是一种控制人的手段"},{"content":"男女之间最大的矛盾 男女之间最大的矛盾在于：\n一方面，女人想找一个各方面能力比自己强的男人；另一方面，又想要这个男人事事都顺着自己。\n这就出现了一个难题：\n一个能力弱的人如何管理一个能力强的人？\n这几乎是不可能的。\n你跑去跟老板说，我能力弱，所以你得听我的，这可能吗？\n但如果你说，你儿子在我手上，那情况就不一样了。\n所以，在男女关系中，女人一般是不讲道理的，也没法讲道理。\n就拿女人管钱这事来说，有什么道理可言？是女人更勤俭持家，还是更懂得投资理财啊，显然都不是。\n所以，最后她们只能通过，「爱我就把工资给我」，「我身边的朋友都是老婆管钱的，」这种诉诸情感，诉诸例子的方式来实现的。\n","permalink":"https://note.yxzi.xyz/note/view/bisexual/%E7%94%B7%E5%A5%B3%E4%B9%8B%E9%97%B4%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%9B%E7%9B%BE/","summary":"男女之间最大的矛盾 男女之间最大的矛盾在于：\n一方面，女人想找一个各方面能力比自己强的男人；另一方面，又想要这个男人事事都顺着自己。\n这就出现了一个难题：\n一个能力弱的人如何管理一个能力强的人？\n这几乎是不可能的。\n你跑去跟老板说，我能力弱，所以你得听我的，这可能吗？\n但如果你说，你儿子在我手上，那情况就不一样了。\n所以，在男女关系中，女人一般是不讲道理的，也没法讲道理。\n就拿女人管钱这事来说，有什么道理可言？是女人更勤俭持家，还是更懂得投资理财啊，显然都不是。\n所以，最后她们只能通过，「爱我就把工资给我」，「我身边的朋友都是老婆管钱的，」这种诉诸情感，诉诸例子的方式来实现的。","title":"男女之间最大的矛盾"},{"content":"字节流 package yxzi.xyz;  import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileReader;  public class Rainy {  public static void main(String[] args) throws Exception {  File file = new File(\u0026#34;C:\\\\Users\\\\admin\\\\Desktop\\\\java\\\\File.txt\u0026#34;); // 字节输入流  FileInputStream wj = new FileInputStream(file);  // 字节输出流  FileOutputStream outinput = new FileOutputStream(\u0026#34;C:\\\\Users\\\\admin\\\\Desktop\\\\java\\\\副本.txt\u0026#34;);  // 创建一个字符数组---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  byte arr[] = new byte[1024];  int len = wj.read(arr);  while (len != -1) { // String data = new String(arr); //// System.out.println(data);  len = wj.read(arr);  outinput.write(arr);  outinput.flush();  }  } } 字符流 package yxzi.xyz;  import java.io.File; import java.io.FileReader; import java.io.FileWriter;  public class Rainy {  public static void main(String[] args) throws Exception {  File file = new File(\u0026#34;C:\\\\Users\\\\admin\\\\Desktop\\\\java\\\\File.txt\u0026#34;);   File file2 = new File(\u0026#34;C:\\\\Users\\\\admin\\\\Desktop\\\\java\\\\追加的.txt\u0026#34;);  // 字符输入流  FileReader wj = new FileReader(file); // 输入追加的  FileReader wj2 = new FileReader(file2);  // 字符输出流  FileWriter wirte = new FileWriter(\u0026#34;C:\\\\Users\\\\admin\\\\Desktop\\\\java\\\\副本.txt\u0026#34;); // 输出追加的  FileWriter wirte2 = new FileWriter(\u0026#34;C:\\\\Users\\\\admin\\\\Desktop\\\\java\\\\副本.txt\u0026#34;, true);   // 创建一个字符数组---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  char[] arr = new char[1024]; // 創建第二個字符數組  char[] arr2 = new char[1024];   String data = new String(arr);  System.out.println(data);  wj.read(arr);  wj2.read(arr2); //第一次写入  wirte.write(arr); // 追加写入  wirte2.write(arr2); //清除缓存  wirte.flush();  wirte2.flush();   } } ","permalink":"https://note.yxzi.xyz/note/technology/language/java/%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81/","summary":"字节流 package yxzi.xyz;  import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileReader;  public class Rainy {  public static void main(String[] args) throws Exception {  File file = new File(\u0026#34;C:\\\\Users\\\\admin\\\\Desktop\\\\java\\\\File.txt\u0026#34;); // 字节输入流  FileInputStream wj = new FileInputStream(file);  // 字节输出流  FileOutputStream outinput = new FileOutputStream(\u0026#34;C:\\\\Users\\\\admin\\\\Desktop\\\\java\\\\副本.txt\u0026#34;);  // 创建一个字符数组---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  byte arr[] = new byte[1024];  int len = wj.read(arr);  while (len != -1) { // String data = new String(arr); //// System.","title":"Java 字符流和字节流"},{"content":"遍历集合 package Yxzi;  import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator;  public class Test {  public static void main(String[] args) throws Exception {  ArrayList \u0026lt;Student\u0026gt; arr = new ArrayList();   Student obj1 = new Student(\u0026#34;小明\u0026#34;, 23);  Student obj2 = new Student(\u0026#34;小红\u0026#34;, 18);  Student obj3 = new Student(\u0026#34;小花\u0026#34;, 13);  Student obj4 = new Student(\u0026#34;小黑\u0026#34;, 11);  Student obj5 = new Student(\u0026#34;小白\u0026#34;, 23);   arr.add(obj1);  arr.add(obj2);  arr.add(obj3);  arr.add(obj4);  arr.add(obj5);  // 遍历集合方法一 // for(Object obj : arr){ // System.out.println(obj); // } // 遍历集合方法二 // for(int i = 0; i \u0026lt; arr.size(); i++){ // System.out.println(\u0026#34;姓名：\u0026#34; +arr.get(i).name + \u0026#34; 年龄：\u0026#34;+ arr.get(i).name); // } // 遍历集合方法三 // Iterator\u0026lt;Student\u0026gt; it = arr.iterator(); // while (it.hasNext()){ // try { // System.out.println(\u0026#34;姓名：\u0026#34; + it.next().name + \u0026#34; 年龄：\u0026#34;+ it.next().age); // } catch (Exception e) { // System.out.println(\u0026#34;异常了\u0026#34;); // } finally { // } // }   HashMap hs = new HashMap();  hs.put(\u0026#34;1\u0026#34;,\u0026#34;一号位\u0026#34;);  hs.put(\u0026#34;2\u0026#34;,\u0026#34;二号位\u0026#34;);  hs.put(\u0026#34;3\u0026#34;,null);  System.out.println(hs.get(\u0026#34;1\u0026#34;));  System.out.println(hs.get(\u0026#34;2\u0026#34;));  System.out.println(hs.get(\u0026#34;3\u0026#34;));     } } ","permalink":"https://note.yxzi.xyz/note/technology/language/java/%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88/","summary":"遍历集合 package Yxzi;  import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator;  public class Test {  public static void main(String[] args) throws Exception {  ArrayList \u0026lt;Student\u0026gt; arr = new ArrayList();   Student obj1 = new Student(\u0026#34;小明\u0026#34;, 23);  Student obj2 = new Student(\u0026#34;小红\u0026#34;, 18);  Student obj3 = new Student(\u0026#34;小花\u0026#34;, 13);  Student obj4 = new Student(\u0026#34;小黑\u0026#34;, 11);  Student obj5 = new Student(\u0026#34;小白\u0026#34;, 23);   arr.add(obj1);  arr.","title":"Java 遍历集合"},{"content":"文字样式 fontSize: 11, color: \u0026#34;#eee\u0026#34;, textShadowColor: \u0026#34;rgba(0, 0, 0, 1)\u0026#34;, textShadowBlur: 10, textShadowOffsetX: 1, textShadowOffsetY: 1, 图形样式 barBorderRadius: 2, shadowColor: \u0026#34;rgba(0, 0 0, 0.3)\u0026#34;, shadowBlur: 3, shadowOffsetX: 1, shadowOffsetY: 1, ","permalink":"https://note.yxzi.xyz/note/technology/storehouse/echarts/%E6%96%87%E5%AD%97%E6%A0%B7%E5%BC%8F/","summary":"文字样式 fontSize: 11, color: \u0026#34;#eee\u0026#34;, textShadowColor: \u0026#34;rgba(0, 0, 0, 1)\u0026#34;, textShadowBlur: 10, textShadowOffsetX: 1, textShadowOffsetY: 1, 图形样式 barBorderRadius: 2, shadowColor: \u0026#34;rgba(0, 0 0, 0.3)\u0026#34;, shadowBlur: 3, shadowOffsetX: 1, shadowOffsetY: 1, ","title":"Echarts 文字样式"},{"content":"快速使用 Echarts // 快速使用 Echcarts (function () { \t// 1. 实例化对象 \tvar myChart = echarts.init(document.querySelector(\u0026#39;\u0026#39;)); \t// 2.配置  \t// 3. 把配置给实例对象 \tmyChart.setOption(option); \t// 4. 让图表跟随屏幕自动的去适应 \twindow.addEventListener(\u0026#39;resize\u0026#39;, function () { \tmyChart.resize(); \t}); })(); ","permalink":"https://note.yxzi.xyz/note/technology/storehouse/echarts/%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/","summary":"快速使用 Echarts // 快速使用 Echcarts (function () { \t// 1. 实例化对象 \tvar myChart = echarts.init(document.querySelector(\u0026#39;\u0026#39;)); \t// 2.配置  \t// 3. 把配置给实例对象 \tmyChart.setOption(option); \t// 4. 让图表跟随屏幕自动的去适应 \twindow.addEventListener(\u0026#39;resize\u0026#39;, function () { \tmyChart.resize(); \t}); })(); ","title":"快速使用 Echarts"},{"content":"练字技巧 同字不同书，笔画都是有变化的\n练字期间使用米子格或田字格的纸，不能脱离格子，因为格子是规范，是辅助线\n临帖\n仔细观察原帖的辅助线\n起笔——运笔-收笔\n","permalink":"https://note.yxzi.xyz/note/technology/writing/%E7%BB%83%E5%AD%97%E6%8A%80%E5%B7%A7/","summary":"练字技巧 同字不同书，笔画都是有变化的\n练字期间使用米子格或田字格的纸，不能脱离格子，因为格子是规范，是辅助线\n临帖\n仔细观察原帖的辅助线\n起笔——运笔-收笔","title":"练字技巧"},{"content":"遇到的错误 今天使用 Echarts 绘制地图时，浏览器控制台出现以下错误：\nUncaught DOMException: Failed to execute \u0026#39;drawImage\u0026#39; on \u0026#39;CanvasRenderingContext2D\u0026#39;: The image argument is a canvas element with a width or height of 0. 如何解决\n只需要给需要被绘制的元素设置width和height Css 属性即可。\n","permalink":"https://note.yxzi.xyz/note/technology/storehouse/echarts/%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/","summary":"遇到的错误 今天使用 Echarts 绘制地图时，浏览器控制台出现以下错误：\nUncaught DOMException: Failed to execute \u0026#39;drawImage\u0026#39; on \u0026#39;CanvasRenderingContext2D\u0026#39;: The image argument is a canvas element with a width or height of 0. 如何解决\n只需要给需要被绘制的元素设置width和height Css 属性即可。","title":"Echarts 遇到的错误"},{"content":"地图 常用配置 地图样式 配置 option —\u0026gt; geo —\u0026gt; itemStyle 下的normal .\nnormal: {  //面积区域颜色  areaColor: \u0026#34;#008C8C\u0026#34;,  // 区域分界线颜色  borderColor: \u0026#34;rgba(43, 196, 243, 1)\u0026#34;,  //区域分界线  borderWidth: 1 }, ","permalink":"https://note.yxzi.xyz/note/technology/storehouse/echarts/%E5%9C%B0%E5%9B%BE/","summary":"地图 常用配置 地图样式 配置 option —\u0026gt; geo —\u0026gt; itemStyle 下的normal .\nnormal: {  //面积区域颜色  areaColor: \u0026#34;#008C8C\u0026#34;,  // 区域分界线颜色  borderColor: \u0026#34;rgba(43, 196, 243, 1)\u0026#34;,  //区域分界线  borderWidth: 1 }, ","title":"Echarts 地图"},{"content":"Less \u0026amp; 使用 在类前面添加了\u0026amp;之后，编译之后的 css 变为且的关系，而没有使用\u0026amp;的 css 是父子的关系\n\u0026amp; 符号可以表示对父选择器的引用。 在一个内层选择器的前面，如果没有 \u0026amp; 符号，则这个内层选择器会被解析为父选择器的后代。\n如果内层选择器前面有一个 \u0026amp; 符号，则内层选择器会被解析为父选择器自身或父选择器的伪类。\nLess 代码 .mainbox {\rdisplay: flex;\rmin-width: 1024px;\rmax-width: 1920px;\rmargin: 0 auto;\rpadding: 0.125rem 0 0.125rem 0;\r.column {\rbackground-color: yellowgreen;\rflex: 3;\r\u0026amp;:nth-child(2) {\rflex: 5;\r}\r}\r} 解析后的 Css 代码 .mainbox .column:nth-child(2) { \tflex: 5; } 去掉 \u0026amp; 后的 Css 代码 .mainbox .column :nth-child(2) { \tflex: 5; } ","permalink":"https://note.yxzi.xyz/note/technology/language/css/less/-%E7%AC%A6%E5%8F%B7/","summary":"Less \u0026amp; 使用 在类前面添加了\u0026amp;之后，编译之后的 css 变为且的关系，而没有使用\u0026amp;的 css 是父子的关系\n\u0026amp; 符号可以表示对父选择器的引用。 在一个内层选择器的前面，如果没有 \u0026amp; 符号，则这个内层选择器会被解析为父选择器的后代。\n如果内层选择器前面有一个 \u0026amp; 符号，则内层选择器会被解析为父选择器自身或父选择器的伪类。\nLess 代码 .mainbox {\rdisplay: flex;\rmin-width: 1024px;\rmax-width: 1920px;\rmargin: 0 auto;\rpadding: 0.125rem 0 0.125rem 0;\r.column {\rbackground-color: yellowgreen;\rflex: 3;\r\u0026amp;:nth-child(2) {\rflex: 5;\r}\r}\r} 解析后的 Css 代码 .mainbox .column:nth-child(2) { \tflex: 5; } 去掉 \u0026amp; 后的 Css 代码 .mainbox .column :nth-child(2) { \tflex: 5; } ","title":"Less \u0026 使用"},{"content":"嵌套 #header { \tcolor: black; } #header .navigation { \tfont-size: 12px; } #header .logo { \twidth: 300px; } 用 less 可以这样书写：\n#header {\rcolor: black;\r.navigation {\rfont-size: 12px;\r}\r.logo {\rwidth: 300px;\r}\r} \u0026amp; 在选择器前面添加了 \u0026amp; ，表示与父元素是并且关系，而没有使用\u0026amp;的 css 是父子的关系。\n\u0026amp; 符号可以表示对父选择器的引用。 在一个内层选择器的前面，如果没有\u0026amp;符号，则这个内层选择器会被编译为父选择器的后代。\n如果内层选择器到前面有一个\u0026amp;符号，则内层选择器会被编译为父选择器自身或父选择器的伪类、伪元素等。\ndiv {\rwidth: 100px;\rheight: 100px;\rbackground-color: firebrick;\r.indiv {\rwidth: 50px;\rheight: 50px;\rbackground-color: salmon;\r\u0026amp;:hover {\rbackground-color: aquamarine;\r}\r}\r} 被编译为：\ndiv .indiv:hover { \tbackground-color: aquamarine; } 去掉 \u0026amp; 后：\n如果不加\u0026amp;，表示 indiv 与 hover 是父子关系，这就会导致最后的编译结果div .indiv :hover，很明显，多了一个空格而导致 hover 效果无法被正常的应用。\ndiv .indiv :hover { \tbackground-color: aquamarine; } ","permalink":"https://note.yxzi.xyz/note/technology/language/css/less/%E5%B5%8C%E5%A5%97/","summary":"嵌套 #header { \tcolor: black; } #header .navigation { \tfont-size: 12px; } #header .logo { \twidth: 300px; } 用 less 可以这样书写：\n#header {\rcolor: black;\r.navigation {\rfont-size: 12px;\r}\r.logo {\rwidth: 300px;\r}\r} \u0026amp; 在选择器前面添加了 \u0026amp; ，表示与父元素是并且关系，而没有使用\u0026amp;的 css 是父子的关系。\n\u0026amp; 符号可以表示对父选择器的引用。 在一个内层选择器的前面，如果没有\u0026amp;符号，则这个内层选择器会被编译为父选择器的后代。\n如果内层选择器到前面有一个\u0026amp;符号，则内层选择器会被编译为父选择器自身或父选择器的伪类、伪元素等。\ndiv {\rwidth: 100px;\rheight: 100px;\rbackground-color: firebrick;\r.indiv {\rwidth: 50px;\rheight: 50px;\rbackground-color: salmon;\r\u0026amp;:hover {\rbackground-color: aquamarine;\r}\r}\r} 被编译为：","title":"Less 嵌套"},{"content":"混合 将一个包含一组属性的规则集引入到另一个规则集的方式。\n普通混合 当 less 编译成 css，混合规则集也会被编译到 css 中。这会导致 css 文件过大。\n// .MixColor 会被编译到 css 文件中\r.MixColor {\rwidth: 100px;\rheight: 100px;\rbackground-color: #008c8c;\r}\r.wrap {\rwidth: 200px;\rheight: 200px;\rbackground-color: firebrick;\r.indiv {\r.MixColor;\r}\r.indiv2 {\r.MixColor;\r}\r} 为混合规则集加上()，则混合规则集不会被编译到 css 中。\n//.MixColor 会被编译到 css 文件中\r.MixColor() {\rwidth: 100px;\rheight: 100px;\rbackground-color: #008c8c;\r}\r.wrap {\rwidth: 200px;\rheight: 200px;\rbackground-color: firebrick;\r.indiv {\r.MixColor;\r}\r.indiv2 {\r.MixColor;\r}\r} 参数混合 顾名思义，带有参数的混合。\n参数值需按定义参数名的顺序书写。\n.MixColor(@w,@h,@c) {\rwidth: @w;\rheight: @h;\rbackground-color: @c;\r}\r.wrap {\rwidth: 200px;\rheight: 200px;\rbackground-color: firebrick;\r.indiv {\r// 按参数顺序依次传入对应参数\r.MixColor(5rem,5rem,pink);\r}\r.indiv2 {\r.MixColor(4rem,4rem,rgb(214, 214, 214));\r}\r} 带有默认值的参数混合 定义一个带参数的混合规则集，如果使用该规则集的时候，若没有传入相应的参数，则使用规则集中定义当默认的参数。\n参数值需按定义参数名的顺序书写。\n.MixColor(@w:5rem,@h:5rem,@c:#008c8c) {\rwidth: @w;\rheight: @h;\rbackground-color: @c;\r}\r.wrap {\rwidth: 200px;\rheight: 200px;\rbackground-color: firebrick;\r.indiv {\r// 没有传参，则使用默认参数\r.MixColor();\r}\r.indiv2 {\r.MixColor();\r}\r} 命名混合 传入参数值的时候，将参数的名字也书写进去@Nmae:Value。\n这样，就可以让系统知晓传入的参数值所对应的是哪个参数名。\n.MixColor(@w:5rem,@h:5rem,@c:#008c8c) {\rwidth: @w;\rheight: @h;\rbackground-color: @c;\r}\r.wrap {\rwidth: 200px;\rheight: 200px;\rbackground-color: firebrick;\r.indiv {\r.MixColor(@c:pink);\r}\r.indiv2 {\r.MixColor();\r}\r} 匹配模式 @_会根据传入给当前混合的不同参数，将不同的规则集混入当前混合，以此改变最后的所得到规则集。\n比如变化三角形的四个方向：上、左、下、右。\n// 定义三角形科恩那个的情况\r// @_ 会匹配下方不同参数的规则集，\r// 将不同的规则集混入当前规则集\r.triangle(@_,@b,@c) {\rwidth: 0;\rheight: 0;\rborder-style: dashed;\rdisplay: inline-block;\r}\r// 定义三角形科恩那个的情况：分别朝向四个方向\r.triangle(T,@b,@c) {\rborder-width: @b;\rborder-color: transparent transparent @c transparent;\r}\r.triangle(B,@b,@c) {\rborder-width: @b;\rborder-color: @c transparent transparent transparent;\r}\r.triangle(R,@b,@c) {\rborder-width: @b;\rborder-color: transparent transparent transparent @c;\r}\r.triangle(L,@b,@c) {\rborder-width: @b;\rborder-color: transparent @c transparent transparent;\r}\r// 使用混合规则即，第一个参数定义了三角形的四个方向\r// 它有四个值：T、L、B、R\r.wrap {\r.triangle(T,100px,#008c8c);\r} arguments 将多个的简写属性值直接用@arguments来表示：\n.border(@one,@two,@three) {\rborder: @arguments;\r}\r.wrap {\rwidth: 100px;\rheight: 100px;\r.border(1px, solid, #000);\r} ","permalink":"https://note.yxzi.xyz/note/technology/language/css/less/%E6%B7%B7%E5%90%88/","summary":"混合 将一个包含一组属性的规则集引入到另一个规则集的方式。\n普通混合 当 less 编译成 css，混合规则集也会被编译到 css 中。这会导致 css 文件过大。\n// .MixColor 会被编译到 css 文件中\r.MixColor {\rwidth: 100px;\rheight: 100px;\rbackground-color: #008c8c;\r}\r.wrap {\rwidth: 200px;\rheight: 200px;\rbackground-color: firebrick;\r.indiv {\r.MixColor;\r}\r.indiv2 {\r.MixColor;\r}\r} 为混合规则集加上()，则混合规则集不会被编译到 css 中。\n//.MixColor 会被编译到 css 文件中\r.MixColor() {\rwidth: 100px;\rheight: 100px;\rbackground-color: #008c8c;\r}\r.wrap {\rwidth: 200px;\rheight: 200px;\rbackground-color: firebrick;\r.indiv {\r.MixColor;\r}\r.","title":"Less 混合"},{"content":"域服务器 父域一\n父域二\n子域三\n成员四\n9 月 30 号 vmware\nOne\n大规模联网用域\n小规模联网用组\n更大的规模用林\n打开 one，和 two，three，fou\n更改计算机属性 - 重命名计算机名\n设置密码和用户名\n设置 ipv4 属性\nOne\nip 192.168.10.1，255.255.255.0，192.168.10.1\nDns 127.0.0.1，变为 192.168.10.1\nTwo\nip 地址 192.168.10.2，255.255.255.0，192.168.10.1\nDns 192.168.10.1 变为 192.168.10.2 备用 dns 192.168.10.1\nThree\nip 192.168.10.3，255.255.255.0，192.168.10.1\nDns 192.168.10.1\nFour\nip 192.168.10.4，255.255.255.0，192.168.10.1\nDns 192.168.10.1\n选择 one\n服务器管理 - 添加角色 - 服务器角色\n勾选 dns 服务器 和 active directory 服务，安装完成后重启\n管理工具\n本地安全策略 账户策略 密码策略 密码必须符合复杂性要求 禁用\n虚拟机命令行输入\nnet user userName /passwordreq:yes\n提升为域服务器\n部署配置\n添加新林，根域名 yxzi.xyz\n域控制器选项\n林功能级别和域功能级别保持默认\n设置还原模式的密码\nDns 选项，不管，下一步\nnetbios 域名设置为 yxzi\n路径，保持默认\n查看选项，保持默认\n先决条件检查\n重启登录\n用户和计算机\nTwo\n更改 sid\nwindows，system32 ，sysprep，右击用管理员身份运行\n选择通用，确定\n重启\n添加角色 域服务器和 dns 之后\n虚拟机命令行输入\nnet user userName /passwordreq:yes\n部署配置 将新域添加到现有林\n子域\n父域 yxzi.xyz\n新域名 zxy\nyxzi\n点击选择\n提供执行此操作所需的凭据\n用户名 yxzi\\One\n密码\n域控制器管理 勾选全局编录\n设置还原密码\ndns 下一步\n其他选项 指定 one\n路径，查看选项 默认下一步\n检查，重启\n重启\n打开 Two\n服务器管理，工具，\n域和信任区\ndns 正向查找区域\n打开 Three 和 four\n关机后在虚拟机配置文件 vmx 后缀中加入\nhypervisor.cpuid.v0 = “FALSE”\nmce.enable = “TRUE”\n安装 hyper v\n计算机属性 计算机域更改 隶属于 yxzi\n用户名\nyxzi\\One\n密码\n重启\n打开第三台的 hyper v 右击 hyper v 管理器\n在第一台的计算机管理 computer 可以看到 three\n运行 four\n打开 three 的 服务器管理面板，hyper v，右击 hyper v 管理器\n右击链接到服务器\n在第一次导入虚拟机\n","permalink":"https://note.yxzi.xyz/note/technology/windows-server/win-server-%E5%9F%9F%E6%9C%8D%E5%8A%A1%E5%99%A8/","summary":"域服务器 父域一\n父域二\n子域三\n成员四\n9 月 30 号 vmware\nOne\n大规模联网用域\n小规模联网用组\n更大的规模用林\n打开 one，和 two，three，fou\n更改计算机属性 - 重命名计算机名\n设置密码和用户名\n设置 ipv4 属性\nOne\nip 192.168.10.1，255.255.255.0，192.168.10.1\nDns 127.0.0.1，变为 192.168.10.1\nTwo\nip 地址 192.168.10.2，255.255.255.0，192.168.10.1\nDns 192.168.10.1 变为 192.168.10.2 备用 dns 192.168.10.1\nThree\nip 192.168.10.3，255.255.255.0，192.168.10.1\nDns 192.168.10.1\nFour\nip 192.168.10.4，255.255.255.0，192.168.10.1\nDns 192.168.10.1\n选择 one\n服务器管理 - 添加角色 - 服务器角色\n勾选 dns 服务器 和 active directory 服务，安装完成后重启\n管理工具\n本地安全策略 账户策略 密码策略 密码必须符合复杂性要求 禁用","title":"域服务器"},{"content":"Echarts 折线图 图表类型 在series下配置type.\ntype: \u0026#39;line\u0026#39;, 常用配置 标注图表区域 标记图表中某个范围的数据。\n在series下配置markArea\nmarkArea: {  data: [  [  {  xAxis: \u0026#39;李宁\u0026#39;  },  {  xAxis: \u0026#39;安踏\u0026#39;  }  ],  [  {  xAxis: \u0026#39;耐克\u0026#39;   },  {  xAxis: \u0026#39;阿迪\u0026#39;  }  ],  ], }, 线条是否平滑显示 在series下配置smooth\nsmooth: true, 线条样式 在series下配置lineStyle\nlineStyle: {  color: \u0026#39;red\u0026#39;,  type: \u0026#39;dashed\u0026#39; } 线条区域样式 在series下配置areaStyle\nareaStyle: {  color: \u0026#39;green\u0026#39; } ","permalink":"https://note.yxzi.xyz/note/technology/storehouse/echarts/%E6%8A%98%E7%BA%BF%E5%9B%BE/","summary":"Echarts 折线图 图表类型 在series下配置type.\ntype: \u0026#39;line\u0026#39;, 常用配置 标注图表区域 标记图表中某个范围的数据。\n在series下配置markArea\nmarkArea: {  data: [  [  {  xAxis: \u0026#39;李宁\u0026#39;  },  {  xAxis: \u0026#39;安踏\u0026#39;  }  ],  [  {  xAxis: \u0026#39;耐克\u0026#39;   },  {  xAxis: \u0026#39;阿迪\u0026#39;  }  ],  ], }, 线条是否平滑显示 在series下配置smooth\nsmooth: true, 线条样式 在series下配置lineStyle\nlineStyle: {  color: \u0026#39;red\u0026#39;,  type: \u0026#39;dashed\u0026#39; } 线条区域样式 在series下配置areaStyle","title":"Echarts 折线图"},{"content":"Echarts 柱状图 特点 柱状图描述的是分类数据，呈现的是每一个分类中有多少，\n通过柱状图，可以很清晰的看出每个分类数据的排名情况。\n基本结构 引入 echarts.js 文件, DOM 容器，初始化对象，设置 option。\nvar myChart = echarts.init(document.getElementById(\u0026#39;main\u0026#39;)); var xArr = [\u0026#39;李宁\u0026#39;, \u0026#39;安踏\u0026#39;, \u0026#39;耐克\u0026#39;] var yArr = [30, 25, 55] var option = {  title: {  text: \u0026#39;运动品牌科技水平\u0026#39;,  link: \u0026#39;https://yxzi.xyz/\u0026#39;  }, }; myChart.setOption(option) X 轴数据 在option下配置 X 轴类型和数据。\nxAxis: {  type: \u0026#39;category\u0026#39;,  data: xArr }, Y 轴数据 在option下配置 Y 轴的类型。\nyAxis: {  type: \u0026#39;value\u0026#39;, }, 图表类型 在series下配置type.\n柱状图 type: \u0026#39;bar\u0026#39;, 常用配置 最大与最小值值 在series下配置markPoint.\nmarkPoint: {  data: [  {  type: \u0026#34;max\u0026#34;, name: \u0026#34;最大值\u0026#34;  },  {  type: \u0026#34;min\u0026#34;, name: \u0026#34;最小值\u0026#34;  }  ] }, 平均值 在series下配置markLine.\nmarkLine: {  data: [  {  type: \u0026#34;average\u0026#34;, name: \u0026#34;平均值\u0026#34;  },  ] }, 数值显示及其样式 在series下配置label.\nlabel: {  show: true,  rotate: \u0026#39;45\u0026#39;,  position: \u0026#39;left\u0026#39;, }, 柱的宽度 在series下配置barWidth.\nbarWidth: \u0026#34;20%\u0026#34;, 横向柱状图 修改option下的yAxis和xAxis.\nxAxis: {  type: \u0026#39;value\u0026#39;,  }, yAxis: {  type: \u0026#39;category\u0026#39;,  data: xArr }, ","permalink":"https://note.yxzi.xyz/note/technology/storehouse/echarts/%E6%9F%B1%E7%8A%B6%E5%9B%BE/","summary":"Echarts 柱状图 特点 柱状图描述的是分类数据，呈现的是每一个分类中有多少，\n通过柱状图，可以很清晰的看出每个分类数据的排名情况。\n基本结构 引入 echarts.js 文件, DOM 容器，初始化对象，设置 option。\nvar myChart = echarts.init(document.getElementById(\u0026#39;main\u0026#39;)); var xArr = [\u0026#39;李宁\u0026#39;, \u0026#39;安踏\u0026#39;, \u0026#39;耐克\u0026#39;] var yArr = [30, 25, 55] var option = {  title: {  text: \u0026#39;运动品牌科技水平\u0026#39;,  link: \u0026#39;https://yxzi.xyz/\u0026#39;  }, }; myChart.setOption(option) X 轴数据 在option下配置 X 轴类型和数据。\nxAxis: {  type: \u0026#39;category\u0026#39;,  data: xArr }, Y 轴数据 在option下配置 Y 轴的类型。\nyAxis: {  type: \u0026#39;value\u0026#39;, }, 图表类型 在series下配置type.","title":"Echarts 柱状图"},{"content":"Echarts 通用配置 title 图表的标题。\n标题的样式 在title下配置textStyle、\ntextStyle: {  color: \u0026#39;#008c8c\u0026#39;, }, 标题的边框 在title下配置：\nborderWidth: 5, borderColor: \u0026#39;#008c8c\u0026#39;, borderRadius: 3, 标题的位置 在title下配置：\nleft: 10, top: 20, tooltip 提示框组件\n用于配置鼠标滑过或点击图表时的提示框。\n显示框的触发范围 在tooltip下配置trigger\ntrigger: \u0026#39;axis\u0026#39;, 显示框触发方式 在tooltip下配置triggerOn\ntriggerOn: \u0026#39;click \u0026#39;, 自定义提示框内容 字符串模板\nformatter: \u0026#39;{b} 的科技水平是 {c}\u0026#39; 回调函数\nformatter: function (arg) {  return arg[0].name + \u0026#39;的运动科技水平是\u0026#39; + arg[0].data } toolbox 图表的工具栏。\n打开工具栏配置项 feature: { } 导出图片 以图片的形式导出图表\nsaveAsImage: {}, 数据视图工具 可以展现当前图表所用的数据，编辑后可以动态更新。\ndataView: {}, 还原所有配置项 restore: {}, 数据区域的缩放 dataZoom: {}, 图表类型的动态切换 magicType: { \ttype: [\u0026#39;bar\u0026#39;, \u0026#39;line\u0026#39;]; } legend 图表的图例组件。它展现了不同系列所对应不同的颜色和名字。可以通过点击某个图例来控制对应的系列显示与否。\n增加系列 准备另外一组系列的数据。\nvar yArr2 = [30, 20, 84] 在series配置：\n{  name: \u0026#39;跑鞋知名度\u0026#39;,  type: \u0026#39;bar\u0026#39;,  data: yArr2, } 在option下配置legend\ndata 数组中的每个字符串必须与 series 下对象的某个 name 属性相匹配，否则无法显示图例。\nseries 里面有了 name 值则 legend 里面的 data 可以删掉。\nlegend: {  data: [\u0026#39;跑鞋科技水平\u0026#39;, \u0026#39;跑鞋知名度\u0026#39;] }, ","permalink":"https://note.yxzi.xyz/note/technology/storehouse/echarts/%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE/","summary":"Echarts 通用配置 title 图表的标题。\n标题的样式 在title下配置textStyle、\ntextStyle: {  color: \u0026#39;#008c8c\u0026#39;, }, 标题的边框 在title下配置：\nborderWidth: 5, borderColor: \u0026#39;#008c8c\u0026#39;, borderRadius: 3, 标题的位置 在title下配置：\nleft: 10, top: 20, tooltip 提示框组件\n用于配置鼠标滑过或点击图表时的提示框。\n显示框的触发范围 在tooltip下配置trigger\ntrigger: \u0026#39;axis\u0026#39;, 显示框触发方式 在tooltip下配置triggerOn\ntriggerOn: \u0026#39;click \u0026#39;, 自定义提示框内容 字符串模板\nformatter: \u0026#39;{b} 的科技水平是 {c}\u0026#39; 回调函数\nformatter: function (arg) {  return arg[0].name + \u0026#39;的运动科技水平是\u0026#39; + arg[0].data } toolbox 图表的工具栏。\n打开工具栏配置项 feature: { } 导出图片 以图片的形式导出图表\nsaveAsImage: {}, 数据视图工具 可以展现当前图表所用的数据，编辑后可以动态更新。\ndataView: {}, 还原所有配置项 restore: {}, 数据区域的缩放 dataZoom: {}, 图表类型的动态切换 magicType: { \ttype: [\u0026#39;bar\u0026#39;, \u0026#39;line\u0026#39;]; } legend 图表的图例组件。它展现了不同系列所对应不同的颜色和名字。可以通过点击某个图例来控制对应的系列显示与否。","title":"Echarts 通用配置"},{"content":"域服务器的基本操作 克隆 2008\n打开 ad 01\n新建用户\n点击新建的用户\n隶属于\n添加一个\n将 2012 升级为域控\n添加一个子用户，但无法使用这个用户名登录域服务器\n设置\n192.168.1.1\n255.255.255.0\n网关 192.168.1.1\n配置 2008\n控制面板\n网络链接\n设置 ip\n192.168.1.50\n255.255.255.0\n192.168.1.1\n192.168.1.1\n更改计算机名字\n加入域\nyxzi\\user02（2012 域控上添加的用户）\n在 2008 上面用 user02 这个用户名登录到域控\n打开 ad 01\nuser 02 属性\n账户，登录时间\n新建 用户 user03\n选择 user03 属性\n配置登录名和密码\n指定计算机才能登录\n登录到，输入 ad 02 的计算机名\nad1 新建组 ts01\n添加到组，选择 user02\n选择 user03，隶属于，\nts 属性 用户，即可看到\n新建 组织单位 danwei\n组织单位的属性 防止意外删除\n","permalink":"https://note.yxzi.xyz/note/technology/windows-server/%E5%9F%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","summary":"域服务器的基本操作 克隆 2008\n打开 ad 01\n新建用户\n点击新建的用户\n隶属于\n添加一个\n将 2012 升级为域控\n添加一个子用户，但无法使用这个用户名登录域服务器\n设置\n192.168.1.1\n255.255.255.0\n网关 192.168.1.1\n配置 2008\n控制面板\n网络链接\n设置 ip\n192.168.1.50\n255.255.255.0\n192.168.1.1\n192.168.1.1\n更改计算机名字\n加入域\nyxzi\\user02（2012 域控上添加的用户）\n在 2008 上面用 user02 这个用户名登录到域控\n打开 ad 01\nuser 02 属性\n账户，登录时间\n新建 用户 user03\n选择 user03 属性\n配置登录名和密码\n指定计算机才能登录\n登录到，输入 ad 02 的计算机名\nad1 新建组 ts01\n添加到组，选择 user02\n选择 user03，隶属于，\nts 属性 用户，即可看到\n新建 组织单位 danwei","title":"域服务器的基本操作"},{"content":"const 声明一个常量（一旦声明就无法被修改的量）。\n声明时必须赋初始值，声明时使用大写。\n常量无法被修改。\n块级作用域。\n使用const声明的对象和数组，可以修改其属性或元素，因为常量所指向的引用地址并没有改变。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/const/","summary":"const 声明一个常量（一旦声明就无法被修改的量）。\n声明时必须赋初始值，声明时使用大写。\n常量无法被修改。\n块级作用域。\n使用const声明的对象和数组，可以修改其属性或元素，因为常量所指向的引用地址并没有改变。","title":"JavaScrip const"},{"content":"var、let、count 使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象；\n使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；\n使用const声明的是常量，在后面出现的代码中不能再修改该常量的值。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/varletcount/","summary":"var、let、count 使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象；\n使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；\n使用const声明的是常量，在后面出现的代码中不能再修改该常量的值。","title":"JavaScrip var、let、count"},{"content":"结构赋值 结构赋值就是从数组和对象中提取自己想要的变量，然后进行赋值。\n数组 将数组中的元素，依次赋给变量。\nconst arr = [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;]; let [a, b, c, d] = arr; console.log(a); console.log(b); console.log(c); console.log(d); 对象 将对象中的属性或方法依次赋给变量。\nconst obj = { \tname: \u0026#39;rainy\u0026#39;, \tage: 21, \tfun() { \tconsole.log(\u0026#39;method called\u0026#39;); \t}, };  let { name, age, fun } = obj; console.log(name); console.log(age); fun(); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/","summary":"结构赋值 结构赋值就是从数组和对象中提取自己想要的变量，然后进行赋值。\n数组 将数组中的元素，依次赋给变量。\nconst arr = [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;]; let [a, b, c, d] = arr; console.log(a); console.log(b); console.log(c); console.log(d); 对象 将对象中的属性或方法依次赋给变量。\nconst obj = { \tname: \u0026#39;rainy\u0026#39;, \tage: 21, \tfun() { \tconsole.log(\u0026#39;method called\u0026#39;); \t}, };  let { name, age, fun } = obj; console.log(name); console.log(age); fun(); ","title":"JavaScrip 结构赋值"},{"content":"为什么人们不喜欢被批评 这不是剂量问题，这是性质问题。\n批评有一条细细的、意识几乎难以觉察、人常常不愿接受的红线：\n批评只能给逻辑、给疑问、给论证，不可以讽刺，不可以定罪，更不可以用作构陷的工具。\n比如：\n有人给车换轮胎没放好千斤顶。\n“换胎必须先把千斤顶放好，否则会 xxx”、“放好千斤顶的标准是 xxxx，你这样做在 x 个方面不达标，这会违反合同”。\n这是批评。\n“修车都不放好千斤顶，你真是蠢到家了”\n“你哪个师傅教的？”\n“你是不是说明书都看不懂？”\n这就不是批评，而是借批评为名的攻击和侮辱。\n“你不放好千斤顶是不是想制造事故压死修车工？”\n这是入人以罪。\n面向大众拿大喇叭广播——“ta 不放好千斤顶就是为了制造事故压死人”\n这是构陷。\n很多人把批评分为“善意批评”和“恶意批评”，这个说法本身其实是错的。\n批评必须也只能是善意的。\n没有善意，哪怕一个脏词都不带，扯尽了天下正义大旗，本质亦为迫害。\n侮辱、入罪、构陷，都是化妆成批评，利用了人们不得不对批评给予的宽容而得逞的恶行。\n心里就没有这些界限意识的人，根本做不到有效批评。\n人不是不欢迎批评，而是批评是一门高度复杂和敏感，有无数红线，需要极强的原则性、高度自我克制、清醒的动机自觉的技能。\n绝大多数人所以为是批评并且本能厌恶和抗拒的东西，其实根本就不是批评，只是乔装打扮、深深寄生在人的恶意本能中的迫害。\n一个真正懂得批评是什么的人，可以用批评造就常人难以想象的杰出人物，可以成就照耀后人的伟业。\n这些批评是贵如黄金，甚至可遇而不可求的。\n求之且不得，何谈厌恶？\n批评的法则的确也是一个很要害的问题。这种能力学好了、用好了，的确是一种强大的白魔法，\n首先我们谈批评的标准操作。\n第一步，是要分析自己的批评冲动本身。\n你想要这个批评造成哪些净改变？\n你要把这些诉求全面的列出来，确保这些诉求是批评所可以达到的、可以合法追求的结果。\n一般来说，人们通过名为批评的行为要达到的几种典型的诉求包括：\n  补偿自己的不满情绪。\n  以最低的代价（也就是避免自己需要追加投入或做出改变）终止和预防自己因该被事件连累而遭受的持续损失。\n  破坏对方的自信，软化对方的立场，使对方变得更易服从自己的安排。\n  破坏对方在组织或社会中的地位和影响力，使其失去威胁。\n  帮助对方认识到自身的问题，提高达成其自身目标的成功率。\n  你要检查一下你自己的批评冲动里包含了哪些诉求，然后对这些诉求做一下梳理。\n这些诉求是正当或者不正当撇开不谈，从纯功利的角度来说，首先你要想清楚的问题是——它们是否适合用“批评”这个手段来需求解决？\n这个问题没有看上去这么简单——当然，批评是可以在早期起到这些效果的，\n但是代价就是一旦作了这些用途，你的批评权就会磨损，多做几次，就会磨损殆尽。\n你要充分的意识到，这是一种对批评权的损耗，眼下这件事是否值得用磨损批评权为代价来解决？\n你是要把你的批评权用在报复 Ta 考了低分让你丢脸上、用在自我吹嘘、榨取崇拜上，\n还是用在劝阻 Ta 和明显危险的人的来往、选择不可持续的职业生涯上？\n如果你把批评权用在批评所不该担当的任务上，并且长期这样做，那么你的批评权就会取消。\n于是在真正重大而要害的事情上你就会失去批评权——倒不见得你没有说话的权利，只是对方大概率会置若罔闻。\n信不信由你——到时候你会发现就那一件事，就足够抵过一切你自认为达成的成就还有余，\n以至于使得那些所谓的指正显得微不足道、可悲甚至可笑。\n就像教孩子开车，把你的影响力全浪费在了让 Ta 学会了怎么开空调却没有教会 Ta 踩刹车、打方向盘一样。\n所谓正确的批评和错误的批评，真正的分界线就在于这一项批评的行为是会磨损还是会增厚你的批评权。\n错误的批评，越批评越要加大音量，直到加无可加、只能眼睁睁的看着它渐渐变得毫无效果。\n正确的批评，则不需要做这样的挣扎，受这种折磨。\n而正确和错误之间的分界线，就在于你让批评承担了不该批评承担的任务。\n那么什么样的任务是不该批评来承担的呢？\n先看平复自己的情绪问题。\n你的情绪受伤，就不应该用批评来表达。\n情绪受伤，如果你认为应该表达，那么就坦白的表达：\n“这些行为让我的感情受到了伤害，如果我的感情受到伤害对你来说是一种损失的话，\n我们应该商量一个成本最低的手段来合作避免它再发生，并且讨论一下我们如何分担这份成本”。\n你的感情受伤，这是一个 problem，一个 issue，一个现象、一个待解决的中性的事务；\n不是一种罪行、一种失败、一种待偿付的债务，这并没有给你任何神奇的审判权和暴力免责权。\n你的受伤现象有机制、有规律，解决它有方法、有成本，如此而已。\n解决感情受伤问题的过程，应该是一个探寻机制和规律，寻找方法、处理成本的问题。\n而且这个成本理所应当在你这一边，对方是出于爱才会存在分担的诉求。\n你是没有任何义务为不伤害我的感情而付出任何成本的。\n完全是因为你爱我，所以我的痛苦才会成为你的损失。\n我相信你爱我，所以我才可能开口把你邀请到这个讨论中来。\n我们讨论的基础，是如何合作避免我们双方的损失，不是为了避免我的损失。\n不清楚我的感情敏感点，不是一种过错——因为连我自己也要疼了才知道哪里会疼。\n无过错可言，又何来“报复”可言？\n这种感情受伤的特殊机制，是没有行业标准的、没有自然常数、一致设定的，这就使得“批评”在此不能适用。\n因为批评必须基于共同承认或接受的一致的逻辑前提。\n基于对方也知道和承认的前提和法则，补足对方运算错误的地方，这才构成批评；\n基于对方根本茫然无知、或者并不认可的、你自己单方面认同的法则，这不是批评，而是一种占领和统治。\n基于你自己认可而对方甚至不知道的法则判定对方有错，并因为对方不接受这个判定而实施言语、经济、社会关系或物理暴力的攻击，这是人对人的战争行为。\n如果这来自宣示了爱的人，则不但构成战争行为，更是一种珍珠港式的偷袭了。\n","permalink":"https://note.yxzi.xyz/note/view/gam/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%BA%E4%BB%AC%E4%B8%8D%E5%96%9C%E6%AC%A2%E8%A2%AB%E6%89%B9%E8%AF%84/","summary":"为什么人们不喜欢被批评 这不是剂量问题，这是性质问题。\n批评有一条细细的、意识几乎难以觉察、人常常不愿接受的红线：\n批评只能给逻辑、给疑问、给论证，不可以讽刺，不可以定罪，更不可以用作构陷的工具。\n比如：\n有人给车换轮胎没放好千斤顶。\n“换胎必须先把千斤顶放好，否则会 xxx”、“放好千斤顶的标准是 xxxx，你这样做在 x 个方面不达标，这会违反合同”。\n这是批评。\n“修车都不放好千斤顶，你真是蠢到家了”\n“你哪个师傅教的？”\n“你是不是说明书都看不懂？”\n这就不是批评，而是借批评为名的攻击和侮辱。\n“你不放好千斤顶是不是想制造事故压死修车工？”\n这是入人以罪。\n面向大众拿大喇叭广播——“ta 不放好千斤顶就是为了制造事故压死人”\n这是构陷。\n很多人把批评分为“善意批评”和“恶意批评”，这个说法本身其实是错的。\n批评必须也只能是善意的。\n没有善意，哪怕一个脏词都不带，扯尽了天下正义大旗，本质亦为迫害。\n侮辱、入罪、构陷，都是化妆成批评，利用了人们不得不对批评给予的宽容而得逞的恶行。\n心里就没有这些界限意识的人，根本做不到有效批评。\n人不是不欢迎批评，而是批评是一门高度复杂和敏感，有无数红线，需要极强的原则性、高度自我克制、清醒的动机自觉的技能。\n绝大多数人所以为是批评并且本能厌恶和抗拒的东西，其实根本就不是批评，只是乔装打扮、深深寄生在人的恶意本能中的迫害。\n一个真正懂得批评是什么的人，可以用批评造就常人难以想象的杰出人物，可以成就照耀后人的伟业。\n这些批评是贵如黄金，甚至可遇而不可求的。\n求之且不得，何谈厌恶？\n批评的法则的确也是一个很要害的问题。这种能力学好了、用好了，的确是一种强大的白魔法，\n首先我们谈批评的标准操作。\n第一步，是要分析自己的批评冲动本身。\n你想要这个批评造成哪些净改变？\n你要把这些诉求全面的列出来，确保这些诉求是批评所可以达到的、可以合法追求的结果。\n一般来说，人们通过名为批评的行为要达到的几种典型的诉求包括：\n  补偿自己的不满情绪。\n  以最低的代价（也就是避免自己需要追加投入或做出改变）终止和预防自己因该被事件连累而遭受的持续损失。\n  破坏对方的自信，软化对方的立场，使对方变得更易服从自己的安排。\n  破坏对方在组织或社会中的地位和影响力，使其失去威胁。\n  帮助对方认识到自身的问题，提高达成其自身目标的成功率。\n  你要检查一下你自己的批评冲动里包含了哪些诉求，然后对这些诉求做一下梳理。\n这些诉求是正当或者不正当撇开不谈，从纯功利的角度来说，首先你要想清楚的问题是——它们是否适合用“批评”这个手段来需求解决？\n这个问题没有看上去这么简单——当然，批评是可以在早期起到这些效果的，\n但是代价就是一旦作了这些用途，你的批评权就会磨损，多做几次，就会磨损殆尽。\n你要充分的意识到，这是一种对批评权的损耗，眼下这件事是否值得用磨损批评权为代价来解决？\n你是要把你的批评权用在报复 Ta 考了低分让你丢脸上、用在自我吹嘘、榨取崇拜上，\n还是用在劝阻 Ta 和明显危险的人的来往、选择不可持续的职业生涯上？\n如果你把批评权用在批评所不该担当的任务上，并且长期这样做，那么你的批评权就会取消。\n于是在真正重大而要害的事情上你就会失去批评权——倒不见得你没有说话的权利，只是对方大概率会置若罔闻。\n信不信由你——到时候你会发现就那一件事，就足够抵过一切你自认为达成的成就还有余，\n以至于使得那些所谓的指正显得微不足道、可悲甚至可笑。\n就像教孩子开车，把你的影响力全浪费在了让 Ta 学会了怎么开空调却没有教会 Ta 踩刹车、打方向盘一样。","title":"为什么人们不喜欢被批评"},{"content":"为什么人很难被说服 归根结底一句话：\n因为世界上没有任何一个人会轻易地认为自己的思想竟然是错的（无论他是皇帝还是乞丐，不管她是圣徒还是妓女，）。\n 有一天，王阳明的弟子问：\n“老师，我犯过许多错误，可你为什么不提醒我？”\n王阳明反问：\n“我没提醒你，你怎么知道自己犯了错误？”\n弟子答：\n“我学习后才知道。”\n王阳明说：\n“所以我教导你学习啊。”\n弟子有点疑惑：\n“我的意思是说，你应该帮助我改正错误。”王阳明笑道：\n“你自己的错误，别人怎么改正得了？只有你自己，才能改正自己的错误。”\n 其实这个心理，可以用《道德经》里的两句话来概括。\n不自是，故彰 一 公元 200 年，中国历史上爆发了一场著名的战役叫“官渡之战”。\n最终，曹操以三万兵马击败袁绍十几万大军，从此拉开了历史新序幕。\n可是这场战役，不仅袁绍自己后悔不已，就连后世无数的历史学家也为之扼腕痛惜。\n为什么？\n因为袁绍本来不会失败，如果当初他采纳了田丰提出的“持久战 + 游击战”建议的话。\n那么按照常理：\n失败后的袁绍一定会痛定思痛，亲自去监狱里给田丰松绑，并且赔礼道歉，重新重用他。\n还别说，在“官渡之战”失败后，真就有一个狱卒向田丰提前道喜。\n然而，田丰却仰天长叹道：\n“他若胜了，我或许能活；可如今败了，我必死无疑。”\n果然，袁绍回来的第一件事，就是将田丰“杀人灭口”。\n不过，田丰之死虽然可惜，还是很有教育意义的。\n起码他临死前的这一叹，就向我们透露了一个人性的天大秘密。\n这个秘密就是：\n正常人，是不会认错的\n什么？让一个人认错真的有这么难？\n对！不仅难，而且难于上青天。\n二 美国著名的心理学家艾略特·阿伦森为了研究这个现象，还专门写过一本书来探讨。\n书的名字就叫《谁会认错》，他在书里收集整理了数不胜数的真实案例：\n从总统到平民；从明星到穷人；\n上至国会议员，下到企业职工；\n无论是高教育的大学教授，还是低文化的街头小贩。\n几乎无一例外，全体国民统统都是“死不认错”的代言人。\n这究竟是为什么呢？我觉得可以用一些形象的比喻来解释：\n因为当一个人承认自己错误的时候，就等于是从大脑中强行卸载掉旧的思维，同时再安装一套新的观念。\n而在新旧交替的过程中，往往会引发大脑信息短路，从而造成思想系统的紊乱。\n这可并不是我空口无凭，一时臆想，而是有着实实在在的心理学和脑神经学双重依据。\n我上面描述的那种现象，在心理学上被称为：认知失调\n这个概念是美国社会心理学家利昂·费斯廷格在 1956 年首次在《当预言失灵》一书中提出来的，\n因为他发现那些所谓的末日邪教派成员们，有一种不可思议的信仰坚持。\n哪怕他们的教主关于地球灭亡的预言失败了，他们也不会认为教主在欺骗。\n但是，毕竟这种“预期落空”引发了他们认知上的不协调，那怎么办呢？\n指望他们知错就改，回头是岸？公开承认自己蠢？别开玩笑了。\n认错这么反人性的事情，世界上从古至今就没有多少人能够做得到。\n这里的”认错“是指发自内心的认为自己的思维是错的，不是那种勉强装出来的面子功夫。\n所以，基本上所有的信徒为了解决这种认知失调的办法不是承认错误，而是去接受一个新的预言：\n外星人已经因为他们的虔诚信仰而饶恕了这个星球。\n也就是说：\n当人们在遇到一个跟自己认知不匹配的新观念的时候，第一反应不是接受并改正，\n而是找出支持旧观念的其他理由，哪怕这个理由荒唐至极。\n三 值得一提的是，美国神经科学家德鲁·威斯顿通过核磁共振技术，扫描人类在处理信息时的脑电图表明：\n 当人面对令自己认知失调的信息时，大脑主管理性的区域就会突然“断电”，停止工作；\n而当恢复了协调时，大脑的情绪区域就会突然“亮灯”，兴奋异常。——艾略特·阿伦森《谁会认错·第一章》\n 也就是说：\n当人在面对自己错误那一刻，是没有理性的，所以是不可能认错的。\n除非等大脑适应了那一套新的、正确的思维程序，人才会恢复理性，改过自新。\n所以，我们在生活中即使听到一个人说“对不起”的时候，也往往是几天，或者是几个月，甚至几年以后。\n当然，如果他的大脑与新思维程序不兼容，那么我们恐怕就永远也不可能看到他低头道歉的样子了。\n四 因此：\n让一个普通人认错都是那么地艰难，何况是帝王将相呢？\n当我们明白了这条人性规律的时候，也就明白了“不自是”的重要性。\n所谓“不自是”，就是不以自己的想法为绝对准绳，去度量天下一切人和事。\n尤其是当一个领导者“自是”的时候，往往会产生涟漪效应，造成的恶果也往往会放大数十倍。\n五 讲一个老典故：\n 公元 631 年，有一个叫李好德的人在公共场合妖言惑众，可能说了一些敏感的政治话题。\n唐太宗大为光火，下令道：“关起来严查！”当时的大理丞张蕴古经过一番调查，\n最后上报说：“此人有癫痫病症，所以才疯言疯语。按大唐律例，应该无罪释放。”\n唐太宗一听：“罢了，那就按制度办吧。”\n第二天，有一个人向唐太宗打小报告：“李好德的哥哥跟张蕴古是老乡，恐怕两人有私情。”\n唐太宗大怒，二话不说。立马派人将张蕴古抓起来，拖出宫门外，就地处斩。\n 然而，唐太宗前脚刚砍下了张蕴古的人头，后脚就悔青了肠子，是的，他知道自己错了。\n但是他面对错误的方式特别有意思：\n他并没有从灵魂深处对自己进行一番深刻的检讨，而是顺手一推，将责任迁怒转稼给了文武百官。\n他质问道：\n“张蕴古即使有罪，也罪不至死。朕只是一时冲动，你们当时怎么都不劝谏呢？你们这些辅臣是干什么吃的？有什么用？”\n六 你看，这就是人性。\n即使是英明神武的唐太宗在面对自己错误的时候，跟一个街头不讲理的泼妇也毫无二致。\n当然，作为一国之君，“自是”是付出巨大代价的。\n张蕴古被杀之后，大唐的法官们人人自危。\n为了怕被人扣上“徇私枉法”的帽子，纷纷在处理案件时都不加斟酌，一律从严。\n从而导致天下百姓惶惶不安，提心吊胆。\n最后，唐太宗痛定思痛，为了避免重蹈覆辙。\n不得不下诏：\n “从今以后，凡是死刑案件，必须反复上奏五次，方可决断。\n判决前，上奏两次；判决当日，上奏三次。”\n 于是在第二年，才出现了全唐死刑犯只有 320 人的“贞观奇迹”。\n这就是一个帝王在“不自是”以后，政策所散发出来的一道明朗光辉。\n所谓的“彰”，不就是“彰明”吗？\n所以老子说：“不自是，故彰。”\n自是者不彰 一  西汉初年，准确的说是公元前 200 年。一方诸侯韩王信（备注：并非淮阴侯韩信）谋反，刘邦亲率大军讨伐。\n刘邦连战连捷，一直打到了山西太原附近。韩王信狗急跳墙，于是勾结了北方的匈奴。准备双剑合璧，联手应战。\n刘邦大怒，但是为了摸清虚实，只好先派了一些使者去查探。\n匈奴首领将计就计，故意将精兵和肥马隐藏起来，军营内外调派的都是老兵瘦马。\n使者前后一共派出了十几拨，回来都报告说：\n“匈奴可伐。”\n刘邦一而再，再而三地听到这样的好消息，自然心花怒放。\n认为平定中原，指日可待。\n不过为了稳妥起见，刘邦最后决定象征性地派娄敬再去一趟。\n然而意外的是，娄敬出使回来却浇了一盆冷水说：\n“两国相持，匈奴应该展示肌肉才对。但是匈奴的军营里连一个壮丁都看不到，此必有诈。所以依老臣看来，匈奴不可伐。”\n刘邦本来信心满满，已经精心策划了好几个月。\n听到娄敬的报告，忍不住破口大骂：\n“你个老匹夫，就会呈口舌之利！匈奴给了你什么好处？妄想用一张嘴就堵住朕的二十万大军。”\n于是，娄敬被关进大牢，刘邦率全军出征。\n 后来的事情我们都知道了：\n刘邦中了匈奴的埋伏，被困在山西大同的白登山七天七夜，史称“白登之围”。\n要不是陈平临时使出了一套变相的美人计，刘邦恐怕就饿死在白登山上了。\n二 这一整个事件的过程：\n其实就是使者们和刘邦从“自见”到“自是”的一步步生长发展的过程，\n他们像井底之蛙一样沉浸在幻想的情境中运筹帷幄， 根本就没有想过站在匈奴的角度去客观地看待两国对峙的全景，焉有不败之理？\n反观娄敬，他就并没有让自己的视角局限于敌我的任何一方。\n所以才能透过层层迷雾，看出完美假象背后的破绽。\n幸运的是，刘邦并没有像袁绍一样愚蠢的“自是”到底。\n他逃回来之后，亲自去大牢里认错检讨，还把娄敬敕封为建信侯。\n当然，你可以说刘邦并非是诚心改悔，只不过是一番政治表演而已。\n但你无法否认的是：\n在后来汉王朝的朝堂上，一定会站出许多敢于提反对意见的人。\n那么对于一个国家来说，这是好事还是坏事？\n答案是显而易见的，当然是好事，这不就恰恰印证了“自是者不彰，不自是故彰”这句话吗？\n所谓的“彰”，指的就是良政能发扬光大的意思。\n而一个好领导者的标准：\n就在于随时随地都能虚怀若谷，不仅不能自以为是，甚至还要常常自以为非。\n三 美国的一位历史学家多丽丝·科恩斯·古德温就在《林肯与劲敌幕僚》一书中指出：\n美国历史上的第十六任总统林肯，就是一位“不自是，常自非”的领袖。\n在他的八名内阁成员中，竟然包含了他曾经的四位政治死敌。\n这四位政敌甚至还被他任命了一些最高职务：\n国务卿的职位，他给了威廉·西沃德；\n陆军部长的职位，他给了爱德温·斯坦顿；\n财政部长的职位，他给了萨蒙·蔡斯；\n首席检察官的职位，他给了爱德华·贝兹；\n我们要知道，这四位政坛老将可都是专门跟林肯唱反调的人。\n即使他们进了内阁，依然对林肯冷嘲热讽，甚至掀桌子大骂都是常有的事情。\n但是，林肯为了避免自己变成井底之蛙，为了避免自己做决策的时候陷入“自是”的假象。\n选择了忍辱负重，兼容并蓄。\n这就是一个优秀领导者的政治远见和职业胸怀。\n四 在上面关于“不自是故彰”的解读中，我提到过一个心理学名词叫：“认知失调”\n就是指人在面对自己的错误的时候，大脑会发生短路，暂时失去思考的能力。\n所以会一错到底，死不悔改，这就意味着：\n普通人的大脑中都安装着一套“死不认错”的思维系统。\n而美国的神经脑科学家德鲁·威斯顿则用现代医学技术，证明了这一点。\n他曾经做过一项研究：\n在人类处理信息时，通过核磁共振进行扫描，脑电图表明：\n当人面对令自己认知失调的信息时，大脑主管理性的区域就会突然断电，停止工作。\n也就是说：\n人在面对跟自己意见相反的信息时，大脑会关闭理性，启动情绪来对抗。\n这让我不禁想起了古代的一则笑话：\n 话说楚国有一个乡下人，从来没有见过生姜。\n有一天跟人争论说：“姜是长在树上的。“\n对方纠正说：“错，姜是长在土里的。”\n这个乡下人却固执己见，说：“你去找十个人问一问，我敢以自己骑的毛驴跟你打赌。”然后，他们果真问了十个人。\n结果十个人都说：“姜是从土里长出的。”\n这个乡下人气得脸色大变，拂袖而去。\n临走时还留下一句话：“毛驴尽管输给你了，但是生姜还是树上长出来的。”\n 虽然，这只是一则笑话。\n但是它无疑是脱胎于现实生活，道出了一条人性至理：\n每个人都是根深蒂固的“自是”者，不管你拿出多少证据证明他错了，他依然会从另一种角度证明自己是正确的。\n任何人都不例外。\n你一定会说，这怎么可能呢？\n但是，这就是事实。\n五 在上个世纪三十年代，戴尔·卡内基在写《人性的弱点》一书的过程中。\n曾经对美国一所著名的“星星监狱”进行了深入的访问和调查，他惊讶地发现：\n无论是杀人犯还是黑帮头目，他们几乎没有一个人觉得自己罪有应得，有的人甚至会认为自己为社会做出了某种贡献。\n比如：\n杀人犯会说自己是替天行道，为民除害；非法经营者会说自己的黑市交易促进了当地的经济繁荣；\n著名的黑社会教父阿尔卡彭则自豪地声称：“自己为社会的边缘青年提供了一份谋生的工作。”\n其实，他们的逻辑虽然听起来荒唐不经，但并不难理解。\n因为每个人生活在世界上，他的思想和行为必须是统一的。\n如果发生偏离，人就会感到迷茫和手足无措。\n就好像机器人的指令和行为如果不统一，也会陷入瘫痪的状态。\n所以，人一旦发生“认知失调”，就必须立即校正。\n那么，思想和行为哪一个更容易被调整呢？\n当然是思想。\n因为你投入行动的成本，一般都远远高于你思考的成本。\n根据行为经济学的“沉没成本”效应，你投入的越多，就越不容易放弃。\n所以，你最划算的办法就是：\n校正自己的思想，以符合自己当前的行为，哪怕是随便找一个荒唐而可笑的理由。\n这就是人们往往“死不认错”的经济学原因。\n六 所以，从这个意义上来说：\n越自是的人，越容易犯罪。\n所以罗素说过一句很有名的话：\n这个世界上最大的麻烦就是：傻瓜和狂热分子对自己坚信不疑，而智者总是充满疑虑。\n为什么会这样呢？\n因为智者就像是一个大法官，每天都要面对并且处理原告的诉讼状和被告的辩护词。\n所谓的“被告”就是我们“行为”，“原告”就是我们的“思想”。\n而大法官其实在短时间内，是很难决断思想与行为究竟“孰是孰非”的，甚至往往会出现“今是而昨非，明是而今非”的矛盾状态。\n所以罗素还说过一句名言：\n我才不会为自己的信仰而死，万一我是错的呢？\n七 由此可见，智者的思想历程，其实就是一个人不断地打破“我执”的过程。\n先是信，然后疑；疑，然后再信；信，然后再疑。如此循环往复，小疑小信，大疑大信。\n释迦牟尼讲经的时候也曾经对一些外道的教徒们说：\n“佛法如金：金不怕火，法不怕疑。以火验金，以疑证法。”\n也就是说在释迦牟尼看来：\n一个人如果没有怀疑，那他根本就不会有真正的信仰。\n而反观现实中那些“自是”的人，往往就都对自己的理念一信到底，坚定不移。\n最可怕的是，他们还往往不允许别人质疑他们自己的信念。\n比如第二次世界大战的发动者，杀人狂魔希特勒。\n八 希特勒就是一个极端自是的人，而极端的自是，必然会造成极端的犯罪。\n因为在他的决策团体中，只允许不折不扣地执行命令，从来就不允许出现不卑不亢的质疑。\n希特勒的一位忠实追随者阿尔伯特·施佩尔就在 1969 年出版的回忆录中透露道：\n“在正常情况下，如果一个人的行为偏离了现实。\n很快就会被周围的人发现并且批评，从而能得到改正。\n但是在希特勒的第三帝国中并不存在这种矫正的机制，它完全是与世隔绝，与外界隔离的。\n所有的人就像是置身于一个四周都是哈哈镜的大厅之中，你的任何一个表情，都只会被放大并且反复确认。\n在哈哈镜里，除了我自己，我什么都看不到。”\n所以，尽管希特勒在二战期间一共屠杀了至少六百万无辜的犹太平民。\n但是，他从来没有一天怀疑过自己的正义性和正确性。\n“自是”到这种地步，已经无药可医了。\n","permalink":"https://note.yxzi.xyz/note/view/gam/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%BA%E5%BE%88%E9%9A%BE%E8%A2%AB%E8%AF%B4%E6%9C%8D/","summary":"为什么人很难被说服 归根结底一句话：\n因为世界上没有任何一个人会轻易地认为自己的思想竟然是错的（无论他是皇帝还是乞丐，不管她是圣徒还是妓女，）。\n 有一天，王阳明的弟子问：\n“老师，我犯过许多错误，可你为什么不提醒我？”\n王阳明反问：\n“我没提醒你，你怎么知道自己犯了错误？”\n弟子答：\n“我学习后才知道。”\n王阳明说：\n“所以我教导你学习啊。”\n弟子有点疑惑：\n“我的意思是说，你应该帮助我改正错误。”王阳明笑道：\n“你自己的错误，别人怎么改正得了？只有你自己，才能改正自己的错误。”\n 其实这个心理，可以用《道德经》里的两句话来概括。\n不自是，故彰 一 公元 200 年，中国历史上爆发了一场著名的战役叫“官渡之战”。\n最终，曹操以三万兵马击败袁绍十几万大军，从此拉开了历史新序幕。\n可是这场战役，不仅袁绍自己后悔不已，就连后世无数的历史学家也为之扼腕痛惜。\n为什么？\n因为袁绍本来不会失败，如果当初他采纳了田丰提出的“持久战 + 游击战”建议的话。\n那么按照常理：\n失败后的袁绍一定会痛定思痛，亲自去监狱里给田丰松绑，并且赔礼道歉，重新重用他。\n还别说，在“官渡之战”失败后，真就有一个狱卒向田丰提前道喜。\n然而，田丰却仰天长叹道：\n“他若胜了，我或许能活；可如今败了，我必死无疑。”\n果然，袁绍回来的第一件事，就是将田丰“杀人灭口”。\n不过，田丰之死虽然可惜，还是很有教育意义的。\n起码他临死前的这一叹，就向我们透露了一个人性的天大秘密。\n这个秘密就是：\n正常人，是不会认错的\n什么？让一个人认错真的有这么难？\n对！不仅难，而且难于上青天。\n二 美国著名的心理学家艾略特·阿伦森为了研究这个现象，还专门写过一本书来探讨。\n书的名字就叫《谁会认错》，他在书里收集整理了数不胜数的真实案例：\n从总统到平民；从明星到穷人；\n上至国会议员，下到企业职工；\n无论是高教育的大学教授，还是低文化的街头小贩。\n几乎无一例外，全体国民统统都是“死不认错”的代言人。\n这究竟是为什么呢？我觉得可以用一些形象的比喻来解释：\n因为当一个人承认自己错误的时候，就等于是从大脑中强行卸载掉旧的思维，同时再安装一套新的观念。\n而在新旧交替的过程中，往往会引发大脑信息短路，从而造成思想系统的紊乱。\n这可并不是我空口无凭，一时臆想，而是有着实实在在的心理学和脑神经学双重依据。\n我上面描述的那种现象，在心理学上被称为：认知失调\n这个概念是美国社会心理学家利昂·费斯廷格在 1956 年首次在《当预言失灵》一书中提出来的，\n因为他发现那些所谓的末日邪教派成员们，有一种不可思议的信仰坚持。\n哪怕他们的教主关于地球灭亡的预言失败了，他们也不会认为教主在欺骗。\n但是，毕竟这种“预期落空”引发了他们认知上的不协调，那怎么办呢？\n指望他们知错就改，回头是岸？公开承认自己蠢？别开玩笑了。\n认错这么反人性的事情，世界上从古至今就没有多少人能够做得到。\n这里的”认错“是指发自内心的认为自己的思维是错的，不是那种勉强装出来的面子功夫。\n所以，基本上所有的信徒为了解决这种认知失调的办法不是承认错误，而是去接受一个新的预言：\n外星人已经因为他们的虔诚信仰而饶恕了这个星球。\n也就是说：\n当人们在遇到一个跟自己认知不匹配的新观念的时候，第一反应不是接受并改正，\n而是找出支持旧观念的其他理由，哪怕这个理由荒唐至极。\n三 值得一提的是，美国神经科学家德鲁·威斯顿通过核磁共振技术，扫描人类在处理信息时的脑电图表明：\n 当人面对令自己认知失调的信息时，大脑主管理性的区域就会突然“断电”，停止工作；","title":"为什么人很难被说服"},{"content":"信息茧房 由于社交网络和智能推送的发展，在这个信息爆炸的年代，反而让人变得更加闭塞，\n而且每个人都在变得更加极端，人与人间的包容性正在变得越来越差。\n互联网巨头近乎掌握了控制人心的能力。\n因为你所接触的一切网站和 APP，都会在后台计算你的行为，描画你的性格，捕捉你的需求，然后精准推送，并满足你的需求。\n从今日头条，到 UC，到各种新闻 APP，甚至知乎，都有着精密的喜好算法，\n全天在向你推送你感兴趣的内容，号称千人千面的精准推送，\n实则只是让人活在自己喜好的世界里，因为算法只会给你推送你乐意点开的内容。\n长此以往，每个人都会只活在自己的世界里，并且以为自己看到的就是整个世界。\n知乎上多数年轻人都受过比较良好的教育，向往或者生存在北上广深，希望或者正在互联网 or 金融领域工作，考虑买房或背负房贷。\n所以你们日常的关注点自然就在北上广深的生活，在金融工作和互联网工作，在超一线城市的房价，如何成为男神女神\u0026hellip;\n所以你们接收到的推送信息往往都只是相关信息，所以你才会有现在中国房价上天，金融互联网高大上，身边都是三观不正的人，\n自己长其实是女神/男神的错觉，并且没有人能告诉你你是错的，因为为了引起的你注意，所有的信息都会按照你的喜好的推。\n你是皇帝，但确是一个无法接收到真正信息，只能看大臣奏折的皇帝。\n你喜欢看情感撕逼，就会一直给你推情感撕逼，你就会觉得这个世界就是这样的，每个人都靠不住，渣男绿茶遍地都是；\n你喜欢同性恋，就会一直给你推同性恋，你就会觉得这个世界对于同性恋特别包涵，大家都特别开明，同性恋就是正义；\n你喜欢看屌丝逆袭，就会一直给你推毒鸡汤，你就会认为这个世界只要努力就没有办不成的事情。\n你喜欢看国富民强，就一直给你推什么虽远必诛，你就会认为我国已经成为世界第一强国，一切事情背后都有一步大棋。\n哪怕你喜欢群 P，喜欢 SM，喜欢各种小众文化，喜欢各种反大众常规道德的东西，\n算法也会一直给你推送相关的资讯，让你时刻认为自己已经在主流圈里吾道不孤。\n\u0026hellip;.无数案例\n你喜欢，你觉得，你认为，你见到的，就是整个世界。\n很可惜，不是。\n为什么每到过年回老家的时候，大家的三观都要被撞一次腰，然后上知乎疯狂提问吐槽求解求同类？\n为什么知乎上这么多与三观崩塌有关的问题？\n因为当你强制脱离当前环境的时候，你就会发现，这个世界与你看到的不一样，\n你认为理所应当的东西，在别人看来就是傻逼，对此你束手无策。\n同一个道理，为什么在知乎里的每一个问题讨论下，都会出现那种你完全无法了解无法认可的回答？而且还有很多赞？你觉得不可思议？\n因为每个人的成长环境和生存环境都不一样，所以接收到的信息不一样。\n为什么这么多“何不食肉糜”的问题与回答？你是不是觉得对方是傻逼？\n对方不是傻，只是看不到你看到的东西。\n如果你还是单纯认为自己看到的片面的推送的信息就是整个世界，那么这样恶性循环下去，\n大概率你会彻底成为一个极端的人并且乐此不疲，\n因为你看到的一切都是满足你极端的需求，你看不到反对意见，最终你会成为大脑的国王，\n但你的王国非常脆弱，你的王位岌岌可危，因为你的一切，都经不起观点碰撞。\n所以在每一次观点碰撞中，你愤怒又惶恐，惶恐又导致更大的愤怒，所以你愈加极端，你愈加容不下异端。\n你以为你代表了主流，实际上在主流眼里你可能是盲流，甚至在其他人眼里你是下九流。\n大家一定要警惕，这个看似因为互联网发展已经联通的世界，\n实际上正在快速分裂成一个个小世界，而这些世界的边界，不在地域上，而在大脑里。\n你看到的，只是你潜意识里想看到的。\n所谓独立思考，就是让你跳出自己思维边界，俯瞰整个世界。\n虽然这个世界可能并不好看。\n","permalink":"https://note.yxzi.xyz/note/view/thinking/%E4%BF%A1%E6%81%AF%E8%8C%A7%E6%88%BF/","summary":"信息茧房 由于社交网络和智能推送的发展，在这个信息爆炸的年代，反而让人变得更加闭塞，\n而且每个人都在变得更加极端，人与人间的包容性正在变得越来越差。\n互联网巨头近乎掌握了控制人心的能力。\n因为你所接触的一切网站和 APP，都会在后台计算你的行为，描画你的性格，捕捉你的需求，然后精准推送，并满足你的需求。\n从今日头条，到 UC，到各种新闻 APP，甚至知乎，都有着精密的喜好算法，\n全天在向你推送你感兴趣的内容，号称千人千面的精准推送，\n实则只是让人活在自己喜好的世界里，因为算法只会给你推送你乐意点开的内容。\n长此以往，每个人都会只活在自己的世界里，并且以为自己看到的就是整个世界。\n知乎上多数年轻人都受过比较良好的教育，向往或者生存在北上广深，希望或者正在互联网 or 金融领域工作，考虑买房或背负房贷。\n所以你们日常的关注点自然就在北上广深的生活，在金融工作和互联网工作，在超一线城市的房价，如何成为男神女神\u0026hellip;\n所以你们接收到的推送信息往往都只是相关信息，所以你才会有现在中国房价上天，金融互联网高大上，身边都是三观不正的人，\n自己长其实是女神/男神的错觉，并且没有人能告诉你你是错的，因为为了引起的你注意，所有的信息都会按照你的喜好的推。\n你是皇帝，但确是一个无法接收到真正信息，只能看大臣奏折的皇帝。\n你喜欢看情感撕逼，就会一直给你推情感撕逼，你就会觉得这个世界就是这样的，每个人都靠不住，渣男绿茶遍地都是；\n你喜欢同性恋，就会一直给你推同性恋，你就会觉得这个世界对于同性恋特别包涵，大家都特别开明，同性恋就是正义；\n你喜欢看屌丝逆袭，就会一直给你推毒鸡汤，你就会认为这个世界只要努力就没有办不成的事情。\n你喜欢看国富民强，就一直给你推什么虽远必诛，你就会认为我国已经成为世界第一强国，一切事情背后都有一步大棋。\n哪怕你喜欢群 P，喜欢 SM，喜欢各种小众文化，喜欢各种反大众常规道德的东西，\n算法也会一直给你推送相关的资讯，让你时刻认为自己已经在主流圈里吾道不孤。\n\u0026hellip;.无数案例\n你喜欢，你觉得，你认为，你见到的，就是整个世界。\n很可惜，不是。\n为什么每到过年回老家的时候，大家的三观都要被撞一次腰，然后上知乎疯狂提问吐槽求解求同类？\n为什么知乎上这么多与三观崩塌有关的问题？\n因为当你强制脱离当前环境的时候，你就会发现，这个世界与你看到的不一样，\n你认为理所应当的东西，在别人看来就是傻逼，对此你束手无策。\n同一个道理，为什么在知乎里的每一个问题讨论下，都会出现那种你完全无法了解无法认可的回答？而且还有很多赞？你觉得不可思议？\n因为每个人的成长环境和生存环境都不一样，所以接收到的信息不一样。\n为什么这么多“何不食肉糜”的问题与回答？你是不是觉得对方是傻逼？\n对方不是傻，只是看不到你看到的东西。\n如果你还是单纯认为自己看到的片面的推送的信息就是整个世界，那么这样恶性循环下去，\n大概率你会彻底成为一个极端的人并且乐此不疲，\n因为你看到的一切都是满足你极端的需求，你看不到反对意见，最终你会成为大脑的国王，\n但你的王国非常脆弱，你的王位岌岌可危，因为你的一切，都经不起观点碰撞。\n所以在每一次观点碰撞中，你愤怒又惶恐，惶恐又导致更大的愤怒，所以你愈加极端，你愈加容不下异端。\n你以为你代表了主流，实际上在主流眼里你可能是盲流，甚至在其他人眼里你是下九流。\n大家一定要警惕，这个看似因为互联网发展已经联通的世界，\n实际上正在快速分裂成一个个小世界，而这些世界的边界，不在地域上，而在大脑里。\n你看到的，只是你潜意识里想看到的。\n所谓独立思考，就是让你跳出自己思维边界，俯瞰整个世界。\n虽然这个世界可能并不好看。","title":"信息茧房"},{"content":"喜欢上一个人的本质是什么 这世上所有的感情，其实都是一种“富兰克林效应”。\n一个人爱上另一个人的根本原因是什么？\n是因为对方的外貌？对方的品格？对方的地位？对方的名声？对方的财富？统统都不是！那究竟是为什么呢？\n一 先讲一个著名的故事：\n二战时期，犹太人遭到德国纳粹的迫害。\n有两个犹太兄弟商量着该向谁寻求帮助，二人的意见发生了分歧。\n弟弟主张向父亲曾经资助过的一个银行家求助，而且这名银行家曾多次表示有机会一定要报恩。\n哥哥则认为，应该向曾经资助他们家族起步的另一位木材商求助。\n两人谁也说服不了谁，于是分头行动，从此失去联系。\n多年后，由木材商冒死相助逃到日本的哥哥回国寻找弟弟，发现弟弟全家早已惨死在奥斯威辛集中营。\n后来哥哥从纳粹档案中找到了举报弟弟藏匿处的电话记录，打电话的人——正是那位银行家。\n哥哥仰天长叹：\n曾经帮助过你的人，比你所帮助过的人，更可靠。\n二 现代的营销学里的有一个非常经典的案例，上个世纪美国有一家吸尘器公司的推销冠军。\n他在退休前一天对其他的员工们说：\n你们这些笨蛋，推销业务时只会敲开门问：“太太您好！能不能给我三分钟介绍我们公司的一个产品。”\n每次话还没说完，“啪”的一声就吃了闭门羹。你说你们这不是赤裸裸的骚扰吗？顾客没报警已经是客气的了。”\n于是这些员工们就好奇的地问：“那您是如何向顾客推销的？”\n这位退休的老员工回答道：\n“我会说，太太您好！我是一个路过的推销员，口渴了。您能不能给我一杯水喝呢？”\n于是，我走进顾客的家，先观察一下环境。\n然后在顾客给我准备水的时间里，轻描淡写地唠一唠家长里短，然后旁敲侧击地说几句自己所推销的“吸尘器”。\n顾客没有压力，自然就会接话。\n如此一来，产品推销的成功率可以提高百分之六七十。其他的员工们听了如梦方醒，纷纷给这位老员工鼓掌。\n其实这个案例，有一个心理学的名词，叫做：“富兰克林效应。”\n这个效应是根据 18 世纪美国的国父之一的本杰明·富兰克林所说的一句话发展而来的。\n富兰克林曾说：\n相比那些被你帮助过的人，那些曾经帮助过你的人会更愿意再帮你一次。\n他为什么会这么说呢？因为他曾经做过一件影响了世界心理学的事情。\n这个故事最早是记录在卡耐基的《人性的弱点》一书中，后来在 1993 年，\n美国著名的心理学家艾略特·阿伦森，又将这个故事写进了他的《社会心理学》。\n故事大体是这样的：\n 1736 年，有一天富兰克林在宾夕法尼亚的议院发表演讲。\n另一位议员完全反对他的观点，于是也发表了一篇演讲，十分激烈地批评了富兰克林。\n富兰克林有点措手不及，但是又想争取这位议员的同意。\n怎么办呢？\n他无意中打听到这位议员的家里正好有一套非常稀有的图书。\n于是他十分恭敬地写了一封信，厚着脸皮向这个议员借书。\n没想到这个议员竟然同意了，过了一段时间，富兰克林在还书的同时郑重地表达了谢意。\n几天后当他们再次在议会厅见面时，富兰克林是这样描写的：\n“他竟然主动跟我打招呼（以前从来没有过），后来我们谈话，他还表示，任何时候都愿意为我效劳。”\n从此他们两人化敌为友，终生保持着友谊。\n所以后世的心理学家们人得出一个结论：\n让别人喜欢你的最好方法不是去帮助他们，而是让他们来帮助你。\n这就是著名的“富兰克林”效应的由来。\n 三 一个世纪以后，美国的另一位总统林肯就深受“富兰克林效应“的启发。\n有一次，林肯准备让一位政敌帮个小忙。\n一位议员批评道：“你为什么要试图跟政敌做朋友呢？你应当消灭他们。”\n林肯却温和的回答道：“难道我不是在消灭我的敌人吗？特别是当我们变成朋友的时候。”\n让一个敌人帮你一个小忙，就能化敌为友，化干戈为玉帛。\n这个套路，真的可信吗？真的可行吗？\n四 1969 年，心理学家琼•杰克和戴维•兰迪决定亲自上阵，检验一下这个有二百年历史的“富兰克林效应”在 20 世纪是否已经过期。\n于是他们安排了一次知识竞赛，让所有的参与者赢了一笔小钱。\n竞赛结束后，一名研究人员向其中三分之一的参与者们表示：\n“他是用自己的钱来组织的竞赛，现在他没钱了，能否请他们把钱退还给他。“\n一名秘书向另一组三分之一的参与者们表示：\n”这是由心理学实验室赞助的竞赛，现在实验室资金短缺，能否请他们把钱退还。“\n实验过后，所有的参与者们都被要求填写了一项问卷调查，分别给研究人员和秘书打分。\n实验结果证明：\n研究人员的分数远远高于秘书。\n而且愿意把钱退回来的参与者，所给出的分数远远高于不愿意退钱者。\n也就是说，“富兰克林效应”检验合格，依然保质。\n五 伟大的文学家托尔斯泰也同样对这个效应深表赞同：\n他曾在《战争与和平》一书中写道：\n“我们并不因为别人对我们的好而爱他们，而是因为自己对他们的好而爱他们。”\n而托尔斯泰所说的“好”，其实就是给予帮助。\n因为木材商已经给予了犹太家族一笔钱的帮助，所以产生好感，愿意冒险相助。\n因为顾客已经给予了推销员一杯水的帮助，所以产生好感，愿意接受推销。\n因为政敌已经给予了富兰克林一套书的帮助，所以产生好感，愿意化解仇恨。\n也正因为如此，参加知识竞赛的参与者们才会特别钟情于自掏腰包的研究人员，而不是那位花公司钱的秘书。\n其实不止如此，这个效应还涉及到另一个心理学现象：\n 当你帮助过一个人的时候，哪怕你不怎么喜欢这个人。\n你的大脑也会自动调整认知，告诉你对方是一个值得帮助的人，你在做一件对的事情。\n如此，你便会在心理上形成一种“路径依赖”。\n当对方再一次向你求助的时候，你反而比第一次更乐意效劳，也更加喜欢对方。\n 美国著名经济学家道格拉斯·诺斯，正是由于发现了人性的这一惯性定理，\n成功解释了经济制度的演进，在 1993 年获得了诺贝尔经济学奖。\n但是，人性为什么会这样呢？\n六 要回答这个问题，就必须先回答另一个问题。那就是：\n一个人爱上另一个人的根本原因是什么？\n是因为对方的外貌？对方的品格？对方的地位？对方的名声？对方的财富？\n统统都不是！那究竟是为什么呢？\n我们不妨再来听听法国作家埃克苏佩里《小王子》里的一个故事：\n 小王子在一个小小的星球上生活，有一天星球上忽然绽放了一朵娇艳的玫瑰花。\n小王子从来没有见过这么美丽的花，于是他每天细心地呵护，精心地照料。\n他当时觉得这是世宇宙里唯一的一朵玫瑰，比所有的花都美。\n后来有一天他来到地球，发现仅仅一个花园里就有 5000 朵几乎完全一样的玫瑰花。\n那一刻他终于知道，他所拥有的只不过是一朵普通的花。\n这个发现，使小王子非常伤心。\n但是尽管如此，不知道为什么，他心里还是放不下自己的那一朵玫瑰。\n直到有一天一只小狐狸跟他说：\n\u0026ldquo;正因为你为你的玫瑰花费了时间和心血，才使你的玫瑰变得美丽。\u0026rdquo;\n小王子恍然大悟，终于明白：\n尽管世界上有无数朵玫瑰花，但他星球上的那朵玫瑰花仍然是独一无二的。\n因为他浇灌过她，保护过她，陪着她一起说话，陪着她一起沉默……所以她是他独一无二的玫瑰。\n 七 同理，我们地球上的人类，多如满天繁星，多于恒河沙数。\n试问：\n我们哪一个人不是千万人类中平凡的一员？\n我们哪一个人的所爱不是千万朵玫瑰中平凡的一支呢？\n我们手里的玫瑰之所以一枝独秀，并非是玫瑰本身多么耀眼，而是因为我们在玫瑰身上倾注了自己全部的目光。\n我们心中的所爱之所以一笑倾城，并非是因为对方本身多么迷人，而是因为我们在对方身上付出了自己所有的感情。\n八 为什么得不到的一方永远在骚动，被宠的另一方总是有恃无恐？\n因为前者持续在付出，而后者几乎没有。\n为什么父母永远在骚动，子女一直有恃无恐？\n因为父母持续在付出，而子女几乎没有。\n为什么好孩子永远在骚动，坏孩子一直有恃无恐？\n因为坏孩子费心，耗费了父母更多的付出。好孩子省心，节省了父母本来的付出。\n为什么母爱一般情况下更甚于父爱？\n因为母亲十月怀胎，千难万险，对孩子的付出更甚于父亲。\n这个效应放在职场、友情或者其他领域中都同样适用。\n所谓“会哭的孩子有奶吃”，“人脉都是麻烦出来的”等等，就是这个效应所分娩出来的金科玉律。\n因此，我们爱一个人，是因为付出。\n没有付出，就不可能有爱。\n所以严格来说，这个世界上根本就没有一见钟情。\n九 如果有一个人告诉你他在几秒钟之内爱上了一个女孩。\n你只需问他一句：”在那几秒钟之内，你愿意为那个女孩去死吗？“\n他肯定不愿意，就像我们不愿意为自己所喜欢的明星去死一样。\n因为几秒钟的时间，是不可能爱上一个人的。\n当然，女性亦然。\n十 那他是如何爱上那个女孩的呢？情况如下：\n他在见面之后，朝思暮想，茶思饭想，无时无刻不在想，甚至连做梦都在想。\n所以他一天的思念除了睡觉，可能长达 16 个小时。\n而另一位对这个女孩同样有好感的男人，每天的思念可能只是 1 个小时。\n我们假设，爱上一个人需要 160 个小时的思念：\n那么前者只需要 10 天，而后者需要 160 天。\n这，就是一见钟情的真相。\n“钟”本来就代表时间，所谓的一见钟情：\n是指两人在初次见面激发荷尔蒙分泌，互生好感之后，还需要时间才能生情。\n在一定的时间内：\n如果双方都付出，就会孕育出爱情。\n如果只有一方付出，只会分娩出单相思。\n如果双方都没有付出，最多也就生出交情。\n所以，如果没有足够的付出，别说是几秒钟，哪怕是相识一个世纪你都不可能爱上一个人。\n十一 思念，就是一个人的情感付出。\n当然付出还包括很多种：\n时间、金钱、陪伴，精力等等。\n但归根结底，所有的付出都会随着时间潜移默化，最终变成情感的付出。\n因为那一段付出的时光，已经悄然形成美好的回忆，融入你的血液，转化成了你生命的一部分。\n从前有一个女儿问父亲，如何让她喜欢的男孩子喜欢她呢？\n父亲回答说：“让他给你买一个冰激凌。”\n女儿又问：“然后呢？”\n父亲回答：“让他再买一个。”\n当然，这里讲的只是方法论，具体情境还要具体对待，不同的人需要使用不同的技巧，切勿生搬硬套。\n总而言之，终极心法就是一句话：\n你付出的同时，也要引导对方为你付出。\n这位父亲就是人性大师，深谙“富兰克林效应“。\n因为这个男孩买冰激凌的行为，看似简单，却无疑是一种潜移默化的付出。\n他会想：\n女孩喜欢吃什么样的冰激凌？草莓的还是牛奶的？大的还是小的？这一家的还是另一家的？\n无形之中，男孩就为这个女孩付出了时间、金钱、以及精力。\n渐渐地，男孩就会问自己，为什么我要给她买冰激凌呢？\n因为她可爱、懂事、笑声很甜等等，哪怕这个女孩在外人看来一无是处，我们也大可放心。\n无论如何，男孩都会找足一百个理由说服自己。\n或许你会问：\n为什么男孩会那么蠢?\n其实何止这个男孩，可以说是人性本身就是这么蠢。\n十二 没错，这又涉及到心理学的一个效应叫：\n”认知失调“。\n简单来讲就是：\n当人们发现客观现实与自己的认知不一致的时候，会产生一种不协调不舒适的感觉。\n这是美国社会心理学家利昂·费斯廷格在 1956 年首次在《当预言失灵》一书中提出来的。\n因为他发现那些所谓的末日邪教派成员们，有一种不可思议的信仰坚持。\n哪怕他们的教主关于地球灭亡的预言失败了，他们也不会认为教主在欺骗。\n但是，毕竟这种“预期落空”引发了他们认知上的不协调，那怎么办呢？\n指望他们知错就改，回头是岸？公开承认自己蠢？别开玩笑了。\n认错这么反人性的事情，世界上从古至今就没有多少人能够做得到。\n声明一下：\n这里的”认错“是指发自内心的认为自己的思维是错的，不是那种勉强装出来的面子功夫。\n所以，基本上所有的信徒为了解决这种认知失调的办法不是承认错误，\n而是去接受一个新的预言：\n外星人已经因为他们的虔诚信仰而饶恕了这个星球。\n十三 那个男孩先是走进了”富兰克林效应“的圈套，然后又染上了”路径依赖“的惯性，接着又踩到了”认知失调“的陷阱，\n最后还有一个”沉没成本“对着他眉来眼去，你觉得他能轻易地放弃那个他天天为之买冰激凌的女性吗？\n几乎不可能！除非发生无法预料的异常状况。\n相反，男孩会因为自己的付出而渐渐觉得这个女孩超凡脱俗，与众不同。\n日积月累，他就不知不觉地爱上了这个女孩。\n爱情，其实就是这么简单。\n所谓爱，就是你对一个人付出的总和。\n","permalink":"https://note.yxzi.xyz/note/view/bisexual/%E5%96%9C%E6%AC%A2%E4%B8%8A%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88/","summary":"喜欢上一个人的本质是什么 这世上所有的感情，其实都是一种“富兰克林效应”。\n一个人爱上另一个人的根本原因是什么？\n是因为对方的外貌？对方的品格？对方的地位？对方的名声？对方的财富？统统都不是！那究竟是为什么呢？\n一 先讲一个著名的故事：\n二战时期，犹太人遭到德国纳粹的迫害。\n有两个犹太兄弟商量着该向谁寻求帮助，二人的意见发生了分歧。\n弟弟主张向父亲曾经资助过的一个银行家求助，而且这名银行家曾多次表示有机会一定要报恩。\n哥哥则认为，应该向曾经资助他们家族起步的另一位木材商求助。\n两人谁也说服不了谁，于是分头行动，从此失去联系。\n多年后，由木材商冒死相助逃到日本的哥哥回国寻找弟弟，发现弟弟全家早已惨死在奥斯威辛集中营。\n后来哥哥从纳粹档案中找到了举报弟弟藏匿处的电话记录，打电话的人——正是那位银行家。\n哥哥仰天长叹：\n曾经帮助过你的人，比你所帮助过的人，更可靠。\n二 现代的营销学里的有一个非常经典的案例，上个世纪美国有一家吸尘器公司的推销冠军。\n他在退休前一天对其他的员工们说：\n你们这些笨蛋，推销业务时只会敲开门问：“太太您好！能不能给我三分钟介绍我们公司的一个产品。”\n每次话还没说完，“啪”的一声就吃了闭门羹。你说你们这不是赤裸裸的骚扰吗？顾客没报警已经是客气的了。”\n于是这些员工们就好奇的地问：“那您是如何向顾客推销的？”\n这位退休的老员工回答道：\n“我会说，太太您好！我是一个路过的推销员，口渴了。您能不能给我一杯水喝呢？”\n于是，我走进顾客的家，先观察一下环境。\n然后在顾客给我准备水的时间里，轻描淡写地唠一唠家长里短，然后旁敲侧击地说几句自己所推销的“吸尘器”。\n顾客没有压力，自然就会接话。\n如此一来，产品推销的成功率可以提高百分之六七十。其他的员工们听了如梦方醒，纷纷给这位老员工鼓掌。\n其实这个案例，有一个心理学的名词，叫做：“富兰克林效应。”\n这个效应是根据 18 世纪美国的国父之一的本杰明·富兰克林所说的一句话发展而来的。\n富兰克林曾说：\n相比那些被你帮助过的人，那些曾经帮助过你的人会更愿意再帮你一次。\n他为什么会这么说呢？因为他曾经做过一件影响了世界心理学的事情。\n这个故事最早是记录在卡耐基的《人性的弱点》一书中，后来在 1993 年，\n美国著名的心理学家艾略特·阿伦森，又将这个故事写进了他的《社会心理学》。\n故事大体是这样的：\n 1736 年，有一天富兰克林在宾夕法尼亚的议院发表演讲。\n另一位议员完全反对他的观点，于是也发表了一篇演讲，十分激烈地批评了富兰克林。\n富兰克林有点措手不及，但是又想争取这位议员的同意。\n怎么办呢？\n他无意中打听到这位议员的家里正好有一套非常稀有的图书。\n于是他十分恭敬地写了一封信，厚着脸皮向这个议员借书。\n没想到这个议员竟然同意了，过了一段时间，富兰克林在还书的同时郑重地表达了谢意。\n几天后当他们再次在议会厅见面时，富兰克林是这样描写的：\n“他竟然主动跟我打招呼（以前从来没有过），后来我们谈话，他还表示，任何时候都愿意为我效劳。”\n从此他们两人化敌为友，终生保持着友谊。\n所以后世的心理学家们人得出一个结论：\n让别人喜欢你的最好方法不是去帮助他们，而是让他们来帮助你。\n这就是著名的“富兰克林”效应的由来。\n 三 一个世纪以后，美国的另一位总统林肯就深受“富兰克林效应“的启发。\n有一次，林肯准备让一位政敌帮个小忙。\n一位议员批评道：“你为什么要试图跟政敌做朋友呢？你应当消灭他们。”\n林肯却温和的回答道：“难道我不是在消灭我的敌人吗？特别是当我们变成朋友的时候。”\n让一个敌人帮你一个小忙，就能化敌为友，化干戈为玉帛。\n这个套路，真的可信吗？真的可行吗？\n四 1969 年，心理学家琼•杰克和戴维•兰迪决定亲自上阵，检验一下这个有二百年历史的“富兰克林效应”在 20 世纪是否已经过期。\n于是他们安排了一次知识竞赛，让所有的参与者赢了一笔小钱。\n竞赛结束后，一名研究人员向其中三分之一的参与者们表示：\n“他是用自己的钱来组织的竞赛，现在他没钱了，能否请他们把钱退还给他。“","title":"喜欢上一个人的本质是什么"},{"content":"开车撞人后怎么处理最理智 一位资深警察的微信，有车的朋友一定要存！(从此理直气壮）\n一 出了事故不要害怕，立刻打 110 和保险公司。对方伤重请直接打 120，你留在现场等交警。\n二 不要垫付，如果交警要扣车，你就让他扣，所有他需要的资料都给他。\n自己步行或者打车上下班，15 个工作日你直接去交警 大队要验车报告。\n不给你，你就立刻即刻马上不要迟疑的到交警同一栋办公楼找到一个叫\u0026quot;行政科\u0026quot;的地方提出行政复议。\n然后拿着验车报告去提车，停车场 1 分钱都不要给他，拿着验车报告你直接就可以拿车。\n如果对方不给你车，你直接打 110，说有人非法扣车，\n验车和停车是不要钱的，国家有财拨专门用于这一部分。\n而且百分之百这个停车场都不是交警自己的，都是外包的，他们和交警穿的是同一条裤子。\n这一部分你要是担心自己的新车扣了以后被损，你就提前自己拍照，然后弄 一个车衣去盖起来。\n三 拿到车该上班就上班，不上班你就休息，千万不要紧张，\n现在你要做的事情就是不要去医院找打，也不要主动打电话调解，\n你等他们联系你，或者交警通知你处理事故，任何关于医院的费用你都说我没钱，请和我的保险公司联系。\n如果告我的话，请连我的保险公司一起告，你连面都不用出，保险公司就请非常专业的讼棍帮你打官司，\n最后要赔多少，完全不用自己管。\n四 现在你要考虑怎么拿回自己的行驶证，经过第三点，\n这个时候对方要么接受调解愿意接受交警认责比例，把发票给你，你去报销，然后签字，你拿回行驶证。\n若经过第三点，对方不愿意调解，那就告，你放心大胆的开车，有人查你就说有官司在身，行驶证抵押了。\n时间一长，要么保险公司答应赔，要么伤者自己接受调解，法院一判下来，\n你就可以直接拿判决书去找交警，约对方一起去签字拿回东西。对方不去，你直接找交警，\n时间长了不给你行驶证你就去行政科闹一下。\n五 修车部分很简单，该修的地方，保险勘探现场的时候会有一张现场单，你拿去 4S，其他他们会搞定。\n六 营养部分，误工部分，你不要私下答应，当地有一份很完整的赔偿标准，\n对方拿出所有的发票和证明后交警开具调解书，你拿去保险公司都能报，\n三不一没有原则 ：不垫付、 不探望 、不调解，没有钱。\n","permalink":"https://note.yxzi.xyz/note/view/gam/%E5%BC%80%E8%BD%A6%E6%92%9E%E4%BA%BA%E5%90%8E%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E6%9C%80%E7%90%86%E6%99%BA/","summary":"开车撞人后怎么处理最理智 一位资深警察的微信，有车的朋友一定要存！(从此理直气壮）\n一 出了事故不要害怕，立刻打 110 和保险公司。对方伤重请直接打 120，你留在现场等交警。\n二 不要垫付，如果交警要扣车，你就让他扣，所有他需要的资料都给他。\n自己步行或者打车上下班，15 个工作日你直接去交警 大队要验车报告。\n不给你，你就立刻即刻马上不要迟疑的到交警同一栋办公楼找到一个叫\u0026quot;行政科\u0026quot;的地方提出行政复议。\n然后拿着验车报告去提车，停车场 1 分钱都不要给他，拿着验车报告你直接就可以拿车。\n如果对方不给你车，你直接打 110，说有人非法扣车，\n验车和停车是不要钱的，国家有财拨专门用于这一部分。\n而且百分之百这个停车场都不是交警自己的，都是外包的，他们和交警穿的是同一条裤子。\n这一部分你要是担心自己的新车扣了以后被损，你就提前自己拍照，然后弄 一个车衣去盖起来。\n三 拿到车该上班就上班，不上班你就休息，千万不要紧张，\n现在你要做的事情就是不要去医院找打，也不要主动打电话调解，\n你等他们联系你，或者交警通知你处理事故，任何关于医院的费用你都说我没钱，请和我的保险公司联系。\n如果告我的话，请连我的保险公司一起告，你连面都不用出，保险公司就请非常专业的讼棍帮你打官司，\n最后要赔多少，完全不用自己管。\n四 现在你要考虑怎么拿回自己的行驶证，经过第三点，\n这个时候对方要么接受调解愿意接受交警认责比例，把发票给你，你去报销，然后签字，你拿回行驶证。\n若经过第三点，对方不愿意调解，那就告，你放心大胆的开车，有人查你就说有官司在身，行驶证抵押了。\n时间一长，要么保险公司答应赔，要么伤者自己接受调解，法院一判下来，\n你就可以直接拿判决书去找交警，约对方一起去签字拿回东西。对方不去，你直接找交警，\n时间长了不给你行驶证你就去行政科闹一下。\n五 修车部分很简单，该修的地方，保险勘探现场的时候会有一张现场单，你拿去 4S，其他他们会搞定。\n六 营养部分，误工部分，你不要私下答应，当地有一份很完整的赔偿标准，\n对方拿出所有的发票和证明后交警开具调解书，你拿去保险公司都能报，\n三不一没有原则 ：不垫付、 不探望 、不调解，没有钱。","title":"开车撞人后怎么处理最理智"},{"content":"我们渴望的是智慧 我们渴求的不是知识，而是智慧。\n无论读书还是日常生活，都是精神在现实中的映射，\n寻找日常生活中的的真实自我，依旧是求道的一部分，\n我们渴求的依旧是那种生存性的智慧，是内化于自己之日常生命的反复追问，\n而不是将读书与生活割裂，将知识与行动分离。\n","permalink":"https://note.yxzi.xyz/note/view/thinking/%E6%88%91%E4%BB%AC%E6%B8%B4%E6%9C%9B%E7%9A%84%E6%98%AF%E6%99%BA%E6%85%A7/","summary":"我们渴望的是智慧 我们渴求的不是知识，而是智慧。\n无论读书还是日常生活，都是精神在现实中的映射，\n寻找日常生活中的的真实自我，依旧是求道的一部分，\n我们渴求的依旧是那种生存性的智慧，是内化于自己之日常生命的反复追问，\n而不是将读书与生活割裂，将知识与行动分离。","title":"我们渴望的是智慧"},{"content":"时空扭曲 这个概念有点玄。\n这里说的时空扭曲，指的是主观的时间流逝感觉随着年龄开始加速，而且一发不可收拾。\n相信大部分人都有这样的感觉，时间过得越来越快快了。\n小学时是一个月一个月过，大学一学期一学期过，工作后就变成了一年一年过，越往上过的越快，\n如果你问问你的父母，他们会告诉你十年一眨眼就没了，他们讨论着十几年二十年前的陈年旧事，好像就发生在昨天\u0026hellip;\n我很早就开始研究抗衡这种时空扭曲的方法。\n我在网上找了一些解释，有一个说法比较有趣：\n 五岁的时候人的记忆有五年，这时候过一年，到六岁时，记忆增加了五分之一。\n六岁到七岁，记忆增加了六分之一。\n七岁到八岁记忆就只增加了七分之一。\n以此类推，到了二十岁的时候，过多一年，记忆便只增加二十分之一。\n这一年的时光虽然没变，但是参照物变了。\n所以大家就感觉时间过得快了。\n可能等你六十岁的的时候，过一年记忆只增加六十分之一，那时时间就过得更快了。\n 这个说法有一定的道理，如果你仔细回忆一下，会发现童年的课间十分钟休息足够你从楼上跑下去玩儿点什么；\n但现在你坐在公司电脑前，才喝了杯热饮，把东西摊开准备干活，啥都没干呢一个小时就没了。\n小时候两个月的暑假特别漫长，现在的一个月不就是四个星期，一眨眼就没了。\n如果用记忆增量理论来解释，那就说明我们在成年后的工作和生活都是在简单重复，\n所以大脑中的“总数据”并没有像儿时那样处在迅猛增长的阶段，大脑处理今天的 24 小时，\n只需要动用几年前就已经存好的索引，驾轻就熟，总信息量几乎没有增加，\n你主观上感受到的“新东西”当然就少，而体验“新东西”恰恰是放慢主观时间的命门。\n套用网络上“舒适区”的说法，要解决时空扭曲的问题，\n我们必须走出“熟悉区”，熟悉区是时空黑洞，会不断加速消耗，吞噬你的时间。\n如果你走出办公室，去陌生的国度一个月，就会发现这一个月并没有像办公室里那样，星期三过完就差不多能指望星期天了，\n而是觉得比在办公室两个星期都要多，这便是对抗时空扭曲的一个例子。\n并不是只有旅游才能有这样的效果，你如果在自己身上多试验，会发现能找到很多适用于你个人的手段，\n但前提是你要有“摆脱熟悉区”的意识。\n因此，我认为只要能掌握了对抗时空扭曲的能力，人就能延长主观生命。\n","permalink":"https://note.yxzi.xyz/note/view/thinking/%E6%97%B6%E7%A9%BA%E6%89%AD%E6%9B%B2/","summary":"时空扭曲 这个概念有点玄。\n这里说的时空扭曲，指的是主观的时间流逝感觉随着年龄开始加速，而且一发不可收拾。\n相信大部分人都有这样的感觉，时间过得越来越快快了。\n小学时是一个月一个月过，大学一学期一学期过，工作后就变成了一年一年过，越往上过的越快，\n如果你问问你的父母，他们会告诉你十年一眨眼就没了，他们讨论着十几年二十年前的陈年旧事，好像就发生在昨天\u0026hellip;\n我很早就开始研究抗衡这种时空扭曲的方法。\n我在网上找了一些解释，有一个说法比较有趣：\n 五岁的时候人的记忆有五年，这时候过一年，到六岁时，记忆增加了五分之一。\n六岁到七岁，记忆增加了六分之一。\n七岁到八岁记忆就只增加了七分之一。\n以此类推，到了二十岁的时候，过多一年，记忆便只增加二十分之一。\n这一年的时光虽然没变，但是参照物变了。\n所以大家就感觉时间过得快了。\n可能等你六十岁的的时候，过一年记忆只增加六十分之一，那时时间就过得更快了。\n 这个说法有一定的道理，如果你仔细回忆一下，会发现童年的课间十分钟休息足够你从楼上跑下去玩儿点什么；\n但现在你坐在公司电脑前，才喝了杯热饮，把东西摊开准备干活，啥都没干呢一个小时就没了。\n小时候两个月的暑假特别漫长，现在的一个月不就是四个星期，一眨眼就没了。\n如果用记忆增量理论来解释，那就说明我们在成年后的工作和生活都是在简单重复，\n所以大脑中的“总数据”并没有像儿时那样处在迅猛增长的阶段，大脑处理今天的 24 小时，\n只需要动用几年前就已经存好的索引，驾轻就熟，总信息量几乎没有增加，\n你主观上感受到的“新东西”当然就少，而体验“新东西”恰恰是放慢主观时间的命门。\n套用网络上“舒适区”的说法，要解决时空扭曲的问题，\n我们必须走出“熟悉区”，熟悉区是时空黑洞，会不断加速消耗，吞噬你的时间。\n如果你走出办公室，去陌生的国度一个月，就会发现这一个月并没有像办公室里那样，星期三过完就差不多能指望星期天了，\n而是觉得比在办公室两个星期都要多，这便是对抗时空扭曲的一个例子。\n并不是只有旅游才能有这样的效果，你如果在自己身上多试验，会发现能找到很多适用于你个人的手段，\n但前提是你要有“摆脱熟悉区”的意识。\n因此，我认为只要能掌握了对抗时空扭曲的能力，人就能延长主观生命。","title":"时空扭曲"},{"content":"点菜时人人都说随便点的局面 讲真，多年点菜的经验让我明白一点：凡是点菜时说随便的人，其意往往并非是字面意义上的“随便”。\n而是告诉你：他们要的不是选择权，而是决定权。\n领导们说“随便”，实在是因为点菜这种事是做下属的分内之事，不需要领导亲力亲为；\n并不代表着你可以权纲独断，代替领导拍板。\n好比说，部门工作上出了问题，负责拿出具体解决方案的人是你，而领导负责在你拿出的 ABCD 解决方案中挑选并拍板。\n朋友们说“随便”，实在是因为他们不愿意为点菜这件事耗费脑细胞，不想在密密麻麻的菜单中费神，\n他们只是希望可以将一切简化为行和不行两个选项，就像做判断题一样打勾打叉就好。\n一言以蔽之，选择恐惧症。他们真的对吃什么不在意吗？点菜前说随便，点好了又反对，这种情况难道你们没有碰到过？\n所以，遇到这种点菜说“随便”的领导/长辈/朋友，你的正确做法就是：\n将厚厚的一本菜单按照一定次序缩减到数个选项，然后让他们挑选并拍板。\n具体步骤   高声叫来服务员，询问：“你们这有什么特色菜？”之后，服务员当着全席报出 ABCDEF 数个选项。此时，若坐主位的领导长辈们插话：“A 不错！”，点 A；若无人插话，则进入第二步。\n  对应服务员报出的 ABCDEF 选项，自己斟酌或进一步询问服务员（如问卖的最好的是什么之类），选出两到三个，向主位的领导或长辈询问：“领导/长辈，我觉得这个 A 还有 B 啊 C 啊挺不错的，您觉得呢？”。此时，若坐主位的领导长辈们说：“A 不错！”，点 A；若对方回答：“随便！都行！”，进入第三步。\n  继续斟酌缩小范围到一个，对着主位并兼顾全席说：“那就点这个 A 吧，听说这边做得挺好的/卖的挺不错的/蛮有特色的。”。此时，若坐主位的领导长辈们说：“好好好/随便随便/都行都行”或不答言，点 A；若有人异议，则将 A 换成其他，循环此步骤至无人异议。此时，第一道菜点完。\n  继续询问服务员：“你们这里主菜/蔬菜/汤/主食有什么推荐没？”重复以上一到三步，将剩余的菜点完。点菜具体类别次序另说，这里不赘述。\n  牢记三句话：知情权在全席；选择权在你；决定权在主位。\n以上是和领导长辈们，和朋友之间就可轻松一点。\n不用叫服务员自己确定选项也行，也可自己做主点一两道。总之，关键点在于：\n不断缩小选择范围，让对方只用选择“是”或者“否”，尽量简化对方思考内容，同时给予对方决定权。\n这个原则可不仅适用于点菜，凡是在生活工作中扔给你一句“随便”的人，皆可按此原则处理。\n人际交往之间，重要的就是要有个能以小见大，见微知著的心。\n","permalink":"https://note.yxzi.xyz/note/view/gam/%E7%82%B9%E8%8F%9C%E6%97%B6%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%AF%B4%E9%9A%8F%E4%BE%BF%E7%82%B9%E7%9A%84%E5%B1%80%E9%9D%A2/","summary":"点菜时人人都说随便点的局面 讲真，多年点菜的经验让我明白一点：凡是点菜时说随便的人，其意往往并非是字面意义上的“随便”。\n而是告诉你：他们要的不是选择权，而是决定权。\n领导们说“随便”，实在是因为点菜这种事是做下属的分内之事，不需要领导亲力亲为；\n并不代表着你可以权纲独断，代替领导拍板。\n好比说，部门工作上出了问题，负责拿出具体解决方案的人是你，而领导负责在你拿出的 ABCD 解决方案中挑选并拍板。\n朋友们说“随便”，实在是因为他们不愿意为点菜这件事耗费脑细胞，不想在密密麻麻的菜单中费神，\n他们只是希望可以将一切简化为行和不行两个选项，就像做判断题一样打勾打叉就好。\n一言以蔽之，选择恐惧症。他们真的对吃什么不在意吗？点菜前说随便，点好了又反对，这种情况难道你们没有碰到过？\n所以，遇到这种点菜说“随便”的领导/长辈/朋友，你的正确做法就是：\n将厚厚的一本菜单按照一定次序缩减到数个选项，然后让他们挑选并拍板。\n具体步骤   高声叫来服务员，询问：“你们这有什么特色菜？”之后，服务员当着全席报出 ABCDEF 数个选项。此时，若坐主位的领导长辈们插话：“A 不错！”，点 A；若无人插话，则进入第二步。\n  对应服务员报出的 ABCDEF 选项，自己斟酌或进一步询问服务员（如问卖的最好的是什么之类），选出两到三个，向主位的领导或长辈询问：“领导/长辈，我觉得这个 A 还有 B 啊 C 啊挺不错的，您觉得呢？”。此时，若坐主位的领导长辈们说：“A 不错！”，点 A；若对方回答：“随便！都行！”，进入第三步。\n  继续斟酌缩小范围到一个，对着主位并兼顾全席说：“那就点这个 A 吧，听说这边做得挺好的/卖的挺不错的/蛮有特色的。”。此时，若坐主位的领导长辈们说：“好好好/随便随便/都行都行”或不答言，点 A；若有人异议，则将 A 换成其他，循环此步骤至无人异议。此时，第一道菜点完。\n  继续询问服务员：“你们这里主菜/蔬菜/汤/主食有什么推荐没？”重复以上一到三步，将剩余的菜点完。点菜具体类别次序另说，这里不赘述。\n  牢记三句话：知情权在全席；选择权在你；决定权在主位。\n以上是和领导长辈们，和朋友之间就可轻松一点。\n不用叫服务员自己确定选项也行，也可自己做主点一两道。总之，关键点在于：\n不断缩小选择范围，让对方只用选择“是”或者“否”，尽量简化对方思考内容，同时给予对方决定权。\n这个原则可不仅适用于点菜，凡是在生活工作中扔给你一句“随便”的人，皆可按此原则处理。\n人际交往之间，重要的就是要有个能以小见大，见微知著的心。","title":"点菜时人人都说随便点的局面"},{"content":"配置默认网关 enable\rconfigure terminal\rip default-gateway 192.168.10.1 ","permalink":"https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E9%BB%98%E8%AE%A4%E7%BD%91%E5%85%B3/","summary":"配置默认网关 enable\rconfigure terminal\rip default-gateway 192.168.10.1 ","title":"Cisco 配置默认网关"},{"content":"初始化 初始化一个 Echarts 实例，参数是一个 dom，它决定了图表最终呈现的位置。\nvar myChart = echarts.init(document.getElementById(\u0026#39;main\u0026#39;)); 绘制图表 用一个对象作为配置项，绘制整个图表。\nvar option = {}; 标题 title: {  text: \u0026#39;运动品牌科技水平\u0026#39;,  //标题文本点击tiao超链接  link: \u0026#39;https://yxzi.xyz/\u0026#39; }, X 轴 xAxis: {  // 轴类型为类目轴  type: \u0026#39;category\u0026#39;,  // 类目轴的类别名称  data: [\u0026#39;李宁\u0026#39;, \u0026#39;安踏\u0026#39;, \u0026#39;匹克\u0026#39;, \u0026#39;迪卡侬\u0026#39;, \u0026#39;耐克\u0026#39;, \u0026#39;阿迪达斯\u0026#39;] }, Y 轴 yAxis: {  // 轴类型为数值轴，数值轴是不需要设置data属性，  // 因为数值轴针对xAxis的data中的类别名称去series的data中去寻找对应的数据  type: \u0026#39;value\u0026#39;, }, series 一个系列配置。\nseries: [  {  // 表示下面data中的数据表示的是哪一方面的数据，这里表示的是科技水平  name: \u0026#39;科技水平\u0026#39;,  // 定义图标的类型，这里是柱状图  type: \u0026#39;bar\u0026#39;,  // xAxis 中与类目相对应的数据  data: [22, 15, 12, 15, 80, 40]  }  ] 将配置项设置给 Echarts 实例对象 myChart.setOption(option); ","permalink":"https://note.yxzi.xyz/note/technology/storehouse/echarts/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/","summary":"初始化 初始化一个 Echarts 实例，参数是一个 dom，它决定了图表最终呈现的位置。\nvar myChart = echarts.init(document.getElementById(\u0026#39;main\u0026#39;)); 绘制图表 用一个对象作为配置项，绘制整个图表。\nvar option = {}; 标题 title: {  text: \u0026#39;运动品牌科技水平\u0026#39;,  //标题文本点击tiao超链接  link: \u0026#39;https://yxzi.xyz/\u0026#39; }, X 轴 xAxis: {  // 轴类型为类目轴  type: \u0026#39;category\u0026#39;,  // 类目轴的类别名称  data: [\u0026#39;李宁\u0026#39;, \u0026#39;安踏\u0026#39;, \u0026#39;匹克\u0026#39;, \u0026#39;迪卡侬\u0026#39;, \u0026#39;耐克\u0026#39;, \u0026#39;阿迪达斯\u0026#39;] }, Y 轴 yAxis: {  // 轴类型为数值轴，数值轴是不需要设置data属性，  // 因为数值轴针对xAxis的data中的类别名称去series的data中去寻找对应的数据  type: \u0026#39;value\u0026#39;, }, series 一个系列配置。\nseries: [  {  // 表示下面data中的数据表示的是哪一方面的数据，这里表示的是科技水平  name: \u0026#39;科技水平\u0026#39;,  // 定义图标的类型，这里是柱状图  type: \u0026#39;bar\u0026#39;,  // xAxis 中与类目相对应的数据  data: [22, 15, 12, 15, 80, 40]  }  ] 将配置项设置给 Echarts 实例对象 myChart.","title":"Echarts 基本配置"},{"content":"人对事物的感受程度不一样 我从读高中起就一直有一个疑问，就是：不同人对于快乐和痛苦的感受度会否不一样呢？\n譬如说同样患有急性肠胃炎，有没有可能一个人的疼痛感是另一个人的 1000 倍呢？\n急性肠胃炎带给 A 的痛苦感相当于用刀割肉一般，但对于 B 来说只是如同被捏了一下而已。\n如果这是真的，很多成功人士们标榜自己可以承受苦难，其实只是一个他们自己都没有意识到的谎言。\n情况也许只是，面对同样的苦，这些成功人士比我们大多数人天生对苦的感受度要低很多而已。\n也就是说，那些叫你坚持、叫你努力、叫你吃苦的成功学鸡汤可能卵用都没有，\n因为人和人的体质天生不一样，坚持做一件事给 A 带来的苦只是 1 Unit，而给 B 带来的苦却有可能是 1000 Unit。\n对于成功人士体质的人来说，早起读书给他们带来的苦只是 1 Unit，对于我们可能是 1000 unit 啊！\n所以，怎么能说我们不早起就是意志力薄弱呢！\n我一开始以为只有我一个人这样想，后来发现原来早在 1911 年就有一个经济学家和我抱有同样的疑问。\n这个经济学家叫斯坦利.耶方斯（Stanley Jevons），他说：\n \u0026hellip;\u0026hellip;在所有的例子中，从来没有人试图把一个心灵中的感觉强度与另一个心灵的感觉强度做比较。\n据我们所知，一个心灵的敏感度可能比另一个心灵强 1000 倍。\n然而，如果敏感度的差异在各方面上比例相同，则我们将永远无法发现这些差异。\n这样，每个人的心灵对于其他任何人来说都是不可测量的，几乎不可能存在一个共同的标准。\n 我观察社会，我越发觉得这是极有可能的。\n那些努力攀登权力顶峰的人肯定是握有权力给他们带来的快感比我们常人要多 1000 倍，\n不然实在想不到为什么有好好的王爷不做，偏要去造反。\n再想到学校里的学霸，起早贪黑的学习，肯定是分数带来的快感是我们常人的 1000 倍，而低分带来的痛苦感也是我们的 1000 倍。\n令人细思极恐的是：\n如果这个猜想是真的，那么每个人的人生都是命定的。\n上帝在塑造我们的时候，只需要对不同人的快乐和痛苦两个感受度进行数值上的调整，\n那么不同人就会因着不同的感受度而做不同的取舍，最后走上完全不一样的人生。\n","permalink":"https://note.yxzi.xyz/note/view/thinking/%E4%BA%BA%E5%AF%B9%E4%BA%8B%E7%89%A9%E7%9A%84%E6%84%9F%E5%8F%97%E7%A8%8B%E5%BA%A6%E4%B8%8D%E4%B8%80%E6%A0%B7/","summary":"人对事物的感受程度不一样 我从读高中起就一直有一个疑问，就是：不同人对于快乐和痛苦的感受度会否不一样呢？\n譬如说同样患有急性肠胃炎，有没有可能一个人的疼痛感是另一个人的 1000 倍呢？\n急性肠胃炎带给 A 的痛苦感相当于用刀割肉一般，但对于 B 来说只是如同被捏了一下而已。\n如果这是真的，很多成功人士们标榜自己可以承受苦难，其实只是一个他们自己都没有意识到的谎言。\n情况也许只是，面对同样的苦，这些成功人士比我们大多数人天生对苦的感受度要低很多而已。\n也就是说，那些叫你坚持、叫你努力、叫你吃苦的成功学鸡汤可能卵用都没有，\n因为人和人的体质天生不一样，坚持做一件事给 A 带来的苦只是 1 Unit，而给 B 带来的苦却有可能是 1000 Unit。\n对于成功人士体质的人来说，早起读书给他们带来的苦只是 1 Unit，对于我们可能是 1000 unit 啊！\n所以，怎么能说我们不早起就是意志力薄弱呢！\n我一开始以为只有我一个人这样想，后来发现原来早在 1911 年就有一个经济学家和我抱有同样的疑问。\n这个经济学家叫斯坦利.耶方斯（Stanley Jevons），他说：\n \u0026hellip;\u0026hellip;在所有的例子中，从来没有人试图把一个心灵中的感觉强度与另一个心灵的感觉强度做比较。\n据我们所知，一个心灵的敏感度可能比另一个心灵强 1000 倍。\n然而，如果敏感度的差异在各方面上比例相同，则我们将永远无法发现这些差异。\n这样，每个人的心灵对于其他任何人来说都是不可测量的，几乎不可能存在一个共同的标准。\n 我观察社会，我越发觉得这是极有可能的。\n那些努力攀登权力顶峰的人肯定是握有权力给他们带来的快感比我们常人要多 1000 倍，\n不然实在想不到为什么有好好的王爷不做，偏要去造反。\n再想到学校里的学霸，起早贪黑的学习，肯定是分数带来的快感是我们常人的 1000 倍，而低分带来的痛苦感也是我们的 1000 倍。\n令人细思极恐的是：\n如果这个猜想是真的，那么每个人的人生都是命定的。\n上帝在塑造我们的时候，只需要对不同人的快乐和痛苦两个感受度进行数值上的调整，\n那么不同人就会因着不同的感受度而做不同的取舍，最后走上完全不一样的人生。","title":"人对事物的感受程度不一样"},{"content":"没有思想的旅行，行万里路也无异于邮差 在欧洲旅行，常见的景点之一就是许多古堡和教堂。\n首次见到这些景点，大家还会赞叹两句（高大、富丽堂皇之类）。\n但等再次遇到这类景点，就会感到索然乏味，很多人甚至是过门而不入。\n他们乏味感完全可以理解。\n换做我们任何人，没有文化知识的积淀，对历史知识的缺乏。碰到这类景点，估计也是如此，这一点，在国内依然成立。\n在国内旅游，任何一个城市，典型的一类景点包括寺庙、石窟、园林、宫殿群。\n而要“读懂”这类景点，无不需要历史、宗教、文化等知识积累。\n否则要么是任由导游的胡诌乱扯，要么是走马观花之下的乏味。\n之后，大部分人所得不过是朋友圈的“摄影大赛”。\n而后来和朋友描述此行所得时，不过怅然的感慨“看景不如听景”。\n而人要真想提高眼界，首先是阅读和思考，从而形成自己对世界的理解。\n而之后的游历，更多的不是增长见识，而是对自己思想的验证。\n而在当今，交通和资讯高度发达。\n无论是在国内旅游，还是到国外，普通的中产家庭都是能够负担起的。\n而与之相比，阅读和思考反而是很多人所匮乏的。\n而很多时候，一个爱思考和爱阅读的人甚至不用游历太多，也能拥有深刻的见解。\n一个人思考什么远比看见什么重要。\n康德终身没有离开过故乡，但这并不妨碍他拥有伟大的思想，成为德国历史上最伟大的哲学家。\n","permalink":"https://note.yxzi.xyz/note/view/thinking/%E6%B2%A1%E6%9C%89%E6%80%9D%E6%83%B3%E7%9A%84%E6%97%85%E8%A1%8C%E8%A1%8C%E4%B8%87%E9%87%8C%E8%B7%AF%E4%B9%9F%E6%97%A0%E5%BC%82%E4%BA%8E%E9%82%AE%E5%B7%AE/","summary":"没有思想的旅行，行万里路也无异于邮差 在欧洲旅行，常见的景点之一就是许多古堡和教堂。\n首次见到这些景点，大家还会赞叹两句（高大、富丽堂皇之类）。\n但等再次遇到这类景点，就会感到索然乏味，很多人甚至是过门而不入。\n他们乏味感完全可以理解。\n换做我们任何人，没有文化知识的积淀，对历史知识的缺乏。碰到这类景点，估计也是如此，这一点，在国内依然成立。\n在国内旅游，任何一个城市，典型的一类景点包括寺庙、石窟、园林、宫殿群。\n而要“读懂”这类景点，无不需要历史、宗教、文化等知识积累。\n否则要么是任由导游的胡诌乱扯，要么是走马观花之下的乏味。\n之后，大部分人所得不过是朋友圈的“摄影大赛”。\n而后来和朋友描述此行所得时，不过怅然的感慨“看景不如听景”。\n而人要真想提高眼界，首先是阅读和思考，从而形成自己对世界的理解。\n而之后的游历，更多的不是增长见识，而是对自己思想的验证。\n而在当今，交通和资讯高度发达。\n无论是在国内旅游，还是到国外，普通的中产家庭都是能够负担起的。\n而与之相比，阅读和思考反而是很多人所匮乏的。\n而很多时候，一个爱思考和爱阅读的人甚至不用游历太多，也能拥有深刻的见解。\n一个人思考什么远比看见什么重要。\n康德终身没有离开过故乡，但这并不妨碍他拥有伟大的思想，成为德国历史上最伟大的哲学家。","title":"没有思想的旅行，行万里路也无异于邮差"},{"content":"var 变量会进行函数声明提升，即预编译处理。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/var/","summary":"var 变量会进行函数声明提升，即预编译处理。","title":"JavaScrip var"},{"content":"Rip 协议 RIP 协议是比较老的一款动态路由协议，这款协议现在用的已经很少了；\nRIP 协议在 IPv4 里分成两个版本，目前就 RIPv2 版本来讲的话，其实也有很多问题，\n比如\n 根据路由器或者三层转发设备的条数来判断路径优劣这种判断机制是不准确的。 最大条数只有 15 跳也限制了 RIP 的网络规模。 RIP 运行的速度比较慢，而且可能产生环路对网络有很大的影响。  router rip 启用 Rip\nversion 2 切换到 RipV2 版本\nnetwork 通告该路由器的所有直连网络，通告之后，\n该路由器的路由表就会显示除了通告外的所有网络的路由表的本地接口和远程网络的数量是一样的.\nshow ip protocol 显示该路由器的路由协议，路由表前面的大写字母叫做路由来源\nno auto-summary 禁用该路由器上的自动汇总\npassive-interface g0/1 将连接局域网的接口 g 0/1 配置为被动接口，\ndefault-information originate 配置路由器的完全指定默认路由的默认信息来源\n","permalink":"https://note.yxzi.xyz/note/technology/internet/cisco/rip-%E5%8D%8F%E8%AE%AE/","summary":"Rip 协议 RIP 协议是比较老的一款动态路由协议，这款协议现在用的已经很少了；\nRIP 协议在 IPv4 里分成两个版本，目前就 RIPv2 版本来讲的话，其实也有很多问题，\n比如\n 根据路由器或者三层转发设备的条数来判断路径优劣这种判断机制是不准确的。 最大条数只有 15 跳也限制了 RIP 的网络规模。 RIP 运行的速度比较慢，而且可能产生环路对网络有很大的影响。  router rip 启用 Rip\nversion 2 切换到 RipV2 版本\nnetwork 通告该路由器的所有直连网络，通告之后，\n该路由器的路由表就会显示除了通告外的所有网络的路由表的本地接口和远程网络的数量是一样的.\nshow ip protocol 显示该路由器的路由协议，路由表前面的大写字母叫做路由来源\nno auto-summary 禁用该路由器上的自动汇总\npassive-interface g0/1 将连接局域网的接口 g 0/1 配置为被动接口，\ndefault-information originate 配置路由器的完全指定默认路由的默认信息来源","title":"Cisco Rip 协议"},{"content":"SSH 取代 Telnet 远程登录 进入 PC 的 Desktop，选择 Command Prompt，\n输入密码并登录。\n保护密码\n进入特权模式，保存\n加密密码 在全局模式下：\nServerce password-encryption SSH 加密通信 ip domian-name username\rip ssh version 2\rcrypto key generate rsa ","permalink":"https://note.yxzi.xyz/note/technology/internet/cisco/ssh-%E5%8F%96%E4%BB%A3-telnet/","summary":"SSH 取代 Telnet 远程登录 进入 PC 的 Desktop，选择 Command Prompt，\n输入密码并登录。\n保护密码\n进入特权模式，保存\n加密密码 在全局模式下：\nServerce password-encryption SSH 加密通信 ip domian-name username\rip ssh version 2\rcrypto key generate rsa ","title":"Cisco SSH 取代 Telnet"},{"content":"琐碎知识点 C 直连网络\nL 本地接口\nS 静态路由\n汇总路由的作用 将多条路由汇总为一条，减少路由表体积\n浮动静态路由的作用 配置静态路由的同时，再后面手动配置一个默认的管理距离\n默认静态路由的 ipv4 地址 0.0.0.0 0.0.0.0\nACL 是控制列表\n控制列表最后一条是默认拒绝语句\nACL 的两种类型 标准 ACL ，扩展类型 ACL\n通配符掩码中的 0 是全匹配 1 是全忽略\n通配符掩码是 子网反掩码\nhost 表示 0.0.0.0\n静态路由 目标地址 送出接口或吓一跳\n递归静态路由（吓一跳静态路由）\n完全指定路由（接口和下一跳都配置）\n子网掩码 24 可以包含多少个网络位\n网络位 只有八位\n全 0 为 网络地址\n全 1 为广播地址\nrip 动态协议\n汇总路由\n进站 in\n出站 out\n三个接口\n每个接口有都有一个 in 或 out\n一共可以写 6 个 ACL\n每个 in 和每个 out 都可以写 ipv4 或 ipv6 的地址\nAccess list 10 deny ip 地址 反码\n搭建网络需要考虑哪些因素\n命令题，动态路由\nACL host 等同于 0.0.0.0\npermit any 等同于 255.255.255.255\n给一个主机地址，\n默认子网掩码为 32\n","permalink":"https://note.yxzi.xyz/note/technology/internet/cisco/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/","summary":"琐碎知识点 C 直连网络\nL 本地接口\nS 静态路由\n汇总路由的作用 将多条路由汇总为一条，减少路由表体积\n浮动静态路由的作用 配置静态路由的同时，再后面手动配置一个默认的管理距离\n默认静态路由的 ipv4 地址 0.0.0.0 0.0.0.0\nACL 是控制列表\n控制列表最后一条是默认拒绝语句\nACL 的两种类型 标准 ACL ，扩展类型 ACL\n通配符掩码中的 0 是全匹配 1 是全忽略\n通配符掩码是 子网反掩码\nhost 表示 0.0.0.0\n静态路由 目标地址 送出接口或吓一跳\n递归静态路由（吓一跳静态路由）\n完全指定路由（接口和下一跳都配置）\n子网掩码 24 可以包含多少个网络位\n网络位 只有八位\n全 0 为 网络地址\n全 1 为广播地址\nrip 动态协议\n汇总路由\n进站 in\n出站 out\n三个接口\n每个接口有都有一个 in 或 out\n一共可以写 6 个 ACL\n每个 in 和每个 out 都可以写 ipv4 或 ipv6 的地址","title":"Cisco 琐碎知识点"},{"content":"配置中继 进交换机的全局\ninterface f 0/1 switchport mode trunk switchport trunk native vlan 99 ","permalink":"https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%BB%A7/","summary":"配置中继 进交换机的全局\ninterface f 0/1 switchport mode trunk switchport trunk native vlan 99 ","title":"Cisco 配置中继"},{"content":"配置交换机端口安全 配置 S1\nenable configure terminal 配置端口模式 interface f 0/1 switchport mode access 打开端口的安全模式 switch port-security //开启f0/1端口的安全功能 switchport port-security maximum 1 // 配置该端口的最大连接数为 1（最大能配置为128 switch） switchport port-security mac-address sticky // 让交换机口主动记下最先插入设备的 MAC 地址。 switchport port-security violation restrict //针对不合法的MAC地址连接该端口，配置端口的处理模式为：（protect[丢弃数据包，不发警告] | restrict[丢弃数据包，在 console 发警告] | shutdown[关]） no shutdown 、 exit ","permalink":"https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E5%AE%89%E5%85%A8/","summary":"配置交换机端口安全 配置 S1\nenable configure terminal 配置端口模式 interface f 0/1 switchport mode access 打开端口的安全模式 switch port-security //开启f0/1端口的安全功能 switchport port-security maximum 1 // 配置该端口的最大连接数为 1（最大能配置为128 switch） switchport port-security mac-address sticky // 让交换机口主动记下最先插入设备的 MAC 地址。 switchport port-security violation restrict //针对不合法的MAC地址连接该端口，配置端口的处理模式为：（protect[丢弃数据包，不发警告] | restrict[丢弃数据包，在 console 发警告] | shutdown[关]） no shutdown 、 exit ","title":"Cisco 配置交换机端口安全"},{"content":"配置单臂路由 拓扑图 三台 PC\n中间一台交换机\n一台路由器在交换机上方\n将交换机与路由器连起来\n配置 S1 进全局模式 enable configure terminal hostname S1  vlan 10 exit  vlan 20 exit  vlan 30 exit 将指定 access 端口分配给指定 vlan interface f 0/2\rswitchport acces vlan 10\rexit\rinterface f 0/3\rswitchport acces vlan 20\rexit\rinterface f 0/4\rswitchport acces vlan 30\rexi 将二层端口配置成 trunk 模式 interface g 0/1\rswitchport mode trunk 配置 R1 enable\rconfigure terminal\rhostname R1 配置虚拟子端口 interface g 0/0.1\renc dot1Q 10\rip address 192.168.2.2（pc的默认网关）255.255.255.0\rexit\rinterface g 0/0.2\renc dot1Q 20\rip address 192.168.3.2（pc的默认网关）255.255.255.0\rexit\rinterface g 0/0.3\renc dot1Q 30\rip address 192.168.4.2（pc的默认网关）255.255.255.0\rexit 开启虚拟端口 interface g 0/0\rno shutdown\rexit 配置 PC 配置 PC 0 ip 地址 192.168.2.1\r子网掩码：255.255.255.0\r默认网关 192.168.2.2 配置 PC 1 ip 地址 3.1\r子网掩码：255.255.255.0\r默认网关：192.168.3.2 配置 PC3 ip 地址：192.168.14.1\r子网掩码：255.255.255.0\r默认网关：192.168.4.2 ","permalink":"https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1/","summary":"配置单臂路由 拓扑图 三台 PC\n中间一台交换机\n一台路由器在交换机上方\n将交换机与路由器连起来\n配置 S1 进全局模式 enable configure terminal hostname S1  vlan 10 exit  vlan 20 exit  vlan 30 exit 将指定 access 端口分配给指定 vlan interface f 0/2\rswitchport acces vlan 10\rexit\rinterface f 0/3\rswitchport acces vlan 20\rexit\rinterface f 0/4\rswitchport acces vlan 30\rexi 将二层端口配置成 trunk 模式 interface g 0/1\rswitchport mode trunk 配置 R1 enable\rconfigure terminal\rhostname R1 配置虚拟子端口 interface g 0/0.","title":"Cisco 配置单臂路由"},{"content":"Hugo 命令 hugo new site MyBlog 创建一个新的站点文件夹\nhugo new Article/first.md hugo -t ThemeName hugo -D 构建静态页面\n","permalink":"https://note.yxzi.xyz/note/technology/frame/hugo/%E5%91%BD%E4%BB%A4/","summary":"Hugo 命令 hugo new site MyBlog 创建一个新的站点文件夹\nhugo new Article/first.md hugo -t ThemeName hugo -D 构建静态页面","title":"Hugo 命令"},{"content":"SHH 密钥登录 用 xshell 生成密钥 新建用户密钥生成向导\n输入密钥长度，比如 2024，下一步\n输入密钥名称、密码，下一步\n将公钥保存为文件，完成\n将公钥上传到服务器 我这里用的服务器是 Linux，以及宝塔面板。\n进入服务器的**/root/.ssh路径，在这个文件夹中新建authorized_keys文件，并将之前保存的公钥中的文件内容复制到新建的authorized_keys**文件中。\n配置 sshd_config 找到服务器下的**/etc/ssh/sshd_config**，点击编辑。\n核对文件中的内容是否与一下内容一致，不一致请作出对应的的修改。\n注意，一下内容前面的注释符号**#**请删掉。\nAuthorizedKeysFile .ssh/authorized_keys PasswordAuthentication no ","permalink":"https://note.yxzi.xyz/note/technology/linux/shh-%E5%AF%86%E9%92%A5%E7%99%BB%E9%99%86/","summary":"SHH 密钥登录 用 xshell 生成密钥 新建用户密钥生成向导\n输入密钥长度，比如 2024，下一步\n输入密钥名称、密码，下一步\n将公钥保存为文件，完成\n将公钥上传到服务器 我这里用的服务器是 Linux，以及宝塔面板。\n进入服务器的**/root/.ssh路径，在这个文件夹中新建authorized_keys文件，并将之前保存的公钥中的文件内容复制到新建的authorized_keys**文件中。\n配置 sshd_config 找到服务器下的**/etc/ssh/sshd_config**，点击编辑。\n核对文件中的内容是否与一下内容一致，不一致请作出对应的的修改。\n注意，一下内容前面的注释符号**#**请删掉。\nAuthorizedKeysFile .ssh/authorized_keys PasswordAuthentication no ","title":"SHH 密钥登录"},{"content":"使用 Git 注意本地密钥是否和远程的密钥一样。\n","permalink":"https://note.yxzi.xyz/note/technology/softwareuse/vscode/%E4%BD%BF%E7%94%A8-git/","summary":"使用 Git 注意本地密钥是否和远程的密钥一样。","title":"Vs Code 使用 Git"},{"content":"Vs Code 扩展 Bracket Pair Colorizer 给匹配的括号着色\nPath Intellisense 自动完成文件名\nMaterial Icon Theme 好看的文件图标\nPrettier - Code formatter 更优雅的代码格式化。vscode 里比较优秀的一个格式化插件。\nVS Code Counter 统计代码总行数、注释行数、空白行数，以及使用的语言。\n使用方法：右键需要统计的文件夹—Count lines in directory\nPower Mode 一款超级炫酷的编辑代码的插\nHTML Snippets 非常实用的 HTML 代码片段以及提示\nAtuo Rename Tag 修改 html 标签，自动帮你完成尾部闭合标签的同步修改\nCode Runner 能够运行多种语言的代码片段或代码文件：JavaScript，C，C ++，Java，PHP，Python，Perl，Ruby，Go 等等\nEasy LESS 保存style.less后，会自动生成style.css到当前路径\npx to rem \u0026amp; rpx 实现 px 和 rem 单位之间转换，并支持 WXSS。\nMarkdown Preview Mermaid Support markdown 支持思维导图\nVetur vue 补全\n","permalink":"https://note.yxzi.xyz/note/technology/softwareuse/vscode/%E6%89%A9%E5%B1%95/","summary":"Vs Code 扩展 Bracket Pair Colorizer 给匹配的括号着色\nPath Intellisense 自动完成文件名\nMaterial Icon Theme 好看的文件图标\nPrettier - Code formatter 更优雅的代码格式化。vscode 里比较优秀的一个格式化插件。\nVS Code Counter 统计代码总行数、注释行数、空白行数，以及使用的语言。\n使用方法：右键需要统计的文件夹—Count lines in directory\nPower Mode 一款超级炫酷的编辑代码的插\nHTML Snippets 非常实用的 HTML 代码片段以及提示\nAtuo Rename Tag 修改 html 标签，自动帮你完成尾部闭合标签的同步修改\nCode Runner 能够运行多种语言的代码片段或代码文件：JavaScript，C，C ++，Java，PHP，Python，Perl，Ruby，Go 等等\nEasy LESS 保存style.less后，会自动生成style.css到当前路径\npx to rem \u0026amp; rpx 实现 px 和 rem 单位之间转换，并支持 WXSS。\nMarkdown Preview Mermaid Support markdown 支持思维导图\nVetur vue 补全","title":"Vs Code 扩展"},{"content":"WinSCP SSH 密钥登录 WinSCP -\u0026gt; 高级 -\u0026gt; SSH -\u0026gt; 验证 -\u0026gt; 密钥文件\n","permalink":"https://note.yxzi.xyz/note/technology/linux/winscp-ssh-%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95/","summary":"WinSCP SSH 密钥登录 WinSCP -\u0026gt; 高级 -\u0026gt; SSH -\u0026gt; 验证 -\u0026gt; 密钥文件","title":"WinSCP SSH 密钥登录"},{"content":"《三体·地球往事》 我的第一本科幻书 《三体·地球往事》是我看的第一本科幻类型的书，说句实话，我第一次看三体第一部的时候，感觉这玩意很难看懂，深奥的物理知识，为数不多的科幻描写，真给我整懵逼了，让我不得不怀疑这本获得了雨果奖的科幻神作，但时间一转，我终于在今年初将三部曲看完了，这一次的阅读，不知是不是我三本连起来读的原因，在阅读的过程中无比感叹作者知识的宽广与深度，以及无与伦比的想象力！\n自身想象力的匮乏 在这之前，我也对宇宙有着幻想，也会独自走到楼顶，望着深渊般的天空与时而闪烁的群星，我内心颤栗着，不禁幻想着自己能有一双翅膀，能看看天空真实的模样，想想就令人十分兴奋！虽然我不知道宇宙是什么样的，是否有外星人，我们是否是宇宙中唯一的人类，但幸运的是，《三体·地球往事》带我走进了这个复杂而又奇妙的世界！复杂的是那些对我而言深奥复杂的物理知识，正儿八经，这里差点把我劝退》…奇妙的是原来宇宙还能这样！\n读这本书的过程中，我感到我的想象力是如此匮乏与空虚，空有想象力，但却无法形成一个独立世界，无法像书中那样，自成一个符合逻辑与科学的世界，但又丝毫不缺乏一种超前与震撼的感觉。\n汪淼是主角的错觉 刚开始读的时候，我原以为汪淼就是书中的主角，但读到后面愈发觉得，这人怕只是一个移动摄像机，具体点说，像一个旁观者，故事中大部分场景都是以他的视角来描写的，像是作者故意安排这个人来带我们了解这个三体世界，了解三体游戏。\n叶文洁的登场 其次是主角叶文洁，讲道理，读到这里的时候，我根本不会想到主角会是一个老太太，但读到红岸基地时候的故事的故事之后，我知道了，我小巧了这个弱不禁风的老太太，特别是当叶文洁按下发射器的那一刻，我的灵魂似乎已经来到了红岸基地，静静的看着叶文洁按下发射器，看着这改变人类未来的一幕，也让我感受到了叶文洁对人类的绝对失望，在这之前，他的父亲在文革时期被活生生的被皮带抽死在批斗台上，她自己在台下目睹了这一切，我想，在那一刻，她一定无比憎恨人类，而在这之后，她通过白沐霖接触到禁书《寂静的春天》中的环保理念后，他对白沐霖产生了好感，因为他让她再次相信这个世界还是有善良的人的，但就是这个在黑暗中带给她一丝光明的白沐霖，将她推入了万丈深渊，让她成为了一个替罪羔羊，最后就是发现对她一向非常好的领导雷志成，也只是想占有了她的研究成果图谋上位后，她彻底失望了，我想，这也是她为什么会按下发射按钮的原因，她坚信，只有这个远高于地球文明的三体文明才能解决现在人类解决不了的问题。\n叶文洁的决断 在这之后，她为了保守这个秘密，不惜杀害这个从监狱里救出她的恩人和深爱她的丈夫，看到这里我也非常佩服叶文洁的决断，愈发觉得她对整个人类世界的失望是无法用语言形容的，她希望借三体世界这个高级文明的力量来拯救这个腐败的人类的世界，她在这方便似乎已经陷入了魔怔，为此还间接导致数位顶级科学家，也就是书中开头的所说的数位科学家的大佬离奇死亡，甚至其中还包括她的女儿，我不由的感叹，这何尝不是一种疯狂，一种狠辣，不由让我感叹这些手段，是一个女人能做出来的吗。也许叶文洁从她父亲死亡的那一刻起，就已经是另外一个人了。\n诡异而又神秘的游戏 接着就是三体游戏，刚开始，我很疑惑，一个现时中的科幻书啥要扯上游戏，而且这个游戏还用很多我们国家古代的人名，比如：秦始皇、爱因斯坦、墨子、冯诺依曼等等，我就更加疑惑了，咋滴，一个科幻小说，还回顾一下世界历史吗，结果读到后面我发现我错了，而且错的离谱。\n这个游戏是以叶文洁为首的三体组织所建立的，这也很让我意外，这个似乎弱不禁风的女子，居然是这个组织的建立者，我再次发现我低估了这个改变人类命运的女人。\n这个三体游戏，也是这个组织建立的，这也很合理，毕竟这个组织可是世界各地顶尖的科学家所设立的，都是高端人士啊。看到这里我也不禁在心中说出两个字，牛逼啊！别的组织都是 i 从低端人才开始招揽，你们居然直接从科学家开始\u0026hellip;\n后来我也很疑惑为什么三体组织要开发这个游戏，毕竟凡事都是有目的的。这个看似无害的游戏也并非看起来的那么友善。后来我逐渐发现，这个游戏非常有可能是为了让更多的人了解三体这个世界而开发的，也就是说三体组织想让地球上更多的人了解三体世界，接纳三体世界。\n这似乎也暴露了一个惊人的结论：三体组织与三体世界互相联系过！\nend\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/novel/%E4%B8%89%E4%BD%93%E5%9C%B0%E7%90%83%E5%BE%80%E4%BA%8B/","summary":"《三体·地球往事》 我的第一本科幻书 《三体·地球往事》是我看的第一本科幻类型的书，说句实话，我第一次看三体第一部的时候，感觉这玩意很难看懂，深奥的物理知识，为数不多的科幻描写，真给我整懵逼了，让我不得不怀疑这本获得了雨果奖的科幻神作，但时间一转，我终于在今年初将三部曲看完了，这一次的阅读，不知是不是我三本连起来读的原因，在阅读的过程中无比感叹作者知识的宽广与深度，以及无与伦比的想象力！\n自身想象力的匮乏 在这之前，我也对宇宙有着幻想，也会独自走到楼顶，望着深渊般的天空与时而闪烁的群星，我内心颤栗着，不禁幻想着自己能有一双翅膀，能看看天空真实的模样，想想就令人十分兴奋！虽然我不知道宇宙是什么样的，是否有外星人，我们是否是宇宙中唯一的人类，但幸运的是，《三体·地球往事》带我走进了这个复杂而又奇妙的世界！复杂的是那些对我而言深奥复杂的物理知识，正儿八经，这里差点把我劝退》…奇妙的是原来宇宙还能这样！\n读这本书的过程中，我感到我的想象力是如此匮乏与空虚，空有想象力，但却无法形成一个独立世界，无法像书中那样，自成一个符合逻辑与科学的世界，但又丝毫不缺乏一种超前与震撼的感觉。\n汪淼是主角的错觉 刚开始读的时候，我原以为汪淼就是书中的主角，但读到后面愈发觉得，这人怕只是一个移动摄像机，具体点说，像一个旁观者，故事中大部分场景都是以他的视角来描写的，像是作者故意安排这个人来带我们了解这个三体世界，了解三体游戏。\n叶文洁的登场 其次是主角叶文洁，讲道理，读到这里的时候，我根本不会想到主角会是一个老太太，但读到红岸基地时候的故事的故事之后，我知道了，我小巧了这个弱不禁风的老太太，特别是当叶文洁按下发射器的那一刻，我的灵魂似乎已经来到了红岸基地，静静的看着叶文洁按下发射器，看着这改变人类未来的一幕，也让我感受到了叶文洁对人类的绝对失望，在这之前，他的父亲在文革时期被活生生的被皮带抽死在批斗台上，她自己在台下目睹了这一切，我想，在那一刻，她一定无比憎恨人类，而在这之后，她通过白沐霖接触到禁书《寂静的春天》中的环保理念后，他对白沐霖产生了好感，因为他让她再次相信这个世界还是有善良的人的，但就是这个在黑暗中带给她一丝光明的白沐霖，将她推入了万丈深渊，让她成为了一个替罪羔羊，最后就是发现对她一向非常好的领导雷志成，也只是想占有了她的研究成果图谋上位后，她彻底失望了，我想，这也是她为什么会按下发射按钮的原因，她坚信，只有这个远高于地球文明的三体文明才能解决现在人类解决不了的问题。\n叶文洁的决断 在这之后，她为了保守这个秘密，不惜杀害这个从监狱里救出她的恩人和深爱她的丈夫，看到这里我也非常佩服叶文洁的决断，愈发觉得她对整个人类世界的失望是无法用语言形容的，她希望借三体世界这个高级文明的力量来拯救这个腐败的人类的世界，她在这方便似乎已经陷入了魔怔，为此还间接导致数位顶级科学家，也就是书中开头的所说的数位科学家的大佬离奇死亡，甚至其中还包括她的女儿，我不由的感叹，这何尝不是一种疯狂，一种狠辣，不由让我感叹这些手段，是一个女人能做出来的吗。也许叶文洁从她父亲死亡的那一刻起，就已经是另外一个人了。\n诡异而又神秘的游戏 接着就是三体游戏，刚开始，我很疑惑，一个现时中的科幻书啥要扯上游戏，而且这个游戏还用很多我们国家古代的人名，比如：秦始皇、爱因斯坦、墨子、冯诺依曼等等，我就更加疑惑了，咋滴，一个科幻小说，还回顾一下世界历史吗，结果读到后面我发现我错了，而且错的离谱。\n这个游戏是以叶文洁为首的三体组织所建立的，这也很让我意外，这个似乎弱不禁风的女子，居然是这个组织的建立者，我再次发现我低估了这个改变人类命运的女人。\n这个三体游戏，也是这个组织建立的，这也很合理，毕竟这个组织可是世界各地顶尖的科学家所设立的，都是高端人士啊。看到这里我也不禁在心中说出两个字，牛逼啊！别的组织都是 i 从低端人才开始招揽，你们居然直接从科学家开始\u0026hellip;\n后来我也很疑惑为什么三体组织要开发这个游戏，毕竟凡事都是有目的的。这个看似无害的游戏也并非看起来的那么友善。后来我逐渐发现，这个游戏非常有可能是为了让更多的人了解三体这个世界而开发的，也就是说三体组织想让地球上更多的人了解三体世界，接纳三体世界。\n这似乎也暴露了一个惊人的结论：三体组织与三体世界互相联系过！\nend","title":"《三体·地球往事》"},{"content":"《三体·死神永生》 ","permalink":"https://note.yxzi.xyz/note/afterthought/book/novel/%E4%B8%89%E4%BD%93%E6%AD%BB%E7%A5%9E%E6%B0%B8%E7%94%9F/","summary":"《三体·死神永生》 ","title":"《三体·死神永生》"},{"content":"《三体·黑暗森林》 ","permalink":"https://note.yxzi.xyz/note/afterthought/book/novel/%E4%B8%89%E4%BD%93%E9%BB%91%E6%9A%97%E6%A3%AE%E6%9E%97/","summary":"《三体·黑暗森林》 ","title":"《三体·黑暗森林》"},{"content":"《人体内旅行》 第一次看《人体内旅行》这部纪录片。\n看完后，很是让我感受到了人体的精密，得天独厚的同时，但又不堪一击。\n不得不使我开始思考一个问题——我明明有着如此神秘且奇妙的人体结构，为什么我还是如此的平凡且普通？\n亦或者是我没有发现我的独特之处？\n还是像我这样拥有神秘人体结构的人太多了？\n我发现，这个时代似乎很少人珍惜自己的身体健康，似乎这样说也不准确，而应该说，\n珍惜身体健康的人越来越珍惜，不珍惜的人越来越不珍惜。\n这种两级分化的现象很让我不解，但又似乎不可避免。\n是因为内心不重视吗？但我想没人会不重视自己的身体吧。\n或者只是因为这该死的生活压力，无法让人抽出空闲时间来思考这些问题罢。\n","permalink":"https://note.yxzi.xyz/note/afterthought/movie/documentary/%E4%BA%BA%E4%BD%93%E5%86%85%E6%97%85%E8%A1%8C/","summary":"《人体内旅行》 第一次看《人体内旅行》这部纪录片。\n看完后，很是让我感受到了人体的精密，得天独厚的同时，但又不堪一击。\n不得不使我开始思考一个问题——我明明有着如此神秘且奇妙的人体结构，为什么我还是如此的平凡且普通？\n亦或者是我没有发现我的独特之处？\n还是像我这样拥有神秘人体结构的人太多了？\n我发现，这个时代似乎很少人珍惜自己的身体健康，似乎这样说也不准确，而应该说，\n珍惜身体健康的人越来越珍惜，不珍惜的人越来越不珍惜。\n这种两级分化的现象很让我不解，但又似乎不可避免。\n是因为内心不重视吗？但我想没人会不重视自己的身体吧。\n或者只是因为这该死的生活压力，无法让人抽出空闲时间来思考这些问题罢。","title":"《人体内旅行》"},{"content":"《元尊》 ","permalink":"https://note.yxzi.xyz/note/afterthought/book/fantasy/%E5%85%83%E5%B0%8A/","summary":"《元尊》 ","title":"《元尊》"},{"content":"《地球脉动》 ","permalink":"https://note.yxzi.xyz/note/afterthought/movie/documentary/%E5%9C%B0%E7%90%83%E8%84%89%E5%8A%A8/","summary":"《地球脉动》 ","title":"《地球脉动》"},{"content":"《夜行者》 ","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E5%A4%9C%E8%A1%8C%E8%80%85/","summary":"《夜行者》 ","title":"《夜行者》"},{"content":"《宇宙时空之旅》 ","permalink":"https://note.yxzi.xyz/note/afterthought/movie/documentary/%E5%AE%87%E5%AE%99%E6%97%B6%E7%A9%BA%E4%B9%8B%E6%97%85/","summary":"《宇宙时空之旅》 ","title":"《宇宙时空之旅》"},{"content":"《小王子》 玫瑰和狐狸对小王子的感情分别是怎样的？ 我的回答是，玫瑰和狐狸对小王子都是爱。\n但是他们爱的方式和成熟度是有很大差别的。\n玫瑰的爱是青涩的，甚至有点小女人有点作的。\n狐狸的爱是成熟的，包容的，付出的，让小王子成长的。\n为什么这么说捏，下面来解释一下。\n写玫瑰时已经用了大量的铺垫，然而玫瑰的出场却不免让让人有点失望。\n 她已经精细地做了那么长的准备工作，却打着哈欠说道：\n“我刚刚睡醒，真对不起，瞧我的头发还是乱蓬蓬的……”\n小王子这时再也控制不住自己的爱慕心情： “你是多么美丽啊！”\n花儿悠然自得地说：\n“是吧，我是与太阳同时出生的……”\n小王子看出了这花儿不太谦虚，可是她确实丽姿动人。\n 玫瑰一开花说的第一句话就有些故作姿态，暗示引导小王子去注意她赞美她。虽然识破了玫瑰的故意并不能阻止小王子对玫瑰的爱慕，但玫瑰却因此给小王子留下了骄傲虚荣的印象。\n其实这里我们已经能看出来玫瑰的青涩，但她的骄傲爱面子只会让她的爱变得更加稚嫩。\n再看小王子走时玫瑰的独白。\n 花儿咳嗽了一阵。但并不是由于感冒。\n她终于对他说道：“我方才真蠢。请你原谅我。希望你能幸福。” 花儿对他毫不抱怨，他感到很惊讶。他举着罩子，不知所措地伫立在那里。 他不明白她为什么会这样温柔恬静。\n“的确，我爱你。”花儿对他说道：“但由于我的过错，你一点也没有理会。 这丝毫不重要。不过，你也和我一样的蠢。希望你今后能幸福。把罩子放在一边吧，我用不着它了。”\n“要是风来了怎么办？”\n“我的感冒并不那么重……夜晚的风对我有益。”\n“要是有虫子野兽呢？……”\n“我要是想认识蝴蝶，经不起两三只毛毛虫是不行的。据说这是很美的。不然还有谁来看我呢？你就要到远处去了。至于说大动物，我并不怕，我有爪子。”\n于是，她天真地显露出她那四根刺，随后又说道： “别这么磨蹭了。真烦人！你既然决定离开这儿，那么，快走吧！”\n她是怕小王子看见她在哭。她是一朵非常骄傲的花……\n 她一开花便要他为她浇水，装咳嗽，晚上还要罩子，其实连她自己都知道她根本不需要至如此，而这一切全都是——爱的试炼。她让他为她服务，反复考验，并享受这种状态。\n这简直是现实生活中的缩影，我认识的很多敏感又有点小虚荣的女孩都会这样对自己爱的人，不是不爱，不爱就不会折磨对方了，只是太青涩，完全不懂的如何去表达爱。\n其实玫瑰是懂事的，小王子疲惫了要走到更远的地方开拓视野，玫瑰没有哭闹，只是简单地祝他幸福并且叫他放心走不要挂念她，玫瑰的懂事叫人心疼。\n而“她是一朵非常骄傲的花”这句无论是评价还是独白，我的理解是这是玫瑰对自己的一种掩饰。她怕小王子看见她哭是因为，她怕他看到就会看穿她的敏感脆弱，进而选择不去别的地方闯荡而束缚捆绑了他，亦或者她更怕即便他看到她流泪也还是执意离开。\n她很青涩很敏感，让人不禁心生怜悯变得温柔起来。\n————————————————————————————————————\n而狐狸呢。\n小王子去了很多星球，终于来到了地球，在意识到自己星球的玫瑰并不是独一无二时遇见并驯养了狐狸，在小王子离开的时候，狐狸非常难过，但仍然悉心告诉小王子自己的秘密，他的的最后一句叮嘱是：\n “再见。”狐狸说。“喏，这就是我的秘密。很简单：只有用心才能看得清。 实质性的东西，用眼睛是看不见的。”\n“实质性的东西，用眼睛是看不见的。”小王子重复着这句话，以便能把它 记在心间。\n“正因为你为你的玫瑰花费了时间，这才使你的玫瑰变得如此重要。”\n“正因为你为你的玫瑰花费了时间……”小王子又重复着，要使自己记住这些。\n“人们已经忘记了这个道理，”狐狸说，“可是，你不应该忘记它。你现在要对你驯服过的一切负责到底。你要对你的玫瑰负责……”\n“我要对我的玫瑰负责……”小王子又重复着……\n 狐狸知道并且厌烦了在猎人过节日时去偷鸡，他已经谙熟了这个世界的生存法则。而这个世界的法则跟小王子的世界是完全不一样的，小王子的星球的生存法则就是纪律性的——分辨并拔掉猴面包树的苗，定期清理火山。小王子的世界因为有定数，所以单纯简单，他们两个注定无法在一个世界。 所以狐狸一出场就以一个成熟老练甚至狡黠的身份出现，这也注定了他感情上的成熟和智者身份的教诲。\n在狐狸执意要小王子驯养他之前，他就知道这段感情注定是一场空。\n其实驯养不一定意味着就会喜欢就会爱，驯养的本质是一种习惯，一种填补。 但狐狸爱上了他。因为即便在分别的时候如此难过，狐狸也不忘叮嘱小王子要对玫瑰负责。让自己爱的人对他爱的人负责，是怎样的心情，怎样的心胸呢，要多么深沉的爱才可以认真说出这种话呢。小王子在玫瑰那里受的伤，狐狸来安抚，小王子对玫瑰的责任，狐狸来教，狐狸阿狐狸，你怎么偏偏爱上了如此单纯的小王子。\n你教导小王子要对他所驯养的一切负责，这其中是不是，也包括你自己呢？如果不包括，又是怎样的一种牺牲阿。\n但在小王子走后，至少狐狸不会那么寂寞，因为狐狸从此爱上风吹麦浪的声音，心中有了想念的人。无牵无挂心中空空如也才最是寂寞。\n你走，我不送你。你来，无论多大风多大雨，我要去接你。 ——梁实秋\n你要走便走，我不会留。\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/novel/%E5%B0%8F%E7%8E%8B%E5%AD%90/","summary":"《小王子》 玫瑰和狐狸对小王子的感情分别是怎样的？ 我的回答是，玫瑰和狐狸对小王子都是爱。\n但是他们爱的方式和成熟度是有很大差别的。\n玫瑰的爱是青涩的，甚至有点小女人有点作的。\n狐狸的爱是成熟的，包容的，付出的，让小王子成长的。\n为什么这么说捏，下面来解释一下。\n写玫瑰时已经用了大量的铺垫，然而玫瑰的出场却不免让让人有点失望。\n 她已经精细地做了那么长的准备工作，却打着哈欠说道：\n“我刚刚睡醒，真对不起，瞧我的头发还是乱蓬蓬的……”\n小王子这时再也控制不住自己的爱慕心情： “你是多么美丽啊！”\n花儿悠然自得地说：\n“是吧，我是与太阳同时出生的……”\n小王子看出了这花儿不太谦虚，可是她确实丽姿动人。\n 玫瑰一开花说的第一句话就有些故作姿态，暗示引导小王子去注意她赞美她。虽然识破了玫瑰的故意并不能阻止小王子对玫瑰的爱慕，但玫瑰却因此给小王子留下了骄傲虚荣的印象。\n其实这里我们已经能看出来玫瑰的青涩，但她的骄傲爱面子只会让她的爱变得更加稚嫩。\n再看小王子走时玫瑰的独白。\n 花儿咳嗽了一阵。但并不是由于感冒。\n她终于对他说道：“我方才真蠢。请你原谅我。希望你能幸福。” 花儿对他毫不抱怨，他感到很惊讶。他举着罩子，不知所措地伫立在那里。 他不明白她为什么会这样温柔恬静。\n“的确，我爱你。”花儿对他说道：“但由于我的过错，你一点也没有理会。 这丝毫不重要。不过，你也和我一样的蠢。希望你今后能幸福。把罩子放在一边吧，我用不着它了。”\n“要是风来了怎么办？”\n“我的感冒并不那么重……夜晚的风对我有益。”\n“要是有虫子野兽呢？……”\n“我要是想认识蝴蝶，经不起两三只毛毛虫是不行的。据说这是很美的。不然还有谁来看我呢？你就要到远处去了。至于说大动物，我并不怕，我有爪子。”\n于是，她天真地显露出她那四根刺，随后又说道： “别这么磨蹭了。真烦人！你既然决定离开这儿，那么，快走吧！”\n她是怕小王子看见她在哭。她是一朵非常骄傲的花……\n 她一开花便要他为她浇水，装咳嗽，晚上还要罩子，其实连她自己都知道她根本不需要至如此，而这一切全都是——爱的试炼。她让他为她服务，反复考验，并享受这种状态。\n这简直是现实生活中的缩影，我认识的很多敏感又有点小虚荣的女孩都会这样对自己爱的人，不是不爱，不爱就不会折磨对方了，只是太青涩，完全不懂的如何去表达爱。\n其实玫瑰是懂事的，小王子疲惫了要走到更远的地方开拓视野，玫瑰没有哭闹，只是简单地祝他幸福并且叫他放心走不要挂念她，玫瑰的懂事叫人心疼。\n而“她是一朵非常骄傲的花”这句无论是评价还是独白，我的理解是这是玫瑰对自己的一种掩饰。她怕小王子看见她哭是因为，她怕他看到就会看穿她的敏感脆弱，进而选择不去别的地方闯荡而束缚捆绑了他，亦或者她更怕即便他看到她流泪也还是执意离开。\n她很青涩很敏感，让人不禁心生怜悯变得温柔起来。\n————————————————————————————————————\n而狐狸呢。\n小王子去了很多星球，终于来到了地球，在意识到自己星球的玫瑰并不是独一无二时遇见并驯养了狐狸，在小王子离开的时候，狐狸非常难过，但仍然悉心告诉小王子自己的秘密，他的的最后一句叮嘱是：\n “再见。”狐狸说。“喏，这就是我的秘密。很简单：只有用心才能看得清。 实质性的东西，用眼睛是看不见的。”\n“实质性的东西，用眼睛是看不见的。”小王子重复着这句话，以便能把它 记在心间。\n“正因为你为你的玫瑰花费了时间，这才使你的玫瑰变得如此重要。”\n“正因为你为你的玫瑰花费了时间……”小王子又重复着，要使自己记住这些。\n“人们已经忘记了这个道理，”狐狸说，“可是，你不应该忘记它。你现在要对你驯服过的一切负责到底。你要对你的玫瑰负责……”\n“我要对我的玫瑰负责……”小王子又重复着……\n 狐狸知道并且厌烦了在猎人过节日时去偷鸡，他已经谙熟了这个世界的生存法则。而这个世界的法则跟小王子的世界是完全不一样的，小王子的星球的生存法则就是纪律性的——分辨并拔掉猴面包树的苗，定期清理火山。小王子的世界因为有定数，所以单纯简单，他们两个注定无法在一个世界。 所以狐狸一出场就以一个成熟老练甚至狡黠的身份出现，这也注定了他感情上的成熟和智者身份的教诲。\n在狐狸执意要小王子驯养他之前，他就知道这段感情注定是一场空。\n其实驯养不一定意味着就会喜欢就会爱，驯养的本质是一种习惯，一种填补。 但狐狸爱上了他。因为即便在分别的时候如此难过，狐狸也不忘叮嘱小王子要对玫瑰负责。让自己爱的人对他爱的人负责，是怎样的心情，怎样的心胸呢，要多么深沉的爱才可以认真说出这种话呢。小王子在玫瑰那里受的伤，狐狸来安抚，小王子对玫瑰的责任，狐狸来教，狐狸阿狐狸，你怎么偏偏爱上了如此单纯的小王子。\n你教导小王子要对他所驯养的一切负责，这其中是不是，也包括你自己呢？如果不包括，又是怎样的一种牺牲阿。\n但在小王子走后，至少狐狸不会那么寂寞，因为狐狸从此爱上风吹麦浪的声音，心中有了想念的人。无牵无挂心中空空如也才最是寂寞。\n你走，我不送你。你来，无论多大风多大雨，我要去接你。 ——梁实秋\n你要走便走，我不会留。","title":"《小王子》"},{"content":"《弱点》 ","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E5%BC%B1%E7%82%B9/","summary":"《弱点》 ","title":"《弱点》"},{"content":"《徒手攀岩》 ","permalink":"https://note.yxzi.xyz/note/afterthought/movie/documentary/%E5%BE%92%E6%89%8B%E6%94%80%E5%B2%A9/","summary":"《徒手攀岩》 ","title":"《徒手攀岩》"},{"content":"《我不是药神》 ","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E6%88%91%E4%B8%8D%E6%98%AF%E8%8D%AF%E7%A5%9E/","summary":"《我不是药神》 ","title":"《我不是药神》"},{"content":"《我害怕阅读的人》 原文 不知何时开始，我害怕阅读的人。\n就像我们不知道冬天从哪天开始，只会感觉夜的黑越来越漫长。\n我害怕阅读的人。一跟他们谈话，我就像一个透明的人，苍白的脑袋无法隐藏。\n我所拥有的内涵是什么？不就是人人能脱口而出，游荡在空气中最通俗的认知吗？\n像心脏在身体的左边。春天之后是夏天。美国总统是世界上最有权力的人。\n但阅读的人在知识里遨游，能从食谱论及管理学，八卦周刊讲到社会趋势，\n甚至空中跃下的猫，都能让他们对建筑防震理论侃侃而谈。\n相较之下，我只是一台在 MP3 世代的录音机；\n过气、无法调整。我最引以为傲的论述，恐怕只是他多年前书架上某本书里的某段文字，\n而且，还是不被荧光笔画线注记的那一段。\n我害怕阅读的人。\n当他们阅读时，脸就藏匿在书后面。\n书一放下，就以贵族王者的形象在我面前闪耀，举手投足都是自在风采。\n让我明了，阅读不只是知识，更是魔力。\n他们是懂美学的牛顿。懂人类学的梵谷。懂孙子兵法的甘地。\n血液里充满答案，越来越少的问题能让他们恐惧。\n彷佛站在巨人的肩牓上，习惯俯视一切。\n那自信从容，是这世上最好看的一张脸。\n我害怕阅读的人。\n因为他们很幸运；当众人拥抱孤独、或被寂寞拥抱时，\n他们的生命却毫不封闭，不缺乏朋友的忠实、不缺少安慰者的温柔，甚至连互相较劲的对手，都不会匮乏。\n他们一翻开书，有时会因心有灵犀，而大声赞叹，\n有时又会因立场不同而陷入激辨，有时会获得劝导或慰藉。\n这一切毫无保留，又不带条件，是带亲情的爱情，是热恋中的友谊。\n一本一本的书，就像一节节的脊椎，稳稳的支持着阅读的人。\n你看，书一打开，就成为一个拥抱的姿式。\n这一切，不正是我们毕生苦苦找寻的？\n我害怕阅读的人。\n他们总是不知足。\n有人说，女人学会阅读，世界上才冒出妇女问题，也因为她们开始有了问题，女人更加读书。\n就连爱因斯坦；这个世界上智者中的最聪明者，临终前都曾说：\n我看我自己，就像一个在海边玩耍的孩子，找到一块光滑的小石头，就觉得开心。\n后来我才知道自己面对的，还有一片真理的大海，那没有尽头\n读书人总是低头看书，忙着浇灌自己的饥渴，他们让自己是敞开的桶子，随时准备装入更多、更多、更多。\n而我呢？手中抓住小石头，只为了无聊地打水漂而已。\n我害怕阅读的人。\n我祈祷他们永远不知道我的不安，免得他们会更轻易击垮我，甚至连打败我的意愿都没有。\n我如此害怕阅读的人，因为他们的榜样是伟人，就算做不到，退一步也还是一个，我远不及的成功者。\n我害怕阅读的人，他们知道「无知」在小孩身上才可爱，而我已经是一个成年的人。\n我害怕阅读的人，因为大家都喜欢有智慧人。\n我害怕阅读的人，他们能避免我要经历的失败。\n我害怕阅读的人，他们懂得生命太短，人总是聪明得太迟。\n我害怕阅读的人，他们的一小时，就是我的一生。\n我害怕阅读的人，尤其是，还在阅读的人。\n这篇文章是台湾奥美给天下文化做的长文案，在网上广为流传。\n文字很震撼，把不读书人的内心的怯懦写了出来，\n不知你有什么反应，但我看完后有一种读书的迫切感，害怕那些阅读的人把我越落越远。\n“一跟他们谈话，我就像一个透明的人，苍白的脑袋无从隐藏。”\n我对这种感受有切身体会。\n我一度自认为也算涉猎极广的人，但是因为工作原因，难免会和不同领域的高手对招。\n有次聊合作，自己深度备课的谈资在那些高人眼里，不过是初阶小白掌握的东西，而且结合到事情上还往往张冠李戴。\n当他们质问的眼神盯着我，“我就像一个透明的人，苍白的脑袋无从隐藏”。\n也许，不读书造成的这种无地自容的情形在生活中也有很多，\n只不过和我们对话的那些阅读的人不会像领导或专家一样咄咄逼人，\n他们只会在内心中暗暗鄙视：原来这是个不学无术的家伙。\n而我们自己反而不觉，仍然在那里滔滔不绝地暴露自己的无知。\n其实你在生活中戴着面具表演的时候，深知自己口中说出的那些话连自己都不知道是什么东西，\n内心深处尚存那么一丝的怯懦和心虚，说明你还没有在虚伪的生活里完全迷失。\n而读书，则是可以帮你走出这种困扰的唯一途径。\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/essay/%E6%88%91%E5%AE%B3%E6%80%95%E9%98%85%E8%AF%BB%E7%9A%84%E4%BA%BA/","summary":"《我害怕阅读的人》 原文 不知何时开始，我害怕阅读的人。\n就像我们不知道冬天从哪天开始，只会感觉夜的黑越来越漫长。\n我害怕阅读的人。一跟他们谈话，我就像一个透明的人，苍白的脑袋无法隐藏。\n我所拥有的内涵是什么？不就是人人能脱口而出，游荡在空气中最通俗的认知吗？\n像心脏在身体的左边。春天之后是夏天。美国总统是世界上最有权力的人。\n但阅读的人在知识里遨游，能从食谱论及管理学，八卦周刊讲到社会趋势，\n甚至空中跃下的猫，都能让他们对建筑防震理论侃侃而谈。\n相较之下，我只是一台在 MP3 世代的录音机；\n过气、无法调整。我最引以为傲的论述，恐怕只是他多年前书架上某本书里的某段文字，\n而且，还是不被荧光笔画线注记的那一段。\n我害怕阅读的人。\n当他们阅读时，脸就藏匿在书后面。\n书一放下，就以贵族王者的形象在我面前闪耀，举手投足都是自在风采。\n让我明了，阅读不只是知识，更是魔力。\n他们是懂美学的牛顿。懂人类学的梵谷。懂孙子兵法的甘地。\n血液里充满答案，越来越少的问题能让他们恐惧。\n彷佛站在巨人的肩牓上，习惯俯视一切。\n那自信从容，是这世上最好看的一张脸。\n我害怕阅读的人。\n因为他们很幸运；当众人拥抱孤独、或被寂寞拥抱时，\n他们的生命却毫不封闭，不缺乏朋友的忠实、不缺少安慰者的温柔，甚至连互相较劲的对手，都不会匮乏。\n他们一翻开书，有时会因心有灵犀，而大声赞叹，\n有时又会因立场不同而陷入激辨，有时会获得劝导或慰藉。\n这一切毫无保留，又不带条件，是带亲情的爱情，是热恋中的友谊。\n一本一本的书，就像一节节的脊椎，稳稳的支持着阅读的人。\n你看，书一打开，就成为一个拥抱的姿式。\n这一切，不正是我们毕生苦苦找寻的？\n我害怕阅读的人。\n他们总是不知足。\n有人说，女人学会阅读，世界上才冒出妇女问题，也因为她们开始有了问题，女人更加读书。\n就连爱因斯坦；这个世界上智者中的最聪明者，临终前都曾说：\n我看我自己，就像一个在海边玩耍的孩子，找到一块光滑的小石头，就觉得开心。\n后来我才知道自己面对的，还有一片真理的大海，那没有尽头\n读书人总是低头看书，忙着浇灌自己的饥渴，他们让自己是敞开的桶子，随时准备装入更多、更多、更多。\n而我呢？手中抓住小石头，只为了无聊地打水漂而已。\n我害怕阅读的人。\n我祈祷他们永远不知道我的不安，免得他们会更轻易击垮我，甚至连打败我的意愿都没有。\n我如此害怕阅读的人，因为他们的榜样是伟人，就算做不到，退一步也还是一个，我远不及的成功者。\n我害怕阅读的人，他们知道「无知」在小孩身上才可爱，而我已经是一个成年的人。\n我害怕阅读的人，因为大家都喜欢有智慧人。\n我害怕阅读的人，他们能避免我要经历的失败。\n我害怕阅读的人，他们懂得生命太短，人总是聪明得太迟。\n我害怕阅读的人，他们的一小时，就是我的一生。\n我害怕阅读的人，尤其是，还在阅读的人。\n这篇文章是台湾奥美给天下文化做的长文案，在网上广为流传。\n文字很震撼，把不读书人的内心的怯懦写了出来，\n不知你有什么反应，但我看完后有一种读书的迫切感，害怕那些阅读的人把我越落越远。\n“一跟他们谈话，我就像一个透明的人，苍白的脑袋无从隐藏。”\n我对这种感受有切身体会。\n我一度自认为也算涉猎极广的人，但是因为工作原因，难免会和不同领域的高手对招。\n有次聊合作，自己深度备课的谈资在那些高人眼里，不过是初阶小白掌握的东西，而且结合到事情上还往往张冠李戴。\n当他们质问的眼神盯着我，“我就像一个透明的人，苍白的脑袋无从隐藏”。\n也许，不读书造成的这种无地自容的情形在生活中也有很多，\n只不过和我们对话的那些阅读的人不会像领导或专家一样咄咄逼人，\n他们只会在内心中暗暗鄙视：原来这是个不学无术的家伙。\n而我们自己反而不觉，仍然在那里滔滔不绝地暴露自己的无知。\n其实你在生活中戴着面具表演的时候，深知自己口中说出的那些话连自己都不知道是什么东西，\n内心深处尚存那么一丝的怯懦和心虚，说明你还没有在虚伪的生活里完全迷失。\n而读书，则是可以帮你走出这种困扰的唯一途径。","title":"《我害怕阅读的人》"},{"content":"《斗罗大陆 龙王传说》 ","permalink":"https://note.yxzi.xyz/note/afterthought/book/fantasy/%E6%96%97%E7%BD%97%E5%A4%A7%E9%99%86-%E9%BE%99%E7%8E%8B%E4%BC%A0%E8%AF%B4/","summary":"《斗罗大陆 龙王传说》 ","title":"《斗罗大陆 龙王传说》"},{"content":"《斗罗大陆》 ","permalink":"https://note.yxzi.xyz/note/afterthought/book/fantasy/%E6%96%97%E7%BD%97%E5%A4%A7%E9%99%86/","summary":"《斗罗大陆》 ","title":"《斗罗大陆》"},{"content":"《旅行到宇宙边缘》 ","permalink":"https://note.yxzi.xyz/note/afterthought/movie/documentary/%E6%97%85%E8%A1%8C%E5%88%B0%E5%AE%87%E5%AE%99%E8%BE%B9%E7%BC%98/","summary":"《旅行到宇宙边缘》 ","title":"《旅行到宇宙边缘》"},{"content":"《时间的风景》 ","permalink":"https://note.yxzi.xyz/note/afterthought/movie/documentary/%E6%97%B6%E9%97%B4%E7%9A%84%E9%A3%8E%E6%99%AF/","summary":"《时间的风景》 ","title":"《时间的风景》"},{"content":"《明日边缘》 人生在世只有两位师傅，分别是痛苦和恐惧。\n两人被追杀，乘救生艇逃跑，其中一个掉进了水中，爬上了岸，看到一辆卡车便坐了进去，他拿起了副驾驶上的红酒和三明治，吃着喝着，和观众一起看着水中的两艘船你追我赶。虽全程无话，但却非常有意思。\n","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E6%98%8E%E6%97%A5%E8%BE%B9%E7%BC%98/","summary":"《明日边缘》 人生在世只有两位师傅，分别是痛苦和恐惧。\n两人被追杀，乘救生艇逃跑，其中一个掉进了水中，爬上了岸，看到一辆卡车便坐了进去，他拿起了副驾驶上的红酒和三明治，吃着喝着，和观众一起看着水中的两艘船你追我赶。虽全程无话，但却非常有意思。","title":"《明日边缘》"},{"content":"《星际迷航》 ","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E6%98%9F%E9%99%85%E8%BF%B7%E8%88%AA/","summary":"《星际迷航》 ","title":"《星际迷航》"},{"content":"《月亮与六便士》 主要内容 一个有着稳定的工作，漂亮妻子、可爱儿女的四十多岁中年人，为了自己沉睡了多年的梦想——画画，而离开这个幸福而平凡的家庭，独自一人来到一个破房间中创作。后来生病了，将死之际被好人朋友发现，这个好人朋友将他带到了自己家，几乎逼迫自己的妻子照顾这个垂危的人，在这期间，他抢占好人朋友的画室，朋友最终忍无可，终于是在某一天让他离开，然后他就带着这位好人朋友的妻子离开了。好人朋友很后悔，像舔狗一样祈求他的妻子回到他的生边，但这没用。\n夏天来了，好人朋友的妻子自杀了，是被中年人逼的，好人朋友悲痛万分，安葬后，他回到了自己的家乡，回家之前还准备带着这位中年人，想给他找个住的地方，中年人回绝了，随便将那副好人妻子的裸体画送给了他。\n没有了好人朋友的照料，中年人的生活过的很苦，几乎就像一个乞丐一般，但他从来不抱怨，不将这些苦难当作一回事。一次偶然间，他来到了一座孤岛，他说：”这才是我梦寐以求的地方，我本该属于这里，我似乎在这里呆过！“\n在岛上的几年，他依旧过的很苦，但却很快乐，在这里，它可以安心的画画。\n作者在这里还讲了一个医生的故事，也是在不经意间看到了一个地方，激起了内心中那种美妙的自由感，而决定放弃自己光明的前途，从此生活在了这个自己心中像家一样的地方。\n之后，他娶了一个名叫阿塔的女孩，他们幸福的生活着。一直到他因病去世，去世之前，他在他们住的房子的墙壁上画了一幅惊天之作，后来被阿塔烧毁了。\n在他去世之后，他的画出名了，值很多钱。现在，当初那些看过他的画的人都像作者一样——后悔当时没有买下他的画。\n感想 后悔的人们 在斯特里克兰成名之前，几乎没有人看得懂他的画，人们都唾弃他，但但他去世之后，他的画出名了，这个时候的他们依旧看不懂他的画，但却因为他的画值足够多的金钱，而后悔当初为什么不多买几幅他的画。\n斯特里克兰 斯特里克兰这个人，他冷漠，决断，他为了画画而抛下了妻子，孩子，抛下了这个家庭，仅凭这些，他也就不是一个好父亲，但抛开这一点，他让我佩服，他完全不受色欲的影响，不受道德的约束，不在意别人的看法，对舒适不感兴趣，毫不在意生活中的苦难，不受人恩惠，却总有人恩惠他，一心画画。\n亚伯拉罕 亚伯拉罕原本是一个前途无量的医生，但在在经过亚历山大港的时候，他如同天启，就好像他的心被说明揪住了，突然之前满心欢喜，一种美妙的自由感。他感觉就像回到了家里，一下子打定主意，此生就在亚历山大港生活了。\n小说结尾 “我”陈述了斯特里克兰的人生。\n他求仁得仁，得其所哉，为了自己的梦想，在塔希提以一种文明人无法理解、他自己很快乐的方式，结束了人生。\n而罗伯特-思特里克兰，代表文明社会，做出了评断：上帝的磨盘转动很慢，但是磨得很细。这就是道貌岸然的说，斯特里克兰（因为抛弃妻子），恶有恶报。\n”我“想反驳他，但我止住了。\n而这里的亨利叔叔，只是”我“的一个例证。\n”我“很显然是站在思特里克兰一边的，对道貌岸然用各类引语评断他人行为，非常厌恶。\n佳句   一个作者，应该从写作本身，从思想宣泄中获得快乐，至于其他，都不必介意，一本书或成功或失败，或赞誉或诋毁，他都应该淡然一笑\n  再过去的那些日子，我们都羞于表达，因为怕人嘲笑，所以尽量约束自己，不让人觉得骄傲自大。\n  生活如此平静，始终沉默，不动声色，你会突然心生烦恼，感到莫名的不安，这样的安逸总让我惊惧，我的血液里有一种强烈的冲动，渴望一种桀骜不驯的旅程，我的心渴望更加惊险的生活\n  卑鄙与高尚，邪恶与善良，仇恨与热爱，可以并存于同一颗心灵中。\n  我爱她，远远胜过爱自己，要我说，爱情中如果考虑自尊，只能说明你更爱自己。\n  恐惧会让人变得残酷无情。\n  精彩片段 布拉奇与斯特洛夫的美好生活  尽管如此，当我回想在巴黎度过的这个冬天，给我留下美好记忆的，依然是德克.斯特洛夫。他的小家，始终迷人。 他和他妻子，就像-幅让人感觉快意的画，他对她天真的爱，总是带着刻意的优雅。尽管他的举止依然可笑，但他的真情实意还是会打动你。我能理解他妻子对他的感觉，很高兴见她温柔以待。如果她有幽默感，她一定会觉得好笑，因为他把她放在了宝座上，当偶像一样膜拜，但即便她感到好笑，她也必然被深深感动。他是忠贞不渝的爱人，当她老了，失去了丰满的线条和美丽的身材，对他来说，她也依然没变。在他眼里，她永远是世上最美的女人。他们的生活，安然有序，令人愉悦。他们的房间，只有一个画室，一间卧室， 和一 一个小厨房。所有的家务，都由斯特洛夫夫人包揽;当德克在画他那些糟糕的画时，她就去市场买菜，做午饭，缝补衣服，整天像勤快的蚂蚁般忙忙碌碌;到了晚上，她坐在画室里，又是缝缝补补，而德克弹奏着曲子，我敢肯定，她定听不懂。\n  我想起在蒙马特那间温馨的画室里，斯特洛夫和他的妻子，这幸福的一对，他们诚实善良，热情好客，但这种生活却被一桩偶然的事件无情地击碎，在我看来真是残酷\n但最残忍的是，它发生了和没发生几乎一样，世界已然继续，他是一时悲痛，而非爱的深沉，至于布兰奇，无论她最初带着怎样光明的希望和梦想，死了就跟没来过这世界上一样，仿佛一切都很空虚，没有意义。\n 斯特里特兰的美好生活  他画的不是很多，整天在山上游荡，在溪水里洗澡，他坐在海边眺望环礁湖，太阳下山就去看看莫里阿岛。他也经常坐在礁石上钓鱼。他喜欢在码头上闲逛，和当地人聊天。他很安静，招人喜欢，每天吃完晚饭，他就和阿塔一起回测楼。\n离此处不远有一条小溪，他经常在哪里洗澡，有时候会有鱼群出现，当地人会拿着长矛赶来，吵吵嚷嚷，把正向大海游去的鱼叉上来。隔三岔五，他也会去海滩，带回来一筐五颜六色的小雨，阿塔就用椰子油把鱼炸了，有时还会配上一大只龙虾，偶尔，她也会做一盘美味的大螃蟹，这种螃蟹经常在你脚下爬来爬去。山上长着野橘，阿塔经常和村里两三个伙伴儿一起去采摘，总是满载而归，带回来的橘子连着绿叶，甘甜爽口。很快，椰子成熟了，阿塔的表弟、堂姐堂妹一拥而上，全爬上树，将打吧的椰果扔下来。他们把椰子剖开，放在太阳下晾晒。晒干了就把椰肉割下取出，装进口袋。女人们就把他们拿到附近的村子里的商人那儿，换回大米、肥皂、罐头肉和一点钱。\n 斯特里特兰的自信  斯特里特兰在库特拉斯医生那里得知自己生病之后，他送给了这个医生一幅画，并说道：\u0026ldquo;现在可能没什么，将来有一天，你会很高兴拥有它！\u0026rdquo;\n对自己的画，这是何等的自信？\n 阿塔的三句话  当阿塔知道斯特里克兰得病之后，她说：\n“他们不会把你弄走吧？”\n“别人谁要走就走吧，我不会离开你的，你是我 男人，我是你女人，要是你抛下我，我就在屋后的树上吊死，我对上帝发誓。”\n“ 你是我男人，我是你女人，你去哪儿，我跟到哪儿。”\n ","permalink":"https://note.yxzi.xyz/note/afterthought/book/novel/%E6%9C%88%E4%BA%AE%E4%B8%8E%E5%85%AD%E4%BE%BF%E5%A3%AB/","summary":"《月亮与六便士》 主要内容 一个有着稳定的工作，漂亮妻子、可爱儿女的四十多岁中年人，为了自己沉睡了多年的梦想——画画，而离开这个幸福而平凡的家庭，独自一人来到一个破房间中创作。后来生病了，将死之际被好人朋友发现，这个好人朋友将他带到了自己家，几乎逼迫自己的妻子照顾这个垂危的人，在这期间，他抢占好人朋友的画室，朋友最终忍无可，终于是在某一天让他离开，然后他就带着这位好人朋友的妻子离开了。好人朋友很后悔，像舔狗一样祈求他的妻子回到他的生边，但这没用。\n夏天来了，好人朋友的妻子自杀了，是被中年人逼的，好人朋友悲痛万分，安葬后，他回到了自己的家乡，回家之前还准备带着这位中年人，想给他找个住的地方，中年人回绝了，随便将那副好人妻子的裸体画送给了他。\n没有了好人朋友的照料，中年人的生活过的很苦，几乎就像一个乞丐一般，但他从来不抱怨，不将这些苦难当作一回事。一次偶然间，他来到了一座孤岛，他说：”这才是我梦寐以求的地方，我本该属于这里，我似乎在这里呆过！“\n在岛上的几年，他依旧过的很苦，但却很快乐，在这里，它可以安心的画画。\n作者在这里还讲了一个医生的故事，也是在不经意间看到了一个地方，激起了内心中那种美妙的自由感，而决定放弃自己光明的前途，从此生活在了这个自己心中像家一样的地方。\n之后，他娶了一个名叫阿塔的女孩，他们幸福的生活着。一直到他因病去世，去世之前，他在他们住的房子的墙壁上画了一幅惊天之作，后来被阿塔烧毁了。\n在他去世之后，他的画出名了，值很多钱。现在，当初那些看过他的画的人都像作者一样——后悔当时没有买下他的画。\n感想 后悔的人们 在斯特里克兰成名之前，几乎没有人看得懂他的画，人们都唾弃他，但但他去世之后，他的画出名了，这个时候的他们依旧看不懂他的画，但却因为他的画值足够多的金钱，而后悔当初为什么不多买几幅他的画。\n斯特里克兰 斯特里克兰这个人，他冷漠，决断，他为了画画而抛下了妻子，孩子，抛下了这个家庭，仅凭这些，他也就不是一个好父亲，但抛开这一点，他让我佩服，他完全不受色欲的影响，不受道德的约束，不在意别人的看法，对舒适不感兴趣，毫不在意生活中的苦难，不受人恩惠，却总有人恩惠他，一心画画。\n亚伯拉罕 亚伯拉罕原本是一个前途无量的医生，但在在经过亚历山大港的时候，他如同天启，就好像他的心被说明揪住了，突然之前满心欢喜，一种美妙的自由感。他感觉就像回到了家里，一下子打定主意，此生就在亚历山大港生活了。\n小说结尾 “我”陈述了斯特里克兰的人生。\n他求仁得仁，得其所哉，为了自己的梦想，在塔希提以一种文明人无法理解、他自己很快乐的方式，结束了人生。\n而罗伯特-思特里克兰，代表文明社会，做出了评断：上帝的磨盘转动很慢，但是磨得很细。这就是道貌岸然的说，斯特里克兰（因为抛弃妻子），恶有恶报。\n”我“想反驳他，但我止住了。\n而这里的亨利叔叔，只是”我“的一个例证。\n”我“很显然是站在思特里克兰一边的，对道貌岸然用各类引语评断他人行为，非常厌恶。\n佳句   一个作者，应该从写作本身，从思想宣泄中获得快乐，至于其他，都不必介意，一本书或成功或失败，或赞誉或诋毁，他都应该淡然一笑\n  再过去的那些日子，我们都羞于表达，因为怕人嘲笑，所以尽量约束自己，不让人觉得骄傲自大。\n  生活如此平静，始终沉默，不动声色，你会突然心生烦恼，感到莫名的不安，这样的安逸总让我惊惧，我的血液里有一种强烈的冲动，渴望一种桀骜不驯的旅程，我的心渴望更加惊险的生活\n  卑鄙与高尚，邪恶与善良，仇恨与热爱，可以并存于同一颗心灵中。\n  我爱她，远远胜过爱自己，要我说，爱情中如果考虑自尊，只能说明你更爱自己。\n  恐惧会让人变得残酷无情。\n  精彩片段 布拉奇与斯特洛夫的美好生活  尽管如此，当我回想在巴黎度过的这个冬天，给我留下美好记忆的，依然是德克.斯特洛夫。他的小家，始终迷人。 他和他妻子，就像-幅让人感觉快意的画，他对她天真的爱，总是带着刻意的优雅。尽管他的举止依然可笑，但他的真情实意还是会打动你。我能理解他妻子对他的感觉，很高兴见她温柔以待。如果她有幽默感，她一定会觉得好笑，因为他把她放在了宝座上，当偶像一样膜拜，但即便她感到好笑，她也必然被深深感动。他是忠贞不渝的爱人，当她老了，失去了丰满的线条和美丽的身材，对他来说，她也依然没变。在他眼里，她永远是世上最美的女人。他们的生活，安然有序，令人愉悦。他们的房间，只有一个画室，一间卧室， 和一 一个小厨房。所有的家务，都由斯特洛夫夫人包揽;当德克在画他那些糟糕的画时，她就去市场买菜，做午饭，缝补衣服，整天像勤快的蚂蚁般忙忙碌碌;到了晚上，她坐在画室里，又是缝缝补补，而德克弹奏着曲子，我敢肯定，她定听不懂。\n  我想起在蒙马特那间温馨的画室里，斯特洛夫和他的妻子，这幸福的一对，他们诚实善良，热情好客，但这种生活却被一桩偶然的事件无情地击碎，在我看来真是残酷\n但最残忍的是，它发生了和没发生几乎一样，世界已然继续，他是一时悲痛，而非爱的深沉，至于布兰奇，无论她最初带着怎样光明的希望和梦想，死了就跟没来过这世界上一样，仿佛一切都很空虚，没有意义。\n 斯特里特兰的美好生活  他画的不是很多，整天在山上游荡，在溪水里洗澡，他坐在海边眺望环礁湖，太阳下山就去看看莫里阿岛。他也经常坐在礁石上钓鱼。他喜欢在码头上闲逛，和当地人聊天。他很安静，招人喜欢，每天吃完晚饭，他就和阿塔一起回测楼。\n离此处不远有一条小溪，他经常在哪里洗澡，有时候会有鱼群出现，当地人会拿着长矛赶来，吵吵嚷嚷，把正向大海游去的鱼叉上来。隔三岔五，他也会去海滩，带回来一筐五颜六色的小雨，阿塔就用椰子油把鱼炸了，有时还会配上一大只龙虾，偶尔，她也会做一盘美味的大螃蟹，这种螃蟹经常在你脚下爬来爬去。山上长着野橘，阿塔经常和村里两三个伙伴儿一起去采摘，总是满载而归，带回来的橘子连着绿叶，甘甜爽口。很快，椰子成熟了，阿塔的表弟、堂姐堂妹一拥而上，全爬上树，将打吧的椰果扔下来。他们把椰子剖开，放在太阳下晾晒。晒干了就把椰肉割下取出，装进口袋。女人们就把他们拿到附近的村子里的商人那儿，换回大米、肥皂、罐头肉和一点钱。\n 斯特里特兰的自信  斯特里特兰在库特拉斯医生那里得知自己生病之后，他送给了这个医生一幅画，并说道：\u0026ldquo;现在可能没什么，将来有一天，你会很高兴拥有它！\u0026rdquo;\n对自己的画，这是何等的自信？\n 阿塔的三句话  当阿塔知道斯特里克兰得病之后，她说：\n“他们不会把你弄走吧？”","title":"《月亮与六便士》"},{"content":"《死亡诗社》 ","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E6%AD%BB%E4%BA%A1%E8%AF%97%E7%A4%BE/","summary":"《死亡诗社》 ","title":"《死亡诗社》"},{"content":"《永无止境》 艾迪，一个失败者，某一天，女朋友跟他分手后，他走在大街上偶遇一个买药的朋友，这个朋友给了他一颗药，他吃了下去，大脑瞬间开发到了百分之百，之后和房东暧，回到房间昧收拾杂乱的屋子。\n","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E6%B0%B8%E6%97%A0%E6%AD%A2%E5%A2%83/","summary":"《永无止境》 艾迪，一个失败者，某一天，女朋友跟他分手后，他走在大街上偶遇一个买药的朋友，这个朋友给了他一颗药，他吃了下去，大脑瞬间开发到了百分之百，之后和房东暧，回到房间昧收拾杂乱的屋子。","title":"《永无止境》"},{"content":"《河西走廊》 ","permalink":"https://note.yxzi.xyz/note/afterthought/movie/documentary/%E6%B2%B3%E8%A5%BF%E8%B5%B0%E5%BB%8A/","summary":"《河西走廊》 ","title":"《河西走廊》"},{"content":"《流浪地球》 太阳正在急速老化持续膨胀，一百年后，太阳会膨胀到吞没震哥个地球。\n三百年后，太阳系将不复存在。\n面对灾难，人类异常团结，人类决定，将整个地球推离太阳系，为人类寻找新家园，人类在地球上建造了一万个行星发动机，为飞离太阳系提供动力，这个计划叫做流浪地球计划。\n在飞离太阳系之前，由于地球表面的环境的不断恶化 零下 80+℃，导致人类无法在地球表面生存，为此，人类在每个行星发动机下面都建造了地下城，使得人类可以继续生活。\n刘启带着韩朵朵偷偷来到了地面上。\n刘培强在空间站工作了十七年，在地球也飞到木星的位置后，终于离职了\n因木星引力太大，地球上的部分行星发动机遭到其引力的影响，导致四千七百多座星发动机出现停机故障。\n因空间站调配全部资源进行地面辅助救援工作，为此空间站上的人都需要休眠，使得空间站进入低功耗模式。\n这时的刘培强已经发现空间站的智能机器莫斯似乎想叛逃——空间站距离地球越来越远。\n韩子昂他们几个在返回避难区的路程中，被迫接受了与 CN171-11 救援队一起运送“火石”的危险任务。\n运送火石的过程中，遭到了第二次强震，韩子昂与另一个成员牺牲了。\n刘启、韩朵朵和 Tim 与运送火石的大部队分离，这里充分的体现了你有用才留着你，没用了没人会管你。\n刘启找到一辆运输车之后，遇到了李一一，同时接到新任务，将火石送到苏拉威西，重新组织 CN171-11 救援队一起救援苏拉威西。\n行星发动机大部分重启完毕，在众人都以为地球已经脱离危险的时候，空间站的莫斯说出了真相：“在救援行动启动后的 0.42 秒，莫斯就已经推演本次救援的结果，联合政府虽早已知晓，但仍竭尽全力组织救援，但这注定是一场徒劳的救援，空间站的撤离，就代表着救援行动的失败。”\n这时候的木星的引力远远超过地球上的发动机的总推力。\n地球上的人类被放弃了， 这种世界末日将要来临的感觉，我不知道那是一种怎么样的绝望。\n不知道为什么，我现在很兴奋，这种前所未有的感觉令我的血液在燃烧。\n在这关键的石刻，刘启突然想到了小时候与父亲的对话，最后想到了一个方法——点燃木星，让木星的冲击波冲向地球，使得地球被冲击波推理木星的引力范围。\n说实话，一个小屁孩能想到的科学知识，为毛那些世界顶尖科学家想不到\u0026hellip;.可能这就是剧情需要吧。\n之后才知道这个救援方案已经被以色列的顶尖科学家提出过，但救援成功的概率为 0.\n但刘培强并没有放弃，最终让韩朵朵获得了在世界广播的能力，说了几句比较啰嗦的话之后\u0026hellip;\u0026hellip;\n所有的车辆开始往苏拉威西发动机方向赶，说实话，这里让人挺震撼的。\n我虽然不相信人类的人性真会这样做，但我希望它可以这样做\n老何为了找到那啥牺牲了。\ntim 为了将刘启从那啥拉回来也在鬼门关走了一走\n在只剩下最后十五分钟的时候，其他人来帮忙了——推那啥玩意\n最后还是差五千公里\u0026hellip;..\n刘培强在这个时候决定牺牲空间站，空间站上的燃料可以达到五千公里，刚好可以点燃木星，原本我以为他会带着空间站上休眠仓一起赴死，没想到这玩意还可以解体\u0026hellip;..\n让人类永远保持理智，确实是一种奢求。\n刘培强决定牺牲自己，但刘启慌了，虽然他表面讨厌自己的父亲，但这个时候刘启慌了\u0026hellip;..很多人也许觉得刘启自私，这种时候还想着个人感情，但我觉这才合理，毕竟他还只是个孩子。\n我以为刘启死了，没想到活了下来\u0026hellip;.明明头盔都破碎了，当然，着也是我希望看到的，毕竟我可不希望只剩韩朵朵一个人活了下。\n着电影总体来说挺不错的，给我感觉就是——希望那一刻能够来临！\n","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E6%B5%81%E6%B5%AA%E5%9C%B0%E7%90%83/","summary":"《流浪地球》 太阳正在急速老化持续膨胀，一百年后，太阳会膨胀到吞没震哥个地球。\n三百年后，太阳系将不复存在。\n面对灾难，人类异常团结，人类决定，将整个地球推离太阳系，为人类寻找新家园，人类在地球上建造了一万个行星发动机，为飞离太阳系提供动力，这个计划叫做流浪地球计划。\n在飞离太阳系之前，由于地球表面的环境的不断恶化 零下 80+℃，导致人类无法在地球表面生存，为此，人类在每个行星发动机下面都建造了地下城，使得人类可以继续生活。\n刘启带着韩朵朵偷偷来到了地面上。\n刘培强在空间站工作了十七年，在地球也飞到木星的位置后，终于离职了\n因木星引力太大，地球上的部分行星发动机遭到其引力的影响，导致四千七百多座星发动机出现停机故障。\n因空间站调配全部资源进行地面辅助救援工作，为此空间站上的人都需要休眠，使得空间站进入低功耗模式。\n这时的刘培强已经发现空间站的智能机器莫斯似乎想叛逃——空间站距离地球越来越远。\n韩子昂他们几个在返回避难区的路程中，被迫接受了与 CN171-11 救援队一起运送“火石”的危险任务。\n运送火石的过程中，遭到了第二次强震，韩子昂与另一个成员牺牲了。\n刘启、韩朵朵和 Tim 与运送火石的大部队分离，这里充分的体现了你有用才留着你，没用了没人会管你。\n刘启找到一辆运输车之后，遇到了李一一，同时接到新任务，将火石送到苏拉威西，重新组织 CN171-11 救援队一起救援苏拉威西。\n行星发动机大部分重启完毕，在众人都以为地球已经脱离危险的时候，空间站的莫斯说出了真相：“在救援行动启动后的 0.42 秒，莫斯就已经推演本次救援的结果，联合政府虽早已知晓，但仍竭尽全力组织救援，但这注定是一场徒劳的救援，空间站的撤离，就代表着救援行动的失败。”\n这时候的木星的引力远远超过地球上的发动机的总推力。\n地球上的人类被放弃了， 这种世界末日将要来临的感觉，我不知道那是一种怎么样的绝望。\n不知道为什么，我现在很兴奋，这种前所未有的感觉令我的血液在燃烧。\n在这关键的石刻，刘启突然想到了小时候与父亲的对话，最后想到了一个方法——点燃木星，让木星的冲击波冲向地球，使得地球被冲击波推理木星的引力范围。\n说实话，一个小屁孩能想到的科学知识，为毛那些世界顶尖科学家想不到\u0026hellip;.可能这就是剧情需要吧。\n之后才知道这个救援方案已经被以色列的顶尖科学家提出过，但救援成功的概率为 0.\n但刘培强并没有放弃，最终让韩朵朵获得了在世界广播的能力，说了几句比较啰嗦的话之后\u0026hellip;\u0026hellip;\n所有的车辆开始往苏拉威西发动机方向赶，说实话，这里让人挺震撼的。\n我虽然不相信人类的人性真会这样做，但我希望它可以这样做\n老何为了找到那啥牺牲了。\ntim 为了将刘启从那啥拉回来也在鬼门关走了一走\n在只剩下最后十五分钟的时候，其他人来帮忙了——推那啥玩意\n最后还是差五千公里\u0026hellip;..\n刘培强在这个时候决定牺牲空间站，空间站上的燃料可以达到五千公里，刚好可以点燃木星，原本我以为他会带着空间站上休眠仓一起赴死，没想到这玩意还可以解体\u0026hellip;..\n让人类永远保持理智，确实是一种奢求。\n刘培强决定牺牲自己，但刘启慌了，虽然他表面讨厌自己的父亲，但这个时候刘启慌了\u0026hellip;..很多人也许觉得刘启自私，这种时候还想着个人感情，但我觉这才合理，毕竟他还只是个孩子。\n我以为刘启死了，没想到活了下来\u0026hellip;.明明头盔都破碎了，当然，着也是我希望看到的，毕竟我可不希望只剩韩朵朵一个人活了下。\n着电影总体来说挺不错的，给我感觉就是——希望那一刻能够来临！","title":"《流浪地球》"},{"content":"《浪潮》 ","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E6%B5%AA%E6%BD%AE/","summary":"《浪潮》 ","title":"《浪潮》"},{"content":"《爆裂鼓手》\n一个年轻的鼓手正在勤奋的练习。\n安德鲁被弗莱彻选为乐队新替补，众人中只有他被选上，他心中一定和开心，\n安德鲁还成功约了喜欢的女孩一起吃披萨\n安德鲁被弗莱彻放鸽子，但后来发现并灭有，六点的时候光头给了康纳利一份谱子，但因安德鲁迟到了，因此他 并没有。。\n这光头很严格，但为什么喜欢开别人玩笑，逗别人玩呢？\n安德鲁被弗莱彻扔椅子，扇耳光，当众羞辱。\n安德鲁带伤练习打鼓。\n安德鲁与喜欢的女孩约会\n弗莱彻喜怒无常。\n安德鲁把别人的乐谱弄丢了，但他背过谱子，他上了，他们获得了第一名。\n坦纳你来干嘛了今天是核心排练没时间调教替补，弗莱彻说。留下坦纳一脸懵逼。\n弗莱彻全看表现，今天你行，你就取代他上，明天他行，他就取代你。\n我宁愿酗酒吸毒 34 岁就家破人亡，成为人们晚餐桌上的话题，也不愿意腰缠万贯满面红光的活到 9 0 岁，但是没人记得我\n安德鲁以为他是核心乐手，没想到再弗莱彻心中不过是个临时核心。现在弗莱彻找到了另一个也会安德鲁所会的双倍慢摇，弗莱彻为了让音乐会达到最高水准，让他们竞争，并选出最适合的乐手，但安德鲁却慌了，他怕康纳利会取代他。他输了，他被替代了，他不服\n安德鲁决定和女友妮可分手，为了他那梦想。\n疯子吧，这弗莱彻，压迫式训练。\n安德鲁为了当核心驾车拿鼓锥，但在返回的途中出车祸了，他依旧拿着鼓锥跑向表演现场，弗莱彻都惊讶。\n安德鲁在表演途中坚持不了，弗莱彻说 ：“你玩完了。”安德鲁冲上去打弗莱彻。\n有人给安德鲁说肖恩不是上出车祸死的，而是被弗莱彻逼成抑郁症杀死的。\n安德鲁的父亲不想看到儿子被弗莱彻逼成像肖恩这样，因此找了律师控告弗莱彻，使他失业。安德鲁对此犹豫了，但最终还是决定让弗莱彻事业。\n安德鲁在酒吧偶遇弗莱彻，被弗莱彻的一席话感动，大致意思就是我曾经在学校并不是为了指挥，而是为了逼迫，并再次说出来理查帕克的例子。\n出了就把后，弗莱彻说出了目的——他想让安德鲁在音乐节上当他的鼓手。\n“康纳利呢”安德鲁回答。\n他一直都是我用来激发你动力的而已。弗莱彻回答\n看到这里我已经开始觉得这光头还真不错，虽然之前我就已经觉得有着一方面的考虑，但当他真说出目的的时候，还是觉得弗莱彻的教育理念从某个方面讲，确实有用。\n安德鲁答应了弗莱彻，并邀请前女友妮可观看他的爵士乐表演，但现在的妮可已经有男朋友了。哈哈哈哈，看到这我直接心情愉悦，这部活该吗？有些人，一旦错过，就不在了。\n音乐节来了，演出开始，但谱子确实错的，弗莱彻原来早已知道谁让他失去了职位，早已开始报复，演出结束过后，安德鲁到休息室拥抱父亲，父亲让他回家， 但他转身便来到了台上，直接无视弗莱彻，开始 solo，中途弗莱彻说了一句：“我把你眼球挖出来”，被安德鲁用那啥打了一下，这一下真痛快！\n安德鲁继续即兴，越来越快，弗莱彻这次真的震惊了。\n最后一刻，弗莱彻和安德鲁相视一笑。在他们的眼神对望和表情变化中，我看到了对音乐执着追求的狂热和艺术上不受任何干扰的默契。这种过程，非常短暂，短到让人无法相信，但是这，可能就是艺术的魅力吧。\n","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E7%88%86%E8%A3%82%E9%BC%93%E6%89%8B/","summary":"《爆裂鼓手》\n一个年轻的鼓手正在勤奋的练习。\n安德鲁被弗莱彻选为乐队新替补，众人中只有他被选上，他心中一定和开心，\n安德鲁还成功约了喜欢的女孩一起吃披萨\n安德鲁被弗莱彻放鸽子，但后来发现并灭有，六点的时候光头给了康纳利一份谱子，但因安德鲁迟到了，因此他 并没有。。\n这光头很严格，但为什么喜欢开别人玩笑，逗别人玩呢？\n安德鲁被弗莱彻扔椅子，扇耳光，当众羞辱。\n安德鲁带伤练习打鼓。\n安德鲁与喜欢的女孩约会\n弗莱彻喜怒无常。\n安德鲁把别人的乐谱弄丢了，但他背过谱子，他上了，他们获得了第一名。\n坦纳你来干嘛了今天是核心排练没时间调教替补，弗莱彻说。留下坦纳一脸懵逼。\n弗莱彻全看表现，今天你行，你就取代他上，明天他行，他就取代你。\n我宁愿酗酒吸毒 34 岁就家破人亡，成为人们晚餐桌上的话题，也不愿意腰缠万贯满面红光的活到 9 0 岁，但是没人记得我\n安德鲁以为他是核心乐手，没想到再弗莱彻心中不过是个临时核心。现在弗莱彻找到了另一个也会安德鲁所会的双倍慢摇，弗莱彻为了让音乐会达到最高水准，让他们竞争，并选出最适合的乐手，但安德鲁却慌了，他怕康纳利会取代他。他输了，他被替代了，他不服\n安德鲁决定和女友妮可分手，为了他那梦想。\n疯子吧，这弗莱彻，压迫式训练。\n安德鲁为了当核心驾车拿鼓锥，但在返回的途中出车祸了，他依旧拿着鼓锥跑向表演现场，弗莱彻都惊讶。\n安德鲁在表演途中坚持不了，弗莱彻说 ：“你玩完了。”安德鲁冲上去打弗莱彻。\n有人给安德鲁说肖恩不是上出车祸死的，而是被弗莱彻逼成抑郁症杀死的。\n安德鲁的父亲不想看到儿子被弗莱彻逼成像肖恩这样，因此找了律师控告弗莱彻，使他失业。安德鲁对此犹豫了，但最终还是决定让弗莱彻事业。\n安德鲁在酒吧偶遇弗莱彻，被弗莱彻的一席话感动，大致意思就是我曾经在学校并不是为了指挥，而是为了逼迫，并再次说出来理查帕克的例子。\n出了就把后，弗莱彻说出了目的——他想让安德鲁在音乐节上当他的鼓手。\n“康纳利呢”安德鲁回答。\n他一直都是我用来激发你动力的而已。弗莱彻回答\n看到这里我已经开始觉得这光头还真不错，虽然之前我就已经觉得有着一方面的考虑，但当他真说出目的的时候，还是觉得弗莱彻的教育理念从某个方面讲，确实有用。\n安德鲁答应了弗莱彻，并邀请前女友妮可观看他的爵士乐表演，但现在的妮可已经有男朋友了。哈哈哈哈，看到这我直接心情愉悦，这部活该吗？有些人，一旦错过，就不在了。\n音乐节来了，演出开始，但谱子确实错的，弗莱彻原来早已知道谁让他失去了职位，早已开始报复，演出结束过后，安德鲁到休息室拥抱父亲，父亲让他回家， 但他转身便来到了台上，直接无视弗莱彻，开始 solo，中途弗莱彻说了一句：“我把你眼球挖出来”，被安德鲁用那啥打了一下，这一下真痛快！\n安德鲁继续即兴，越来越快，弗莱彻这次真的震惊了。\n最后一刻，弗莱彻和安德鲁相视一笑。在他们的眼神对望和表情变化中，我看到了对音乐执着追求的狂热和艺术上不受任何干扰的默契。这种过程，非常短暂，短到让人无法相信，但是这，可能就是艺术的魅力吧。","title":"《爆裂鼓手》"},{"content":"《猫鼠游戏》 ","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E7%8C%AB%E9%BC%A0%E6%B8%B8%E6%88%8F/","summary":"《猫鼠游戏》 ","title":"《猫鼠游戏》"},{"content":"《白日梦想家》 沃尔特的生活似乎不太尽人意的感觉，这不是我们大多数人的生活么？\n沃尔特在网上看到一个有好感的人，她叫谢尔，却不敢让她知道，日常生活中，这不就是大多数人在遇到自己喜欢的人后，那种犹豫、害怕、紧张，不知所措的感觉吗？\n沃尔特正在打电话，然后他突然像钢铁侠那样从窗户跳进房子里，救了一条狗出来\u0026hellip;.科幻片既视感？过了会儿发现，原来是白日梦。我在生活中也会经常幻想自己是超人、有超能力，然后去干一件大事情，最后被我喜欢的人所崇拜，并在一起，然后，你又回到了现实，才发现这只是幻想罢了。\n仅仅几分钟，我似乎已经看到了以后我的未来？幻想着一切，但却一无所有。\n他是《生活》杂志底片资产部的一名员工，公司现在急需肖恩寄来的底片作为杂志的封面，但他似乎并没有找到这张底片，因此，他需要先找到肖恩。\n他终于鼓起勇气和谢尔搭上了话。\n第一次白日梦，幻想自己变成了超人，并在一座失火的教堂中救出小狗，出来后便遇到了谢尔。\n第二次白日梦，幻想谢尔的偶像从雪山走到她的旁边。\n第三次白日梦，幻想自己给谢尔造了一个金色的雕塑。\n第四次白日梦，幻想和主管打架。\n第五次白日梦，幻想自己喜欢的人和他表白\u0026hellip;.\n他与喜欢的人一起去接她的儿子\n这里有个细节，华特在教她的儿子滑板的时候，每次用滑板做一个帅气的动作都会看向她\n华特似乎是受到了某种启示，坐飞机来到了格陵兰岛的努克镇寻找肖恩。\n胖子开直升机送华特到一艘船上寻找肖恩，在这里他应该又做了一个白日梦\u0026hellip;但不同的是这次华特似乎没有发呆。\n之后到了船的上空，胖子让华特跳到船上去，这时候的直升机的下方是一艘渔船和接他的救生艇，他跳了，但跳反了。鲨鱼来了，但鲨鱼居然没有吃掉它\u0026hellip;我开始怀疑这是不是他做的白日梦了。\n华特上了一艘渔船到的冰岛，骑上了自行车，来到了火山，继续寻找肖恩。\n风景美，人也自由。\n火山喷发了，华特似乎看到肖恩站在直升机上拍风景照。\n华特被胡子哥裁掉了，谢尔也是。\n华特来到了谢尔的住处寻找谢尔，顺便将滑板送给他的孩子。\n开门了，是一个人男人，“我找谢尔”华特说道\n男人随即转身去叫谢尔，“honey！有人找你。”，我觉得这个男的应该不是谢尔的前夫，而是哥哥之类的？\n华特转身，放下了滑板，独自一人走了。\n生活中，也许我们也遇到过。\n回到家，华特很消沉，无意间发现了一张线索和他们家的钢琴很像，便问了母亲。\n在母亲的鼓励下，他踏上了去往阿富汗的旅程。\n华特在阿富汗人的带领下，来到了喜马拉雅山的山腰，因某种原因，华特独自一人登山，在和暗恋网的工作人员童话的过程中，遇到了肖恩。\n肖恩告诉华特，他把那张照片放到了送给华特的钱包里，但遗憾的是，华特在这之前已经把钱包扔掉了，虽然我并不知道他为什么要扔掉。\n”有时候，我并不想为了拍照而拍照，只想享受那一刻。“肖恩说道。\n肖恩叫上华特去踢球。\n夕阳下，一群人在玩乐，自由，快乐，安然。\n回到家，他拿到了一笔卖掉钢琴的巨款，并找回了肖恩送给他的钱包，这个钱包被他妈妈从垃圾桶里捡了出来。\n他应该很后悔扔掉了钱包，但现在找回来了，他很开心。\n他将底片拿回了《生活》杂志的公司，胡子哥也将底片作为了最后一刊《生活》杂志的封面。\n华特拿到了遣散费后，在人群中无意间看到了谢尔，并追了上去。聊了会儿，原来上次只是谢尔的前夫在她家修冰箱，并没有破镜重圆。\n华特主动的约了谢尔看表演，希尔答应了。\n他们一起走在大街上，看到了最后一刊的《生活》杂志，封面是华特——拿着仔细底片观察。\n“要不要买一本”谢尔说。\n“我可能待会才来买，我只想装装酷，不想马上买一本。”华特回答。\n片尾\n华特牵起了谢尔的手。\n","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E7%99%BD%E6%97%A5%E6%A2%A6%E6%83%B3%E5%AE%B6/","summary":"《白日梦想家》 沃尔特的生活似乎不太尽人意的感觉，这不是我们大多数人的生活么？\n沃尔特在网上看到一个有好感的人，她叫谢尔，却不敢让她知道，日常生活中，这不就是大多数人在遇到自己喜欢的人后，那种犹豫、害怕、紧张，不知所措的感觉吗？\n沃尔特正在打电话，然后他突然像钢铁侠那样从窗户跳进房子里，救了一条狗出来\u0026hellip;.科幻片既视感？过了会儿发现，原来是白日梦。我在生活中也会经常幻想自己是超人、有超能力，然后去干一件大事情，最后被我喜欢的人所崇拜，并在一起，然后，你又回到了现实，才发现这只是幻想罢了。\n仅仅几分钟，我似乎已经看到了以后我的未来？幻想着一切，但却一无所有。\n他是《生活》杂志底片资产部的一名员工，公司现在急需肖恩寄来的底片作为杂志的封面，但他似乎并没有找到这张底片，因此，他需要先找到肖恩。\n他终于鼓起勇气和谢尔搭上了话。\n第一次白日梦，幻想自己变成了超人，并在一座失火的教堂中救出小狗，出来后便遇到了谢尔。\n第二次白日梦，幻想谢尔的偶像从雪山走到她的旁边。\n第三次白日梦，幻想自己给谢尔造了一个金色的雕塑。\n第四次白日梦，幻想和主管打架。\n第五次白日梦，幻想自己喜欢的人和他表白\u0026hellip;.\n他与喜欢的人一起去接她的儿子\n这里有个细节，华特在教她的儿子滑板的时候，每次用滑板做一个帅气的动作都会看向她\n华特似乎是受到了某种启示，坐飞机来到了格陵兰岛的努克镇寻找肖恩。\n胖子开直升机送华特到一艘船上寻找肖恩，在这里他应该又做了一个白日梦\u0026hellip;但不同的是这次华特似乎没有发呆。\n之后到了船的上空，胖子让华特跳到船上去，这时候的直升机的下方是一艘渔船和接他的救生艇，他跳了，但跳反了。鲨鱼来了，但鲨鱼居然没有吃掉它\u0026hellip;我开始怀疑这是不是他做的白日梦了。\n华特上了一艘渔船到的冰岛，骑上了自行车，来到了火山，继续寻找肖恩。\n风景美，人也自由。\n火山喷发了，华特似乎看到肖恩站在直升机上拍风景照。\n华特被胡子哥裁掉了，谢尔也是。\n华特来到了谢尔的住处寻找谢尔，顺便将滑板送给他的孩子。\n开门了，是一个人男人，“我找谢尔”华特说道\n男人随即转身去叫谢尔，“honey！有人找你。”，我觉得这个男的应该不是谢尔的前夫，而是哥哥之类的？\n华特转身，放下了滑板，独自一人走了。\n生活中，也许我们也遇到过。\n回到家，华特很消沉，无意间发现了一张线索和他们家的钢琴很像，便问了母亲。\n在母亲的鼓励下，他踏上了去往阿富汗的旅程。\n华特在阿富汗人的带领下，来到了喜马拉雅山的山腰，因某种原因，华特独自一人登山，在和暗恋网的工作人员童话的过程中，遇到了肖恩。\n肖恩告诉华特，他把那张照片放到了送给华特的钱包里，但遗憾的是，华特在这之前已经把钱包扔掉了，虽然我并不知道他为什么要扔掉。\n”有时候，我并不想为了拍照而拍照，只想享受那一刻。“肖恩说道。\n肖恩叫上华特去踢球。\n夕阳下，一群人在玩乐，自由，快乐，安然。\n回到家，他拿到了一笔卖掉钢琴的巨款，并找回了肖恩送给他的钱包，这个钱包被他妈妈从垃圾桶里捡了出来。\n他应该很后悔扔掉了钱包，但现在找回来了，他很开心。\n他将底片拿回了《生活》杂志的公司，胡子哥也将底片作为了最后一刊《生活》杂志的封面。\n华特拿到了遣散费后，在人群中无意间看到了谢尔，并追了上去。聊了会儿，原来上次只是谢尔的前夫在她家修冰箱，并没有破镜重圆。\n华特主动的约了谢尔看表演，希尔答应了。\n他们一起走在大街上，看到了最后一刊的《生活》杂志，封面是华特——拿着仔细底片观察。\n“要不要买一本”谢尔说。\n“我可能待会才来买，我只想装装酷，不想马上买一本。”华特回答。\n片尾\n华特牵起了谢尔的手。","title":"《白日梦想家》"},{"content":"《秘密特工》 人生在世只有两位师傅，分别是痛苦和恐惧。\n两人被追杀，乘救生艇逃跑，其中一个掉进了水中，爬上了岸，看到一辆卡车便坐了进去，他拿起了副驾驶上的红酒和三明治，吃着喝着，和观众一起看着水中的两艘船你追我赶。虽全程无话，但却非常有意思。\n","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E7%A7%98%E5%AF%86%E7%89%B9%E5%B7%A5/","summary":"《秘密特工》 人生在世只有两位师傅，分别是痛苦和恐惧。\n两人被追杀，乘救生艇逃跑，其中一个掉进了水中，爬上了岸，看到一辆卡车便坐了进去，他拿起了副驾驶上的红酒和三明治，吃着喝着，和观众一起看着水中的两艘船你追我赶。虽全程无话，但却非常有意思。","title":"《秘密特工》"},{"content":"《红猪》国语版 小孩子和小孩都好可爱，这些空贼确定是来抓人质的吗？\n这部电影女主的国语配音真的太美妙了，是那种可以让人心安的声音和调调\n男主中了魔咒，脸变成了猪头\n红猪离开了吉娜，吉娜舍不得他\n吉娜说：“因为我给自己下了赌注，我打赌，如果我在这座花园的时候，那个人能来找我，我这辈子就会跟着他，可是那个傻瓜，它只会晚上在店里找我。\u0026quot;\n然后，他来了，但他似乎又走了\n里面的人对女人很好，很尊重女人。\n治愈的情节真的很多。\n吉娜一直深爱着马克\n","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E7%BA%A2%E7%8C%AA%E5%9B%BD%E8%AF%AD%E7%89%88/","summary":"《红猪》国语版 小孩子和小孩都好可爱，这些空贼确定是来抓人质的吗？\n这部电影女主的国语配音真的太美妙了，是那种可以让人心安的声音和调调\n男主中了魔咒，脸变成了猪头\n红猪离开了吉娜，吉娜舍不得他\n吉娜说：“因为我给自己下了赌注，我打赌，如果我在这座花园的时候，那个人能来找我，我这辈子就会跟着他，可是那个傻瓜，它只会晚上在店里找我。\u0026quot;\n然后，他来了，但他似乎又走了\n里面的人对女人很好，很尊重女人。\n治愈的情节真的很多。\n吉娜一直深爱着马克","title":"《红猪》国语版"},{"content":"《绿皮书》 ","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E7%BB%BF%E7%9A%AE%E4%B9%A6/","summary":"《绿皮书》 ","title":"《绿皮书》"},{"content":"《肖申克的救赎》 银行家杜弗兰被指控杀害妻子和及其情人。\n监狱里的人欢迎新人，他们打赌哪位新人最先崩溃。\n胖子崩溃了，被监狱长拖出牢房殴打，最终死亡。没人记得他的名字。\n监狱里，只能男的和男的做那种事。有人问杜弗兰：\n”你名草有主了吗“\n”真难追“\n他和监狱长做了个交易。并且让监狱长请他的兄弟们喝酒，享受着这短暂的自由。\n此后，杜弗兰利用他的知识帮狱警们避税，获得了好的工作，果然，知识才是力量，你的知识足够重要，足够让你成为特殊。\n老头在肖申克监狱待了十年，获释的时候居然想杀掉一个人，就为了在这个监狱继续呆下去。\n监狱是个怪地方，起初你对监狱恨之入骨，然后你对它习以为常，时间够久之后，你会变得无比依赖这里，这就是制度化。\n老头出狱了，获得了住所，和一份超市包装员的工作，但他工作的很辛苦，以为他的手有关节炎。晚上睡觉会时常惊醒，做噩梦，他是一个老人。他收拾好东西这边离开这个令他担惊受怕的地方。他自杀了。瑞德说：\n”他还不如老死在肖申克监狱。“\n杜弗兰给州长写信，目的是为了让州长在肖申克监狱建一个图书馆，六年后，终于是让州长拨款了两千美刀，并且还捐赠了很多书籍。\n安迪越狱了，整整二十年。这就是知识的重要性。\n监狱里的友情。\n自由的重要性\n希望的重要性\n学识的重要性\n坚持的重要性\n","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E8%82%96%E7%94%B3%E5%85%8B%E7%9A%84%E6%95%91%E8%B5%8E/","summary":"《肖申克的救赎》 银行家杜弗兰被指控杀害妻子和及其情人。\n监狱里的人欢迎新人，他们打赌哪位新人最先崩溃。\n胖子崩溃了，被监狱长拖出牢房殴打，最终死亡。没人记得他的名字。\n监狱里，只能男的和男的做那种事。有人问杜弗兰：\n”你名草有主了吗“\n”真难追“\n他和监狱长做了个交易。并且让监狱长请他的兄弟们喝酒，享受着这短暂的自由。\n此后，杜弗兰利用他的知识帮狱警们避税，获得了好的工作，果然，知识才是力量，你的知识足够重要，足够让你成为特殊。\n老头在肖申克监狱待了十年，获释的时候居然想杀掉一个人，就为了在这个监狱继续呆下去。\n监狱是个怪地方，起初你对监狱恨之入骨，然后你对它习以为常，时间够久之后，你会变得无比依赖这里，这就是制度化。\n老头出狱了，获得了住所，和一份超市包装员的工作，但他工作的很辛苦，以为他的手有关节炎。晚上睡觉会时常惊醒，做噩梦，他是一个老人。他收拾好东西这边离开这个令他担惊受怕的地方。他自杀了。瑞德说：\n”他还不如老死在肖申克监狱。“\n杜弗兰给州长写信，目的是为了让州长在肖申克监狱建一个图书馆，六年后，终于是让州长拨款了两千美刀，并且还捐赠了很多书籍。\n安迪越狱了，整整二十年。这就是知识的重要性。\n监狱里的友情。\n自由的重要性\n希望的重要性\n学识的重要性\n坚持的重要性","title":"《肖申克的救赎》"},{"content":"《苏菲的世界》 凌晨，初次看完《苏菲的世界》这本书。\n这本书真是越到后面越有趣，小说与哲学科普的完美结合；并且充满了悬疑的情节和有趣的脑洞。\n作者让小说中的苏菲发现了自己只是书中的一个虚拟人物后，非常的接受不了，并和她的哲学老师密谋逃脱这个虚拟世界。\n而更有意思的是，这本书中还有一个女孩叫席德，她处于苏菲世界之外的世界，她的父亲将《苏菲的世界》当作生日的礼物送给了她，席德读了这本书后，决定帮助苏菲他们逃脱书中的世界，在她所处的世界阻拦着自己的父亲。\n站在我的维度来看，席德和他父亲也是我手中这本书的作者虚构的。\n这不得不让人陷入沉思：作为读者的我们，是否也是别人虚构的人物呢？\n我们是否也像他们那样完全没有发现自己是被虚构的？\n或者是有人已经发现了，并且像苏菲和她的哲学老师那样逃出了他们以为的“书中世界”，\n实际上也只是进入了另一个虚构的世界罢了。\n我无法回答，这个世界上也许也没有人能回答，但肯定有人发现，也许是那些大哲学家，比如尼采、叔本华、柏拉图。\n自认为比较精彩的片段  这次他们走过所有关于超自然现象的书，停在书店最里面一个看起来不甚牢固的架子前。架子的上方挂着一块很小的牌子，上面写着：哲学类。艾伯特指着架上的一本书。苏菲看到书名时不禁吓了一跳。上面写着：苏菲的世界。\n“你要不要我买一本送给你？”\n“我不太敢看耶！”\n 这一段我自认为是比较让人浮想联翩的，作为当事人的苏菲，又有多么的恐惧呢。\n自认为书中的佳句  追寻真理的过程就像准备破解一场犯罪案件的过程，有人认为安德森是凶手，有人则认为尼博尔或法布克才是。有时警方可以侦破案件，但也可能永远无法查出真相（虽然这个真相一定存在于某个地方，但是它一定不会自己跳出来告诉你：“我是真相”。 哲学家们在成长的过程中不能习惯这世界上的一切（将世间一切当作理所当然），因为他们需要时刻保持一颗好奇心（这是极为重要的一项能力）。 大多数人都忙于日常生活的琐事，这些人对于世界的好奇心大多都受到了生活的压抑，直到生活将他们的好奇心磨灭殆尽。 神话存在的意义是为了解释当时时代人们所不了解、不理解的事物。 你知晓的一切，都不是事物本身的模样，只是大多数人所以为的模样。 在某个期间，哲学乃是男人的专利，一个妇女无论如何有思想都只能对男人俯首听命，因此许多宝贵经验就这样丧失了。 当时的人并没有现代的各种高科技电子设备可以利用，他们唯一的工具就是自己的心灵。 真正的知识来自内心，而不是得自别人的传授；唯有出自内心的知识，才能使人拥有真正的智慧。 智者是有智慧的人，而哲学家则是追求智慧的人。 诡辩家是自以为无所不知的人，而哲学家是明白自己一无所知的人。 大部分人不是太过笃定，就是漠不关心。 人只要有正确的见解，就会采取正确的行动。 一个人之所以犯错，是因为这个人不知道何者是对的。 如果你做一些自己深知不对的事，你还会活得很快乐吗？ 哲学家们对永远“真”，永远“善”，永远“美”的事物感兴趣。 对于那些不断改变的事物不可能会有真正的认识。 人既不能懦弱，也不能太过鲁莽，而要勇敢（不够勇敢就是懦弱，太过勇敢就变成鲁莽）；既不能吝啬，也不能挥霍，而要慷慨（不够慷概就是吝啬，太过慷概就变成挥霍）；饮食也是如此，既不能吃太少，也不能吃太多（吃的太少会导致太瘦，吃的太多会导致太胖）。 运用理智使自己不受当时主流思想的影响。 上帝不是一切，一切都在上帝之中。 一个人可能宁愿整个地球遭到毁灭，也不愿意直接的手指被割到。 一个人可以完全随心所欲的以自己的方式诠释生命。 万一你睡着了呢？万一你在睡眠时做梦了呢？万一你在梦中到了天堂，在那儿采下了一朵奇异而美丽的花？万一你醒来时，花儿正在手中？啊，那时你要如何呢？ “死亡和我们没有关系”，因为“只要我们存在一天，死亡就不会来临，而当死亡来临的那一刻，我们也不在存在了”；毕竟，我们好像从未听说某人得了“死亡”这种疾病。 神不足惧，死不足忧，祸苦易忍，福乐易求 所有的自然现象，比如生病与死亡，都只是遵守大自然不变的法则而已，因此他们认为人们必须学会接受自己的命运。 没有任何事情是偶然发生的，每一件事物发生都有其必要 当人在追求较短暂的快乐时，必须考虑是否还有其他方式可以获得更大、更持久或更强烈的快乐。 当我们考量一个行动是否有乐趣时，必须同时斟酌它可能会带来的副作用。 我们心中很”理所当然“的看法也不一定经得起时间的考验。 你不可能知道一个人是否爱你，你只能相信他爱你，或者，希望他爱你  ","permalink":"https://note.yxzi.xyz/note/afterthought/book/philosophy/%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C/","summary":"《苏菲的世界》 凌晨，初次看完《苏菲的世界》这本书。\n这本书真是越到后面越有趣，小说与哲学科普的完美结合；并且充满了悬疑的情节和有趣的脑洞。\n作者让小说中的苏菲发现了自己只是书中的一个虚拟人物后，非常的接受不了，并和她的哲学老师密谋逃脱这个虚拟世界。\n而更有意思的是，这本书中还有一个女孩叫席德，她处于苏菲世界之外的世界，她的父亲将《苏菲的世界》当作生日的礼物送给了她，席德读了这本书后，决定帮助苏菲他们逃脱书中的世界，在她所处的世界阻拦着自己的父亲。\n站在我的维度来看，席德和他父亲也是我手中这本书的作者虚构的。\n这不得不让人陷入沉思：作为读者的我们，是否也是别人虚构的人物呢？\n我们是否也像他们那样完全没有发现自己是被虚构的？\n或者是有人已经发现了，并且像苏菲和她的哲学老师那样逃出了他们以为的“书中世界”，\n实际上也只是进入了另一个虚构的世界罢了。\n我无法回答，这个世界上也许也没有人能回答，但肯定有人发现，也许是那些大哲学家，比如尼采、叔本华、柏拉图。\n自认为比较精彩的片段  这次他们走过所有关于超自然现象的书，停在书店最里面一个看起来不甚牢固的架子前。架子的上方挂着一块很小的牌子，上面写着：哲学类。艾伯特指着架上的一本书。苏菲看到书名时不禁吓了一跳。上面写着：苏菲的世界。\n“你要不要我买一本送给你？”\n“我不太敢看耶！”\n 这一段我自认为是比较让人浮想联翩的，作为当事人的苏菲，又有多么的恐惧呢。\n自认为书中的佳句  追寻真理的过程就像准备破解一场犯罪案件的过程，有人认为安德森是凶手，有人则认为尼博尔或法布克才是。有时警方可以侦破案件，但也可能永远无法查出真相（虽然这个真相一定存在于某个地方，但是它一定不会自己跳出来告诉你：“我是真相”。 哲学家们在成长的过程中不能习惯这世界上的一切（将世间一切当作理所当然），因为他们需要时刻保持一颗好奇心（这是极为重要的一项能力）。 大多数人都忙于日常生活的琐事，这些人对于世界的好奇心大多都受到了生活的压抑，直到生活将他们的好奇心磨灭殆尽。 神话存在的意义是为了解释当时时代人们所不了解、不理解的事物。 你知晓的一切，都不是事物本身的模样，只是大多数人所以为的模样。 在某个期间，哲学乃是男人的专利，一个妇女无论如何有思想都只能对男人俯首听命，因此许多宝贵经验就这样丧失了。 当时的人并没有现代的各种高科技电子设备可以利用，他们唯一的工具就是自己的心灵。 真正的知识来自内心，而不是得自别人的传授；唯有出自内心的知识，才能使人拥有真正的智慧。 智者是有智慧的人，而哲学家则是追求智慧的人。 诡辩家是自以为无所不知的人，而哲学家是明白自己一无所知的人。 大部分人不是太过笃定，就是漠不关心。 人只要有正确的见解，就会采取正确的行动。 一个人之所以犯错，是因为这个人不知道何者是对的。 如果你做一些自己深知不对的事，你还会活得很快乐吗？ 哲学家们对永远“真”，永远“善”，永远“美”的事物感兴趣。 对于那些不断改变的事物不可能会有真正的认识。 人既不能懦弱，也不能太过鲁莽，而要勇敢（不够勇敢就是懦弱，太过勇敢就变成鲁莽）；既不能吝啬，也不能挥霍，而要慷慨（不够慷概就是吝啬，太过慷概就变成挥霍）；饮食也是如此，既不能吃太少，也不能吃太多（吃的太少会导致太瘦，吃的太多会导致太胖）。 运用理智使自己不受当时主流思想的影响。 上帝不是一切，一切都在上帝之中。 一个人可能宁愿整个地球遭到毁灭，也不愿意直接的手指被割到。 一个人可以完全随心所欲的以自己的方式诠释生命。 万一你睡着了呢？万一你在睡眠时做梦了呢？万一你在梦中到了天堂，在那儿采下了一朵奇异而美丽的花？万一你醒来时，花儿正在手中？啊，那时你要如何呢？ “死亡和我们没有关系”，因为“只要我们存在一天，死亡就不会来临，而当死亡来临的那一刻，我们也不在存在了”；毕竟，我们好像从未听说某人得了“死亡”这种疾病。 神不足惧，死不足忧，祸苦易忍，福乐易求 所有的自然现象，比如生病与死亡，都只是遵守大自然不变的法则而已，因此他们认为人们必须学会接受自己的命运。 没有任何事情是偶然发生的，每一件事物发生都有其必要 当人在追求较短暂的快乐时，必须考虑是否还有其他方式可以获得更大、更持久或更强烈的快乐。 当我们考量一个行动是否有乐趣时，必须同时斟酌它可能会带来的副作用。 我们心中很”理所当然“的看法也不一定经得起时间的考验。 你不可能知道一个人是否爱你，你只能相信他爱你，或者，希望他爱你  ","title":"《苏菲的世界》"},{"content":"《触不可及》 影片中有一句话令我印象深刻：“只有德瑞斯没有将菲利普当作残疾人——因为他总把电话递给我，你知道为什么吗？因为他忘了我不能动。”\n德瑞斯带着菲利普飚车、极限运动、抽烟，似乎完全没把菲利普当残疾人看待。\n德瑞斯帮菲利普面的了菲利普一直在逃避的事——不敢与笔友埃莱奥诺在现实中见面，怕对方嫌弃自己是残疾人。\n两个阶级差距巨大的人，依旧能成为朋友。\n","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E8%A7%A6%E4%B8%8D%E5%8F%AF%E5%8F%8A/","summary":"《触不可及》 影片中有一句话令我印象深刻：“只有德瑞斯没有将菲利普当作残疾人——因为他总把电话递给我，你知道为什么吗？因为他忘了我不能动。”\n德瑞斯带着菲利普飚车、极限运动、抽烟，似乎完全没把菲利普当残疾人看待。\n德瑞斯帮菲利普面的了菲利普一直在逃避的事——不敢与笔友埃莱奥诺在现实中见面，怕对方嫌弃自己是残疾人。\n两个阶级差距巨大的人，依旧能成为朋友。","title":"《触不可及》"},{"content":"《走在自己的时区里》 原文 纽约时间比加州时间早三个小时，\n但加州时间并没有变慢。\n有人 22 岁就毕业了，\n但等了五年才找到好的工作！\n有人 25 岁就当上 CEO，\n却在 50 岁去世。\n也有人迟到 50 岁才当上 CEO，\n然后活到 90 岁。\n有人依然单身，\n同时也有人已婚。\n奥巴马 55 岁就退休，\n川普 70 岁才开始当总统。\n世上每个人本来就有自己的发展时区。\n身边有些人看似走在你前面，\n也有人看似走在你后面。\n但其实每个人在自己的时区有自己的步程。\n不用嫉妒或嘲笑他们。\n他们都在自己的时区里，你也是！\n生命就是等待正确的行动时机。\n所以，放轻松。\n你没有落后。\n你没有领先。\n在命运为你安排的属于自己的时区里，一切都准时。\n读后感 我相信你也和我一样，读完这篇短文后，心中的梦想似乎又发芽了，那团火似乎又燃了起来。\n《被讨厌的勇气》一书中，有着一个非常重要概念：课题分离，在这篇短文中，用 时区分离 我觉得也没什么问题\n有的人看似走到你前面，也有些人看似走到你后面，但他们都有着自己的课题，有着自己的人生，我们没必要去嫉妒他们，也没必要去可怜他们，因为这仅仅是我们的课题不同而已。\n比如别人对你提出要求，你的课题是判断要不要接受 Ta 的要求，只需要就事论事做出你想做的回应就好。至于 Ta 怎么来处理你的回应，他会不会感到失望，会不会认为你太不近人情，那是他的课题了，他的课题，不在你的考虑范围之内。\n阿德勒用一句话来形容课题分离，这句话是：可以把马带到水边，但不能强迫其喝水。倘若无视他人的意愿而强迫其改变，那结果只会是日后产生更加强烈的反作用。\n课题，我也原称之为时区，生活在自己的时区里，一切都是准时的。\n一切烦恼都来自于人际关系，而一切人际关系的矛盾都是因为对别人的时区妄加干涉或者自己的时区被别人妄加干涉。\n我们所处的时区也是如此，别人在别人的时区，自己在自己的时区，我们不能让别人干涉属于自己的时区，也不要去干涉别人的时区。\n共勉。\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/essay/%E8%B5%B0%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%B6%E5%8C%BA%E9%87%8C/","summary":"《走在自己的时区里》 原文 纽约时间比加州时间早三个小时，\n但加州时间并没有变慢。\n有人 22 岁就毕业了，\n但等了五年才找到好的工作！\n有人 25 岁就当上 CEO，\n却在 50 岁去世。\n也有人迟到 50 岁才当上 CEO，\n然后活到 90 岁。\n有人依然单身，\n同时也有人已婚。\n奥巴马 55 岁就退休，\n川普 70 岁才开始当总统。\n世上每个人本来就有自己的发展时区。\n身边有些人看似走在你前面，\n也有人看似走在你后面。\n但其实每个人在自己的时区有自己的步程。\n不用嫉妒或嘲笑他们。\n他们都在自己的时区里，你也是！\n生命就是等待正确的行动时机。\n所以，放轻松。\n你没有落后。\n你没有领先。\n在命运为你安排的属于自己的时区里，一切都准时。\n读后感 我相信你也和我一样，读完这篇短文后，心中的梦想似乎又发芽了，那团火似乎又燃了起来。\n《被讨厌的勇气》一书中，有着一个非常重要概念：课题分离，在这篇短文中，用 时区分离 我觉得也没什么问题\n有的人看似走到你前面，也有些人看似走到你后面，但他们都有着自己的课题，有着自己的人生，我们没必要去嫉妒他们，也没必要去可怜他们，因为这仅仅是我们的课题不同而已。\n比如别人对你提出要求，你的课题是判断要不要接受 Ta 的要求，只需要就事论事做出你想做的回应就好。至于 Ta 怎么来处理你的回应，他会不会感到失望，会不会认为你太不近人情，那是他的课题了，他的课题，不在你的考虑范围之内。\n阿德勒用一句话来形容课题分离，这句话是：可以把马带到水边，但不能强迫其喝水。倘若无视他人的意愿而强迫其改变，那结果只会是日后产生更加强烈的反作用。\n课题，我也原称之为时区，生活在自己的时区里，一切都是准时的。\n一切烦恼都来自于人际关系，而一切人际关系的矛盾都是因为对别人的时区妄加干涉或者自己的时区被别人妄加干涉。\n我们所处的时区也是如此，别人在别人的时区，自己在自己的时区，我们不能让别人干涉属于自己的时区，也不要去干涉别人的时区。\n共勉。","title":"《走在自己的时区里》"},{"content":"《超人之钢铁之躯》 超人出生的同时，氪星上的自然资源被耗尽了，因此导致其内核的不稳定——氪星将被毁灭。最终，氪星的将军佐德试图发起政变，但为时已晚，超人的父亲和母亲都预见了末日的降临，他们为了留下氪星上唯一的血脉，用了一些手段。\n佐德想要氪星的中枢宝典，但中枢宝典似乎已经被超人的父亲植入了超人体内。超人被飞船送走了，同时佐德杀死了超人的父亲，佐德也被监禁了三百个循环年，同时也避免了被毁灭，随后，氪星爆炸了。飞船坠落到了地球\u0026hellip;\n佐德想要宝典拯救氪星，但超人的父亲乔伊莱并不觉得这是一个办法，唯有让自己的儿子，唯一自然出生的氪星人带着宝典去往另一个星球。\n超人在一艘穿上捕鱼，这似乎是职业？\n船员处于好心救了克拉克一次，一个基地失火了，超人初显神威，将他们救了出来。\n超人开始回忆童年。全班同学坐校车，校车车胎爆了，导致校车开向了河里，本该九死一生的情况，但幼时的克拉克就已经拥有了超人的部分神力，将校车推向了岸边，同时再下河将之在车上嘲笑他的小胖也救上了岸。\n但这也让同学的父母还是怀疑克拉克异于常人的现象，但克拉克的父母必须极力掩饰，因为人类会恐惧未知的东西，如果让其他人知道克拉克的与众不同，那么人类也许会消灭克拉克，这一切都让克拉克听见了，他独自一人坐在皮卡车上思考着，他的养父走了过来，告诉了自己的来历，以及随他一起飞往地球的飞船和中枢宝典。当卡拉克知道自己不是地球人之后，我想他应该很伤心，我想每个人都会伤心把，因为你在这个世界上，居然没有一个同类，我想，每个人都不想成为别人眼中的异类，因为这会很孤独。\n酒吧里，好友被人乱摸，克拉克上去劝阻，但似乎被当软柿子了，超人本可以直接干掉这败类，但他忍住了，出门后将他的车砸掉了\u0026hellip;\n克拉克无意间来到了来自氪星的侦察艇上，并先驾驶着它离开了人类的实现范围。这艘侦察艇上残留了超人父亲乔伊莱的影子。乔伊莱便开始向解释这发生的一切\u0026hellip;氪星上的人都是人工造的，在出生前就已经被赋予了某种职业。为了改变这一切，超人凯尔诞生了，数百年来唯一一个自然出生的氪星人。乔伊莱将战衣给了超人凯尔，并告诉他——伊莱家族族徽的含义是——坚信每个人都有向善的根本信念。\n凯尔开始了训练，逐渐掌握自己的超能力。\n记者莱恩开始寻找克拉克，为了新闻的真实性，因为这会让她出名，但当他找到克拉克后，询问他为什么要一直逃避，为什么不去帮助人类，克拉克的回答让莱恩明白了——父亲为了不让他暴露超能力，不让他再一次成为别人眼中的异类，又或者是为了他的安全着想，他自己冒着生命危险就瞎了小狗，这里说实话有点搞笑，为了救一条狗——汉克，居然搭上了丈夫的性命，这不是闹着玩吗，也许是因为明白了父亲的良苦用心，在这之后，克拉克一直过着普通人的生活，很佩服，如果换做是我，肯定是做不到的，也许这也是为什么我不是超人的原因。别人是选择做普通人，而我确实被迫做普通人。\n再次见到母亲，母亲已经快是满头白发，他告诉母亲，他找到了自己的族人，知道了自己的身世，此时的母子俩非常的开心。\n”担心他们会把你从我身边夺走“母亲说，哎，也许这是我的弱点吧。\n佐德终于找到了地球，找到了凯尔，他用全世界的电子设备告诉凯尔——你不是一个人。佐德用全世界的人类威胁凯尔，想让他投降，人类也开始寻找他，但不是保护，而是交出他，就是人性——善恶交织。\n唯一知道凯尔身份的人——露易丝莱恩也被扣了个叛国罪\u0026hellip;将被逮捕。\n克拉克再次回忆起小时候父亲对自己说的话——你得自己决定成为什么样的人，不管你成为何种人，正义或邪恶，都将改变这个世界。\n回到现实，卡拉克很纠结，因为他知道佐德不可信，但他同样也不知道人类可不可信，有人告诉他——有时候你要先信任别人，才能得到别人的信任。\n克拉克投降了，为了路易斯莱恩，这些人真是可笑，若不是超人愿意，你们怎么能困住超人？\n克拉克和路易斯都被带上了飞船，他们都被窥视佐德窥视了记忆，而后，佐德来到了卡拉克母亲住的地方，逼问克拉克的母亲，飞船和宝典在哪里。\n超人察觉到佐德可能会伤害自己的母亲，以最快的速度赶到，刚好是看到了佐德威胁母亲的一幕，直接将佐德按在地上狂打——你以为你可以困住我的母亲？超人干掉了佐德的头盔，本以为可以直接干掉佐德，但奈何佐德的部下赶来了，救了佐德一命。\n超人和氪星人初次战斗，前期一打一打不过，之后超人越战越勇，二打一直接不分上下，其中一个氪星人的头盔被打破，但他们的飞船又来将他们救走了，我寻思为什么不直接用飞船的光线干超人？这样不跟家碾压？难道是为了给飞船节省能量？我暂时也只能想到这个理由了。\n超人也是在初次碰撞中获得了人类的认可——他不是我们的敌人。\n佐德开始改造地球，他想让地球变成氪星，这样才能复活他的族人们，从这一点来说，佐德并没有错，他一心为氪星，他配得上一星之将。\n佐德以人类威胁凯尔， 最终凯尔还是杀了佐德，为了几个人类。杀死了自己最后一个同类。我也许一生都无法理解超人的这种感觉。\n地球得救了，但超人却永远失去了最后一个族人。\n小狗汉克也离开了这个世界。\n这是一场种族之战，没有对错可言。\n","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E8%B6%85%E4%BA%BA%E4%B9%8B%E9%92%A2%E9%93%81%E4%B9%8B%E8%BA%AF/","summary":"《超人之钢铁之躯》 超人出生的同时，氪星上的自然资源被耗尽了，因此导致其内核的不稳定——氪星将被毁灭。最终，氪星的将军佐德试图发起政变，但为时已晚，超人的父亲和母亲都预见了末日的降临，他们为了留下氪星上唯一的血脉，用了一些手段。\n佐德想要氪星的中枢宝典，但中枢宝典似乎已经被超人的父亲植入了超人体内。超人被飞船送走了，同时佐德杀死了超人的父亲，佐德也被监禁了三百个循环年，同时也避免了被毁灭，随后，氪星爆炸了。飞船坠落到了地球\u0026hellip;\n佐德想要宝典拯救氪星，但超人的父亲乔伊莱并不觉得这是一个办法，唯有让自己的儿子，唯一自然出生的氪星人带着宝典去往另一个星球。\n超人在一艘穿上捕鱼，这似乎是职业？\n船员处于好心救了克拉克一次，一个基地失火了，超人初显神威，将他们救了出来。\n超人开始回忆童年。全班同学坐校车，校车车胎爆了，导致校车开向了河里，本该九死一生的情况，但幼时的克拉克就已经拥有了超人的部分神力，将校车推向了岸边，同时再下河将之在车上嘲笑他的小胖也救上了岸。\n但这也让同学的父母还是怀疑克拉克异于常人的现象，但克拉克的父母必须极力掩饰，因为人类会恐惧未知的东西，如果让其他人知道克拉克的与众不同，那么人类也许会消灭克拉克，这一切都让克拉克听见了，他独自一人坐在皮卡车上思考着，他的养父走了过来，告诉了自己的来历，以及随他一起飞往地球的飞船和中枢宝典。当卡拉克知道自己不是地球人之后，我想他应该很伤心，我想每个人都会伤心把，因为你在这个世界上，居然没有一个同类，我想，每个人都不想成为别人眼中的异类，因为这会很孤独。\n酒吧里，好友被人乱摸，克拉克上去劝阻，但似乎被当软柿子了，超人本可以直接干掉这败类，但他忍住了，出门后将他的车砸掉了\u0026hellip;\n克拉克无意间来到了来自氪星的侦察艇上，并先驾驶着它离开了人类的实现范围。这艘侦察艇上残留了超人父亲乔伊莱的影子。乔伊莱便开始向解释这发生的一切\u0026hellip;氪星上的人都是人工造的，在出生前就已经被赋予了某种职业。为了改变这一切，超人凯尔诞生了，数百年来唯一一个自然出生的氪星人。乔伊莱将战衣给了超人凯尔，并告诉他——伊莱家族族徽的含义是——坚信每个人都有向善的根本信念。\n凯尔开始了训练，逐渐掌握自己的超能力。\n记者莱恩开始寻找克拉克，为了新闻的真实性，因为这会让她出名，但当他找到克拉克后，询问他为什么要一直逃避，为什么不去帮助人类，克拉克的回答让莱恩明白了——父亲为了不让他暴露超能力，不让他再一次成为别人眼中的异类，又或者是为了他的安全着想，他自己冒着生命危险就瞎了小狗，这里说实话有点搞笑，为了救一条狗——汉克，居然搭上了丈夫的性命，这不是闹着玩吗，也许是因为明白了父亲的良苦用心，在这之后，克拉克一直过着普通人的生活，很佩服，如果换做是我，肯定是做不到的，也许这也是为什么我不是超人的原因。别人是选择做普通人，而我确实被迫做普通人。\n再次见到母亲，母亲已经快是满头白发，他告诉母亲，他找到了自己的族人，知道了自己的身世，此时的母子俩非常的开心。\n”担心他们会把你从我身边夺走“母亲说，哎，也许这是我的弱点吧。\n佐德终于找到了地球，找到了凯尔，他用全世界的电子设备告诉凯尔——你不是一个人。佐德用全世界的人类威胁凯尔，想让他投降，人类也开始寻找他，但不是保护，而是交出他，就是人性——善恶交织。\n唯一知道凯尔身份的人——露易丝莱恩也被扣了个叛国罪\u0026hellip;将被逮捕。\n克拉克再次回忆起小时候父亲对自己说的话——你得自己决定成为什么样的人，不管你成为何种人，正义或邪恶，都将改变这个世界。\n回到现实，卡拉克很纠结，因为他知道佐德不可信，但他同样也不知道人类可不可信，有人告诉他——有时候你要先信任别人，才能得到别人的信任。\n克拉克投降了，为了路易斯莱恩，这些人真是可笑，若不是超人愿意，你们怎么能困住超人？\n克拉克和路易斯都被带上了飞船，他们都被窥视佐德窥视了记忆，而后，佐德来到了卡拉克母亲住的地方，逼问克拉克的母亲，飞船和宝典在哪里。\n超人察觉到佐德可能会伤害自己的母亲，以最快的速度赶到，刚好是看到了佐德威胁母亲的一幕，直接将佐德按在地上狂打——你以为你可以困住我的母亲？超人干掉了佐德的头盔，本以为可以直接干掉佐德，但奈何佐德的部下赶来了，救了佐德一命。\n超人和氪星人初次战斗，前期一打一打不过，之后超人越战越勇，二打一直接不分上下，其中一个氪星人的头盔被打破，但他们的飞船又来将他们救走了，我寻思为什么不直接用飞船的光线干超人？这样不跟家碾压？难道是为了给飞船节省能量？我暂时也只能想到这个理由了。\n超人也是在初次碰撞中获得了人类的认可——他不是我们的敌人。\n佐德开始改造地球，他想让地球变成氪星，这样才能复活他的族人们，从这一点来说，佐德并没有错，他一心为氪星，他配得上一星之将。\n佐德以人类威胁凯尔， 最终凯尔还是杀了佐德，为了几个人类。杀死了自己最后一个同类。我也许一生都无法理解超人的这种感觉。\n地球得救了，但超人却永远失去了最后一个族人。\n小狗汉克也离开了这个世界。\n这是一场种族之战，没有对错可言。","title":"《超人之钢铁之躯》"},{"content":"《超越感觉》 前言 任何两个人都不是完全一样的，每个人观察世界时都有其独特的视角和特有的方法。\n人类忽视这种主观方面的任何一个观点都是一种扭曲。\n感觉和思考不是互相排斥的，它们完全是互补的，因此不必关注其中之一，从而抛弃另一个。两者都是人的自然特质。\n人的思维能够超越感觉，实现清晰、公正、批判的问题解决和决策。\n你是谁 世界对我们的影响远远超出了我们大多数人的认知。\n时间和地点的影响 生活在不同的时代或文化背景下，会使你成为一个不同的人。\n如果你成长于印度，那你也许会完全适应父母选择你的配偶。\n如果你生活在殖民时期的美洲，那你可能不会反对禁止妇女从事陪审团的做法。\n观念的影响 当表达一个观念时，同时也在逻辑上不可避免的传达了与此密切相关的一些观念\n 给出观念：智力是由遗传决定的，并且不能增加。\n教育者知道后，他们以职业课程代替了学术的课程，并且接受了教授学生们的事实而不是判断过程的方法论。\n立法者知道后，决定阻止智力低下的人们进入到这个国家。\n商界领袖知道后，将无需头脑的人交给智力低的人们去完成。\n 你所面对的无数观念将以类似的方式（轻微的或深刻的）影响着你的信念和行为。这甚至在你未有意识地理解这些观念之前就可能发生。\n因为认为很少有耐心读完一本需要思考的书籍，所以许多出版社商就用名人写的轻松消遣之作代替严肃的书籍。\n大众文化的影响 电视节目制作人运用频繁的场景转换和感官诉求（如汽车碰撞、暴 力和性邂逅），以维持观众的兴趣不减。\n观众么期望教室 和工作场所也提供像电视中得到的同样的连续刺激。\n人们很少有耐心读完一本需要思考的书籍，所 以许多出版商就用名人写的轻松消遣之作代替严肃的书籍。\n今天，政客比新闻记者更加让人生厌地操控人民。政客不是表达他 们的思想，而是调查人们想什么，并且假装分享人民的看法。\n操纵的学问  所罗门·阿希（Solomon Asch）指 出，只是通过改变系列中的词序，人们的反应就能发生变化。他要求研 究的参与者用一系列形容词来评价一个人。当他把褒义形容词放在第一 位时——聪慧、勤奋、冲动、批判的、固执、妒忌——参与者给出了积 极的评价。当他调换这些词的词序，把妒忌放在第一位，把聪慧放在最 后一位时，他们给出了消极的评价。\n 我们以最大的热情捍卫的许多信仰，也许就是以这种方式根 植于我们头脑中的。\n舆论就像自然气候，它是如此地广泛深入人心，以至那些生活于其中、不知 道其他观点的人视之为理所当然。\n心理学的影响  当孩子们觉得自己在某个课目上表现愚笨（或者在各科都愚笨）时，他们就会无意识地以行为去证实 这种自我形象。他们觉得自己愚笨，所以行动也表现得如此。这位教育 工作者推断出，正是这种失败主义的态度而不是能力上的任何缺陷破坏 了他们的努力，因而着手改变他们的自我形象。他发现，当他做到这一 点时，他们就不再表现得愚笨了。\n 什么是批判性思考 许多人可能只是告诉你去思 考，却根本未解释思考是什么，以及一名好的思考者具备什么样的品 质，而这是差的思考者所缺乏的。\n 生活中最有趣和令人震惊的矛盾是：一方面， 几乎所有人都不断坚持“逻辑”、“逻辑推理”和“合理推理”；另 一方面，他们却不能表现出这种能力，当别人表现出来时也不 愿接受之。\n我们大多数所谓的推理在于为继续相信我们已经相信的东 西找到理由。\n清晰的思考是非常罕见的事，但甚至简单清楚的思考也几 乎是罕见的。我们许多人在大多数时间里根本就不思考。我们 信奉并且感觉着，但并不思考。\n思想懒惰是人最常见的特质之一。\n 心智和大脑 大脑是思考的必要条件，但没有表明大 脑是思考的充分条件。\n大脑是由物质组成的 物理实体，因而会衰退，而心智则是形而上的实体。\n批判性思考的定义  感觉在引导我们注意到自己应当思考的问题上是有用的，它也能提 供完成艰苦的脑力工作所需要的热情和献身精神。但是，它从来就不是 思维的一个良好替代者，因为它极不可靠。有些感觉是有益的、高尚 的，甚至是崇高的；而其他的则不是。\n相反，思考则是用以解决问题、作出决定或取得理解而进行的有意 识的精神过程。感觉除了表达自身以外没有其他目的，而思考则有超越自身而达成知识或采取行动的目标。但这并不是说思考是不会错。\n 批判性思考者的特点    批判性思考者 批判性思考者     以诚待己，承认自己所不知道的事情，认识自己的局限性，能看到自己的缺点。 假装自己知道的比做的还多，无视自己的局限性，并假设自己的观点无差错。   把问题和有争议的议题视为令人兴奋的挑战。 把问题和有争议的议题视为对自我的损害或威胁。   思考者尽力领会复杂性，对其保持好奇心和耐心，并准备花时间 去解决难题。 对复杂性缺乏耐心，宁可困惑不解也不努力搞明白。   把判断建立在证据而不是个人喜好上，只要证据不充分就 推迟判断。当新证据揭示出错误时，他们就修改判断。 把判断建立在第一印象和直觉反应上。他们不关心证据的 数量和质量，并且顽固地坚持自己的观点。   对他人的思想感兴趣，因而愿意专心地阅读和倾听，即使 他们往往不同意他人的观点 只关注自身和自己的观点，因而不愿关注他人的观点。一 看到不同意见，他们往往会想“我怎么能够反驳它？   认识到极端的观点（无论是保守的还是自由派的）很少正确，所以他们避免它们，践行公正性并且寻求平衡的观点。 忽视平衡的必要性，优先考虑支持他们既成观点的看法。   践行克制，控制自己的感情而不是受感情所控制，三思而 后行。 容易遵从自己的感情和冲动地行动。    没有心智约束的人不是一个自由的人，而是奴隶。\n直觉的作用  你可能碰到 过一个陌生人，并且马上“知道”你们将是终身伴侣。当一名汽车推销员 告诉你，他给你的报价是最后的、最低的价格，你的直觉也许告诉你他 在说谎。在学习某个特定课程的第一天，你可能有一种强烈的感觉：你 将会学不好它\n 有些直觉最终证明是错误的。\n 那位有吸引力的陌生人可能并没有成为你的终身伴侣，而是你很讨厌的人。那位汽车推销 员的最后价格也许证明就是那么多。而且，那门课你学得很 好，而不是很坏。\n 批判性思考与写作 写作可用于两个广泛目标之一：发现思想或交流思想。\n 每当你写作以开发思想时，集中于你正考察的问题并记录下你所有 的想法、疑问和断言。不要担心组织结构或正确性。如果想法产生得缓 慢，那要保持耐心。如果一些想法突然地匆忙到来，那也不要试图减缓 这个过程并把其中任何一个都开发出来；只需把它们全部记录下来（此 后会有时间去详尽阐述和矫正）。\n 批判性思考与讨论 只要可能，就提前做准备\n 考虑一下你对该话题已经了 解的知识。\n尝试预测在讨论中有可能表达的不同观点，并考虑每一个观点的 相对优点。\n 设定合理的预期\n 人们很少轻易或迅速地改变自己的想 法，特别是在长期持有的信念上。而且，当遇到与自己不同的观点时， 他们当然想知道有什么支持这些观点的根据。期望有人质疑你的观点， 并且从善如流地、优雅地作出反应。\n 抛弃自我中心和个人议程\n 自我中心显然产生对他人的无礼态度——特别是“我比其他人重要”、“我的观 点比其他任何人的都好”以及“规则不适用于我”。\n 起作用但不主导一切\n 如果你比较有节制，那就很少说 什么。这两者中任何一种人都没有什么过错。但是，当每个人都献计献 策时，讨论就是最有成效的。要做到这一点，健谈的人需要一点克制， 而节制的人则要承担贡献他们想法的责任。\n 积极的倾听\n 当参与者们并不相互倾听时，讨论就不过成了一系列的个人独白。\n保持注意力的最好方法就是警惕这种分神并且抵制之。努力进 入演讲者的思想架构，并理解所说的每句话，并把它与前面的话联系起 来。\n 负责任地判断思想\n 对不熟悉或与你意见不同的观点 要特别小心，因为这些是你最容易拒绝公正地听取的观点\n 抵制喊叫或打断的冲动\n 如果你确信自己的想法正确，那你就不需要提高声音或使他人保持沉默\n不要以不可反对的方式表示异议\n 避免抄袭  当你研究一个课题时，把其他来源的思想与你自己的思想区分开来。首先把你查阅的每条信息的来源都记录下来。对因特网资源，记下网址、材料的作者和标题以及你访问的日期。对于书籍，记下作者、标题、出版地、出版社和出版日期。\n当你阅读每个资料来源时，用笔记记下你想在自己的写作中引用的思想。如果作者的话非常清楚和简洁，那就精确地复制它们，并用引号把它们标注起来。否则，就作转述——即用你自己的话重述作者的思想。把作者这段话出现的页码记下来。\n你在写论文时，通过审慎地运用引语和改述来把借用的思想和语言加入你自己的作品中。\n 真理是什么 今天，把真理看作是相对和主观的，已是一种时尚。俗话说：“每个人创造他或她自己的真理，对你是真理也许对我并不是。”这句话的含义远远超出了“这是个自由的国度，我可以相信自己想要的”这种说法。于是，这个陈述就变成了任何一个人认为是真理的任何事情，都是因为他或她认为它是真理。\n这个观念的含义相当令人惊愕，但由于某些原因，很少有人认识到这些含义，而且更少的人有兴趣检验其合理性。\n 每个人都对，无人是错的。事实上是无人有可能出错——教授，我的答案不可能错。它们是我的真理！\n每个人的感知和记忆都是完美无瑕的，从不会出错、失灵或有过失。\n无人采纳他人的“真理”。如果真理完全是个人的，那每个人的真理必定是独特的。\n 究竟始于何处  你听到过一句老话：“所见即所信 。”反之也同样正确——所信即所见 。在或多或少的程度上，我们视为自己独特视角的看法承受着他人思想和信念的印记\n 不完善感知  如果我们不喜欢的某个人大声说话并且神气活现，那我们有可能认为此人是故意炫耀以引人注意。但如果是一个朋友以同样的方式行事，那我们就把他或她看作活泼和外向。\n 不完善记忆 真实的记忆也许会被虚假的记忆所替代。\n 即使我们的感知最初是正确无误的，我们的记忆也经常扭曲它。我们忘记了细节，当后来试图回想发生什么时，我们就求助想象来填充这些空白。虽然我们可能最初意识到这样一种重建过程在发生，但这种意识很快就消失了，我们开始相信自己记起来的正是最初的感知。\n 有缺陷的信息 一个信念的质量取决于支持它的信息的质量。\n事情一直在发生着，变得太快。无论我们是否看到，它们都发生\n 离家三个月的大学生有可能生动地画出邻家的榆木树，但它却可能在两个月前就被砍掉了。一个士兵也许完整地记得家乡的一切——每一个景色、声音和气味，回家却发现主街道的一半被市区的更新所摧毁，老旧的中学已经关闭，一辆新轿车停在他最好朋友的门前的车道上\n 即使最明智的人也会出错 最受人尊重的头脑在某日视为真理的事，在后来被证明是错误的\n 你的祖父母可能知道我们的太阳系有 8 大行星。\n自 1930 年发现冥王星以来，你和父母知道有 9 大行星。但是，如果加利福尼亚大学约瑟夫·布雷迪（Joseph L. Brady）观察正确的话，你的孩子将知道有十大行星。可是最近，冥王星却从名单中剔除了。\n  医生用吗啡做止痛药多年后，发现人对它有依赖性。于是搜寻没有依赖性的替代物。发现的替代物是什么呢？海洛因。\n 真理是发现的，不是创造的 大多数人只能接近真理。\n 那种“每个人都创造他或她的真理”的想法也让人感到可笑。不错，我们的确创造一些事物，但是，它不是真理。它是信念 ，即我们信以为真但很可能是虚假的想法。\n真理不依赖我们对它的认可，无论如何也不因我们的无知而被改变，或者因为我们的一厢情愿而被改造。因为，它在那里等待被发现。\n我将永远不可能找到自己想知道的所有答案。但是，我可以观察得更准确一点，权衡问题更全面一点，作出决定时更仔细一点。如果我这么做了，我就会更接近真理。\n 理解原因和结果 一件事件看一看先于另一个事件却并不导致该事件。\n 打碎一面镜子，看见黑猫过马路或在楼梯下面行走，都被认为这将会造成厄运。\n 这种类似的事情完全忽视了事情的巧合性，这两件事也许有相关性但却没有因果性。\n并非所有的因果关系都包含必然性。\n因果关系被界定为：一件事情影响另一间事情发生的现象。\n一个观念影响了一个行为或信念的产生。\n 一个种族比另一个种族优越的观念导致针对相信国家的军事行动，歧视性法律，奴役制和种族的灭绝。\n 自由意志\n最难破除的是随着时间逐渐养成的习惯。\n起初哪些无法让人接受的行为（性和暴力），但随着时间的推移，人们养成了接受它们的习惯，抗议逐步减少。最终，这种习惯根深固蒂，以致于反对这种性和暴力的人都被认为是怪人。\n因果性经常是复杂的\n一件事，从时间线的最后向最前推导，可以得出的最早原因，也就是根本原因。\n 一家化工厂的老板也许正在努力降低成本时，把化学品倒入附近的小溪，最终流入河中。\n这个行为可能产生意料之外的结果——河流污染，鱼类死亡，甚至让居住在远离此工厂的人致癌。\n这些结果并不会因为他无意为之而不真实。\n事件很少是(如果有的话)“偶然发生的”。它们是作为 特定影响的结果而发生的，这些影响可以是大的，也可以是小的， 可以是直接的，也可以是间接的，在时间或空间上可以是接近的， 也可以是远离的;可以是不可抗拒的(强力或必然的)，或者是可抗 拒的(遭引诱、鼓动或怂恿的)。\n 相信“每个人都可以创造他或她自己的真理”的人决不应与任何人拿任何事情进行争论。他如果这样做了，那就是自相矛盾\n认知意味着什么？ 有些时候，你知道一件事，但它可能是错的，反之，你不知道一件事，却有可能是对的。这也许是记忆的差错。\n认知的必要条件 我们常常不能用文字表达我们的知识，我们也许只能说：”我知识知道，经此而已。“但却不能表达出具体知道什么，或者我们如何得知的它。\n摆脱自负，因为任何人都不可能开始学习他认为自己早已知道的事。\n我们如何知道 被动学习具有严重缺陷。它使我们易于非批判地接受被告知的事，甚至当告诉我们的只是些传闻和谣言的时候也是如此。\n一位作者陈述的观点可能被另外一名作者重新表述为一个事实，他又可能被另一位作者作为权威来引用；这个过程可能会无限地继续下去，除非有人怀疑最初作者作为其观点依据的事实或质疑他对这些事实所作的解释。\n 你曾玩过谣言（或打电话）的游戏吗？它开始时是一个人写下一条讯息，但不让任何人看到。然后这个人开始逐字逐句地把此讯息小声地传给另一个人。这个人再小声地传给其他人，依此类推，传遍所有参加游戏的人。最后一个人逐字写下他或她听到的讯息。然后比较这两个文字记载的讯息。\n一般情况下，最初的讯息在一个传一个的过程中发生了改变，往往是巨大的改变。\n  没有两个词恰好包含完全相同的意思。因此，人们用自己的话复述一个故事，而不是准确地引用原话，这一简单事实改变了故事的内容。还有大部分人听得也不完整。而且，许多人喜欢对一个故事添加自己的创造，试图改进它，打上他们自己个人风格的印记。这种倾向也许是有意识的，也许是无意识的。但是，在任何一种情况下，结果都一样——听到它的那些人都以为自己知道。\n 为什么认知是最困难的 每天新发生的情况无先例可寻。\n知识经常被遗忘或被不明智地拒绝。\n信仰是一种形式的知识吗？ 信仰的真实性不能被确定性的证明\n知识的障碍 设定 就是把某事看作理所当然的——也就是随意地把未被证明或可以合理争论的某事当作真的来接受。因为设定一般是无意识的活动，所以我们经常意识不到自己的设定和它们对我们的影响\n猜想\n是提出一个直觉判断或是冒险提出一个对正确性没有任何信心的答案。它是一种常见的日常活动。对那些没有为考试认真学习的学生来说，这是最后时刻的生存技巧。\n 只要你不够确定，那就说可能和大概。说“我认为”或“在我看来”而不是“我知道”。最重要的是，向自己或他人坦诚地面对自己的无知。承认你自己不知道某事，可显示卓识、克制和学术真诚。这些不是缺点而是优点。承认无知是通往知识关键的第一步。\n  这是否意味着你应当是无主见的，并对你说的每件事都加上也许和大概？这是否意味着要成为一名批判的思考者，你必须抛弃信念？对这两个问题的答案是加着重号的不！ 这仅仅意味着你应当恰如其分地评估有把握的、大胆的陈述，以便为证据允许时的情况留下余地。\n 你的观点又多少根据 在我看来，真理是宝贵的……我宁愿独自一人坚守正确的，也不愿追随多数人而坚持错误的……因此，持有这样的观点已使我遭受到一些同胞的轻蔑、鄙视和嘲笑。我被看成是古怪的、奇特的和孤僻的……但是，真理就是真理，即使全世界都拒绝它并反对我，我仍然固守真理。\n是否可以质疑他人的观点，者取决于所涉及问题的种类。\n 如果艾格尼丝发现雷金纳德英俊，而莎莉不同意，那就的确不存在什么有意义的争辩的基础。\n一些人把酱涂在热狗上，而另一些人更喜欢倒上芥末或调料，也许此时此刻某人在某处正往热狗上涂抹大量的蛋黄酱、蓝莓或球芽甘蓝。那又怎样？差别万岁！\n 观点这个术语指的是判断的表达而不是喜好的表达。在某些情况下，很多人并不清楚某人是在表达喜好还是在表达判断。\n 当你离开电影院时，一位朋友也许对你说：“这是一部精彩的电影”，这可能意味着“我喜欢它”或“它达到了很高的电影制作水平”。如果她仅仅说喜欢它，而你不喜欢，那么争论会是围绕个人喜好的争论，一场无意义的争论。但是，如果她作出一个美学判断，那你能够合理地质疑她，引用这部电影未达到的具体电影标准。\n 只有当不伤害他人时，我们才可自由地根据自己的观点行事。\n可能出错的观点 如果我们可自由地拥有一种观点，那我们也许会试图推断它一定是正确的。但事实并非如此。\n 在油量指针指到零时继续驾驶高耗油车的某人，也许认为指针显示的问题还可以撑过下一个 50 英里。16 岁退学的学生可能认为，早点进入就业市场最终能提高就业保障。然而，无论如何深刻地、真诚地持有这些观点，他们还是错了\n 关于道德问题的观点 你的观点“对你是对的”，而我的观点“对我是对的”\n 这种流行观点也许看起来是相当有道理和宽宏大量的，但它却是完全肤浅的。几乎每一天都出现需要理性的人们违背的情况。你听过任何人声称，入室盗窃、虐待配偶或强奸，对于信奉这些行为的人来说在道德上是可接受的吗？当某人因猥亵儿童被定罪，有市民在法院前面拉着写有“恋童癖对我们来说可能是错的，但对他却是对的”横幅游行的吗？如果你的老师发现你考试作弊，她能接受你的目的可为手段辩护的解释吗？如果酒精测试表明，你正在开车的同学血液酒精含量高于平均积分点，交警会表扬他按照自己的道德信念而生活的行为吗？\n 还是那句话——只有当不伤害他人时，我们才可自由地根据自己的观点行事。\n甚至专家也可能出错  在 1919—1922 年之间，纽约大都会艺术博物馆买了 17 个黄金容器，它们被专家鉴定为来自一座有 3500 年历史的埃及古墓的真正宝藏。1982 年，人们发现这些容器是 20 世纪的赝品。\n1928 年，发明了一种叫二氧化钍胶体（thorotrast）的药，并把它用于显出身体的某些器官的轮廓，以便能获得更清晰的 X 光射线。19 年以后，医生们获知，即使小剂量的这种药物也可致癌。\n1959 年，一种叫沙利度胺（thalidomide）的镇静剂投放市场。许多医生为孕妇开这种药。后来，当大量畸形婴儿出生时，医疗权威认识到这应归咎于沙利度胺。\n 我们不知道未来的研究人员将推翻我们这一代专家的哪些观点。但我们可以确定，某些观点将被推翻。而这些很可能是在当代看起来无懈可击的观点。\n错误的种类 这些人比其他人容易犯错。\n 那些根本不进行推理、而是像其周围人（父母、邻居、牧师和他们羡慕或尊敬的任何其他人）一样思考和行动的人。这样的人信奉权威，喜欢跟风。\n那些决意让激情而不是理性统摄自己生活的人。这些人只喜欢支持他们观点的人。\n那些真诚地遵循理性，但缺乏准确、全面的判断力，从而看不到问题的各个方面的人。他们喜欢跟同一种类型的人谈话，读一种类型的书，所以所接触的也只是一种观念。\n那些对已经形成的观点从不费心再次检验的人。这些人是所有人中最容易出错的，因为他们拒绝了在新证据面前纠正错误的所有机会\n 有见识的对无见识的观点 遇到问题，我们通常会尽可能的去询问最专业的人，而不是一个业余者。\n一个观点要被看作是有见识的，就必须以更加坚实的事实为基础，即比我们对这个观点的熟悉程度、我们持有该观点的时间长度或我们思考自己所希望的东西的假定权利还要坚实。\n 如果我们想更多地了解宇宙中的各种类星体，那我们可以在街角叫住某人并询问他，这个人会自由地提出一种看法。但是，去问一位天文学家会更加明智。\n  鲸能相互交流吗？如果可以，那它们能传递信息多远？我们的汽车修理工对这个问题会有一个看法吗？可能有。我们的杂货商、牙医和银行家也可能有自己的看法。但是，无论这些人多么聪明，他们有关鲸的看法并不是很有见识。观点有价值的那些人是对鲸做过一些研究的人，他们会告诉们座头鲸会发出各种各样的声音。除了滴答声以外，它们还发出吱吱声、砰砰声和叽嘎声。\n 观点陈述仅占了一两句，而支持其观点的细节则要占据若干段落、页面甚至是整个一章节。你在写作自己的分析论文时，需要谨记这一点。\n证据是什么？ 陈述一种观点，就是告诉他人我们对某事的看法；提供证据是向他人表明我们认为有意义的事情。\n为什么如此多的写作和演说由一个又一个观点堆砌而成，而很少或根本就没有提供支持这些观点的证据？\n 人类心智是名副其实的意见加工厂，因此，大多数人有丰富的意见进行交流。 人们易于记住自己的观点，而忘记他们获得这些观点的过程，就像学生们在忘记构成期末课程成绩的各个测验和家庭作业成绩以后很久，仍然记得他们的最后成绩一样。 在某些方面也更为重要的原因是，有时候很少有或者根本就没有什么可以记住的证据——也就是说，所说的观点并不是依据什么重要的东西。  个人经验 个人经验是一种我们不用去图书馆或利用因特网就能获得的证据。我们的大脑里就装着它。并且，虽然我们对自己的个人经验充满信心。但它也有可能只是个例。\n未公开的传说 未公开的传说是我们从他人那里听说的故事，这种故事的最大问题在于很难证实它们。因为我们不知道这些故事是二手、三手、四手还是五手的。而在这传播的过程中，有可能改变其内容。复述这些故事的人并非不诚实；甚至他们会力求准确，但多少会在不经意间遗漏一些语词、增添其他语词、改变细节或事件的顺序。\n评价证据 我们都喜欢把自己视为完全客观的，对每个议题的正反两面都平等地开放。但是，事实很少如此。即使在评价之初我们没有就某个议题采取坚定的立场，但由于我们整体上的生活哲学、我们的政治或社会观点、对相关议题的看法或我们对与各种观点相联系的人们的态度，我们通常也将“倾斜”于某一个方面或其他方面。这种倾向性也称之为偏见 ，它可能微不足道，以至对我们的判断很少或没有影响。\n为了保住面子坚持错误观点不仅是愚蠢的，在德性上也是不诚实的\n什么是论证 论证不是争吵\n论证在理想上是具有不同见解的人一起工作以达到对某个议题更深刻、更准确理解的合作性努力。经过这样的努力，各个自我受到了控制，每个人即使都希望是正确的，也愿意被证明是错误的。因为每个人在这个过程中呈现出更深刻的洞察力，所以就没有输家。遗憾的是，自我是不容易被压制的。此外，我们大多数人已被训练成相信，每次论证就像体育竞赛一样，必定存在赢家和输家。因此。我们常常更多关注的是驳斥针对我们“对手”的“得分”，而不是知识和智慧的增长，所以，即使我们竭尽所能，也往往达不到这种理想状态。\n我的更好 我们的信念已被接受，我们何以或者为何几乎不知道……但是，这就提出了关于我们的观念之合理性的问题……而且，我们马上就发现自己对这些观念充满了难以抑制的激情；我们捍卫它们就像保护自己挨打的肩膀一样。无论它们多么合理，这个问题都不会让我们烦心。因为我们拒绝从反对者那里了解真实情况。\n这种倾向可归因于“我的更好”的看法上，这是我们或多或少都持有的看法。\n自我中心的人 自我中心意指聚焦于或集中于个人自身，并且仅对个人自己的爱好、需要和观点感兴趣。\n因为自我思维的视角很有局限性，所以自我思维的人难以从各种各样的视角来看问题。\n当某人自己的看法是最终的、绝对正确的仲裁者时，为什么还要费心去对有争议的问题进行艰苦的检验、查看专家证言并评价证据呢？\n族群中心的人 熟悉的人自然要比不熟悉的人更令人愉悦，假装不是如此，那是自欺欺人。\n控制“我的更好”的思维 我们对自己思想的偏爱有可能妨碍我们发现自己思想中的缺失，也妨碍对他人洞见的领悟和借鉴。\n我们对自己观点的忠诚有可能使我们无视其他的视角，让我们看不到不熟悉的真理，将自己束缚在过去的结论中。\n立场的错误  想象一下，你戴了一副镜片严重扭曲的眼镜，却没有意识到这个问题。你有一切理由相信你看到的人、场所和事情都是像它们所显现的那样，而事实上它们是相当不同的。当你与他人分享你的感知而他们对此质疑时，你起先是惊讶不已，并对他们不能像你一样清晰地观察世界而困惑不解。最后，你要么停止与他人进行交流，要么变得更加武断，希望凭你表达的生动有力来解决你确信属于他们的问题的事情。\n 视角匮乏  考虑关于一场具体战争的起因议题。社会学家会倾向于关注社会条件，经济学家关注经济条件，心理学家关注相关国家领导人的内心动机和冲动[ 。然而，由于战争是一种复杂现象，最有意义的答案通常是所有这些因素（也许还有一些其他因素）的结合 。只有那些学会超越自己单个学科视角限制的学者才有可能获得有意义的答案。\n 无根据的假定  假定人们的感觉总是值得信赖的。 事实是，信念和欲望有可能扭曲感知，导致人们有选择地或不准确地看和听。\n假定如果一个想法被广泛报道，那它一定是真的。 虚构的故事也能像真理一样广泛传播。\n假定拥有某些理由就证明某人已经从逻辑上进行了推论。 理由可以是非批判性地从他人那里借来。并且，即使理由是推理得出的，它们仍然可能是不合逻辑的。\n假设确信构成证据。 有可能在情感上依附于一个错误。\n假定熟知的想法比不熟知的更有根据。\n熟知仅表明之前听说过或阅读过；它并不保证我们听过或读过的就是正确的。\n假定如果某一事件在时间上跟随另一事件发生，那它必定是由另一事件引起的。 时间上的紧密联系有可能是意外。\n假定多数人的看法是正确的。 多数人曾经犯过错误——例如，赞同对女巫处以死刑和容忍奴隶制度。\n假定事情现在是什么样子就是它们应当是什么样子。 人是不完善的，他们的发明包括想法总有改进的余地。\n假定变化总是变得更好。 在一些事件中，变化改善了事态；而在另一些事件中，则使得事情变坏。例如，当政府试图通过提高税率来增加国库岁入时，其净效果通常是岁入下降。（关于这个的许多例子，可运用 Google 搜索工具搜索术语“非故意的结果”。）\n假定表象是值得信任的。 表象有可能出错。比如，美国小说家辛克莱尔·刘易斯（Sinclair Lewis）乘坐定期班轮去英国旅行。当他和一位朋友在甲板上步行时，他注意到一位妇女坐在甲板长凳上阅读他的一本小说。充满自豪感的他向朋友谈论看见别人如此专注地读他的作品是多么美妙的感觉。恰好在那一刻，那位妇女把那本书扔到海里去了。[ 1]\n假定我们头脑中如果有一个想法，那就是我们自己的，并且值得去护卫。 我们头脑中的一些想法（从理想上说是大部分想法）是我们细心分析的结果。另一些想法（在某些情况下其数量大得令人尴尬）则是不加批判地取自他人的，因而在任何重要的意义上并不是“我们自己的”。\n假定我们越是确信一个想法，这个想法就越有效。 一个想法的有效性是由支持它的证据的数量和质量决定的。我们确信的程度与此无关。换句话说，绝对确信的东西有可能仍然是错误的。\n假设我们在某人的论证中发现错误，我们就已经反驳了该论证。 一个论证有可能包含小缺陷却仍然是合理的论证。例如，证据的一两个项目可能有错误，但其他的论据仍然可以足以支持该论证。简言之，反驳一个论证需要的不只是挑剔瑕疵。\n 盲目遵从 另一种积极的遵从是模仿好的行为榜样——值得效仿的人们。这种遵从帮助我们培养自己的能力，并成为更好的个体。\n 避免盲目遵从的秘密在于，无论他人为了让你像他们一样思考、讲话和行为而施加怎样的恳求、奚落和敦促，都要加以抵制。不要屈从，而是问问自己，什么是合理的、正确的，并遵循这条路线，无论你所处的立场是多数人的还是少数人的\n 绝对主义 一个准则一旦确立，绝对主义者就拒绝允许例外。\n 例如，在进入学校大楼后，一位年轻的模范学生想起忘记把小刀从他的衣兜中拿走。意识到他的学校有一条禁止武器规定，他立刻走进校长办公室，并将小刀交给管理人员。校行政人员不是表扬他的责任心，而是暂停这个男孩入校并宣布考虑开除他。\n 克服绝对主义的关键在于：当你开始考察任何问题（即使是你此前思考过的问题）时，致力于接受你所发现的事实，而不是要求它是整洁而简单的。\n相对主义 相对主义者的信条是：“如果一个人认为任何行为在道德上是可接受的，那它对此人就是可以接受的。\n支持或反对变化的偏见 你支持还是反对变化？唯一合理的答案是：“这取决于变化是什么？”有些变化改善了事态；而其他的变化则让事情更糟。\n 当伽利略说，“地球围着太阳转”时，人们觉得不快，部分是因为千百次的日出和日落已经告诉他们太阳 在运转，但也部分地是因为他们之前只是从未听说过地球是运动的。这一新思想威胁了他们有关地球是太阳系中心的固有信念。他们已经把这种思想在头脑中整齐地打了包。这是他们对宇宙理解之基本部分；这也和他们的宗教纠缠在一起。而现在这个自命不凡的伽利略竟然要求他们打开这个包袱或重新讨论这个问题。\n 我们的思维和行为习惯在我们看来是唯一正确的思维和行为方式。新思想挑战了我们的安全感，所以我们倾向于抵制它。这解释了为什么许多人牢牢地抓住过时的传统不放，\n为了克服这两种对待变化的偏见，请检视你对新思想的反应。\n程序错误 有偏见的证据考量 只寻求肯定你偏见的证据\n双重标准 双重标准包括用一种判断标准对待我们自己的思想以及与我们自己相容的思想，而用完全不同的——更苛刻的——判断标准对待与我们思想不一致的看法。\n许多人对自己所赞同的思想是直言不讳的言论自由提倡者，却急于审查他们所不赞同的思想。\n为了避免双重标准的错误，事先决定你将使用什么判断标准，并前后一致地用这些标准，即使相关的材料数据并不支持你的看法。\n草率的结论 他们习惯于接受忽然想到的第一判断，从不费心探究一个不同的判断是否可能是同样合理的，甚至是更加合理的。\n 他们要是看到一个男人与一个不是他妻子的女人上了出租车，马上推断她是他的情人，而她有可能只是他的一个亲戚、商业伙伴或客户。如果一位朋友经过他们身边而没有跟他们说话，他们就推断他是个势利小人，而这个人也许因全神贯注而没有注意到他们。\n 心理学家对大约 200 万新兵进行智力测验。其结果，按照心理年龄表示的最终成绩如下：北欧移民，13 分；南部、中部欧洲的移民，11 分；美国出生的黑人，10 分。这些心理学家贸然断定南部欧洲人和黑人是“痴愚者”（当时认为这个术语是科学的）\n 一般而言，北欧人已移民到美国 20 年或更多时间，因此英语流利，并受过相当良好的教育。相反，南部和中部的欧洲人较近期才来到美国，他们既不讲流利的英语，也没有受过良好的教育（因为贫穷）。最后，许多美国出生的黑人被剥夺了受教育的机会。\n 过度概括和刻板成见 们容易进行过度的概括——也就是把仅适合一个群体某些成员的东西归属为所有成员。\n如果你参观纽约市，并碰到几个粗鲁的人，你这么说可能是正确的：“有些纽约人是粗鲁的”，但“大部分纽约人是粗鲁的”就不正确了，更不要说“纽约人是粗鲁的”。\n虽然刻板成见既可能是正面的，也可能是负面的，但它们更经常是负面的\n过度简单化 老师必须向学生、经验丰富的雇员必须向新手、律师必须向客户、医生必须向病人、科学家必须向普通大众进行解释。\n简单化就是把复杂的思想按比例缩减到较少知识的人能够明白的程度。\n过度简单化不只是使复杂的思想比较容易理解，它也歪曲和扭曲思想。过度简单化不是让人们有知，而是误导他们。不幸的是，过度简单化的陈述有可能听起来富有洞见。\n我们比他人更了解自己。\n 我们的确比他人更了解关于我们自己的某些事情：例如：我们的希望、梦想和幻想。但为了维护自我形象，我们会无意识地掩盖一些关于我们自己的事情：比如像妒忌、气量小和虚伪等个人缺点。而这些是其他人一目了然的。\n 事后归因谬误 它表达了这样一种推理，当一件事发生在另一件之后，那它必定是另一件事的结果。这种思维中的错误在于没有认识到仅仅时间上的邻近并不能证明因果关系。一件事可能碰巧发生在另一件事之后，而与它完全没有关系。\n事后归因谬误很可能是大部分迷信的基础。某人从楼梯下面走过或者打破一面镜子，或是一只黑猫穿过他面前的小径之后不久，不幸降临在此人身上，他就判断该事件导致了这种不幸。\n为了避免事后归因谬误，你需要做的就是暂缓作出因果关系的判断，直到你排除了其他的解释，包括巧合。\n表达的错误 自相矛盾 它表示不可能在同一时间以同样的方式作出既真又假的陈述。\n相对主义者认为每个人都可以创造他或她自己的真理，不存在某种观点比其他任何的观点更有价值，然后又由于斥责反对他们看法的人而导致自相矛盾。\n 一位学者提出物质世界是虚幻的，而唯有非物质世界或精神世界才是真实的观点，此人有可能因财产纠纷而把邻居告上法院。\n 为了克服自相矛盾，请检查你所说的和所写的。一旦察觉到任何自相矛盾，就仔细考察它。\n循环论证 进行循环论证的人试图以一种不同的形式来重复一个陈述来证明它。\n当这个陈述简短时，循环论证也许相当明显。\n 如果某人说“今天离婚不断攀升，因为越来越多的婚姻发生破裂”。\n 无意义的陈述 无意义的说明是对无道理的理由作的说明。\n “好消息！由于我们家具销售史无前例的巨大成功，我们再延长十天。”我们也许要问，如果它如此成功，那他们怎么还有足够的商品延长十天销售？（我们当中比较玩世不恭的人也许会把这个标题作如下表述：“销售是如此的失败，以至于我们的仓库堆满了劣质商品，我们要不顾一切地让人们购买它。”）\n 错误类比 类比是通过参考不同但比较熟悉的 2 某事来解释比较陌生的某事的一种做法，实际上就是说：“这个与那个相像。”类比对于促进理解，特别是对复杂思想的理解可以有帮助，但它们也有潜在的误导性。\n 即使是一个巨大的历史罪恶也不能自然而然地解释此后所有的罪恶……癌症的确能致命，但它并不能解释所有的死亡，甚或是大多数的死亡。\n 一些类比的错误例子：\n “动物有四肢和肌肉，它运动；地球没有四肢和肌肉，所以它不运动。”\n一个恶名昭著的例子就是传统上借用世界各地的革命者和恐怖分子之名来证明杀人正当性的类比：“如果你想得到炒鸡蛋，就不得不打破鸡蛋。”批判性思考者正当地回应道：“但人和鸡蛋很不相同！”\n 随时核查你的类比，确保他们所声称的相似之处是真实和合理的，不存在重要且明显的差异。\n非理性诉求  是一个男人杀害了自己的双亲，然后请求法庭宽大，因为他是个孤儿！\n 对权威的非理性诉求\n 对权威的理性诉求说，“这是一个或多个权威所说的”，并着手表明为什么应当接受这种观点。\n对权威的非理性诉求则说，“这是一个或多个权威所说的。不容置疑地接受它”。由于权威也不能特别地免除错误，从不质疑他们所宣称的东西的想法就是愚蠢的，因而也是不能接受的。\n 对共同信念的非理性诉求\n 对共同信念的理性诉诸说，“大多数人相信这一点”，并着手表明该信念的合理性。\n对共同信仰的非理性诉求则说，“相信它乃是因为 大多数人都相信它”。\n 对宽容的非理性诉求\n 对宽容的理性诉求解释了为什么宽容在相关的特定情形中是恰当的。\n非理性的诉求则说，“由于宽容是普遍地好的，它对包括本案在内的每种情形都是正确的反应。”这是纯粹的胡说。对有些行为——例如，恐怖主义、强奸和虐待儿童，迫切需要谴责。容忍这些行为的社会会怂恿它们，并犯下进一步侵害这些受害人的罪行。\n 区别理性和非理性诉求的最好办法就是看这种诉求是否伴随着你为何应当接受它 的解释。如果提供了一个解释，并证明它是合理的，那么这个诉求就是理性的。如果没有提供解释或所提供的解释不可信，那么这个诉求就是非理性的。\n反应的错误  我们一旦接受了某个观点，自尊心就使我们不愿承认自己是错的。当对我们的观点提出一些反对意见时，我们更关心的是发现反击它们的方式，而不是在它们当中可能有多少真理或合理的见解；我们宁可费力地为自己的观点寻找新的支持，也不坦然面对明显与自己的观点相矛盾的任何新事实。我们都知道，指出我们犯了错误的意见会多么容易让人火冒三丈；我们的第一感觉就是宁可做任何事也不愿承认错误，而我们最先想到的是“我如何通过解释来消除它？”\n 知道你自己 世界上 90％的悲哀出自人们不了解自己，自己的能力、弱点，甚至是其自身的真正的美德。我们大多数人对自己就像完全的陌生人一样走完了几乎整个一生。\n 我是寡言的还是健谈的？一般是乐观的还是悲观的？努力工作的还是懒惰的？恐惧的还是勇敢的？严肃的还是随意的？谦虚的还是骄傲的？竞争性的还是非竞争性的？我对陌生人是紧张的还是轻松的？我在紧急情况下能保持镇定、方寸不乱吗？我对自己做的每件事都有信心吗？我憎恨特定类型的人（例如受人欢迎的同学）吗？能比较准确地把我归入领导者还是追随者吗？\n  我在多大程度上是值得信赖的？我能保守秘密，还是必定会向至少一个或两个人泄漏秘密？我对朋友忠诚吗？我曾经“利用”他人吗？我对他人的感觉有多大的敏感性？我曾故意伤害其他人吗？我妒忌任何人吗？我喜欢制造麻烦吗？我在人们之间播下怀疑和纠纷的种子吗？我急于散播最新的谣言吗？我在背后说朋友的坏话吗？我对其他人的评论通常是赞许的还是不赞许的？我批评别人真实的或想象的缺点以作为一种吹嘘自我的手段吗？我遵守诺言吗？我对人们的缺点和错误有多大程度的容忍？\n  我对别人是诚实的吗？对我自己呢？我评价自己的技巧和才能时的客观程度如何？我的智力有多高？我在学校用功程度如何？和别人相处时，我扮演了多少不同的角色？这些角色哪些是真实的？哪些是为了隐藏我会感到羞愧或难堪而不让别人看到的那些方面而设计的假面具？我对未来规划的合理程度如何？我在压力下能很好地工作吗？\n 挑战与回报 人们倾向于回避对他们自己问题的关注和解决，反而经常求助于强辩、否定、补偿、识别、规划、回避、压制和其他防御性策略，把自己的问题扫到地毯下面。”\n敏锐的观察 观察人  人们在听人说话时，会发出某些信号显示对所说内容的赞同还是反对。偶尔的点头、鼓励式的微笑，甚至表示赞同的低声“嗯”，都表示“我同意你的看法”。另一方面，轻轻地摇头、眉毛上扬、眼睛上挑时的撅嘴、皱眉头——所有这些都暗示了至少部分的不同意。类似地，讨厌某项讨论的人通常也会显露出这种感觉，即使他们尽力不这样做。他们看手表，无可奈何地叹息，把注意力转向所预期话题以外的某人或某事，烦躁不安地玩自己衣服上的一个物件，频繁地改变姿势，这些方式都传递着他们希望改变主题或谈话同伴的信息。\n 好的侦探都是敏锐的观察者。他们知道，一个细小的、容易忽视的线索可能意味着案件破解和不破解之间的天壤之别。类似地，好的出庭律师认真审慎地观察人。当提及案件的某个方面时，目击证人的紧张一瞥可能暗示着最有成效的询问线索。\n我们如果仔细地观察他人的行为，那就能更有效地进行批判的思考。\n进行探究 观点可以是有见识的，也可以是无见识的。\n处理不确定的结果 无论一个问题如何与解决方案相抵触，但探究还是有益的。即使它只是产生不可检验的 专家意见，这些意见也比无见识的随意推测要有价值。所以我们不应被困难的议题所吓倒。我们只应对我们答案有可能达到怎样的彻底性和终极性持现实态度。\n集中于焦点 在搜索因特网时有可能更难实现效率，因为造成分心的东西往往更多、更有诱惑力。作出特别的努力来约束你的因特网搜索，把注意力集中到相关的材料上。\n多少探究才够充分 一个新事实可能颠覆一大堆证据\n 对批判性思考的最大挑战之一就是当你发现一位知识渊博之士支持你的偏见时，让你停止探究的那种诱惑。当这个人是你遇到的第一个人时，这种诱惑将特别地强烈。你将希望说：“这是确定的答案。本案到此为止！”如果你遵从这种倾向，那你将使该议题琐碎化，并欺骗自己，难以获得真正的理解。\n 形成判断 判断是通过证据考察和仔细推理得出的结论。它们是思考的结果。不像感觉，判断不是自发和无意识的。当然，它们可能含有自发的因素（比如直觉）。\n程序越是科学，就越不需要评价，这是一种流行的看法。但这种看法是错误的。科学程序产生或发现的事实信息必须被分类和解释为有意义的。\n作出重要的区分 把人与思想区分开来。\n 人们容易把人和思想混淆起来。就像我们倾向于忽视朋友的缺点而夸大敌人的缺点一样，我们也倾向于赞许地看待自己喜欢或羡慕的人的思想，而排斥地看待自己不喜欢或不羡慕的人的思想。\n 可钦佩的人有可能出错，而卑劣的人也可能说对了。\n把所说的与如何说区分开来\n我们对一个人的关注不在于他讲得多么雄辩，而在于他的证据是什么。\n把熟知性与正确性区分开来。\n熟悉的思想并不必然是正确的。\n力求一个平衡点 大批自由派思想者听起来都相似，就像大批保守派思想者千人一腔一样。当某人最终运用心智训练打破这种模式，并对该议题采取一种平衡的看法时，其结果就是一种全新独创的、往往是具有深刻洞见的观点。\n处理可能性 无论何时当你不能达成确定性时，就集中关注可能性。\n让你的主语适当的具体  今天的大学生 比十年前的同类人较不精通语法和惯用法。\n今天的美国大学生 比十年前的同类人较不精通语法和惯用法。\n今天美国的两年制大专生 比十年前的同类人较不精通语法和惯用法。\n今天这所大学的学生 比十年前的同类人较不精通语法和惯用法。\n 包括所有适当的限定语 你越是仔细地考虑准确表达你思想所必需的限定语，你的判断可能就越是可辩护的。这不仅包括时间上的限定语，而且也包括地点和环境上的限定语。\n 美国 40 岁以上、未读过大学的男人倾向于反对全国妇女组织（National Organization for Women）提出的妇女解放的观念”\n 这个判断（这可能真也可能假）中，几乎每个词都是限定语。它说（a）不是所有的男人而是美国 男人，（b）不是所有年龄段和达到教育水平的人，而是40 岁以上未读过大学的人 ，（c）不是一般的妇女解放观念，而是全国妇女组织提出的 观念。\n避免夸大其词 如果你要自己的判断经得起他人细致入微的检验，那就避免所有的夸大其词。在你不能确定自己判断的准确性，你应倾向于选择低估的陈述而不是高估的陈述。也就是说，你应采用比较适度的解释，较少极端的结论。这样做，当你错了的时候（每个人有时必定会错），你将至少因为表现出一种控制和约束的意识而拥有挽救的优雅。\n说服他人 慎思的判断值得共享\n 说服意味着如此有效地表述你的观点，以至让在该议题上未持立场的人将倾向于同意你的看法，而那些不同意你的人将被激励起来重新考虑他们自己的观点。这项任务比看起来的更加困难。中立的人将以开放的心态听取建议，但只在你论证了自己观点合理性的时候。那些不同意你的人将倾向于拒绝你的观点，原因很明显，因为它质疑了他们自己的看法。接受你的观点意味着抛弃他们自己的观点，\n 尊重你的受众\n如果你认为自己试图说服的人是愚蠢的或在认知上不诚实，那你必定会透露出这种信念，如果不是直接地、那也会间接地在你的语调或选词中表露出来。而且，他们通常会意识到你对他们的蔑视，并觉得受到伤害或感到不满，这种反应将几乎不会让他们接受你的劝说。\n这里适宜作一个提醒。不应觉得你需要声明对读者的尊重。这样的声明有听起来缺少诚意的效果。致力于尊重的感觉；如果能做到这一点，你就没有必要刻意声明。事实将表明一切。\n尽可能让人理解你的论证\n应当始终十分谨慎地处理你与读者间分歧的最尖锐之点。这些分歧点代表了对说服的最大障碍。如果你夸大地陈述自己的观点，那就必定强化读者对他们自己观点的确信，而不是设法让他们质疑自己所确信的东西。\n承认对方有道理之处\n没有一方是拥有全部真理的。\n 追求真理的全部责任要求我们不是勉强地而是欣慰地、毫不犹豫地承认真理。这并不意味着只在你文章的开头放上一个简短的句子，说“在某种程度上，每个人都是对的，我认为你也是”。然后一头栽入你自己的观点当中。\n 不要忽视任何相关的事实\n论证的目的不是击败他人，而是通过观点的交流发现真理的全部复杂性。当这样做时，人人都赢。当真理的任何一个部分被掩盖起来时，无人获胜，即使看起来也许是某人赢了。\n 你认为目前联邦主导的反贫困项目要比所提议的州主导的项目更有益于穷人。你正在进一步研究这个主题，准备给不同意你的那些读者写一篇支持你自己观点的文章。在研究该问题时，你发现了一篇没有广泛报道的报告，它用文献表明了当前联邦政府项目严重的低效率和浪费。而且很清楚的是，这些低效率现象在所提议的州项目中不大可能发生。你认识到读者很可能没有看到这篇报道，而且在你文章中提到它，会损害你最初的观点。你应当做什么？如果你有充分的理由推断这篇报道真的与该议题不相关，那提及它就是愚蠢的。但是，如果你确信它是相关的，那么，诚信将要求你提到它，处理它所提出的问题，并相应地修改你的观点。\n 不要用论证压倒读者\n在一篇短文中你不可能“证明”任何事情。尽管对你而言，证据“看起来是无可反驳的”，你也可能认为是“毫无疑问的”，但请记住，让读者作出自己的判断才是明智的。\n集中于最可能说服读者的论证\n不同的论证回吸引不同的读者\n绝不使用你认为不合理或无关的论证\n真诚和尊重事实是作者最重要的品格。没有这些品格，就没有真正的说服，而只是巧妙的表述。\n为你的观点得到认可而容留时间\n 在你表述自己的观点时，你的读者会立即抛弃他们自己的看法，转而接受你的观点，这种预期是不现实的。除了罕见的情况，你应该期待的最佳情况是，他们将被触动，根据你所说的重新考虑该议题，而你的洞见将最终导致他们修改自己的观点。“最终”可能是在下周或明年，而不是当下的 5 分钟以后，这一事实并不必然是对你说服他人之技巧所作的评价。它也许只是反映了人们形成的与其观点之间的纽带是不容易打破的。\n 一个缺乏说服力的表述 一名学生选择写一封信，指出他对学校餐厅的食物和服务的抱怨。他的读者是餐厅经理，他的任务是给这位读者留下他合理性的印象，并让她重新评价其职员的表现。\n 本校园不断发生关于餐厅的讨论。学生们厌恶低劣的食品、服务、肮脏的碟子和餐具。作为学生，我想指出自己抱怨的理由。\n首先，让我们考虑食物的质量。肉要么没煮熟，要么煮过了头。让人奇怪的是质量如此低劣如何能上市销售。蔬菜索然无味。但这也好，因为没有几个学生屈尊去吃它们。有些学生还在他们的饭菜中得到奖赏——像汤里的头发或土豆里的死苍蝇。这些只是食物如何低劣的几个例子。\n学生们的另一个抱怨是低效的服务。因为服务缓慢，学生们经常坐在那儿吃冷饭。很多学生不得不饿一顿，因为他们没有时间等。有些学生被迫支出额外的费用去当地餐厅就餐。\n可能最常见的抱怨是学生被迫使用肮脏的碟子和餐具。我猜想所有的东西都经过洗碗机，但出于奇怪的巧合，很少有几件东西洗出来是干净的。但是，工作人员对此并不担心——他们对肮脏视而不见，并把碟子和餐具递给服务生。鸡蛋在叉子上结块，而肉片粘在盘子上——当学生用一片肉的价钱得到两片肉时，这自然会提高学生的士气！\n问题在于，能够做些什么来纠正这些毛病？学生已经对行政人员提出了他们的抱怨，但这并没有起什么作用。这些人看起来并不正视这些问题。显然，必须做些事情。需要很多的改进。但有任何改进吗？你和我一样清楚。没有！\n 一个有说服力的表述  什么样的学生一直抱怨餐厅的食品质量？通常是那些由母亲照顾饮食并发现除了沉溺于专人服务以外就难以适应任何事情的学生。在大学第一学期，我的室友就是这样的一个人。他在此吃完每顿饭后都要抱怨一小时（而且他一共也没有吃过几顿饭）。在他看来，汉堡牛排“不适合人消化”，奶油白汁鸡“味同嚼蜡”，等等——他对自己“被迫”吃的每一种饭都有一个适度贬低的评论。\n约翰在这儿待了大约一个月。他喜欢上课并且学得很好。他也交了不少朋友。但他不停地说他母亲做的饭——每周三次的两英寸牛排、卤汁面条、意大利面条加猪排、肉圆和意大利热香肠。所以他离开大学回到了乌托邦。当然，没有几个学生走得像约翰那么远。但通过我听到学生对餐厅抱怨的频度来判断，他不是唯一的一个被母亲的饭菜不可救药地惯坏的学生。\n我们餐厅的服务和食品质量通常是好的。确实，肉偶尔会煮过头，蔬菜有时也会乏味，但这在家里也会发生（我母亲只给五个人做饭，而不是 1500 人）。事实上，我认为可能仅有两件事或许需要改进。\n第一点是排队等待。在我们的餐厅，我通常至少要等 15 分钟才能得到服务，而且我去得相当早。我从朋友处得知，在其他大学，排队时快速移动也是例外而不是惯例。所以，对此也许没有什么事可做。但如果管理部门发现某些方式去“交错安排”服务或加快队列移动，那至少有一个学生会对此感激。第二点是肮脏的碟子和餐具。在大多数用餐时间，我发现自己不得不擦去至少一只盘子或一件餐具上的污迹。可能出于效率的考虑，刷碗工不愿意清洗肮脏的餐具两遍。或许他们太忙了没有注意到。但是，洁净的碟子和餐具有助于让饭菜更吊人胃口。\n上述两点改进也许并不能让像约翰那样被宠坏的或乐于抱怨的学生满意。但是，这些改进将促使我们的餐厅成为就餐的更佳场所。\n ","permalink":"https://note.yxzi.xyz/note/afterthought/book/thought/%E8%B6%85%E8%B6%8A%E6%84%9F%E8%A7%89/","summary":"《超越感觉》 前言 任何两个人都不是完全一样的，每个人观察世界时都有其独特的视角和特有的方法。\n人类忽视这种主观方面的任何一个观点都是一种扭曲。\n感觉和思考不是互相排斥的，它们完全是互补的，因此不必关注其中之一，从而抛弃另一个。两者都是人的自然特质。\n人的思维能够超越感觉，实现清晰、公正、批判的问题解决和决策。\n你是谁 世界对我们的影响远远超出了我们大多数人的认知。\n时间和地点的影响 生活在不同的时代或文化背景下，会使你成为一个不同的人。\n如果你成长于印度，那你也许会完全适应父母选择你的配偶。\n如果你生活在殖民时期的美洲，那你可能不会反对禁止妇女从事陪审团的做法。\n观念的影响 当表达一个观念时，同时也在逻辑上不可避免的传达了与此密切相关的一些观念\n 给出观念：智力是由遗传决定的，并且不能增加。\n教育者知道后，他们以职业课程代替了学术的课程，并且接受了教授学生们的事实而不是判断过程的方法论。\n立法者知道后，决定阻止智力低下的人们进入到这个国家。\n商界领袖知道后，将无需头脑的人交给智力低的人们去完成。\n 你所面对的无数观念将以类似的方式（轻微的或深刻的）影响着你的信念和行为。这甚至在你未有意识地理解这些观念之前就可能发生。\n因为认为很少有耐心读完一本需要思考的书籍，所以许多出版社商就用名人写的轻松消遣之作代替严肃的书籍。\n大众文化的影响 电视节目制作人运用频繁的场景转换和感官诉求（如汽车碰撞、暴 力和性邂逅），以维持观众的兴趣不减。\n观众么期望教室 和工作场所也提供像电视中得到的同样的连续刺激。\n人们很少有耐心读完一本需要思考的书籍，所 以许多出版商就用名人写的轻松消遣之作代替严肃的书籍。\n今天，政客比新闻记者更加让人生厌地操控人民。政客不是表达他 们的思想，而是调查人们想什么，并且假装分享人民的看法。\n操纵的学问  所罗门·阿希（Solomon Asch）指 出，只是通过改变系列中的词序，人们的反应就能发生变化。他要求研 究的参与者用一系列形容词来评价一个人。当他把褒义形容词放在第一 位时——聪慧、勤奋、冲动、批判的、固执、妒忌——参与者给出了积 极的评价。当他调换这些词的词序，把妒忌放在第一位，把聪慧放在最 后一位时，他们给出了消极的评价。\n 我们以最大的热情捍卫的许多信仰，也许就是以这种方式根 植于我们头脑中的。\n舆论就像自然气候，它是如此地广泛深入人心，以至那些生活于其中、不知 道其他观点的人视之为理所当然。\n心理学的影响  当孩子们觉得自己在某个课目上表现愚笨（或者在各科都愚笨）时，他们就会无意识地以行为去证实 这种自我形象。他们觉得自己愚笨，所以行动也表现得如此。这位教育 工作者推断出，正是这种失败主义的态度而不是能力上的任何缺陷破坏 了他们的努力，因而着手改变他们的自我形象。他发现，当他做到这一 点时，他们就不再表现得愚笨了。\n 什么是批判性思考 许多人可能只是告诉你去思 考，却根本未解释思考是什么，以及一名好的思考者具备什么样的品 质，而这是差的思考者所缺乏的。\n 生活中最有趣和令人震惊的矛盾是：一方面， 几乎所有人都不断坚持“逻辑”、“逻辑推理”和“合理推理”；另 一方面，他们却不能表现出这种能力，当别人表现出来时也不 愿接受之。\n我们大多数所谓的推理在于为继续相信我们已经相信的东 西找到理由。\n清晰的思考是非常罕见的事，但甚至简单清楚的思考也几 乎是罕见的。我们许多人在大多数时间里根本就不思考。我们 信奉并且感觉着，但并不思考。\n思想懒惰是人最常见的特质之一。\n 心智和大脑 大脑是思考的必要条件，但没有表明大 脑是思考的充分条件。","title":"《超越感觉》"},{"content":"《骡子》 ","permalink":"https://note.yxzi.xyz/note/afterthought/movie/film/%E9%AA%A1%E5%AD%90/","summary":"《骡子》 ","title":"《骡子》"},{"content":"不可论断他人 不可论断人是非常重要的原则。\n但是与此同时，人却又没有办法不去论断人。\n比如，你要聘用员工，你就需要在几个人中间挑一个；\n比如，你要谈恋爱，你也经常需要在几个人中间挑一个；比如，你要选择供应商，你总是要在几个里面选一个。\n你终究是要进行选择，终究是要进行判断，不选择、不判断，你的人生将无以继续。\n而选择和判断的对象，又常常是人，这是没有办法避免的。\n那么要怎么实践“不论断人”的教训？\n看权柄，也就是判断权 判断之前，考虑一下此人此事你是否有判断权。\n法官，对接受法律管辖的人在刑罚上有判断权；\n教师，对来求学的学生在学业上有判断权；\n雇主，对雇员的受雇事务有判断权……\n所有的人都对所被征询之事有判断权。\n你需要意识到，人有免于判断的自由，这种自由是不应侵犯的。\n只有被请求判断，得到了授权，你的判断才不会被视作一种对他人自由的侵害。\n你一定要在你看到某种许可证后，才开始你的判断。\n这些“判断许可”，有时是通过隐式的邀约获取的，比如你是一个医生，对方来挂了号，这就是允许了你的判断。\n又比如你是在知乎回答他人的一个问题，他既然问了求答，也就自然等于做了授权。\n但在这其中，你要注意避免受甲的邀约去判断并未授权给他的乙。\n甲邀请你去判断乙，你必须要先检查甲是否有权判断乙。\n比如甲是不是乙的监护人？如果是，那是可以的。\n甲是不是乙的医生？如果是，那么你是可以受邀参与关于乙的疾病会诊的。\n同时，你还要检查乙给予的授权范围，考虑乙所授予甲的判断权，是否包含可以被转授的许可。\n比如，在没有被授权的情况下，独立执业的心理医生是无权邀请其他人来会诊的。\n但如果一名病人是去一家诊所求治，合同关系是与诊所之间签署，那么这可能包含了该诊所所有的受雇医生。\n你如果也是这位医生的同事，如果你受到邀请，你也就有了判断权，\n是的，关于判断权的问题就是这么微妙、复杂而又严肃。\n所以出于严谨、保守起见，你最好把授权问题弄得显式和明确一些，\n比如你拿不准的话就直接问一下对方是否是在求取你的关于某一方面的判断，\n得不到肯定答复就干脆不继续。或者你一定要有明确预示的权柄在先，\n以至于只要在这个场合下与你接触的人就等于自动声明并给予你判断权。\n举个比较经典而应景的例子，你在知乎自己的回答的讨论区里，有自由删除、折叠一切回复的编辑权，\n那么这就意味着在你讨论区里发表言论的人，等于自动的声明了愿意接受你的删除、折叠的判断。\n在这前提下，你就可以自由行使被授予的权柄，而不必纠结对方的“抗议”\n因为那本质上是对方出尔反尔，不讲信用，或者缺少对待社会契约的正确意识罢了。\n那不是你的问题，你无论如何自由心证，也没有“侵犯他人自由”的问题。\n在讨论区里抗议答主删除或者折叠自己的回复是一种对自己的社会责任不明了，对契约关系不敏感、对伦理认识不成熟的表现。\n基于同一种规则，你去别人的答案下写长篇回复——或者哪怕一个字也罢，\n你都必须做好可能被删除或者折叠的心理准备，因为对方有这完全的自由，而且你一但落笔就等于签了弃权协议。\n所以明智一点说，你如果是打算去做任何可能被对方看作不礼貌的判断，\n你最好是自己写一个答案，而不是去对方的答案下“要求尊重言论自由”。\n解决争议的最好方式，不是去“寻求共识”，而是在各自有权柄的区域各自独裁专断，然后各安天命。\n你进入我的领域，就接受我的判断，我进入你的领域，就老老实实接受你的判断。\n有效的避免判断人的一个诀窍，是人要努力提高自己的判断的价值。 提高到什么程度？\n提高到其他人会花钱来购买你的判断、会竞争得到你判断的机会的程度。\n当你的判断对他人贵重到这个地步，你就知道珍惜自己的判断了。\n你的判断是有市场价值的，你还会到处乱扔吗？对方真的配得到你的判断吗？\n到了这个程度，你自然而然的不会轻易去犯判断人的错误。\n何止不会犯这个错，就是对方请你开口对某个事物进行判断，\n你也会苛刻的考量对方的邀请是否真的有质量——礼仪是否全备、态度是否周正、诚意是否真实——是否真的配得到。\n不是三顾茅庐者，何德何能堪得三分天下之计？\n而要培养出这个等级的判断力，殊非易事。你自己的学识、阅历、修养乃至信仰态度，都与你的“邀约价值”息息相关。\n而这一切之中，影响最大的，是他人对你的爱和信任。\n如果不是爱你或信任你，你的知识再怎么高超，又如何让人相信你的判断是有信服力的呢？\n其实人为何总是要去擅夺判断的权柄？其实是出于对拥有判断权的人的艳羡。\n他们太羡慕那些“一言即出，闻者服膺”的人的权柄。\n却一直没明白这权柄的根源何在——并非出于你的知识与能力，而是出对判断者的爱和信任。\n 让你的判断拥有动人心魄的价值的，\n不是你的地位、你的文凭、你的能力、你的资格证书，\n而是这背后直指人心的爱。\n  我们要回到自身。\n每个人都有免于人的判断的自由。\n人们可以抓你、审你、判你、关你、乃至于杀你。\n但只要你的内心不接受对方的审判权，那么这一切都仅仅只是暴力的不同形式，并不构成真正意义上的审判。\n难不成路上出现一群强盗把你绑了去，装模作样宣判你犯有“不肯被抢劫之罪”，然后判你一个“死刑”，你就真的“有罪”吗？\n只有你接受了对方的审判权，对方才拥有了审判你的审判权。\n对方的审判结果，对你才不仅仅只是一种暴力优势的结果，而同时是你对自己的自由的尊重。\n “我认可这个判断者关于我的特定范围行为的正义性的判断高于我自己的判断，我接受 ta 来替代我自己执行这一判断权，直到我自己取消这一授权。”——这就是伦理关系的本质。\n 我们不是在谈“关联”，不是在谈“交互影响”，而是在谈真正的“关系”，那种可以被识别为敌我、亲疏、向背的伦理关系。\n任何两个人，只要建立了这样的自觉的、清醒的“交出/代理判断权”的关联，\n他们就不再是任何意义上的无关的陌生人了，他们之间就有了无可否认的紧密关系。\n这句话，只要你看得明白，你就能看见一切孤独的根源。\n你缺少足够的勇气，不敢将这判断权真正的交给任何人，于是你与人无法建立真实的关系。\n你也缺少足够的爱，使得没有人胆敢将这判断权交给你，于是你从另一面无法与人建立真实的关系。\n这就是孤独的根源，这就是深渊般的人生黑暗的来源。\n","permalink":"https://note.yxzi.xyz/note/view/gam/%E4%B8%8D%E5%8F%AF%E8%AE%BA%E6%96%AD%E4%BB%96%E4%BA%BA/","summary":"不可论断他人 不可论断人是非常重要的原则。\n但是与此同时，人却又没有办法不去论断人。\n比如，你要聘用员工，你就需要在几个人中间挑一个；\n比如，你要谈恋爱，你也经常需要在几个人中间挑一个；比如，你要选择供应商，你总是要在几个里面选一个。\n你终究是要进行选择，终究是要进行判断，不选择、不判断，你的人生将无以继续。\n而选择和判断的对象，又常常是人，这是没有办法避免的。\n那么要怎么实践“不论断人”的教训？\n看权柄，也就是判断权 判断之前，考虑一下此人此事你是否有判断权。\n法官，对接受法律管辖的人在刑罚上有判断权；\n教师，对来求学的学生在学业上有判断权；\n雇主，对雇员的受雇事务有判断权……\n所有的人都对所被征询之事有判断权。\n你需要意识到，人有免于判断的自由，这种自由是不应侵犯的。\n只有被请求判断，得到了授权，你的判断才不会被视作一种对他人自由的侵害。\n你一定要在你看到某种许可证后，才开始你的判断。\n这些“判断许可”，有时是通过隐式的邀约获取的，比如你是一个医生，对方来挂了号，这就是允许了你的判断。\n又比如你是在知乎回答他人的一个问题，他既然问了求答，也就自然等于做了授权。\n但在这其中，你要注意避免受甲的邀约去判断并未授权给他的乙。\n甲邀请你去判断乙，你必须要先检查甲是否有权判断乙。\n比如甲是不是乙的监护人？如果是，那是可以的。\n甲是不是乙的医生？如果是，那么你是可以受邀参与关于乙的疾病会诊的。\n同时，你还要检查乙给予的授权范围，考虑乙所授予甲的判断权，是否包含可以被转授的许可。\n比如，在没有被授权的情况下，独立执业的心理医生是无权邀请其他人来会诊的。\n但如果一名病人是去一家诊所求治，合同关系是与诊所之间签署，那么这可能包含了该诊所所有的受雇医生。\n你如果也是这位医生的同事，如果你受到邀请，你也就有了判断权，\n是的，关于判断权的问题就是这么微妙、复杂而又严肃。\n所以出于严谨、保守起见，你最好把授权问题弄得显式和明确一些，\n比如你拿不准的话就直接问一下对方是否是在求取你的关于某一方面的判断，\n得不到肯定答复就干脆不继续。或者你一定要有明确预示的权柄在先，\n以至于只要在这个场合下与你接触的人就等于自动声明并给予你判断权。\n举个比较经典而应景的例子，你在知乎自己的回答的讨论区里，有自由删除、折叠一切回复的编辑权，\n那么这就意味着在你讨论区里发表言论的人，等于自动的声明了愿意接受你的删除、折叠的判断。\n在这前提下，你就可以自由行使被授予的权柄，而不必纠结对方的“抗议”\n因为那本质上是对方出尔反尔，不讲信用，或者缺少对待社会契约的正确意识罢了。\n那不是你的问题，你无论如何自由心证，也没有“侵犯他人自由”的问题。\n在讨论区里抗议答主删除或者折叠自己的回复是一种对自己的社会责任不明了，对契约关系不敏感、对伦理认识不成熟的表现。\n基于同一种规则，你去别人的答案下写长篇回复——或者哪怕一个字也罢，\n你都必须做好可能被删除或者折叠的心理准备，因为对方有这完全的自由，而且你一但落笔就等于签了弃权协议。\n所以明智一点说，你如果是打算去做任何可能被对方看作不礼貌的判断，\n你最好是自己写一个答案，而不是去对方的答案下“要求尊重言论自由”。\n解决争议的最好方式，不是去“寻求共识”，而是在各自有权柄的区域各自独裁专断，然后各安天命。\n你进入我的领域，就接受我的判断，我进入你的领域，就老老实实接受你的判断。\n有效的避免判断人的一个诀窍，是人要努力提高自己的判断的价值。 提高到什么程度？\n提高到其他人会花钱来购买你的判断、会竞争得到你判断的机会的程度。\n当你的判断对他人贵重到这个地步，你就知道珍惜自己的判断了。\n你的判断是有市场价值的，你还会到处乱扔吗？对方真的配得到你的判断吗？\n到了这个程度，你自然而然的不会轻易去犯判断人的错误。\n何止不会犯这个错，就是对方请你开口对某个事物进行判断，\n你也会苛刻的考量对方的邀请是否真的有质量——礼仪是否全备、态度是否周正、诚意是否真实——是否真的配得到。\n不是三顾茅庐者，何德何能堪得三分天下之计？\n而要培养出这个等级的判断力，殊非易事。你自己的学识、阅历、修养乃至信仰态度，都与你的“邀约价值”息息相关。\n而这一切之中，影响最大的，是他人对你的爱和信任。\n如果不是爱你或信任你，你的知识再怎么高超，又如何让人相信你的判断是有信服力的呢？\n其实人为何总是要去擅夺判断的权柄？其实是出于对拥有判断权的人的艳羡。\n他们太羡慕那些“一言即出，闻者服膺”的人的权柄。\n却一直没明白这权柄的根源何在——并非出于你的知识与能力，而是出对判断者的爱和信任。\n 让你的判断拥有动人心魄的价值的，\n不是你的地位、你的文凭、你的能力、你的资格证书，\n而是这背后直指人心的爱。\n  我们要回到自身。\n每个人都有免于人的判断的自由。\n人们可以抓你、审你、判你、关你、乃至于杀你。\n但只要你的内心不接受对方的审判权，那么这一切都仅仅只是暴力的不同形式，并不构成真正意义上的审判。\n难不成路上出现一群强盗把你绑了去，装模作样宣判你犯有“不肯被抢劫之罪”，然后判你一个“死刑”，你就真的“有罪”吗？","title":"不可论断他人"},{"content":"不要让别人知道你过得好 一个残酷的真相是：\n除了父母至亲，只有极少数的人，会无保留的为你的成就而快乐。\n你跑步，瘦的是你，快乐的也是你；\n你赚的钱多，钱是你的，快乐的也是你；\n这样的快乐别人感受不到，也无从分享，对别人来说，你只是在展示自己的快乐而已。\n你的快乐，会映射出别人的不快乐；\n你的勤奋，会映射出别人的懒惰。\n所以他们心里不舒服。\n情商低一些的，还会说些丧气的话。\n进步是你自己的事情，默默的一直进步下去吧，总有一天你会发现自己已经和他们不是一个层次的人了。\n","permalink":"https://note.yxzi.xyz/note/view/gam/%E4%B8%8D%E8%A6%81%E8%AE%A9%E5%88%AB%E4%BA%BA%E7%9F%A5%E9%81%93%E4%BD%A0%E8%BF%87%E5%BE%97%E5%A5%BD/","summary":"不要让别人知道你过得好 一个残酷的真相是：\n除了父母至亲，只有极少数的人，会无保留的为你的成就而快乐。\n你跑步，瘦的是你，快乐的也是你；\n你赚的钱多，钱是你的，快乐的也是你；\n这样的快乐别人感受不到，也无从分享，对别人来说，你只是在展示自己的快乐而已。\n你的快乐，会映射出别人的不快乐；\n你的勤奋，会映射出别人的懒惰。\n所以他们心里不舒服。\n情商低一些的，还会说些丧气的话。\n进步是你自己的事情，默默的一直进步下去吧，总有一天你会发现自己已经和他们不是一个层次的人了。","title":"不要让别人知道你过得好"},{"content":"为什么大学不谈恋爱 我就搞不明白了，为什么上大学就非得谈恋爱不可呢？\n是游戏不好玩还是手机不好玩？非要找小哥哥小姐姐安慰你那寂寞空虚的心？\n你要是觉得大学就必须谈一次恋爱的话，那我问你：\n大学还要好好学习呢，学习了吗？\n大学还要努力实习呢，实习了吗？\n大学还要加油考研究生呢，考研了吗？\n大学还要四六级雅思托福出国交换呢，交换了吗？\n大学可干的事情太多太多了，我就不懂了，怎么这么多人就揪住一个谈恋爱就不放了呢？\n是因为大学里面的恋爱单纯不看房车？你放心，你对象不看，对象的父母也会看的。\n是因为大学里面开销少，不花钱？你放心，一周开一次房的频率，你半个月生活费没了。\n是因为大学里面的时间多，能多相处？你放心，时间多屁事也多，有点时间都给了吵架闹分手了。\n现在谁再说大学无忧无虑的，我上去就是给你一平底锅：\n这段时间，正是人生最迷茫的时刻。父母鞭长莫及管不到你。\n老师，只要你来上课，其他的也都不会干涉你。没人管没人问，你能感觉到周围人都在努力，\n都在给未来做打算，但是一看你，啥啥不知道，啥啥没规划。\n你连自己都还没有活明白，怎么能去帮助另一个人？两个迷茫焦虑的人，又怎么能够互相拯救呢？\n就像经常有大学的小学弟问我如何安慰女朋友，为什么他安慰不了？\n因为他自己也不知道自己何去何从，自己也没经历过外边的磨炼，对于未来毫无概念，\n他只能看着自己的另一半手足无措，不知道在她陷入情绪沼泽的时候应该做些什么。\n甚至都不需要他做些什么，让他把自己照顾好都有点难——生活费晚打个两天就活不下去了，\n寝室里闹点矛盾就人间不值得了，女朋友生个病意外怀个孕就吓得跟孙子一样了……\n还说对那个人负责，你自己出点儿事你自己都扛不住，你还照顾另一个人？\n我知道有不少的人，当初因为来到大学空虚寂寞冷，所以一时冲动谈起了恋爱，\n结果在相处的时候手足无措，最后闹出了一堆矛盾，还落下了情感上面的心理阴影。\n所以我和其他人说，如果大学你是要正儿八经的谈恋爱，你别着急，有就有，没有就算了呗。\n因为对于不少人来说，大学是一段初恋的开始，而初恋往往意味着可能会影响你后面很多段恋情的相处方式，\n对待感情的看法，甚至你以后很多择偶都会像初恋的那个模式。\n因此，这是一件大事，不要跟着别人的节奏走。\n没有情人，就过不了情人节了，过不了就不过呗。\n难不成过清明节没死人你还得抄刀子怼死几个，就为了过节？\n一个人吃饭怎么了？是拿不起来筷子了，还是端不起来饭碗了？这么期待有个人喂你，你不怕噎着？\n就这么需要找个人和你一起奋斗吗？\n小傻瓜，没有人有义务在你还是个生瓜蛋子的时候赌上自己的命运和前程，当你做出成绩来的时候，自然会有人来找你。\n你现在迷茫，焦虑，孤单，想要找一个人的陪伴，来让她证明你存在的价值，但是你的价值根本不需要一个人来告诉你。\n大学时有一位室友，四年都没有谈过恋爱，难道他就没价值了么？\n相反，他相当优秀，颜值才华和人品都拥有，毕业一年在职场也是混得风生水起。\n后来我们问他大学没有谈过恋爱有没有后悔，他说并不后悔，只是有些遗憾。\n如果能拥有一份完美的爱情，那自然是好的，但不至于后悔，因为真的不是必须要拥有的。\n如果你能遇到那个对的人，那最好，谈一场不分手的恋爱，能在大学这个象牙塔一直到结婚，是一件很美好的事情。\n但是如果你没遇到那个人，那就好好努力，当你将来碰到时，你也会感激在这个时间段努力向上的自己，\n正是因为你挺过了这段时间，才让你变成了更好的人，有了出现在那个人眼前的缘分。\n也许，你可能还是看着校园里的情侣偷偷羡慕嫉妒，可能在心中想着要不随便先谈个恋爱吧，不然好像真的会有遗憾。\n真的没有这个必要，谈恋爱这种事情，真的是将就缘分的，不要刻意去追求，不要违背自己的内心。\n后来当你回过头看的时候，你会发现，其实很多事情比起恋爱，有意思多了。\n所以，先做好自己，等那个人来。\n你若盛开，蝴蝶自来。\n你问我，万一那个人这辈子都不会出现怎么办？\n傻孩子，不怕，咱到时候，有钱。\n","permalink":"https://note.yxzi.xyz/note/view/bisexual/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%AD%A6%E4%B8%8D%E8%B0%88%E6%81%8B%E7%88%B1/","summary":"为什么大学不谈恋爱 我就搞不明白了，为什么上大学就非得谈恋爱不可呢？\n是游戏不好玩还是手机不好玩？非要找小哥哥小姐姐安慰你那寂寞空虚的心？\n你要是觉得大学就必须谈一次恋爱的话，那我问你：\n大学还要好好学习呢，学习了吗？\n大学还要努力实习呢，实习了吗？\n大学还要加油考研究生呢，考研了吗？\n大学还要四六级雅思托福出国交换呢，交换了吗？\n大学可干的事情太多太多了，我就不懂了，怎么这么多人就揪住一个谈恋爱就不放了呢？\n是因为大学里面的恋爱单纯不看房车？你放心，你对象不看，对象的父母也会看的。\n是因为大学里面开销少，不花钱？你放心，一周开一次房的频率，你半个月生活费没了。\n是因为大学里面的时间多，能多相处？你放心，时间多屁事也多，有点时间都给了吵架闹分手了。\n现在谁再说大学无忧无虑的，我上去就是给你一平底锅：\n这段时间，正是人生最迷茫的时刻。父母鞭长莫及管不到你。\n老师，只要你来上课，其他的也都不会干涉你。没人管没人问，你能感觉到周围人都在努力，\n都在给未来做打算，但是一看你，啥啥不知道，啥啥没规划。\n你连自己都还没有活明白，怎么能去帮助另一个人？两个迷茫焦虑的人，又怎么能够互相拯救呢？\n就像经常有大学的小学弟问我如何安慰女朋友，为什么他安慰不了？\n因为他自己也不知道自己何去何从，自己也没经历过外边的磨炼，对于未来毫无概念，\n他只能看着自己的另一半手足无措，不知道在她陷入情绪沼泽的时候应该做些什么。\n甚至都不需要他做些什么，让他把自己照顾好都有点难——生活费晚打个两天就活不下去了，\n寝室里闹点矛盾就人间不值得了，女朋友生个病意外怀个孕就吓得跟孙子一样了……\n还说对那个人负责，你自己出点儿事你自己都扛不住，你还照顾另一个人？\n我知道有不少的人，当初因为来到大学空虚寂寞冷，所以一时冲动谈起了恋爱，\n结果在相处的时候手足无措，最后闹出了一堆矛盾，还落下了情感上面的心理阴影。\n所以我和其他人说，如果大学你是要正儿八经的谈恋爱，你别着急，有就有，没有就算了呗。\n因为对于不少人来说，大学是一段初恋的开始，而初恋往往意味着可能会影响你后面很多段恋情的相处方式，\n对待感情的看法，甚至你以后很多择偶都会像初恋的那个模式。\n因此，这是一件大事，不要跟着别人的节奏走。\n没有情人，就过不了情人节了，过不了就不过呗。\n难不成过清明节没死人你还得抄刀子怼死几个，就为了过节？\n一个人吃饭怎么了？是拿不起来筷子了，还是端不起来饭碗了？这么期待有个人喂你，你不怕噎着？\n就这么需要找个人和你一起奋斗吗？\n小傻瓜，没有人有义务在你还是个生瓜蛋子的时候赌上自己的命运和前程，当你做出成绩来的时候，自然会有人来找你。\n你现在迷茫，焦虑，孤单，想要找一个人的陪伴，来让她证明你存在的价值，但是你的价值根本不需要一个人来告诉你。\n大学时有一位室友，四年都没有谈过恋爱，难道他就没价值了么？\n相反，他相当优秀，颜值才华和人品都拥有，毕业一年在职场也是混得风生水起。\n后来我们问他大学没有谈过恋爱有没有后悔，他说并不后悔，只是有些遗憾。\n如果能拥有一份完美的爱情，那自然是好的，但不至于后悔，因为真的不是必须要拥有的。\n如果你能遇到那个对的人，那最好，谈一场不分手的恋爱，能在大学这个象牙塔一直到结婚，是一件很美好的事情。\n但是如果你没遇到那个人，那就好好努力，当你将来碰到时，你也会感激在这个时间段努力向上的自己，\n正是因为你挺过了这段时间，才让你变成了更好的人，有了出现在那个人眼前的缘分。\n也许，你可能还是看着校园里的情侣偷偷羡慕嫉妒，可能在心中想着要不随便先谈个恋爱吧，不然好像真的会有遗憾。\n真的没有这个必要，谈恋爱这种事情，真的是将就缘分的，不要刻意去追求，不要违背自己的内心。\n后来当你回过头看的时候，你会发现，其实很多事情比起恋爱，有意思多了。\n所以，先做好自己，等那个人来。\n你若盛开，蝴蝶自来。\n你问我，万一那个人这辈子都不会出现怎么办？\n傻孩子，不怕，咱到时候，有钱。","title":"为什么大学不谈恋爱"},{"content":"大学教材为什么看不懂 IT 界有个万人皆知的行业准则：不要重复造轮子。\n它的意思是，你可以自己造的玩，但是如果人家已经有足够好的轮子，\n你就不要试图，甚至是通过各种手段，试图去取代这个轮子的地位。\n同理，如果某个学科已经有足够好的教材，您没那水平编出更好的教材，\n就乖乖地用人家的教材就好了，这样既节省资源，同时也能保证中国学生看到的教材内的思想和国外学生是同步的。\n中国的大学有个毛病，就是什么东西也想搞个自己的出来。\n就比如线性代数教材，如此重要的学科，用脚趾头想也能知道，优秀的国外教材已经遍地走了，\n但是各个大学仍然要请自己学校的某几个水平堪忧，语言表达能力菜得扣脚的老师来编写一个教材，\n最后命其名曰——精品教材，而这些垃圾教材坑害的是一批一批的优秀学生，\n当然如果这些学生能被一直坑下去的，自主学习能力也是多少有点问题\u0026hellip;\n可是世界上大多数学生就是这样，他们会乖乖地去上课，听老师念 PPT，\n然后认真看学校推荐用的课本，然后当这些垃圾教材搞得他们一头雾水的时候，\n他们会用这门课难来安慰自己，最后学的不明不白，草草了事。\n我刚来中国科学技术大学的时候，上学期的线性代数，学校用的教材就是所谓学校老师自己编的“精品教材”，\n这个教材是面向非数学专业学生的，我就看了三页就已经搞不明白它在说什么了，\n可以想象，这样的教材迫害了多少学生，耗费了多少学生的时间。\n而且可以想象，编这本教材的老师们从中肯定可以得到补贴，能不能得到版税不清楚，\n但是补贴是肯定有的，而且同时这本教材的编写也能成为所谓的资金申请的理由，\n“为中国科学技术大学量身定制的教材”这句话多么好听啊，可事实上呢？\n由于答主英文水平过关，当时直接去图书馆借了一本英文的线性代数教材，面向数学专业的，\n从第一页开始看下去，便已停不下来，连住一看就是二三十页，看完感觉畅酣淋漓，\n舒畅至极，从那以后，线性代数课我再也没去过，除了最后的考试我出席了。那次期末题不简单，我考了 95 分。\n我自己知道，我并不聪明，若是我不看那本英文教材，我恐怕能考 70 分不错了。\n这就是事实，还有很多例子，比如贵校叶邦角编的的《电磁学》和格利菲斯的《电动力学》在易懂性和深刻性上的巨大差异，\n前者啥也看不懂，后者看的畅酣淋漓。\n《大学物理》与《费恩曼物理学讲义》的惊人对比，前者看的想要睡觉，\n后者看的我想要拍桌，甚至感动地流泪，甚至看完兴奋地睡不着觉。\n 纸质教材？？买教材？？学校让你买教材？？没有学生买教材，那这些教材不就无法带来收入了？\n教材是用来教育的？No No No, 教材是用来挣钱的，相信我。\n马克思主义原理你们都上过吧？这个教材是不是必须买？它为什么不做成 PDF 版，在网上开源呢？\n每年这本教材能卖一千万册吧？没这些钱谁来养那些教材编写委员会呢？\n李重光的乐理书，可能在你们眼里还算不错，但是我看完之后还是搞不明白它说的这一切是怎么运用在作曲中的，\n后来我有了 VPN，在油管上打开了新世界，在众多即兴，乐理的视频教程中，\n我现在可以在任何一首歌里面即兴演奏，写歌也是手到擒来。\n音乐学习的最好方法不是看书，而是看视频，因为视频是声音和图像的结合体，\n比如我现在讲 Lydian 音阶，它的音阶结构是 1 2 3 #4 5 6 7，只讲这个其实你并没有真正懂它的音响效果，\n这个 youtube 频道从图像，PPT，演奏示例，记忆法等如手，教你如何记忆指板位置，如何进行特定和声进行下的 solo 即兴和创作。\n这个世界上不存在真正无法理解的知识，只存在不会表达的糟糕教学者，\n大家都是人，为什么你能懂的东西我就懂不了呢？\n就算我笨一些，能在你脑子里运行的东西也能在我的脑子里运行，只不过可能速度慢一些。\n教材的目的是什么？教材的目的是让学生尽可能地不依靠任何外界帮助，仅仅依靠你的教材就能学会你想表达的知识。\n可以说，我国在此方面做的奇差无比。\n国内这些教材其实牵动了很多人的利益，比如学校的利益，编写者的利益等等，\n中国的大学可能觉得教材都用西方的，是文化不强盛的表现，总想自己搞一个，这正是不自信的表现。\n你要是能编出比国外优秀教材更优秀的，那完全可以啊！\n问题是你能吗？\n 当然还有一点就是，国内的教材更新速度捉急，很多新东西早就出来了，教材上还写着那些旧东西，考试还是按照旧教材考\u0026hellip;\n我一直觉得中国学生整体上是比较聪明的，如果我们能像美国学生那样直接接触到整个世界的优质教学信息，那我们的未来不敢想象。\n不过一个学生如果自己不会去寻求改变，看的破教材还不知道换更好的，\n上不了 Google 还不舍得花钱买 V*N，那这样的学生可能也干不成什么\u0026hellip;\n国外的大部分经典教材，我是说经典教材哦，不是所有！\n经典教材是国外教材的一个很小的子集！ 差不多都有免费的 PDF 版本，直接下载就好，\n这对于那些没有机会接受高等教育，又买不起好教材的人是很友好的，\n而且不仅如此，教材配套的习题集，答案等往往也可以直接下载，\n反观国内的教材，一方面习题没答案，然后老师告诉你们习题最怕有答案，\n但与此同时老师也没有能力建立起一个足够高效的机制能马上让学生知道他们的结果是否正确，\n就相当于，不能给你肉吃，还要叫你多吃素，吃肉会长胖。\n普林斯顿的《Algorithms 4》是业内广受好评的教材，虽然叫算法，事实上数据结构和算法的内容都有。\n我试问国内的哪个计算机教材这样做了？你恐怕是下载个 pdf 版都得在什么微盘，百度云，或是百度文库里面下载吧？\n来，你告诉我，谭浩强的《C 语言程序设计》的开源网站在哪？让我瞻仰一下？没有？\n 我觉得国内教材编写者最大的问题就是：动机不纯。\n对于音乐行业来讲，如果教材编的太好，学生就不想找老师了\u0026hellip;那这些音乐水平高不成低不就的人，饭碗谁给保证呢？\n这个逻辑其实挺简单：你说想要看懂这个教材必须找个好老师给你讲，\n那你这个所谓的好老师为啥不把他讲的写成教材呢？这样大家不是就都看懂了？哪来那么多麻烦事？\n事实上一个人编写的教材应该是比这个讲课要更好懂的，\n因为一个人写出来的东西往往是经过了细致思考的结果，而凭空就说的东西往往会出问题，\n那如果一个人教材写的奇烂无比，他的课我也建议你别去了，误人子弟。\n所以啊，现在掌握大学权力的人，都是高考刚恢复不就参加高考的那批人，\n他们眼中的世界和我们年轻人眼中的不太一样，再过二十年，等我们成为了掌权者，也许这一切会变好。\n学校怎么做是学校的事，你怎么做，还是看你自己。\n有人说英语差看不了英文教材的，我想说，英语的学习其实是自然而然地事情，\n不要在学中做，而要在用中学，忘掉中文，去完全投入英文的环境中，很快你就会适应这一切。\n事实上，如果你说你英文教材有些单词不认识，那我想反问你，难道这个东西翻译成中文你就一定认识了？\n比如线性代数的秩（Rank），你不知道秩是什么意思对吧？但你反而大概知道 Rank 的意思。\n还有人说，我们不能这样直接用别人的，要做出自己的，这个想法其实要真往大了说，\n我觉得挺肤浅的，别人造个加速器，我们要造个更大的，别人造个桥，我们也要造个更长的，\n快歇歇吧，干好自己的本职工作就很好了。\n世界上只有两种东西有真正的价值，一种是创世人所未见，一种是对已见之事的推进与优化，\n做一个比现有的还烂的东西，本身是没价值的，只能当作练习使用，这句话的逻辑已经很明晰了，再反驳我是不会回复的。\n不要过分相信教材的权威性，也不要把老师和教授当神看，大家都是普通人，老师让你做的，也许并不是你想要的，\n我们生在互联网时代，已经给了我们擦亮眼睛，检验真理的能力了，我们也没必要迷信任何权威。\n这世界上谎言很多，要把眼睛擦亮，做个明白人。\n","permalink":"https://note.yxzi.xyz/note/view/society/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9C%8B%E4%B8%8D%E6%87%82%E5%A4%A7%E5%AD%A6%E6%95%99%E6%9D%90/","summary":"大学教材为什么看不懂 IT 界有个万人皆知的行业准则：不要重复造轮子。\n它的意思是，你可以自己造的玩，但是如果人家已经有足够好的轮子，\n你就不要试图，甚至是通过各种手段，试图去取代这个轮子的地位。\n同理，如果某个学科已经有足够好的教材，您没那水平编出更好的教材，\n就乖乖地用人家的教材就好了，这样既节省资源，同时也能保证中国学生看到的教材内的思想和国外学生是同步的。\n中国的大学有个毛病，就是什么东西也想搞个自己的出来。\n就比如线性代数教材，如此重要的学科，用脚趾头想也能知道，优秀的国外教材已经遍地走了，\n但是各个大学仍然要请自己学校的某几个水平堪忧，语言表达能力菜得扣脚的老师来编写一个教材，\n最后命其名曰——精品教材，而这些垃圾教材坑害的是一批一批的优秀学生，\n当然如果这些学生能被一直坑下去的，自主学习能力也是多少有点问题\u0026hellip;\n可是世界上大多数学生就是这样，他们会乖乖地去上课，听老师念 PPT，\n然后认真看学校推荐用的课本，然后当这些垃圾教材搞得他们一头雾水的时候，\n他们会用这门课难来安慰自己，最后学的不明不白，草草了事。\n我刚来中国科学技术大学的时候，上学期的线性代数，学校用的教材就是所谓学校老师自己编的“精品教材”，\n这个教材是面向非数学专业学生的，我就看了三页就已经搞不明白它在说什么了，\n可以想象，这样的教材迫害了多少学生，耗费了多少学生的时间。\n而且可以想象，编这本教材的老师们从中肯定可以得到补贴，能不能得到版税不清楚，\n但是补贴是肯定有的，而且同时这本教材的编写也能成为所谓的资金申请的理由，\n“为中国科学技术大学量身定制的教材”这句话多么好听啊，可事实上呢？\n由于答主英文水平过关，当时直接去图书馆借了一本英文的线性代数教材，面向数学专业的，\n从第一页开始看下去，便已停不下来，连住一看就是二三十页，看完感觉畅酣淋漓，\n舒畅至极，从那以后，线性代数课我再也没去过，除了最后的考试我出席了。那次期末题不简单，我考了 95 分。\n我自己知道，我并不聪明，若是我不看那本英文教材，我恐怕能考 70 分不错了。\n这就是事实，还有很多例子，比如贵校叶邦角编的的《电磁学》和格利菲斯的《电动力学》在易懂性和深刻性上的巨大差异，\n前者啥也看不懂，后者看的畅酣淋漓。\n《大学物理》与《费恩曼物理学讲义》的惊人对比，前者看的想要睡觉，\n后者看的我想要拍桌，甚至感动地流泪，甚至看完兴奋地睡不着觉。\n 纸质教材？？买教材？？学校让你买教材？？没有学生买教材，那这些教材不就无法带来收入了？\n教材是用来教育的？No No No, 教材是用来挣钱的，相信我。\n马克思主义原理你们都上过吧？这个教材是不是必须买？它为什么不做成 PDF 版，在网上开源呢？\n每年这本教材能卖一千万册吧？没这些钱谁来养那些教材编写委员会呢？\n李重光的乐理书，可能在你们眼里还算不错，但是我看完之后还是搞不明白它说的这一切是怎么运用在作曲中的，\n后来我有了 VPN，在油管上打开了新世界，在众多即兴，乐理的视频教程中，\n我现在可以在任何一首歌里面即兴演奏，写歌也是手到擒来。\n音乐学习的最好方法不是看书，而是看视频，因为视频是声音和图像的结合体，\n比如我现在讲 Lydian 音阶，它的音阶结构是 1 2 3 #4 5 6 7，只讲这个其实你并没有真正懂它的音响效果，\n这个 youtube 频道从图像，PPT，演奏示例，记忆法等如手，教你如何记忆指板位置，如何进行特定和声进行下的 solo 即兴和创作。\n这个世界上不存在真正无法理解的知识，只存在不会表达的糟糕教学者，\n大家都是人，为什么你能懂的东西我就懂不了呢？\n就算我笨一些，能在你脑子里运行的东西也能在我的脑子里运行，只不过可能速度慢一些。\n教材的目的是什么？教材的目的是让学生尽可能地不依靠任何外界帮助，仅仅依靠你的教材就能学会你想表达的知识。\n可以说，我国在此方面做的奇差无比。\n国内这些教材其实牵动了很多人的利益，比如学校的利益，编写者的利益等等，","title":"为什么看不懂大学教材"},{"content":"亚里士多德 没有天生的概念 柏拉图认为大自然中是先有 “马的理型”，再有我们感官世界中所看到的马匹，因此他认为 “鸡的观念先于鸡”。\n而他却认为“马的理型”，是我们人类看到若干匹马后，所形成的概念；因此马的 “理型” “形式” 是不存在的；它认为马的 “理型” 或 “形式” 就是马的特征。\n某个事物的 “理型” 或 “形式” 存在于这个事物之中，因为所谓的 “理型” 或“ 形式” 就是这个事物所有的特征。\n如果世间存在 ”马的理型”，那这个“马的理型”又从何而来？这个 ”马的理型” 是否会模仿另外一匹马?\n我们所拥有的任何想法和意念都是透过我们过去所看到、听到的事物，从而进入我们的意识。\n一件事物的形式乃是它的特征 自然界的每一种变化，都是物质将自身的 “潜能” 转变为“实现”的结果。\n自然界的每一个事物都可能实现或达成某一种特定的 “形式”。\n一个事物的 “形式” 或 “特征” ，不但说明了这个事物的潜能，也说明了它的极限。举个例子，一个鸡蛋可以变成一只鸡（鸡蛋的潜能）；但并不一定会顺利的变成一只鸡，因为它有可能变成人类餐桌上的佳肴（未实现鸡蛋的潜能）；同理，鸡蛋显然不能变成一只鹅（鸡蛋并不具有变成鹅的潜能）。\n事物都有“质料”和“形式”。\n目的因 他认为自然界的每一件事物都有其存在的“目的”或“任务”。举个例子，天空之所以会下雨，其目的因就是植物和动物需要雨水才能生长。\n他将世间的事物彻底分门别类，同时还创立了《逻辑学》这门学科。\n自然的层级 无生物，比如石头、水滴、树木只能通过外力改变，而生物则有潜能自行改变。\n宇宙中必然有一位“上帝”（最初推动者）推动世间中所有的运作，即上帝位于大自然的最顶端；并且他认为这位“上帝”是宇宙万物各种活动的“目的因”。\n对女人的看法 女性在某些方面并不完整，认为女性是未完成的男人；甚至认为女人只是土壤，而男人却是“播种者”；男人提供“形式”（男人决定“质料”的“形式”或“特征”），而女人则仅贡献“质料”（组成事物的物质）。\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E4%BA%9A%E9%87%8C%E5%A3%AB%E5%A4%9A%E5%BE%B7/","summary":"亚里士多德 没有天生的概念 柏拉图认为大自然中是先有 “马的理型”，再有我们感官世界中所看到的马匹，因此他认为 “鸡的观念先于鸡”。\n而他却认为“马的理型”，是我们人类看到若干匹马后，所形成的概念；因此马的 “理型” “形式” 是不存在的；它认为马的 “理型” 或 “形式” 就是马的特征。\n某个事物的 “理型” 或 “形式” 存在于这个事物之中，因为所谓的 “理型” 或“ 形式” 就是这个事物所有的特征。\n如果世间存在 ”马的理型”，那这个“马的理型”又从何而来？这个 ”马的理型” 是否会模仿另外一匹马?\n我们所拥有的任何想法和意念都是透过我们过去所看到、听到的事物，从而进入我们的意识。\n一件事物的形式乃是它的特征 自然界的每一种变化，都是物质将自身的 “潜能” 转变为“实现”的结果。\n自然界的每一个事物都可能实现或达成某一种特定的 “形式”。\n一个事物的 “形式” 或 “特征” ，不但说明了这个事物的潜能，也说明了它的极限。举个例子，一个鸡蛋可以变成一只鸡（鸡蛋的潜能）；但并不一定会顺利的变成一只鸡，因为它有可能变成人类餐桌上的佳肴（未实现鸡蛋的潜能）；同理，鸡蛋显然不能变成一只鹅（鸡蛋并不具有变成鹅的潜能）。\n事物都有“质料”和“形式”。\n目的因 他认为自然界的每一件事物都有其存在的“目的”或“任务”。举个例子，天空之所以会下雨，其目的因就是植物和动物需要雨水才能生长。\n他将世间的事物彻底分门别类，同时还创立了《逻辑学》这门学科。\n自然的层级 无生物，比如石头、水滴、树木只能通过外力改变，而生物则有潜能自行改变。\n宇宙中必然有一位“上帝”（最初推动者）推动世间中所有的运作，即上帝位于大自然的最顶端；并且他认为这位“上帝”是宇宙万物各种活动的“目的因”。\n对女人的看法 女性在某些方面并不完整，认为女性是未完成的男人；甚至认为女人只是土壤，而男人却是“播种者”；男人提供“形式”（男人决定“质料”的“形式”或“特征”），而女人则仅贡献“质料”（组成事物的物质）。","title":"亚里士多德"},{"content":"人为什么要努力 人之所以持续不断的努力，并不完全是被正能量驱使，而是被恐惧驱动的。\n因为你看见了一个更好的自己被困在旧躯壳里，你恐惧且不甘，想要把 Ta 救出来，为此你必须付出你的努力。\n","permalink":"https://note.yxzi.xyz/note/view/grow/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%AA%E5%8A%9B/","summary":"人为什么要努力 人之所以持续不断的努力，并不完全是被正能量驱使，而是被恐惧驱动的。\n因为你看见了一个更好的自己被困在旧躯壳里，你恐惧且不甘，想要把 Ta 救出来，为此你必须付出你的努力。","title":"人为什么要努力"},{"content":"人生是一场马拉松 成功的道路并不像想象得那么拥挤，因为在人生的马拉松长路上，绝大部分人跑不到一半就主动退下来了。\n到后来，剩下的少数人不是嫌竞争对手太多，而是发愁怎样找一个同伴陪自己一同跑下去。\n因此，教育是一辈子的事情，笑到最后的人是一辈子接受教育的人。\n回过头来看，一些过去比我们读书更优秀，在起跑线上抢到了更好位置的人，早已放弃了人生的马拉松，\n我们能够跑得更远，仅仅是因为我们还在跑，如此而已。\n急功近利不好，悲观绝望也不好\n","permalink":"https://note.yxzi.xyz/note/view/grow/%E4%BA%BA%E7%94%9F%E6%98%AF%E4%B8%80%E5%9C%BA%E9%A9%AC%E6%8B%89%E6%9D%BE/","summary":"人生是一场马拉松 成功的道路并不像想象得那么拥挤，因为在人生的马拉松长路上，绝大部分人跑不到一半就主动退下来了。\n到后来，剩下的少数人不是嫌竞争对手太多，而是发愁怎样找一个同伴陪自己一同跑下去。\n因此，教育是一辈子的事情，笑到最后的人是一辈子接受教育的人。\n回过头来看，一些过去比我们读书更优秀，在起跑线上抢到了更好位置的人，早已放弃了人生的马拉松，\n我们能够跑得更远，仅仅是因为我们还在跑，如此而已。\n急功近利不好，悲观绝望也不好","title":"人生是一场马拉松"},{"content":"人要会做选择 优秀的选择能力本身就是一个领导者的必备素质，也叫作决策能力。\n它包含了对大量信息的收集、分析和仔细对比，这是一个极为辛苦的认知过程。\n而它也包含了在信息不那么对称的情况下进行一把小小的赌博。\n我们必须努力学会真正清晰地思考和决策方式，才能让自己是“做选择”，而不是“做赌博”。\n","permalink":"https://note.yxzi.xyz/note/view/grow/%E4%BA%BA%E8%A6%81%E4%BC%9A%E5%81%9A%E9%80%89%E6%8B%A9/","summary":"人要会做选择 优秀的选择能力本身就是一个领导者的必备素质，也叫作决策能力。\n它包含了对大量信息的收集、分析和仔细对比，这是一个极为辛苦的认知过程。\n而它也包含了在信息不那么对称的情况下进行一把小小的赌博。\n我们必须努力学会真正清晰地思考和决策方式，才能让自己是“做选择”，而不是“做赌博”。","title":"人要会做选择"},{"content":"人要先努力 一 先努力，你会早一些看到，自己在 24 小时连轴转最努力的情况下，能成就什么。\n而后你才能知道，哪些东西是自己可以去博一博的，哪些东西是只可远观万万不可亵玩的。\n先努力，你会早一些看到，自己在豁出了命去努力、非常努力、比较努力、有点努力、没有努力的情况下，\n分别会得到什么同时又失去什么。\n而后你才能判断，阶段性的目标值得自己投入多少、什么时候该给自己放假，\n哪些情况下需要再加把力、哪些情况下该见好就收，见不好割肉止损也得收。\n每次给自己换挡后，都能坦然的面对即将到来的得失。\n二 先努力，你会早一些看到这个世界真实的样子，然后才有可能找到，适合自己的位置。\n早一些看到，你才有选择的余地、才有调整的空间、才可能有急流勇退和金盆洗手的资格。\n早一些看到，你才能分辨得出，谁给的是经验、谁喂的是鸡汤、谁提炼经验里的鸡精来忽悠你、谁拿浓汤宝当经验自己洗自己。\n否则，你会每天都见识到更大的世界，在一惊一乍的不淡定与对未知的卑微中，度过自己的一生。\n三 在非黄金高峰期搭地铁，只要你肯多往前后走一走，总会发现，一节空到不正常的车厢，找到五个人松散占据着一整排的座位，\n而前后相邻的两节车厢，熙熙攘攘到胸都快被挤掉了，每停一站都要感受一次个人力量的渺小，每个换乘点都是决战紫荆之巅。\n一步天堂一步地狱，不多迈几步，怎么能知道哪步是这一步？\n在足球场上，有这么一种人，他们开赛后先频频犯规，一次比一次尺度大，一次比一次口味重。\n当他们通过一系列试探了解到当值裁判的尺度之后，会把侵犯对手当成常规性的防守手段，比赛屡屡因他们被吹停，\n但他们却很少得牌，还经常引得对手被红牌罚下。\n先努力了，你才可以找出一个性价比高的姿势，从头到尾都死死抱住扶手、从头到尾都跟着对手狂奔。\n确实，你够努力、你更努力、你可 tmd 的努力呢，但是，活的那么苦，结果还不好，除了感动中国，谁都感动不。\n下车了才发现隔壁车厢在拍摄维秘外景的比基尼展示环节，而你在薄薄的人墙之外和狐臭男斗争了一个小时。\n比赛结束了才明白原来只要不扯掉对手的球裤别的什么都能干，谁都能干，扳手可以带，少林功夫可以用。\n四 有一个朋友，刚毕业去了我们那个年代 500 强外企的代表，宝洁，当管理培训生。\n三年后突然辞职考公务员，问其原因，她说她受不了自己回到家里都习惯性的用祈使句和父母说话，\n这份工作让她的性格扭曲到自己都不喜欢自己了，复习几个月后，她考上了。\n几年后我再次去广州出差，得知她已经辞掉了公务员的工作去了我们那个年代著名的养老外企，壳牌。\n我问她为什么的时候她没有再开口，但我能感觉出，那时她的笑容，是最接近大学时期的。\n五 先排除了最不适合自己的，剩下的，都是足够滋润的。\n要是先不努力呢？伟大的无产阶级革命家列宁同志曾经教导过我们：少壮不努力，老大徒伤悲；老二造暗器，老三当总理。\n年轻时得过且过还是以后优哉游哉，自己选咯。\n其实，当你明白人要先努力那天起，你就不需要再努力了，以后的，都是生活。\n","permalink":"https://note.yxzi.xyz/note/view/grow/%E4%BA%BA%E8%A6%81%E5%85%88%E5%8A%AA%E5%8A%9B/","summary":"人要先努力 一 先努力，你会早一些看到，自己在 24 小时连轴转最努力的情况下，能成就什么。\n而后你才能知道，哪些东西是自己可以去博一博的，哪些东西是只可远观万万不可亵玩的。\n先努力，你会早一些看到，自己在豁出了命去努力、非常努力、比较努力、有点努力、没有努力的情况下，\n分别会得到什么同时又失去什么。\n而后你才能判断，阶段性的目标值得自己投入多少、什么时候该给自己放假，\n哪些情况下需要再加把力、哪些情况下该见好就收，见不好割肉止损也得收。\n每次给自己换挡后，都能坦然的面对即将到来的得失。\n二 先努力，你会早一些看到这个世界真实的样子，然后才有可能找到，适合自己的位置。\n早一些看到，你才有选择的余地、才有调整的空间、才可能有急流勇退和金盆洗手的资格。\n早一些看到，你才能分辨得出，谁给的是经验、谁喂的是鸡汤、谁提炼经验里的鸡精来忽悠你、谁拿浓汤宝当经验自己洗自己。\n否则，你会每天都见识到更大的世界，在一惊一乍的不淡定与对未知的卑微中，度过自己的一生。\n三 在非黄金高峰期搭地铁，只要你肯多往前后走一走，总会发现，一节空到不正常的车厢，找到五个人松散占据着一整排的座位，\n而前后相邻的两节车厢，熙熙攘攘到胸都快被挤掉了，每停一站都要感受一次个人力量的渺小，每个换乘点都是决战紫荆之巅。\n一步天堂一步地狱，不多迈几步，怎么能知道哪步是这一步？\n在足球场上，有这么一种人，他们开赛后先频频犯规，一次比一次尺度大，一次比一次口味重。\n当他们通过一系列试探了解到当值裁判的尺度之后，会把侵犯对手当成常规性的防守手段，比赛屡屡因他们被吹停，\n但他们却很少得牌，还经常引得对手被红牌罚下。\n先努力了，你才可以找出一个性价比高的姿势，从头到尾都死死抱住扶手、从头到尾都跟着对手狂奔。\n确实，你够努力、你更努力、你可 tmd 的努力呢，但是，活的那么苦，结果还不好，除了感动中国，谁都感动不。\n下车了才发现隔壁车厢在拍摄维秘外景的比基尼展示环节，而你在薄薄的人墙之外和狐臭男斗争了一个小时。\n比赛结束了才明白原来只要不扯掉对手的球裤别的什么都能干，谁都能干，扳手可以带，少林功夫可以用。\n四 有一个朋友，刚毕业去了我们那个年代 500 强外企的代表，宝洁，当管理培训生。\n三年后突然辞职考公务员，问其原因，她说她受不了自己回到家里都习惯性的用祈使句和父母说话，\n这份工作让她的性格扭曲到自己都不喜欢自己了，复习几个月后，她考上了。\n几年后我再次去广州出差，得知她已经辞掉了公务员的工作去了我们那个年代著名的养老外企，壳牌。\n我问她为什么的时候她没有再开口，但我能感觉出，那时她的笑容，是最接近大学时期的。\n五 先排除了最不适合自己的，剩下的，都是足够滋润的。\n要是先不努力呢？伟大的无产阶级革命家列宁同志曾经教导过我们：少壮不努力，老大徒伤悲；老二造暗器，老三当总理。\n年轻时得过且过还是以后优哉游哉，自己选咯。\n其实，当你明白人要先努力那天起，你就不需要再努力了，以后的，都是生活。","title":"人要先努力"},{"content":"什么是阅读 我认为，阅读仅仅是只是一种兴趣，和玩游戏、健身、看漫画没有本质的区别。\n 我上大学去买烧烤，烧烤摊老板说，现在的大学生，不知道学了这么久都学了什么。\n每天有饭吃有学上，图书馆那么大，还动不动觉得生活没意义，我看还是游戏打的太多。\n我就微笑了一下。\n他说，你还别不信，你看过唐吉诃德么？\n我说，看过啊。\n老板的兴趣浓厚了起来，给我讲他就看过那几本书，爱不释手，以前太穷，现在太忙，最喜欢的就是唐吉诃德。\n我们讨论了一会书里搞笑的内容，说到他把书的故事当真实的时候做出的癫狂事。\n烧烤好了，我就走了。\n 老板很开心，说这么久，终于有个大学生和他聊聊这本书。\n这种感觉我觉得自己特别能理解，小时候大家开开心心拿书互相交换，聊天讨论。\n没人去说中心思想，没人觉得是为了什么。那时候真开心啊。\n突然有一天，别人看着我拿书，都会问，读书是个好习惯，你怎么养成的，怎么坚持的。\n那以后，我就很少再和任何人讨论一本书了。\n这件事我印象特别深，读书就是一种乐趣，不管对方是清洁工，生意人，教授。\n读书本身应该是开开心心和别人聊聊天，就像讨论一下电视剧一样。\n并不会让任何人成为一个成功的人，不知道什么时候读书和成功学挂钩了，我觉得单纯的只是快乐而已，只是乐趣而已。\n看书和不看书的人的区别，就是看书的人只能和看书的人讨论一本书，\n不看书的人呢，可以和另外的人讨论高尔夫、羽毛球、健身、或者随便任何一个自己的爱好。\n","permalink":"https://note.yxzi.xyz/note/view/read/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%85%E8%AF%BB/","summary":"什么是阅读 我认为，阅读仅仅是只是一种兴趣，和玩游戏、健身、看漫画没有本质的区别。\n 我上大学去买烧烤，烧烤摊老板说，现在的大学生，不知道学了这么久都学了什么。\n每天有饭吃有学上，图书馆那么大，还动不动觉得生活没意义，我看还是游戏打的太多。\n我就微笑了一下。\n他说，你还别不信，你看过唐吉诃德么？\n我说，看过啊。\n老板的兴趣浓厚了起来，给我讲他就看过那几本书，爱不释手，以前太穷，现在太忙，最喜欢的就是唐吉诃德。\n我们讨论了一会书里搞笑的内容，说到他把书的故事当真实的时候做出的癫狂事。\n烧烤好了，我就走了。\n 老板很开心，说这么久，终于有个大学生和他聊聊这本书。\n这种感觉我觉得自己特别能理解，小时候大家开开心心拿书互相交换，聊天讨论。\n没人去说中心思想，没人觉得是为了什么。那时候真开心啊。\n突然有一天，别人看着我拿书，都会问，读书是个好习惯，你怎么养成的，怎么坚持的。\n那以后，我就很少再和任何人讨论一本书了。\n这件事我印象特别深，读书就是一种乐趣，不管对方是清洁工，生意人，教授。\n读书本身应该是开开心心和别人聊聊天，就像讨论一下电视剧一样。\n并不会让任何人成为一个成功的人，不知道什么时候读书和成功学挂钩了，我觉得单纯的只是快乐而已，只是乐趣而已。\n看书和不看书的人的区别，就是看书的人只能和看书的人讨论一本书，\n不看书的人呢，可以和另外的人讨论高尔夫、羽毛球、健身、或者随便任何一个自己的爱好。","title":"什么是阅读"},{"content":"休谟 如果你被热炉子烫到你会马上得到一个印象，事后你会回到终究被烫到的这件事，这就是休谟所谓的观念，两者的不同在于印象，比事后的回忆要更加强烈，也更加生动。印象是在我们心中形成挂观念的直接原因。\n不可知论者，他怀疑上帝是否真的存在。因为他觉得上帝，不过是某些元素所组成的，就像天使一样，是由人和翅膀所组成的。\n你相信石头会掉在地上的原因是你见过它发生过很多次。事情发生一次又一次之后，你会变得非常习惯，以至于每次你放开石头时，总会期待发生同样的事，所以就形成了我们所谓的自然界不变的法则。\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E4%BC%91%E8%B0%9F/","summary":"休谟 如果你被热炉子烫到你会马上得到一个印象，事后你会回到终究被烫到的这件事，这就是休谟所谓的观念，两者的不同在于印象，比事后的回忆要更加强烈，也更加生动。印象是在我们心中形成挂观念的直接原因。\n不可知论者，他怀疑上帝是否真的存在。因为他觉得上帝，不过是某些元素所组成的，就像天使一样，是由人和翅膀所组成的。\n你相信石头会掉在地上的原因是你见过它发生过很多次。事情发生一次又一次之后，你会变得非常习惯，以至于每次你放开石头时，总会期待发生同样的事，所以就形成了我们所谓的自然界不变的法则。","title":"休谟"},{"content":"制作光晕  新建透明图层。 将该图层填充为纯黑色。 菜单栏——滤镜——渲染——镜头光晕——调整参数——确定。  ","permalink":"https://note.yxzi.xyz/note/technology/software/photoshop/%E5%88%B6%E4%BD%9C%E5%85%89%E6%99%95/","summary":"制作光晕  新建透明图层。 将该图层填充为纯黑色。 菜单栏——滤镜——渲染——镜头光晕——调整参数——确定。  ","title":"制作光晕"},{"content":"制作剪影  导入图像。 工具栏——快速选择工具。 建立选区。 属性栏——创建或调整选区——调整参数——输出设置——输出到：图层蒙版——确定。 图层面板——创建新的填充或调整图层——纯色——选择颜色——确定。 将纯色图层作为图像的背景。 复制一次图像层——Ctrl + J。 选择位于下方的图像层。 图层面板——添加图层样式——颜色叠加——调整颜色——确定。 移动工具——将位于下方的图像层调整到合适的位置。  ","permalink":"https://note.yxzi.xyz/note/technology/software/photoshop/%E5%88%B6%E4%BD%9C%E5%89%AA%E5%BD%B1/","summary":"制作剪影  导入图像。 工具栏——快速选择工具。 建立选区。 属性栏——创建或调整选区——调整参数——输出设置——输出到：图层蒙版——确定。 图层面板——创建新的填充或调整图层——纯色——选择颜色——确定。 将纯色图层作为图像的背景。 复制一次图像层——Ctrl + J。 选择位于下方的图像层。 图层面板——添加图层样式——颜色叠加——调整颜色——确定。 移动工具——将位于下方的图像层调整到合适的位置。  ","title":"制作剪影"},{"content":"制作灰度图  新建——颜色模式——灰度。 工具栏——渐变工具——黑白渐变。 调整渐变样式。  ","permalink":"https://note.yxzi.xyz/note/technology/software/photoshop/%E5%88%B6%E4%BD%9C%E7%81%B0%E5%BA%A6%E5%9B%BE/","summary":"制作灰度图  新建——颜色模式——灰度。 工具栏——渐变工具——黑白渐变。 调整渐变样式。  ","title":"制作灰度图"},{"content":"努力与命运 我只要认定了宿命的存在，也就意味着自我存在开始的一生百年，\n所有轨迹都已经刻在某块不知名的命运石板上了，此后种种，按序发生。\n那么，我的努力，只是石板上的一行字，这件事是必然发生的。\n而努力改变了所谓命运，其实也是刻在石板上的一部分。\n那么，我们通过努力而改变了命运这件事，本身就是既定的命运的一部分而已。\n因此命运不可以被改变，只要你相信命运，则一切改变皆是命运本身中的必然发生的事罢了。\n比如朱元璋出身贫寒，后登基九五，他大概认为自己改变了命运。\n而如果真的有一块关于他的命运石板的话，则上边一定刻着一行字：\n“朱重八于洪武元年即位于应天府，时年四十岁正。”\n","permalink":"https://note.yxzi.xyz/note/view/grow/%E5%8A%AA%E5%8A%9B%E4%B8%8E%E5%91%BD%E8%BF%90/","summary":"努力与命运 我只要认定了宿命的存在，也就意味着自我存在开始的一生百年，\n所有轨迹都已经刻在某块不知名的命运石板上了，此后种种，按序发生。\n那么，我的努力，只是石板上的一行字，这件事是必然发生的。\n而努力改变了所谓命运，其实也是刻在石板上的一部分。\n那么，我们通过努力而改变了命运这件事，本身就是既定的命运的一部分而已。\n因此命运不可以被改变，只要你相信命运，则一切改变皆是命运本身中的必然发生的事罢了。\n比如朱元璋出身贫寒，后登基九五，他大概认为自己改变了命运。\n而如果真的有一块关于他的命运石板的话，则上边一定刻着一行字：\n“朱重八于洪武元年即位于应天府，时年四十岁正。”","title":"努力与命运"},{"content":"博客添加搜索功能 HTML 代码 然后在网页内需要添加搜索栏的合适位置添加以下代码，一般放在顶部导航栏：\n\u0026lt;div class=\u0026#34;search\u0026#34;\u0026gt; \t\u0026lt;i class=\u0026#34;material-icons search-icon search-start\u0026#34;\u0026gt;search\u0026lt;/i\u0026gt; \t\u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;search-input\u0026#34; placeholder=\u0026#34;Searching...\u0026#34; /\u0026gt; \t\u0026lt;i class=\u0026#34;material-icons search-icon search-clear\u0026#34;\u0026gt;clear\u0026lt;/i\u0026gt; \t\u0026lt;div class=\u0026#34;search-results\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 上面的clear是一个清除输入框内容的图标，search-results是用于输出匹配到的结果的板块；\nCSS 代码 .search { \tposition: relative; \theight: 30px; \ttext-align: right; \tline-height: 30px; \tpadding-right: 10px; }  .search .search-icon { \tfloat: right; \theight: 100%; \tmargin: 0 10px; \tline-height: 30px; \tcursor: pointer; \tuser-select: none; }  .search .search-input { \tfloat: right; \twidth: 30%; \theight: 30px; \tline-height: 30px; \tmargin: 0; \tborder: 2px solid #ddd; \tborder-radius: 10px; \tbox-sizing: border-box; }  .search .search-clear { \tdisplay: none; }  .search .search-results { \tdisplay: block; \tz-index: 1000; \tposition: absolute; \ttop: 30px; \tright: 50px; \twidth: 50%; \tmax-height: 400px; \toverflow: auto; \ttext-align: left; \tborder-radius: 5px; \tbackground: #ccc; \tbox-shadow: 0 0.3rem 0.5rem #333; }  .search .search-results .result-item { \tbackground: aqua; \tcolor: #000; \tmargin: 5px; \tpadding: 3px; \tborder-radius: 3px; \tcursor: pointer; } 样式可以自行随意调整，最终感觉好看就 OK；\navaScript 部分 接下来就是重头戏了，也是实现搜索功能的核心部分，搜索逻辑的实现；\n再来大致分析一下逻辑，和实现的思路：\n 利用 XMLHttpRequest()获取站内 feed.xml 内的所有数据，保存到一个 XML DOM 对象中； 将 XML 对象中的文章标题、链接、内容、索引等通过getElementsByTagName()等方法获取并保存到对应数组变量中； 用户在输入框输入查找内容，提交后内容保存到一个字符串类型变量中； 遍历保存文章内容的数组，通过.search()等方法和输入值进行匹配； 匹配成功后得到所有匹配成功的数组元素的索引值，该索引值也是该内容的标题、链接数组对应的索引值； 将最终搜集的文章标题、链接，以及匹配到的内容片段摘取输出到页面；  这里附上最终的 js 实现代码与注释：\n// 获取搜索框、搜索按钮、清空搜索、结果输出对应的元素 var searchBtn = document.querySelector(\u0026#39;.search-start\u0026#39;); var searchClear = document.querySelector(\u0026#39;.search-clear\u0026#39;); var searchInput = document.querySelector(\u0026#39;.search-input\u0026#39;); var searchResults = document.querySelector(\u0026#39;.search-results\u0026#39;);  // 申明保存文章的标题、链接、内容的数组变量 var searchValue = \u0026#39;\u0026#39;,  arrItems = [],  arrContents = [],  arrLinks = [],  arrTitles = [],  arrResults = [],  indexItem = [],  itemLength = 0; var tmpDiv = document.createElement(\u0026#39;div\u0026#39;); tmpDiv.className = \u0026#39;result-item\u0026#39;;  // ajax 的兼容写法 var xhr = new XMLHttpRequest() || new ActiveXObject(\u0026#39;Microsoft.XMLHTTP\u0026#39;); xhr.onreadystatechange = function () {  if (xhr.readyState == 4 \u0026amp;\u0026amp; xhr.status == 200) {  xml = xhr.responseXML;  arrItems = xml.getElementsByTagName(\u0026#39;item\u0026#39;);  itemLength = arrItems.length;   // 遍历并保存所有文章对应的标题、链接、内容到对应的数组中  // 同时过滤掉 HTML 标签  for (i = 0; i \u0026lt; itemLength; i++) {  arrContents[i] = arrItems[i].getElementsByTagName(\u0026#39;description\u0026#39;)[0].  childNodes[0].nodeValue.replace(/\u0026lt;.*?\u0026gt;/g, \u0026#39;\u0026#39;);  arrLinks[i] = arrItems[i].getElementsByTagName(\u0026#39;link\u0026#39;)[0].  childNodes[0].nodeValue.replace(/\u0026lt;.*?\u0026gt;/g, \u0026#39;\u0026#39;);  arrTitles[i] = arrItems[i].getElementsByTagName(\u0026#39;title\u0026#39;)[0].  childNodes[0].nodeValue.replace(/\u0026lt;.*?\u0026gt;/g, \u0026#39;\u0026#39;);  }  } }  // 开始获取根目录下 feed.xml 文件内的数据 xhr.open(\u0026#39;get\u0026#39;, \u0026#39;/feed.xml\u0026#39;, true); xhr.send();  searchBtn.onclick = searchConfirm;  // 清空按钮点击函数 searchClear.onclick = function(){  searchInput.value = \u0026#39;\u0026#39;;  searchResults.style.display = \u0026#39;none\u0026#39;;  searchClear.style.display = \u0026#39;none\u0026#39;; }  // 输入框内容变化后就开始匹配，可以不用点按钮 // 经测试，onkeydown, onchange 等方法效果不太理想， // 存在输入延迟等问题，最后发现触发 input 事件最理想， // 并且可以处理中文输入法拼写的变化 searchInput.oninput = function () {  setTimeout(searchConfirm, 0); } //输入框获取焦点的时间 searchInput.onfocus = function () {  searchResults.style.display = \u0026#39;block\u0026#39;; }  function searchConfirm() {  if (searchInput.value == \u0026#39;\u0026#39;) {  searchResults.style.display = \u0026#39;none\u0026#39;;  searchClear.style.display = \u0026#39;none\u0026#39;;  } else if (searchInput.value.search(/^\\s+$/) \u0026gt;= 0) {  // 检测输入值全是空白的情况  searchInit();  var itemDiv = tmpDiv.cloneNode(true);  itemDiv.innerText = \u0026#39;请输入有效内容...\u0026#39;;  searchResults.appendChild(itemDiv);  } else {  // 合法输入值的情况  searchInit();  searchValue = searchInput.value;  // 在标题、内容中查找  searchMatching(arrTitles, arrContents, searchValue);  } }  // 每次搜索完成后的初始化 function searchInit() {  arrResults = [];  indexItem = [];  searchResults.innerHTML = \u0026#39;\u0026#39;;  searchResults.style.display = \u0026#39;block\u0026#39;;  searchClear.style.display = \u0026#39;block\u0026#39;; }  function searchMatching(arr1, arr2, input) {  // 忽略输入大小写  input = new RegExp(input, \u0026#39;i\u0026#39;);  // 在所有文章标题、内容中匹配查询值  for (i = 0; i \u0026lt; itemLength; i++) {  if (arr1[i].search(input) !== -1 || arr2[i].search(input) !== -1) {  // 优先搜索标题  if (arr1[i].search(input) !== -1) {  var arr = arr1;  } else {  var arr = arr2;  }  indexItem.push(i); // 保存匹配值的索引  var indexContent = arr[i].search(input);  // 此时 input 为 RegExp 格式 /input/i，转换为原 input 字符串长度  var l = input.toString().length - 3;  var step = 10;   // 将匹配到内容的地方进行黄色标记，并包括周围一定数量的文本  arrResults.push(arr[i].slice(indexContent - step, indexContent) +  \u0026#39;\u0026lt;mark\u0026gt;\u0026#39; + arr[i].slice(indexContent, indexContent + l) + \u0026#39;\u0026lt;/mark\u0026gt;\u0026#39; +  arr[i].slice(indexContent + l, indexContent + l + step));  }  }   // 输出总共匹配到的数目  var totalDiv = tmpDiv.cloneNode(true);  totalDiv.innerHTML = \u0026#39;总匹配：\u0026lt;b\u0026gt;\u0026#39; + indexItem.length + \u0026#39;\u0026lt;/b\u0026gt; 项\u0026#39;;  searchResults.appendChild(totalDiv);   // 未匹配到内容的情况  if (indexItem.length == 0) {  var itemDiv = tmpDiv.cloneNode(true);  itemDiv.innerText = \u0026#39;未匹配到内容...\u0026#39;;  searchResults.appendChild(itemDiv);  }   // 将所有匹配内容进行组合  for (i = 0; i \u0026lt; arrResults.length; i++) {  var itemDiv = tmpDiv.cloneNode(true);  itemDiv.innerHTML = \u0026#39;\u0026lt;b\u0026gt;《\u0026#39; + arrTitles[indexItem[i]] +  \u0026#39;》\u0026lt;/b\u0026gt;\u0026lt;hr /\u0026gt;\u0026#39; + arrResults[i];  itemDiv.setAttribute(\u0026#39;onclick\u0026#39;, \u0026#39;changeHref(arrLinks[indexItem[\u0026#39; + i + \u0026#39;]])\u0026#39;);  searchResults.appendChild(itemDiv);  } }  function changeHref(href) {   // 在当前页面点开链接的情况  location.href = href;   // 在新标签页面打开链接的代码，与上面二者只能取一个，自行决定  // window.open(href); } 可以把上面的代码保存到search-box.js这样的 js 文件中，然后引入到 html 页面里；\n","permalink":"https://note.yxzi.xyz/note/technology/frame/hugo/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/","summary":"博客添加搜索功能 HTML 代码 然后在网页内需要添加搜索栏的合适位置添加以下代码，一般放在顶部导航栏：\n\u0026lt;div class=\u0026#34;search\u0026#34;\u0026gt; \t\u0026lt;i class=\u0026#34;material-icons search-icon search-start\u0026#34;\u0026gt;search\u0026lt;/i\u0026gt; \t\u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;search-input\u0026#34; placeholder=\u0026#34;Searching...\u0026#34; /\u0026gt; \t\u0026lt;i class=\u0026#34;material-icons search-icon search-clear\u0026#34;\u0026gt;clear\u0026lt;/i\u0026gt; \t\u0026lt;div class=\u0026#34;search-results\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 上面的clear是一个清除输入框内容的图标，search-results是用于输出匹配到的结果的板块；\nCSS 代码 .search { \tposition: relative; \theight: 30px; \ttext-align: right; \tline-height: 30px; \tpadding-right: 10px; }  .search .search-icon { \tfloat: right; \theight: 100%; \tmargin: 0 10px; \tline-height: 30px; \tcursor: pointer; \tuser-select: none; }  .","title":"博客添加搜索功能"},{"content":"双重曝光  导入绿幕抠像后的素材与背景 素材。 将背景素材放到抠像绿幕素材的下面。 背景素材——轨道遮罩—Alpha。  ","permalink":"https://note.yxzi.xyz/note/technology/software/after-effects/%E5%8F%8C%E9%87%8D%E6%9B%9D%E5%85%89/","summary":"双重曝光  导入绿幕抠像后的素材与背景 素材。 将背景素材放到抠像绿幕素材的下面。 背景素材——轨道遮罩—Alpha。  ","title":"双重曝光"},{"content":"好感、喜欢与爱 对你有好感 好感只是一种浅层次的情感，没有依赖的成份，是一对多。\n比如你找 Ta 说话，Ta 会以一种不错的态度对你，会很乐意你说话。\n聊天的时候，还会主动开启话题……可是，这只是一种好感，\nTa 只是觉得你是一个有魅力的人，当然只是觉得你有魅力，并未上升为喜欢。\nTa 并不了解你，你的童年怎样，你将来想过怎样的生活，而且，时间上相处的也不长，\n相应的没有任何情感依赖的成份，离开你，Ta 的世界也依然在转，所以 Ta 不会很主动地去找你聊天，陪你说话，找你玩……\n有点喜欢你 如果 Ta 对你产生了一定程度的情感依赖，那么好感便上升为了喜欢。\n这个时候你们会知晓彼此的过去与未来，对彼此的三观，事业等等都有一定的了解，\n同时你们相处的时间够长，有了一定的情感基础，也就是有了情感上的依赖。\n已经爱上了你 你们彼此都在对方的视野里展现了最真实的自我，比如邋遢的行为，崩溃的瞬间，又或者是愤怒的吵架。\nTa 的未来规划里有你；\nTa 会心疼你，深沉的爱着你；\nTa 会自卑，Ta 为了你成为更好的自己；\nTa 会管束你，Ta 希望你能自为更好的自己；\n爱情不是委曲求全，爱情是相互的存在。\n真正的爱情会成就你，也会成就 Ta ，成就的是两个人。\n而不是打着为爱献身的幌子，欺骗你无故的牺牲。\n同样，女生喜欢你，也是喜欢你的个性，千万不要为了教条而随意雕琢自己。\n喜欢打球，就让 Ta 站在旁边为你呐喊；\n喜欢跳水，就让 Ta 爱上游泳馆；\n培养 Ta 早睡早起的良好习惯，跟 Ta 一起去上自习；\n告诉 Ta 不要为自己辛苦熬夜赶论文，告诉 Ta 这些都是值得的。\n这一切的一切都不是一个人在做。\n不是男生单方面费尽心思辛苦不堪地努力成为一个优秀的男朋友，\n也不是女生自己因为男生不接电话而躲在被窝里委屈地哭泣，反思自己哪里不好。\n爱情，是两个人的事，是双方互相成就。\n","permalink":"https://note.yxzi.xyz/note/view/bisexual/%E5%A5%BD%E6%84%9F%E5%96%9C%E6%AC%A2%E4%B8%8E%E7%88%B1/","summary":"好感、喜欢与爱 对你有好感 好感只是一种浅层次的情感，没有依赖的成份，是一对多。\n比如你找 Ta 说话，Ta 会以一种不错的态度对你，会很乐意你说话。\n聊天的时候，还会主动开启话题……可是，这只是一种好感，\nTa 只是觉得你是一个有魅力的人，当然只是觉得你有魅力，并未上升为喜欢。\nTa 并不了解你，你的童年怎样，你将来想过怎样的生活，而且，时间上相处的也不长，\n相应的没有任何情感依赖的成份，离开你，Ta 的世界也依然在转，所以 Ta 不会很主动地去找你聊天，陪你说话，找你玩……\n有点喜欢你 如果 Ta 对你产生了一定程度的情感依赖，那么好感便上升为了喜欢。\n这个时候你们会知晓彼此的过去与未来，对彼此的三观，事业等等都有一定的了解，\n同时你们相处的时间够长，有了一定的情感基础，也就是有了情感上的依赖。\n已经爱上了你 你们彼此都在对方的视野里展现了最真实的自我，比如邋遢的行为，崩溃的瞬间，又或者是愤怒的吵架。\nTa 的未来规划里有你；\nTa 会心疼你，深沉的爱着你；\nTa 会自卑，Ta 为了你成为更好的自己；\nTa 会管束你，Ta 希望你能自为更好的自己；\n爱情不是委曲求全，爱情是相互的存在。\n真正的爱情会成就你，也会成就 Ta ，成就的是两个人。\n而不是打着为爱献身的幌子，欺骗你无故的牺牲。\n同样，女生喜欢你，也是喜欢你的个性，千万不要为了教条而随意雕琢自己。\n喜欢打球，就让 Ta 站在旁边为你呐喊；\n喜欢跳水，就让 Ta 爱上游泳馆；\n培养 Ta 早睡早起的良好习惯，跟 Ta 一起去上自习；\n告诉 Ta 不要为自己辛苦熬夜赶论文，告诉 Ta 这些都是值得的。\n这一切的一切都不是一个人在做。\n不是男生单方面费尽心思辛苦不堪地努力成为一个优秀的男朋友，\n也不是女生自己因为男生不接电话而躲在被窝里委屈地哭泣，反思自己哪里不好。\n爱情，是两个人的事，是双方互相成就。","title":"好感、喜欢与爱"},{"content":"学习的方法 无论是什么学习，如果有这件事情来说对你重要，也有必要，\n但是你却讨厌它，那么请你在讨厌的时候立马去学习它，学到你喜欢它的时候立刻中断它。\n因为人都是追求快乐的，你学到情绪快乐的时候就中断，你的情绪就会带领你再来领略一次那种似曾相识的快乐，\n即便你的情绪不会主动带你来，也不要紧，因为你至少不会在心理上抗拒了。\n所以，做一件事的时候，当这件事情给你的感觉是非常愉悦的时候，请立刻停下来。\n","permalink":"https://note.yxzi.xyz/note/view/study/%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%B9%E6%B3%95/","summary":"学习的方法 无论是什么学习，如果有这件事情来说对你重要，也有必要，\n但是你却讨厌它，那么请你在讨厌的时候立马去学习它，学到你喜欢它的时候立刻中断它。\n因为人都是追求快乐的，你学到情绪快乐的时候就中断，你的情绪就会带领你再来领略一次那种似曾相识的快乐，\n即便你的情绪不会主动带你来，也不要紧，因为你至少不会在心理上抗拒了。\n所以，做一件事的时候，当这件事情给你的感觉是非常愉悦的时候，请立刻停下来。","title":"学习的方法"},{"content":"安装 ThinkPHP 安装 Composer 在 Windows 中，你需要下载并运行 Composer\n安装 composer 时开启 openssl 配置，目录为（php.ini 配置文件的目录中的 php.exe）\n比如 D:\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\n第一次报错  [Composer\\Downloader\\TransportException]\rcurl error 28 while downloading https://repo.packagist.org/packages.json: Timeout was reached 解决方法：修改全局文件(推荐) composer config -g repo.packagist composer https://packagist.phpcomposer.com\n第二次报错  [InvalidArgumentException]\rCould not find package topthink/think with version 6.0.x-dev. 切换 composer 镜像地址：阿里云镜像\ncomposer config -g repo.packagist composer https://mirrors.aliyun.com/composer/\n安装 Thinkphp 开发版 我们这里下载开发版的 ThinkPhp\ncomposer create-project topthink/think=6.0.x-dev tp\n在上一步创建的 tp 文件夹中执行 php think run（确保当前目录有 think 文件）\n最后在浏览器输入 http://localhost:8000/\n","permalink":"https://note.yxzi.xyz/note/technology/frame/thinkphp/%E5%AE%89%E8%A3%85-thinkphp/","summary":"安装 ThinkPHP 安装 Composer 在 Windows 中，你需要下载并运行 Composer\n安装 composer 时开启 openssl 配置，目录为（php.ini 配置文件的目录中的 php.exe）\n比如 D:\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\n第一次报错  [Composer\\Downloader\\TransportException]\rcurl error 28 while downloading https://repo.packagist.org/packages.json: Timeout was reached 解决方法：修改全局文件(推荐) composer config -g repo.packagist composer https://packagist.phpcomposer.com\n第二次报错  [InvalidArgumentException]\rCould not find package topthink/think with version 6.0.x-dev. 切换 composer 镜像地址：阿里云镜像\ncomposer config -g repo.packagist composer https://mirrors.aliyun.com/composer/\n安装 Thinkphp 开发版 我们这里下载开发版的 ThinkPhp\ncomposer create-project topthink/think=6.0.x-dev tp\n在上一步创建的 tp 文件夹中执行 php think run（确保当前目录有 think 文件）","title":"安装 ThinkPHP"},{"content":"康德 理性主义者将理性的重要性说的太过火了，而经验主义者则过分强调感官的经验。\n事物本身和我眼中的事物是不一样的。 我们永远不发确知事物本来的面貌。我们所知道的只是我们眼中所看到的事物\n你的行为是否合乎德正取决于你是否出自善意的为之，并不是取决于你的行为后果。\n只有我们自己确知我们纯粹是为了遵守道德法则而行动时，我们的行为才是自由的。\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E5%BA%B7%E5%BE%B7/","summary":"康德 理性主义者将理性的重要性说的太过火了，而经验主义者则过分强调感官的经验。\n事物本身和我眼中的事物是不一样的。 我们永远不发确知事物本来的面貌。我们所知道的只是我们眼中所看到的事物\n你的行为是否合乎德正取决于你是否出自善意的为之，并不是取决于你的行为后果。\n只有我们自己确知我们纯粹是为了遵守道德法则而行动时，我们的行为才是自由的。","title":"康德"},{"content":"弗洛伊德 性的欲望合需求事实上是人类天性中很自然而且很重要的一部分。\n非理性的冲动经常左右我们的思想、梦境和行动。这种不理性的冲动可能是反映我们的基本需求\n假设在这个演讲厅这么多安安静静、专心听讲的观众里面，有一个人很不安分。他毫无礼貌地大笑，又喋喋不休，并把脚动来动去，使我无法专心演讲。后来我只好宣布我讲不下去了。 这时，你们当中有三四个大汉站起来，在一阵扭打后，把那个搅局的人架了出去。于是这个搅局者就被‘压抑’了，我因此可以继续讲下去。可是为了避免那个被赶走的人再度进来捣乱，那几位执行我的意志的先生便把他们的椅子搬到门口并坐在那儿‘防御’，以继续压抑的动作。现在，如果你们将这个场景转移到心理，把这个大厅称为‘意识’，而把大厅外面称为‘潜意识’，那么你们就可以明白‘压抑’作用的过程了。”\n“可是这个捣乱者坚持要再进来。至少那些被我们压抑的想法和冲动是这样的。这些想法不断从我们的潜意识浮现，使我们经常处于一种压力之下。这是我们为什么常常会说一些本来不想说的话或做一些本来不想做的事的缘故。因为我们的感觉和行动会受到潜意识的鼓动。”\n我们每天的生活里面都充满了这类潜意识的机转。我们时常会忘记某个人的名字，在说话时摸弄自己的衣服，或移动房间里随意放置的物品。我们也时常结结巴巴或看似无辜地说错话，写错字。但佛洛伊德指出，这些举动事实上并不像我们所想的那样是意外的或无心的。这些错误事实上可能正泄漏我们内心最深处的秘密。\n我们应该做的其实是不要太过努力把不愉快的记忆埋藏在潜意识中。因为那就像是试图把水鼠巢穴的入口堵住一样。水鼠一定会从其他的洞口进入花园，因此，让意识与潜意识之间的门半遮半掩事实上是一件很健康的事。\n是不是你愈努力去忘掉一件事情，你在潜意识里就愈容易想起这件事?”\n梦境乃是以伪装的方式满足人被压抑的愿望。\n我们将我们所见、所经验的一切事物都贮存在我们意识深处的某个地方，而这些印象可能会再度浮现。有时我们会突然‘脑中一片空白’，然后过了一会，‘差点就想起来了’，然后再度‘猛然想起’\n合理化 意思就是说，我们自己不愿意承认，也不愿意告诉别人我们做某一件事的真正动机，因为这个动机是让人无法接受的\n投射 它会将把我们内心试图压抑的特点转移到别人身上。譬如说一个很吝啬的人会说别人斤斤计较，而一个不愿承认自己满脑子想着性的人可能愈容易对别人成天想着性的样子感到愤怒\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7/","summary":"弗洛伊德 性的欲望合需求事实上是人类天性中很自然而且很重要的一部分。\n非理性的冲动经常左右我们的思想、梦境和行动。这种不理性的冲动可能是反映我们的基本需求\n假设在这个演讲厅这么多安安静静、专心听讲的观众里面，有一个人很不安分。他毫无礼貌地大笑，又喋喋不休，并把脚动来动去，使我无法专心演讲。后来我只好宣布我讲不下去了。 这时，你们当中有三四个大汉站起来，在一阵扭打后，把那个搅局的人架了出去。于是这个搅局者就被‘压抑’了，我因此可以继续讲下去。可是为了避免那个被赶走的人再度进来捣乱，那几位执行我的意志的先生便把他们的椅子搬到门口并坐在那儿‘防御’，以继续压抑的动作。现在，如果你们将这个场景转移到心理，把这个大厅称为‘意识’，而把大厅外面称为‘潜意识’，那么你们就可以明白‘压抑’作用的过程了。”\n“可是这个捣乱者坚持要再进来。至少那些被我们压抑的想法和冲动是这样的。这些想法不断从我们的潜意识浮现，使我们经常处于一种压力之下。这是我们为什么常常会说一些本来不想说的话或做一些本来不想做的事的缘故。因为我们的感觉和行动会受到潜意识的鼓动。”\n我们每天的生活里面都充满了这类潜意识的机转。我们时常会忘记某个人的名字，在说话时摸弄自己的衣服，或移动房间里随意放置的物品。我们也时常结结巴巴或看似无辜地说错话，写错字。但佛洛伊德指出，这些举动事实上并不像我们所想的那样是意外的或无心的。这些错误事实上可能正泄漏我们内心最深处的秘密。\n我们应该做的其实是不要太过努力把不愉快的记忆埋藏在潜意识中。因为那就像是试图把水鼠巢穴的入口堵住一样。水鼠一定会从其他的洞口进入花园，因此，让意识与潜意识之间的门半遮半掩事实上是一件很健康的事。\n是不是你愈努力去忘掉一件事情，你在潜意识里就愈容易想起这件事?”\n梦境乃是以伪装的方式满足人被压抑的愿望。\n我们将我们所见、所经验的一切事物都贮存在我们意识深处的某个地方，而这些印象可能会再度浮现。有时我们会突然‘脑中一片空白’，然后过了一会，‘差点就想起来了’，然后再度‘猛然想起’\n合理化 意思就是说，我们自己不愿意承认，也不愿意告诉别人我们做某一件事的真正动机，因为这个动机是让人无法接受的\n投射 它会将把我们内心试图压抑的特点转移到别人身上。譬如说一个很吝啬的人会说别人斤斤计较，而一个不愿承认自己满脑子想着性的人可能愈容易对别人成天想着性的样子感到愤怒","title":"弗洛伊德"},{"content":"感情中的决策与试探 男生通常像狗，思路是决策型的。\n女生通常像猫，思路是试探型的。\n你一回家，猫跟狗都蹲在门边。\n狗必须跟你黏糊一阵，猫就是过来看看情况。\n关于信任 男生跟你说，我所有事都信你。\n这是一个决策的开始。\n女生跟你说，我所有事都信你。\n这是一个试探的开始。\n关于吃饭 男生说，吃什么都行。\n这是个决策，他真的吃什么都行。\n女生说吃什么都行。\n这是个试探，你得挨个问她吃什么才行。\n关于意见 男生问，我穿这件衣服好看吗？\n这是个决策，你说好看，他就选那件。\n女生问，我穿这件衣服好看吗？\n这是个试探，你说好看，她会去试下一件。\n关于暧昧 男生说，我不计较你和男同事来往。\n这是个决策，他不一定有底，他是决定不计较。\n女生说，我不计较你和女同事来往。\n这是个试探，具体要看你和哪个女同事来往。\n关于礼物】 男生说，亲爱的你不需要给我买礼物。\n这是个决策，你不买没任何风险。\n女生说，亲爱的你不需要给我买礼物。\n这是个试探，试试看你是不是真不想买。\n关于分手 女生认为自己传递的是一个【试探】\n但他最终告诉你的是一个【决策】\n","permalink":"https://note.yxzi.xyz/note/view/bisexual/%E6%84%9F%E6%83%85%E4%B8%AD%E7%9A%84%E5%86%B3%E7%AD%96%E4%B8%8E%E8%AF%95%E6%8E%A2/","summary":"感情中的决策与试探 男生通常像狗，思路是决策型的。\n女生通常像猫，思路是试探型的。\n你一回家，猫跟狗都蹲在门边。\n狗必须跟你黏糊一阵，猫就是过来看看情况。\n关于信任 男生跟你说，我所有事都信你。\n这是一个决策的开始。\n女生跟你说，我所有事都信你。\n这是一个试探的开始。\n关于吃饭 男生说，吃什么都行。\n这是个决策，他真的吃什么都行。\n女生说吃什么都行。\n这是个试探，你得挨个问她吃什么才行。\n关于意见 男生问，我穿这件衣服好看吗？\n这是个决策，你说好看，他就选那件。\n女生问，我穿这件衣服好看吗？\n这是个试探，你说好看，她会去试下一件。\n关于暧昧 男生说，我不计较你和男同事来往。\n这是个决策，他不一定有底，他是决定不计较。\n女生说，我不计较你和女同事来往。\n这是个试探，具体要看你和哪个女同事来往。\n关于礼物】 男生说，亲爱的你不需要给我买礼物。\n这是个决策，你不买没任何风险。\n女生说，亲爱的你不需要给我买礼物。\n这是个试探，试试看你是不是真不想买。\n关于分手 女生认为自己传递的是一个【试探】\n但他最终告诉你的是一个【决策】","title":"感情中的决策与试探"},{"content":"斯宾诺莎 一元论者，他认为世界万物都是可以被分解为一个真实的“实体”物质。\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E6%96%AF%E5%AE%BE%E8%AF%BA%E8%8E%8E/","summary":"斯宾诺莎 一元论者，他认为世界万物都是可以被分解为一个真实的“实体”物质。","title":"斯宾诺莎"},{"content":"好友间的关系是如何变淡的 为什么没人承认，是社会资源地位见识差距变大，\n你的苦闷他无法理解，他的彷徨在你而言，是变相炫耀。\n两个人无话可说，只能叙旧，直到过去被反复咀嚼，淡而无味，\n又碍于情面，怕被指责势利，还要勉强维持点赞的情分。\n当然，有很多超越阶级的友谊，但两者的见识和思辨力，一定是对等的。\n许多年少时闯祸的朋友，只能被拿来怀念，许多因为恩情而结缘的人，也只适合报恩。\n朋友是需要交换观点的人，而不仅仅是交换感情。\n我越来越觉得，要从同路者中寻找朋友，而不是硬拽着朋友一道上路。\n到了分岔口，温柔道别就好，过年时发一句“羊年吉祥”，也好过两个人口不对心地把酒话桑麻。\n物质差距不一定能冲淡友情，精神差距是一定会的。\n同时，物质差距也让人的精神层面有所改变，所以超越阶层的友谊很罕见。\n老朋友在一起，甚至什么都不用说，只是端起酒杯喝酒，心里确是安宁和踏实。\n","permalink":"https://note.yxzi.xyz/note/view/gam/%E5%A5%BD%E5%8F%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%B7%A1%E7%9A%84/","summary":"好友间的关系是如何变淡的 为什么没人承认，是社会资源地位见识差距变大，\n你的苦闷他无法理解，他的彷徨在你而言，是变相炫耀。\n两个人无话可说，只能叙旧，直到过去被反复咀嚼，淡而无味，\n又碍于情面，怕被指责势利，还要勉强维持点赞的情分。\n当然，有很多超越阶级的友谊，但两者的见识和思辨力，一定是对等的。\n许多年少时闯祸的朋友，只能被拿来怀念，许多因为恩情而结缘的人，也只适合报恩。\n朋友是需要交换观点的人，而不仅仅是交换感情。\n我越来越觉得，要从同路者中寻找朋友，而不是硬拽着朋友一道上路。\n到了分岔口，温柔道别就好，过年时发一句“羊年吉祥”，也好过两个人口不对心地把酒话桑麻。\n物质差距不一定能冲淡友情，精神差距是一定会的。\n同时，物质差距也让人的精神层面有所改变，所以超越阶层的友谊很罕见。\n老朋友在一起，甚至什么都不用说，只是端起酒杯喝酒，心里确是安宁和踏实。","title":"朋友间的关系是如何变淡的"},{"content":"期望值管理 影视剧中往往有这样的观感：一个地痞或者土匪，平日无恶不作。\n到了最后一集，哎，这货突然抗日了，例如《大宅门》里的三爷。\n这时候观众对其好感度会突然爆棚，甚至超过许多没有爆点的正面角色，前几十集的劣迹简直一笔勾销。\n这就是期望值在前期被编剧压低之后的福利。\n我们刚进入一个团队时，如果一开始就大招尽出，会导致周围人和领导对你的期望值不断升高。\n最后总会有一次你满足不了对方的要求，这时候对你的负面评价也会随之而起，甚至会低过一直表现平平的同仁。\n有人将其总结为“不胜任陷阱”，因为在一个上升通道中，只要达到了上层的期望，就会被继续提拔，\n直到提拔到一个你不能胜任的岗位，让所有人失望，这个升迁过程才会结束。\n这一点在情场上也依然适用，你会发现浪子回头会获得相当的赞美，许多女人甚至可以不计较你之前是个多么烂的人。\n但老实巴交的“好好男人”一旦被抓到一次不老实就立刻被打入“渣男”的行列再也不得翻身。\n娱乐圈这样的例子去年今年都有，不用我再赘述。\n这就需要我们对别人对我们的期望值进行有效管理。\n比较常见的手段是憋大招，有一些在对方期待之外的东西不到关键时刻不能随便拿出来用。\n但周围人也不是傻瓜，次数多了，别人都会倾向于相信你藏着一手，例如学生时代那些永远叫嚷着这次考砸了的第一名们，\n信誉早已破产，其他人对其期望值仍然在持续上升，这时候承受的压力可想而知。\n要真正做到有效控制周围人对你的期望值，需要做到真正无迹可寻，并在所有非必要的时刻压抑自己的表现欲与虚荣心。\n","permalink":"https://note.yxzi.xyz/note/view/gam/%E6%9C%9F%E6%9C%9B%E5%80%BC%E7%AE%A1%E7%90%86/","summary":"期望值管理 影视剧中往往有这样的观感：一个地痞或者土匪，平日无恶不作。\n到了最后一集，哎，这货突然抗日了，例如《大宅门》里的三爷。\n这时候观众对其好感度会突然爆棚，甚至超过许多没有爆点的正面角色，前几十集的劣迹简直一笔勾销。\n这就是期望值在前期被编剧压低之后的福利。\n我们刚进入一个团队时，如果一开始就大招尽出，会导致周围人和领导对你的期望值不断升高。\n最后总会有一次你满足不了对方的要求，这时候对你的负面评价也会随之而起，甚至会低过一直表现平平的同仁。\n有人将其总结为“不胜任陷阱”，因为在一个上升通道中，只要达到了上层的期望，就会被继续提拔，\n直到提拔到一个你不能胜任的岗位，让所有人失望，这个升迁过程才会结束。\n这一点在情场上也依然适用，你会发现浪子回头会获得相当的赞美，许多女人甚至可以不计较你之前是个多么烂的人。\n但老实巴交的“好好男人”一旦被抓到一次不老实就立刻被打入“渣男”的行列再也不得翻身。\n娱乐圈这样的例子去年今年都有，不用我再赘述。\n这就需要我们对别人对我们的期望值进行有效管理。\n比较常见的手段是憋大招，有一些在对方期待之外的东西不到关键时刻不能随便拿出来用。\n但周围人也不是傻瓜，次数多了，别人都会倾向于相信你藏着一手，例如学生时代那些永远叫嚷着这次考砸了的第一名们，\n信誉早已破产，其他人对其期望值仍然在持续上升，这时候承受的压力可想而知。\n要真正做到有效控制周围人对你的期望值，需要做到真正无迹可寻，并在所有非必要的时刻压抑自己的表现欲与虚荣心。","title":"期望值管理"},{"content":"柏拉图 永远的真善美 尽管世间所有事物都是 “流动” 的，但一定仍有 ” 某些东西\u0026quot; 永远不会改变（如原子）。\n每一个人都不一样，有的少了腿，有的少了手，有的鼻子高，有的脸大，但我们还是能准确的分辨出这些都是“人”，柏拉图认为，这是因为在人类的背后，存在着一个形式：理型人。\n物质世界的背后，存在一个 ：理型的世界，这个世界中包含存在于自然界中各种事物的 “永恒不变的形式”，这种观点叫做 “柏拉图的理型论”。\n感官和理智 感官：彩虹里哪一种颜色最漂亮、你最喜欢吃什么菜？询问这类问题你大概率会得到许多不同的答案。\n理智：9 × 5 的结果、三角形的内角和，诸如此类的问题你大概只会得到一种答案。\n不朽的灵魂 感官以身体为基础，因此身体是不可靠的；理性是以灵魂为基础，由于灵魂不是物质，因此它是可靠的，灵魂可以探索理型的世界。\n灵魂栖居在某个躯体之前，原本就已经存在；一旦灵魂在某一躯体内醒来时，它便忘却了理型的世界，紧接着，一个人类诞生了，随着时间的推移，这个人的灵魂渴望回“家”，渴望从“肉体的枷锁中挣脱”，它渴望死亡，渴望回到理型的世界。\n物质世界是精神世界的一个映射，有的人却一生都沉沦在物质世界中，从不去探究这个美妙的精神世界。\n哲学之国 国家应该由理性来统治。\n人体由三部分组成：理性属于头部；意志属于胸部；欲望属于腹部。\n理性追求智慧，意志追求勇气，欲望则必须加以阻遏，并且做到自制，才能使人体达到“和谐”的境界。\n黑暗洞穴 我们身处的大自然，虽然不是黑暗或无趣的，但它比起鲜明清楚的理型世界，就显得黑暗而平淡。\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E6%9F%8F%E6%8B%89%E5%9B%BE/","summary":"柏拉图 永远的真善美 尽管世间所有事物都是 “流动” 的，但一定仍有 ” 某些东西\u0026quot; 永远不会改变（如原子）。\n每一个人都不一样，有的少了腿，有的少了手，有的鼻子高，有的脸大，但我们还是能准确的分辨出这些都是“人”，柏拉图认为，这是因为在人类的背后，存在着一个形式：理型人。\n物质世界的背后，存在一个 ：理型的世界，这个世界中包含存在于自然界中各种事物的 “永恒不变的形式”，这种观点叫做 “柏拉图的理型论”。\n感官和理智 感官：彩虹里哪一种颜色最漂亮、你最喜欢吃什么菜？询问这类问题你大概率会得到许多不同的答案。\n理智：9 × 5 的结果、三角形的内角和，诸如此类的问题你大概只会得到一种答案。\n不朽的灵魂 感官以身体为基础，因此身体是不可靠的；理性是以灵魂为基础，由于灵魂不是物质，因此它是可靠的，灵魂可以探索理型的世界。\n灵魂栖居在某个躯体之前，原本就已经存在；一旦灵魂在某一躯体内醒来时，它便忘却了理型的世界，紧接着，一个人类诞生了，随着时间的推移，这个人的灵魂渴望回“家”，渴望从“肉体的枷锁中挣脱”，它渴望死亡，渴望回到理型的世界。\n物质世界是精神世界的一个映射，有的人却一生都沉沦在物质世界中，从不去探究这个美妙的精神世界。\n哲学之国 国家应该由理性来统治。\n人体由三部分组成：理性属于头部；意志属于胸部；欲望属于腹部。\n理性追求智慧，意志追求勇气，欲望则必须加以阻遏，并且做到自制，才能使人体达到“和谐”的境界。\n黑暗洞穴 我们身处的大自然，虽然不是黑暗或无趣的，但它比起鲜明清楚的理型世界，就显得黑暗而平淡。","title":"柏拉图"},{"content":"永生是酷刑 不要用非永生的大脑，去思考永生后的烦恼。\n你看蝙蝠，目不能视，近乎于盲，何其可怜；\n蝙蝠看你，不闻超波，近乎于聋，何其不幸。\n你看燕雀，孱孱弱体寄人篱下，一根竹竿宰其生死；\n燕雀看你，体胖臃肿不能翱翔，徘徊地面哪得自由。\n你看猫狗，生命区区十余载，每日受困屋房中，只是人类一玩伴；\n猫狗看你，终日奔波不得闲，喂食铲屎不敢忘，只是喵汪一奴仆。\n生命的意义是时间的尺度决定的。\n在只能活三个季的蚱蜢眼里，秋季就是生命的尽头，后面是地狱般的寒冬，活着定是无尽的痛苦。\n在只能活一天的蜉蝣眼里，池塘之大就是彼之沧海，朝生暮死，不知晦朔，世间值得已全部看尽。\n五岁的孩童哭闹，因为错过了 30 分钟的动画，对他来说，那是他生命中有意义的 30 分钟。\n十七岁的少女苦恼，因为错付了 30 天的爱情，对她来说，那是她生命中有意义的 30 天。\n三十岁的中年人忧虑，因为错失了 30 月的工作，对他来说，那是她生命中有意义的 30 月。\n五十岁的知命烦懑，因为蹉跎了 30 年的韶华，对他来说，那是他生命中有意义的 30 年。\n八十岁的耄耋懊恼，只因为今日大风，没能如往常一样坐于廊前，看天空云卷云舒，看庭前花开花落，咀嚼岁月如常，\n对她来说，用生命品味时间就很有意义。\n我们觉得永生是酷刑，因为思考这个问题的，是非永生的大脑。\n我们很难设想以亿万年计的生命要去思考什么，见证什么，尝试什么，\n他们做事意义在哪里，带来的收获是什么，感动和喜悦的又是什么。\n只有当生命真到了这个维度，我们可能才会逐渐寻找新的愉悦和感动。\n可能是发出一束光，等待 4.24 年看到另一个星系的回应，那是人马座的时间。\n可能是洒下一片生命种子，过 35 亿年看看会进化出什么生物，那是生命的时间。\n可能是见证一个瞬间，用 140 亿年看看万物从无到有，从坍塌到膨胀，那是宇宙的时间。\n总之，用有限生命的头脑，可能无法设想永生生物的快乐。\n就像处男做春梦，到了关键时刻总是编不下去醒来的。\n有的人说这是不是已经脱离现实上升到哲学的论述了。\n其实，思维是指导行为的。\n小时候曾经有过一次，因上课不听话被老师叫到走廊罚站了整日。\n到了晚上奶奶来接我，我说今日站在走廊经历同学走过议论，太丢脸了，不想再去学校了。\n奶奶笑着告诉我，现在我看是天大的事情，但等长大一些，今天不过是记忆中的一件小事罢了。\n“永生是否是一种酷刑”，很像现代年轻人偶尔会陷入的悲观焦虑。\n有时候一件小事，在当时看来，是足以毁灭自己的，让你感觉前途没了光明。\n其实，等你走到未来，发现还有无限可能。\n前几天安慰一位妈妈，她说知道不对，但放不下对孩子每次考试成绩的焦虑。\n我劝她不妨试着将目标放大，将结果放小去看，或许有用。\n目标放大，想象孩子 25 岁成年工作、结婚的样子。\n孩子的这一次考试还是否还那么重要？\n结果放小，体会你与孩子的每一次学习、玩耍的瞬间，他是不是努力、快乐、感到幸福？\n如果你也有不开心的时候，感觉生命无法迈过的时刻，不妨也想象在更长的时间里，在宇宙的维度下，这烦恼不过是一瞬的烟云。\n认真把握每个精彩的时刻，过好每一个陪伴亲人的瞬间。\n不要为没发生的事情而烦恼。\n不悔既往，不负当下，不惧未来\n宇宙的安排都是完美的。\n","permalink":"https://note.yxzi.xyz/note/view/thinking/%E6%B0%B8%E7%94%9F%E6%98%AF%E9%85%B7%E5%88%91/","summary":"永生是酷刑 不要用非永生的大脑，去思考永生后的烦恼。\n你看蝙蝠，目不能视，近乎于盲，何其可怜；\n蝙蝠看你，不闻超波，近乎于聋，何其不幸。\n你看燕雀，孱孱弱体寄人篱下，一根竹竿宰其生死；\n燕雀看你，体胖臃肿不能翱翔，徘徊地面哪得自由。\n你看猫狗，生命区区十余载，每日受困屋房中，只是人类一玩伴；\n猫狗看你，终日奔波不得闲，喂食铲屎不敢忘，只是喵汪一奴仆。\n生命的意义是时间的尺度决定的。\n在只能活三个季的蚱蜢眼里，秋季就是生命的尽头，后面是地狱般的寒冬，活着定是无尽的痛苦。\n在只能活一天的蜉蝣眼里，池塘之大就是彼之沧海，朝生暮死，不知晦朔，世间值得已全部看尽。\n五岁的孩童哭闹，因为错过了 30 分钟的动画，对他来说，那是他生命中有意义的 30 分钟。\n十七岁的少女苦恼，因为错付了 30 天的爱情，对她来说，那是她生命中有意义的 30 天。\n三十岁的中年人忧虑，因为错失了 30 月的工作，对他来说，那是她生命中有意义的 30 月。\n五十岁的知命烦懑，因为蹉跎了 30 年的韶华，对他来说，那是他生命中有意义的 30 年。\n八十岁的耄耋懊恼，只因为今日大风，没能如往常一样坐于廊前，看天空云卷云舒，看庭前花开花落，咀嚼岁月如常，\n对她来说，用生命品味时间就很有意义。\n我们觉得永生是酷刑，因为思考这个问题的，是非永生的大脑。\n我们很难设想以亿万年计的生命要去思考什么，见证什么，尝试什么，\n他们做事意义在哪里，带来的收获是什么，感动和喜悦的又是什么。\n只有当生命真到了这个维度，我们可能才会逐渐寻找新的愉悦和感动。\n可能是发出一束光，等待 4.24 年看到另一个星系的回应，那是人马座的时间。\n可能是洒下一片生命种子，过 35 亿年看看会进化出什么生物，那是生命的时间。\n可能是见证一个瞬间，用 140 亿年看看万物从无到有，从坍塌到膨胀，那是宇宙的时间。\n总之，用有限生命的头脑，可能无法设想永生生物的快乐。\n就像处男做春梦，到了关键时刻总是编不下去醒来的。\n有的人说这是不是已经脱离现实上升到哲学的论述了。\n其实，思维是指导行为的。\n小时候曾经有过一次，因上课不听话被老师叫到走廊罚站了整日。\n到了晚上奶奶来接我，我说今日站在走廊经历同学走过议论，太丢脸了，不想再去学校了。\n奶奶笑着告诉我，现在我看是天大的事情，但等长大一些，今天不过是记忆中的一件小事罢了。\n“永生是否是一种酷刑”，很像现代年轻人偶尔会陷入的悲观焦虑。\n有时候一件小事，在当时看来，是足以毁灭自己的，让你感觉前途没了光明。\n其实，等你走到未来，发现还有无限可能。\n前几天安慰一位妈妈，她说知道不对，但放不下对孩子每次考试成绩的焦虑。\n我劝她不妨试着将目标放大，将结果放小去看，或许有用。\n目标放大，想象孩子 25 岁成年工作、结婚的样子。\n孩子的这一次考试还是否还那么重要？\n结果放小，体会你与孩子的每一次学习、玩耍的瞬间，他是不是努力、快乐、感到幸福？\n如果你也有不开心的时候，感觉生命无法迈过的时刻，不妨也想象在更长的时间里，在宇宙的维度下，这烦恼不过是一瞬的烟云。\n认真把握每个精彩的时刻，过好每一个陪伴亲人的瞬间。\n不要为没发生的事情而烦恼。\n不悔既往，不负当下，不惧未来\n宇宙的安排都是完美的。","title":"永生是酷刑"},{"content":"洛克 一个事物，在某些性质（重量、形状）上，每个人都会有一致的看法，因为这些性质存在于事物本身之内。但还有一些性质（颜色、味道），就可能因人而异了，因为每个人的感觉是不一样的。\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E6%B4%9B%E5%85%8B/","summary":"洛克 一个事物，在某些性质（重量、形状）上，每个人都会有一致的看法，因为这些性质存在于事物本身之内。但还有一些性质（颜色、味道），就可能因人而异了，因为每个人的感觉是不一样的。","title":"洛克"},{"content":"父母哭穷的行为 可怕的不是真穷，可怕的是不知道有多穷的压迫感和未知感。\n你家要是真穷的话，父母早早对你说清楚，你看，咱家一个月收入就 3000，\n一千交房租，一千五吃饭，存 300 应急，每个月只能给你 200 当午饭钱。\n你会怎么办？\n你但凡超过八岁，会算不过来这个帐吗？会不懂有多少钱才能花多少钱这个道理吗？\n你只要智力正常,情感正常，都会知道再闹着向父母要钱一点用都没有，\n一来因为钱就这么多，二来因为你也知道自己是家里的一份子。\n你会因为只有 200 块午饭钱自卑吗？有可能会，但这不会困扰你太久。\n当你认识到现实之后，你会意识到自卑也什么用都没有，还不如好好想办法怎么把这 200 块花到刀刃上,\n甚至开源节流自己想办法赚些钱铺贴家用。\n但为什么你还是会痛苦，是因为你不知道自己父母的真实意图是什么。\n可能你会发现与父母收入差不多的同事家的孩子有新衣服穿，你却只能穿旧衣服。\n你发现当自己想要一个什么东西的时候，父母总是说没钱，但是转头他们又支出了大笔非必要的开销。\n当你向父母索取任何东西的时候，你的父母总是说家里穷，你再向父母提过多要求就是道德败坏。\n但是在生活中你却发现，你家其实又没有你父母说的那么穷。\n你所体会到的是罪恶感，是无所适从。\n真穷的人花钱才不会有罪恶感，因为真穷的人花钱都是计划好了的。\n计划好了的支出怎么会有罪恶感? 只会有攒了好久钱终于吃了一顿饺子的喜悦。\n只有不知道自己到底是穷是福的人花起钱来才有罪恶感。\n你很想吃饺子，却又思前想后不知道这顿饺子的开销对于家庭和自己的财物状况来说到底意味着什么。\n你咬紧牙关下定决心买了饺子，吃完了就开始担忧是不是这次放纵就能把自己家吃破产。只有在这种情况下，花钱才有罪恶感。\n这是很愚蠢的行为。\n在这种环境中长大的孩子，要么一辈子畏畏缩缩，一辈子都无法体会到物质给人带来的便利和愉悦。\n要么在有了点钱之后就会挥霍无度，希望通过花钱来对抗自己的自卑情绪。\n但这却是很有效的行为，你的父母总对你哭穷，那么当你向父母索取任何东西的时候，\n你自己都会承担非常大的心理压力。这样你的父母就可以节省掉很多抚养成本，还能向别人炫耀自己家的孩子懂事儿，从来不乱要东西。\n因为这个方法真的很有效，所以在中国父母间广泛流传。\n这个方法的核心秘诀在于，大多数向子女哭穷的中国父母，并不是面向解决问题的。\n比方说你想要一双一千块的新鞋，如果你的父母对你说，咱们家的经济状况不好，\n所以每个月只能给你 200 块午餐钱，如果你每个月能省 100 块出来，\n那攒 10 个月你就能买这双鞋了，或者你可以去麦当劳打工，一个小时十几块，攒上三个月你就有钱买这双鞋了。\n你要考虑以下自己是不是要为了一双鞋就付出这么多努力，或者买双便宜一点的也可以。\n这叫面向解决问题。智力和情感正常的子女都会自己做选择。\n实际上这些父母会说，我们这么辛辛苦苦挣钱省钱，每分钱赚的都不容易，你居然还要买一千块的鞋。\n你怎么这么不知道体谅父母，你这是不孝，是道德败坏。\n当诉诸道德的时候，问题本身就不重要了，而因为在面对未成年子女的时候，\n父母天生就占据了权力高位，对道德问题拥有绝对解释权，所以父母可以不需要解决任何实际问题。\n作为还无法自立的子女，你会困惑，会不知道到底该怎么办，会认为真的是自己的错。\n这时，父母的目的就达到了，父母不仅省了钱，还占据了道德制高点。\n在很多中国家庭中，父母和子女是不能讨论任何具体的问题的。\n因为讨论具体问题意味着子女有权力提出自己的想法。\n但是很多中国父母是不能容忍这一点的，在很多中国父母的眼中，自己必须掌握对子女的绝对权力。\n这些中国父母必须掌握道德的制高点，因为只有掌握了道德的制高点，父母才有对一切问题的解释权。\n说家里穷，父母赚钱不容易，是掌握道德制高点非常重要的手段。\n至于家庭的实际情况和你的具体问题是什么，并不重要。\n因为父母的目的是掌握了道德制高点之后让你听话，而不是帮助你解决具体问题。\n生在这样的家庭，你的前半生必然痛苦。物质的匮乏是次要的，对你影响更大的会是世界观和价值观的扭曲。\n这些心理上的阴影必然会伴随你半生，会给你的学业，事业和家庭生活带来极大的负面影响。\n你的父母 shi 不会在乎这些的，因为他们的目的是让你听话，你的问题是你的问题。\n你甚至非常有可能一辈子都意识不到自己的问题所在，浑浑噩噩的也就过去了。\n只有当你有了足够的经历和思考之后，你才有可能从这个阴影里走出来。\n这个过程会非常痛苦，需要非常强大的内心，但这是值得的，因为生活在这样的一个道德陷阱中的人是不可能快乐的。\n","permalink":"https://note.yxzi.xyz/note/view/society/%E7%88%B6%E6%AF%8D%E5%93%AD%E7%A9%B7%E7%9A%84%E8%A1%8C%E4%B8%BA/","summary":"父母哭穷的行为 可怕的不是真穷，可怕的是不知道有多穷的压迫感和未知感。\n你家要是真穷的话，父母早早对你说清楚，你看，咱家一个月收入就 3000，\n一千交房租，一千五吃饭，存 300 应急，每个月只能给你 200 当午饭钱。\n你会怎么办？\n你但凡超过八岁，会算不过来这个帐吗？会不懂有多少钱才能花多少钱这个道理吗？\n你只要智力正常,情感正常，都会知道再闹着向父母要钱一点用都没有，\n一来因为钱就这么多，二来因为你也知道自己是家里的一份子。\n你会因为只有 200 块午饭钱自卑吗？有可能会，但这不会困扰你太久。\n当你认识到现实之后，你会意识到自卑也什么用都没有，还不如好好想办法怎么把这 200 块花到刀刃上,\n甚至开源节流自己想办法赚些钱铺贴家用。\n但为什么你还是会痛苦，是因为你不知道自己父母的真实意图是什么。\n可能你会发现与父母收入差不多的同事家的孩子有新衣服穿，你却只能穿旧衣服。\n你发现当自己想要一个什么东西的时候，父母总是说没钱，但是转头他们又支出了大笔非必要的开销。\n当你向父母索取任何东西的时候，你的父母总是说家里穷，你再向父母提过多要求就是道德败坏。\n但是在生活中你却发现，你家其实又没有你父母说的那么穷。\n你所体会到的是罪恶感，是无所适从。\n真穷的人花钱才不会有罪恶感，因为真穷的人花钱都是计划好了的。\n计划好了的支出怎么会有罪恶感? 只会有攒了好久钱终于吃了一顿饺子的喜悦。\n只有不知道自己到底是穷是福的人花起钱来才有罪恶感。\n你很想吃饺子，却又思前想后不知道这顿饺子的开销对于家庭和自己的财物状况来说到底意味着什么。\n你咬紧牙关下定决心买了饺子，吃完了就开始担忧是不是这次放纵就能把自己家吃破产。只有在这种情况下，花钱才有罪恶感。\n这是很愚蠢的行为。\n在这种环境中长大的孩子，要么一辈子畏畏缩缩，一辈子都无法体会到物质给人带来的便利和愉悦。\n要么在有了点钱之后就会挥霍无度，希望通过花钱来对抗自己的自卑情绪。\n但这却是很有效的行为，你的父母总对你哭穷，那么当你向父母索取任何东西的时候，\n你自己都会承担非常大的心理压力。这样你的父母就可以节省掉很多抚养成本，还能向别人炫耀自己家的孩子懂事儿，从来不乱要东西。\n因为这个方法真的很有效，所以在中国父母间广泛流传。\n这个方法的核心秘诀在于，大多数向子女哭穷的中国父母，并不是面向解决问题的。\n比方说你想要一双一千块的新鞋，如果你的父母对你说，咱们家的经济状况不好，\n所以每个月只能给你 200 块午餐钱，如果你每个月能省 100 块出来，\n那攒 10 个月你就能买这双鞋了，或者你可以去麦当劳打工，一个小时十几块，攒上三个月你就有钱买这双鞋了。\n你要考虑以下自己是不是要为了一双鞋就付出这么多努力，或者买双便宜一点的也可以。\n这叫面向解决问题。智力和情感正常的子女都会自己做选择。\n实际上这些父母会说，我们这么辛辛苦苦挣钱省钱，每分钱赚的都不容易，你居然还要买一千块的鞋。\n你怎么这么不知道体谅父母，你这是不孝，是道德败坏。\n当诉诸道德的时候，问题本身就不重要了，而因为在面对未成年子女的时候，\n父母天生就占据了权力高位，对道德问题拥有绝对解释权，所以父母可以不需要解决任何实际问题。\n作为还无法自立的子女，你会困惑，会不知道到底该怎么办，会认为真的是自己的错。\n这时，父母的目的就达到了，父母不仅省了钱，还占据了道德制高点。\n在很多中国家庭中，父母和子女是不能讨论任何具体的问题的。\n因为讨论具体问题意味着子女有权力提出自己的想法。\n但是很多中国父母是不能容忍这一点的，在很多中国父母的眼中，自己必须掌握对子女的绝对权力。\n这些中国父母必须掌握道德的制高点，因为只有掌握了道德的制高点，父母才有对一切问题的解释权。\n说家里穷，父母赚钱不容易，是掌握道德制高点非常重要的手段。\n至于家庭的实际情况和你的具体问题是什么，并不重要。\n因为父母的目的是掌握了道德制高点之后让你听话，而不是帮助你解决具体问题。\n生在这样的家庭，你的前半生必然痛苦。物质的匮乏是次要的，对你影响更大的会是世界观和价值观的扭曲。\n这些心理上的阴影必然会伴随你半生，会给你的学业，事业和家庭生活带来极大的负面影响。\n你的父母 shi 不会在乎这些的，因为他们的目的是让你听话，你的问题是你的问题。\n你甚至非常有可能一辈子都意识不到自己的问题所在，浑浑噩噩的也就过去了。\n只有当你有了足够的经历和思考之后，你才有可能从这个阴影里走出来。","title":"父母哭穷的行为"},{"content":"登录宝塔 前言 本文是我第一次使用服务器搭建网站后所写的，本文使用的是以下产品。\n轻量云服务器 CentOS 7.6 64bit\nPutty 用于 Windows 从本地登陆到远程 Linux 服务器\n宝塔 下载 Putty 用 Putty 登陆到 Linux 配置 Putty  Host Name（IP address）：轻量应用服务器的公网 IP Port：轻量应用服务器的连接端口，必须设置为22。 Connect type：选择SSH. Saved Sessions：填写会话名称，例如 Rainy。 配置 “Host Name” 后，再配置 “Saved Sessions” 并 Save，则后续使用时可直接双击 “Saved Sessions” 下保存的会话名称登录到对应服务器。  输入用户名和密码   填写完成后单击 open，进入到 Putty 的运行界面，提示 login as.\n  在login as后输入用户名，一般都是 root，按 Enter。\n  输入密码，这里注意密码在输入时是不显示的，大家不要以为密码没输入，输入完成后按 Enter.\n  登陆完成。\n  安装宝塔 Centos 系统直接在登陆后 Putty 界面输入以下命令安装。\nyum install -y wget \u0026amp;\u0026amp; wget -O install.sh http://download.bt.cn/install/install.sh \u0026amp;\u0026amp; sh install.sh 接下来会出现如图所示\n输入 y，并回车，等待几分钟即可。\n安装完毕后，我们会得到登录宝塔面板的 url，账号和密码。\n查看用户名和密码，输入bt default\nBt-Panel: http://IP:8888 username: k5jlmsoc password: 63f4ace0 ","permalink":"https://note.yxzi.xyz/note/technology/linux/%E7%99%BB%E9%99%86%E5%AE%9D%E5%A1%94/","summary":"登录宝塔 前言 本文是我第一次使用服务器搭建网站后所写的，本文使用的是以下产品。\n轻量云服务器 CentOS 7.6 64bit\nPutty 用于 Windows 从本地登陆到远程 Linux 服务器\n宝塔 下载 Putty 用 Putty 登陆到 Linux 配置 Putty  Host Name（IP address）：轻量应用服务器的公网 IP Port：轻量应用服务器的连接端口，必须设置为22。 Connect type：选择SSH. Saved Sessions：填写会话名称，例如 Rainy。 配置 “Host Name” 后，再配置 “Saved Sessions” 并 Save，则后续使用时可直接双击 “Saved Sessions” 下保存的会话名称登录到对应服务器。  输入用户名和密码   填写完成后单击 open，进入到 Putty 的运行界面，提示 login as.\n  在login as后输入用户名，一般都是 root，按 Enter。\n  输入密码，这里注意密码在输入时是不显示的，大家不要以为密码没输入，输入完成后按 Enter.\n  登陆完成。\n  安装宝塔 Centos 系统直接在登陆后 Putty 界面输入以下命令安装。","title":"登录宝塔"},{"content":"知识诅咒 知识的诅咒，简单来说就是你知道一件事物后，你就无法想象你不知道它。\n而当你想把你知道的知识解释给别人的时候，因为信息的不平衡，\n你很难把自己知道的完完全全给对方解释清楚，感觉就是我们被知识“诅咒”了。\n对某个问题，自从知道了，就再也无法设身处地从未知者角度思考它。\n","permalink":"https://note.yxzi.xyz/note/view/thinking/%E7%9F%A5%E8%AF%86%E8%AF%85%E5%92%92/","summary":"知识诅咒 知识的诅咒，简单来说就是你知道一件事物后，你就无法想象你不知道它。\n而当你想把你知道的知识解释给别人的时候，因为信息的不平衡，\n你很难把自己知道的完完全全给对方解释清楚，感觉就是我们被知识“诅咒”了。\n对某个问题，自从知道了，就再也无法设身处地从未知者角度思考它。","title":"知识诅咒"},{"content":"社交的本质 我想用这一篇文章阐明社交的本质，从而在根本上终结所有的社交问题。\n这篇文章一共七千多字，写到最后的时候我有一种预感，这篇文章可能会改变很多人的一生。\n社交在本质上分为两种。\n一种是**「共情社交」，一种是「功利社交」**。\n共情社交 共情社交是指为了获得情感联结与情感体验，打发无聊，或是有共同的兴趣等而产生的社交行为。\n这种社交不涉及利益的交换，且绝大多数人自小产生的社交行为都是源于这种共情类的需求。\n随着一个人年龄的增长，他的共情社交会逐渐的减少；\n并且在同一年龄与阶层中，一个人的心智越成熟、能力越强、社会地位越高，他的共情社交就会越少。\n这就是为什么很多人会觉得越长大越孤单，越长大朋友越少，越长大越难和别人交心；\n还有为什么两个原本社会地位一样的人，其中一个发达了之后就会疏远另一个的原因。\n共情社交存在的根本原因是在于：当一个人的心智尚未成熟独立时，或是当他社会阶层较低、生活不如意时，\n他需要从朋友那里获得情感上的联结和支持。\n在生活中那些越成熟、越独立的人就越是对共情社交不在乎。\n因为他们的人格和在社会上生存的能力足够完善，无论是情感还是物质，他们都不需要“朋友”来给他们提供支持。\n那么有些人可能会说了，那还有一些明明心智很成熟、也很热爱社交的“交际花”，这又如何解释呢？\n那是因为，那些交际花要么只是单纯地喜欢「和很多人一起玩」这件事而已，就和一个人喜欢骑马、喜欢打球一样。\n他就算不和这群人玩，和另一群人一起嗨也是一样。\n即便他长期的喜欢和某一群人一起玩，那也是因为就像你骑马时特别喜欢某一匹，打球时某一球拍用的最顺手，仅此而已。\n只不过是当面向的对象变成人时，也多多少少的会被掺杂上一些情感的因素。\n要么是他建立这么多的社交关系只是为了筛选出足够有价值的「功利社交」的对象，\n他在做的事情只是依托着“社交”这一表象进行互利伙伴的挑选与关系建立罢了。\n人与人交往的本质是利益交换\n利益分为物质利益和精神利益，很多人其实就是没有认识到“精神利益”其实是“利益”的组成部分。\n人类社会就是通过各种利益交换凝聚起来的，“感情”本身就是“利益”的一部分。\n利益交换并不只限于物质对物质，精神对精神。精神利益与物质利益的互换是最常见的事情。\n“钱”就是沟通精神利益与物质利益的重要纽带。\n比如：\n 亲子关系：也许在有些人看来，“亲子关系”不会涉及到利益。但实际上，亲子关系是很典型的精神利益与物质利益的互换。 施舍行为：施予者获得的是精神上的愉悦，受助者获得的是物质上的帮助 + 精神上的愉悦。只要双方都是自愿，这就是个互利双赢的事。 文艺演出：看演出的人得不到任何物质利益，但依然愿意花钱买票。这就是精神利益的价值体现。  所以说“人与人交往的本质是利益交换”是一种很合理的说法。\n不要认为理智会伤害感情，实际上只有以理智为前提，才能拿捏好各种感情的分寸，让大家都过得开心。\n功利社交 功利社交是指为了达成某一目的，或是从对方身上获得利益而产生的社交行为。**\n这种功利性社交在小孩子一开始挑选玩伴的时候就已经产生了：\n比如在班级里面大家都倾向于和零食最多、玩具最多的小孩做朋友；\n我们都喜欢和不会欺负我们、不会抢我们东西的人一块玩；\n如果你的干脆面每天都分给一个小朋友一半而他却从来不分给你，那你最后会放弃这个朋友；\n随着一个人心智的完善和社会地位的提升，他会越来越注重社交的「效益性」。\n即一段社交关系能带给他怎样的利益，和这个朋友继续交往有没有价值，甚至是和一群老朋友一起吃饭还有没有必要。\n「功利社交」有两个基本前提：\n有效信息的交互传递 这个信息是广义的，在人际交往中的如语言、情感、物质、知识等都可以包括在这个信息的范畴内。\n沟通的本质就是信息的传递。\n而有效是功利性社交的一个基本要素。人们产生功利社交行为之前基本上都是抱有一定的目的性的，\n当我和你产生社交时，我们的交流应该是有价值的，而不是毫无意义的闲扯和浪费时间的各说各话。\n一个最起码的前提是，我们能够理解双方所表达的意思。\n你和一个没玩过 LOL 的人谈论补刀和打野技巧，和一个不懂金融的人谈股票，\n你给一个廉洁公正的领导送礼希望提拔你，那么这样的“沟通”就是无意义的。\n较为对等的价值水平 这个价值水平并不仅仅只是指社会地位。它依据的是具体情况和个人的评判标准。\n比如你是个百万富翁，你最喜欢看别人翻跟头，那么一个翻得一手好跟头的乞丐或是白领或是小商贩对你而言都是有价值的。\n那如果这个翻得一手好跟头的人也同时渴望一个有钱的朋友，那你们的价值水平就算是“对等”的。\n而如果这个翻得一手好跟头的人视金钱如粪土，他只喜欢会踩高跷的朋友，\n那你这个百万富翁对他而言就是无意义的，你们的价值水平就并不对等。\n功利性社交的根本目的就是能够从对方那里获得一定的利益或是得到帮助，\n如果一个人和你的差距极大，你很清楚这个人在未来的生活中不可能给你带来丝毫的利益，\n那么这段社交关系对于你而言就是无价值的，所以你本能的就会舍弃。\n一个人的心智成熟到一定程度后，他对共情社交的需求会下降到几乎为零。\n旧的社交关系只有在两个人还能够产生有效交流的前提下才能继续维持。\n大多数情况是：\n你的那些比你强的朋友在默默地舍弃了你，而你也悄悄地舍弃了那些比你弱的朋友。\n当我们能够分清这两种社交时，其实很多问题都已经解决了。因为许多问题的产生最根本的就在于人们对于社交的认知是不清晰的。\n一个最常见、也是影响最大的一个问题就是，很多人把这两种社交类型混为一谈。\n最常见的就是：有一些人认为他的「共情社交」的朋友为他做那些「功利社交」朋友的事情，是理所应当的。\n比如：\n因为你在国外，你的很多朋友不给你代购费找你帮忙代购，你拒绝，他们就说你不够朋友；\n因为你是学英语的，你朋友找你帮忙翻译论文，你费心费力帮他弄完最后连句谢谢都没有；\n因为你是学摄影的，朋友就让你“免费”给他拍照，并以“不就是按几下快门么”为理由；\n这些都是典型的分不清社交边界的表现。\n而更严重的问题在于，我国的传统文化与社会观念一向是将功利社交与共情社交混为一谈。\n“朋友就是要相互帮助的，朋友就是要互相麻烦的啊”这种观念在国人身边普遍流传。\n当你的一个“共情朋友”向你提出“功利需求”的时候，如果你拒绝，你就会背上“不够朋友”的恶名。\n这种人际交往的方式往往还会被美其名曰“够义气”、“显得亲切”、“有人情味”等一系列「高大上」的概念。\n所以在中国「经营人脉」的方式就是「拉关系」，先和你套近乎，成为“朋友”以后再提出「功利性需求」对方就不好意思再拒绝了。\n这本质上其实就是：试图通过建立「共情人脉」来从对方那里获得「功利性」的利益交换。\n正是因为「中国式边界不清的社交」模式，才会令很多人迷信于“人脉管理”，“为人处世之道”，“社交技巧”等等这些「无用」的鸡汤。\n那些所谓的面试时捡了纸团获得了好工作，谈生意时对方看你很有礼貌就和你合作等故事，\n全都是没有过真正的社会经验、或是忽悠涉世未深的学生的鸡汤而已。\n老板、HR、需求方等没有人是傻子，\n当一个价值比你高的人决定是否要和你建立「功利性」社交关系时，那只取决于你在这段「功利关系」中是否有足够的价值。\n老板招人最根本的看的是你能否将工作做好，之后在考虑你的品行时也是在借此衡量你在工作岗位中的价值和是否足够稳定。\n有礼貌、会说话等这些只能是在你价值足够的前提下才能起到一点儿锦上添花的作用。\n并且随着时代的发展和现代化的观念对于人们思想的革新，现在的中国那些过去的社交观念正在逐渐被革新，\n无论是职场、情场、生活等各个方面人们的思维都更加的偏向于现实性、且人与人之间的边界也在逐渐的更加清晰，\n过去的那一套靠“情分”来办事的法则已经在逐渐失效。\n所以我们要意识到：对于「共情朋友」你只能理直气壮地向他提出共情类的需求。\n比如当你难过时可以要求他陪伴你，当你无聊时可以叫他一起玩，当你开心时可以拉着他一起疯。\n但是当你们涉及到「功利性」的交际时，你应当按照「功利社交」的方式去和对方沟通。\n你的朋友再有钱，当你危难时他借钱帮助你这从来都不是理所应当的、这也绝对不是他的“义务”，\n你应该对此怀有感恩，并写下欠条算明利息。\n至于他要不要利息或是把这钱白送给你不要你还了，那是他的事情，\n你应该意识到的是「共情朋友」从来都没有义务对你做出「功利性帮助」的必要。\n而这同时也意味着，当你的「共情朋友」向你提出超出边界的需求时你完全有百分之一百的权利拒绝他。\n决定是否帮助他的选择权完全在你手上，你不应该为他的不幸或问题负责，\n你也完全不需要在拒绝了朋友的请求时心怀愧疚，而对方也完全没有任何的权利因为你不帮助他而斥责你。\n同时由此还可以延展出一个重要的观点就是——不要讨好别人。\n这个讨好不仅只是那种明显的、或是病态的低姿态对别人无底线的讨好，\n而是一切形式、一切场合、对任何人的讨好都是——无用的。\n当人们在面对价值比他高的人时，几乎都会本能的感觉到不同程度的「自卑」，\n这种自卑是源自于动物本能的对危险的恐惧，因为自然的生存法则是比你强大的个体拥有杀死你的能力和权力。\n因此当人们讨好别人时，其实最根本的动机是为了规避风险。\n还有第二个动机是希望从对方那里获得什么。\n获得对方的好感，获得称赞，获得亲密感，获得对方掌握的信息，获得对方手里的资源，等等。\n有很多人被自己总是会去讨好别人而困扰，他们一方面对自己总是习惯性的会在别人面前摆出低姿态这一点深恶痛绝，\n另一方面又会在面对别人时不由自主的放低自己的位置。\n他们很想不再去讨好别人，但却又总是控制不了自己。\n实际上任何一个惯于讨好的人，只要理解了一点之后马上就能停止讨好了。\n他需要理解的就是——讨好无用。\n讨好起不到任何作用，讨好不会令别人喜欢上你，讨好不会令别人接受你，\n讨好不会令别人看得起你，讨好不会让别人愿意平白无故的就帮你，讨好不会令别人把有价值的信息透露给你。\n你想从别人那里得到什么，这只取决于你自身的价值和你所用的手段。\n除非你只是一时的把讨好作为一种手段去和别人拉近关系，否则你只是在做着一件很蠢的事。\n因为讨好不仅无用，还会令别人认为你是低价值的，你越讨好越是会不受人待见，你越讨好越是会被别人不当回事。\n你理解了社交的本质，你理解了别人如何对待你最根本的是取决于你是谁、取决于你的价值，\n然后你还需要学会一种交际方式，你就能不卑不亢的和别人相处了。\n这种交际方式叫做**「对事不对人」**。\n我们绝大多数人在与人相处时都已经不知不觉中习惯了做价值评判与动机揣测，\n同时还会很容易在情绪出现波动时严重影响到理性和思维逻辑，\n尤其是在和别人意见不一致时，几乎所有人都会由“讨论”变成“维护自己的观点”\n从你的角度而言，你要在和别人沟通时停止对别人人格或价值上的评判，而仅仅是阐述事实。\n比如：\n小李你这个工作做得不好而不是小李你这个人真没用；\n阿强你在我危难那次没帮我而不是阿强你真没义气；\n小赵把狗熊推粪坑里了而不是小赵真是个智障；\n从别人对你的角度而言，当别人说你某事做得不好、某一行为有失分寸、某一场合举止失礼时，\n你应当理解为那的确只是对你的行为的评价、而不意味着对你整个人的否定。\n而同时，\n当一个人在与你沟通时总是对你做价值评判，或是借由一件事情攻击你、否定你，\n你应当意识到这绝对不意味着真的是你不好，而是对你做评判的人愚蠢且被情绪冲昏了头脑。\n如果你发现和一个沟通时经常会由就事论事的讨论转变为由情绪控制的攻击，那你应该直接放弃在今后和这个人交流的必要。\n一件很有意思的事情是，每次当我告诉别人：\n你最好放弃这个朋友、也许绝交是更好地选择、你应当更多地关注自己的感受不要为了迎合别人而委屈自己的时候，\n他们总会觉得我的这种观点太无情、太自私了。\n他们认为我对「友情」太过不尊重了，对待朋友也太过的随意。\n假如是一个从小玩到大的发小的话也能轻易放弃吗？再说如果按照我的这种 t 态度对待朋友，那估计身边的朋友会很少很少。\n首先我们应该意识到，衡量一个人是否能做你的朋友的标准从来就不是“你们认识了多久”、\n“你们的感情有多么深厚”这些问题，而是随着你的成长也在改变着的你的新的择友标准。\n要知道「人是会不断改变」的这句话是在意味着，随着你生命发展的不同阶段你的社交关系也必然要随着有所改变。\n而且在你没有明确自己的择友标准和交友原则之前，你所遇到的一切朋友其实只不过是“碰巧和你相遇的一些人”而已，\n你们只是因为每天见面，一起玩，一块聊天，然后就成为“朋友”了。\n如果按照这个标准，理论上来说你遇到的任何人只要和你相处的时间足够久就都能成为你的“朋友”了。\n所以实质上很多人所谓的“朋友”，只不过是「恰好认识了的人」而已。\n真正的「朋友」必然是有一定门槛、符合了你的一定要求，\n并且由于社会交际的随机性，再加上每个人一生中能分配在社交上的精力和时间都是有限的，所以：\n每个人其一生中真正的朋友「必然」是很少的。\n因此在对待社交时我们应该持有的一个心态是开放式、不强求、以自己的需求和评判标准为主导的。\n同时我建议你「尽可能的减少无效社交」。\n「当你的心智足够成熟/感觉自己在和一些朋友相处感觉很累/或者是你自己已经很清楚你不想再和某些人继续交往下去，\n但碍于面子又不好直接终结关系的时候，你应该直接终结这些关系」。\n当然很多人在看到这里的时候会说：以自己为中心怎么可能交到朋友，当你需要别人帮助、有求于人的时候你还能以自己为主导？\n同时他们可能还会担心：减少了朋友、和很多人终结了关系，那如果被群体排斥了怎么办？遇到了问题没有人帮忙怎么办？\n所以接下来的这个建议至关重要，并且也是我为你写这篇文章的核心目的：你要不断的提升自己的价值。\n要注意，我绝对不是在玩成功学、心灵鸡汤那一套吹嘘努力的重要性、鼓励你追求成功。\n相反，我的观点是：\n并不是人人都要成功，人应该做他自己，应该追求「他自己」想要的东西，而不是去迎合别人。\n所以这个「提升自己的价值」是建立在你「知道自己想要的是什么」的前提下。\n只有当你知道自己要什么，当你在做自己的时候，你才能够遇到「真正」的朋友。\n两个都在伪装，都在表演，都在为了生活而生活的人是不可能真的成为朋友的。\n因为他们都没有见到真实的对方，他们并没有真正的磨合，又怎么可能成为朋友呢？\n所以这整篇文章都是为了让你明白：做好你自己才是最重要的。\n社交和朋友不重要并不是说我们就完全不需要在意这些，\n而是因为「朋友」和「良好的社交关系」是在你「做好自己」之后自然而然就会伴随而来的。\n所以虽然我前面的话语写的虽然有些偏激和看起来好像有些极端，\n但实际上我绝对不是在告诉你你可以完全不在意人际关系了，你就完全的无情，完全以自我为中心，对别人非常强硬，不是这样的。\n你永远要记得在人际交往中一个最起码的原则是：不要主动去得罪别人。\n我希望的是，你通篇看下来之后能够对社交这个概念有一个真正的理解和透彻的认识，\n然后你在和别人相处的时候才能轻松自然，不再拘泥于人情礼节、不被别人道德绑架，不错误的为别人的问题负责。\n其实很多人都并不知道自己为什么要需要朋友。\n他们仅仅是从小被教育、模模糊糊的就被大人灌输了“朋友多了很好”“；多和其他人搞好关系”这类概念，\n就理所当然的接受了要多和别人交友的这种设定。\n并且，社会将没有朋友、不爱交际就定义为“孤僻的”、“奇怪的”，大人们都会认为孩子不爱交际就是不好的。\n实际上随着逐渐的成长你会发现，其实我们的社交需求真的并没有那么的重要。\n可能我们很多人在人际交往中感受到更多的并不是友情带来的快乐和开心，\n而是不得不伪装的痛苦，和早已疲惫的应付，所以我不明白的是，为什么很多人要勉强自己。\n就像很多人其实并不喜欢读书，他们没有并不想多么成功，他们也不想做个好人，他们觉得衣服随便穿穿就好，\n他们觉得没必要为了权力地位金钱什么的活的那么累，他们想要的可能是那些只有少数人才想要的，\n他们并不想去关心房地产、汇率、股市等这些概念，他们可能觉得买房子装修好麻烦还不如租一辈子房子比较轻松，\n他们可能觉得并不需要亲密关系所以单身一辈子更自在，等等。\n但是他们却在社会和环境的影响下，做着自己不喜欢做的事，追求着自己并不想要的东西，伪装成自己并不想成为的人，\n挑选“别人会觉得好看”的衣服，做着“别人”会羡慕的工作，为了“物质”或是“稳定”而和一个自己并不想要得到的人结婚。\n他们日复一日的这样生活着，他们的内心无时无刻不被痛苦和迷惘折磨着。\n他们去找那些心理咨询师，质问自己怎么了，他们迫切的想找到答案，为什么自己不开心，为什么自己活的这么累，\n为什么自己总是时常会感到人生没有意义，为什么世界上有这么多的不如意和痛苦，为什么自己总是很纠结很矛盾。\n其实答案很简单：\n他们根本就没有在活着。\n他们并不真的是他们自己，他们只是在扮演一个角色，在迎合别人的眼光，为了获得父母的认可，\n为了让伴侣不离开自己，为了不丢失一份能户口的工作，为了不去面对自己所害怕的事物，\n为了避免错误和别人异样的看法，为了避免“未来”的风险，为了为“以后”做打算，为了…………\n只要你还是要拒绝成为你自己，只要你还是要拒绝为自己负责，那么任何理由你都可以拿来当借口。\n但是现在只要你愿意真正的活过来，只要你下定了决心不再为了别人而活，只要你理解了人生的本质，\n那么你现在就可以卸下那些伪装，你可以试着去追求你想要的生活，你现在就可以开始制定开始新生活的计划，\n你现在就可以成为你自己。\n其实当你真的开始去做，不，甚至是你当你开始考虑的时候你就可以发现，\n你所畏惧的那些其实都并不真的都是那么的困难，很多问题也并不是无解的而是只要你愿意去做，都的确是有解决的办法的。\n问题只是在于你有没有愿意去解决问题的决心而已。\n那么到这里有些人可能已经在头脑中有了一些想法了，但是他们对于什么叫做“做自己”，\n怎样“成为”自己这个问题还是会感到有些无所适从，因为当他们在思考怎样做自己的时候马上又会冒出来下一个问题：\n什么是“自己”？自己要做什么才算是“做自己”呢？\n当你在思考这个问题的时候，你是找不到答案的。因为所谓的“自己”根本就不存在。\n那既然自己不存在还怎么做自己？\n不需要想这个问题。\n让自己放松，让自己感到舒服，吃你爱你的食物，买你喜欢的衣服，看你爱看的电影，\n和你喜欢的人在一起，做自己喜欢做的事情，不着急，慢慢来。\n这就是活着。\n","permalink":"https://note.yxzi.xyz/note/view/gam/%E7%A4%BE%E4%BA%A4%E7%9A%84%E6%9C%AC%E8%B4%A8/","summary":"社交的本质 我想用这一篇文章阐明社交的本质，从而在根本上终结所有的社交问题。\n这篇文章一共七千多字，写到最后的时候我有一种预感，这篇文章可能会改变很多人的一生。\n社交在本质上分为两种。\n一种是**「共情社交」，一种是「功利社交」**。\n共情社交 共情社交是指为了获得情感联结与情感体验，打发无聊，或是有共同的兴趣等而产生的社交行为。\n这种社交不涉及利益的交换，且绝大多数人自小产生的社交行为都是源于这种共情类的需求。\n随着一个人年龄的增长，他的共情社交会逐渐的减少；\n并且在同一年龄与阶层中，一个人的心智越成熟、能力越强、社会地位越高，他的共情社交就会越少。\n这就是为什么很多人会觉得越长大越孤单，越长大朋友越少，越长大越难和别人交心；\n还有为什么两个原本社会地位一样的人，其中一个发达了之后就会疏远另一个的原因。\n共情社交存在的根本原因是在于：当一个人的心智尚未成熟独立时，或是当他社会阶层较低、生活不如意时，\n他需要从朋友那里获得情感上的联结和支持。\n在生活中那些越成熟、越独立的人就越是对共情社交不在乎。\n因为他们的人格和在社会上生存的能力足够完善，无论是情感还是物质，他们都不需要“朋友”来给他们提供支持。\n那么有些人可能会说了，那还有一些明明心智很成熟、也很热爱社交的“交际花”，这又如何解释呢？\n那是因为，那些交际花要么只是单纯地喜欢「和很多人一起玩」这件事而已，就和一个人喜欢骑马、喜欢打球一样。\n他就算不和这群人玩，和另一群人一起嗨也是一样。\n即便他长期的喜欢和某一群人一起玩，那也是因为就像你骑马时特别喜欢某一匹，打球时某一球拍用的最顺手，仅此而已。\n只不过是当面向的对象变成人时，也多多少少的会被掺杂上一些情感的因素。\n要么是他建立这么多的社交关系只是为了筛选出足够有价值的「功利社交」的对象，\n他在做的事情只是依托着“社交”这一表象进行互利伙伴的挑选与关系建立罢了。\n人与人交往的本质是利益交换\n利益分为物质利益和精神利益，很多人其实就是没有认识到“精神利益”其实是“利益”的组成部分。\n人类社会就是通过各种利益交换凝聚起来的，“感情”本身就是“利益”的一部分。\n利益交换并不只限于物质对物质，精神对精神。精神利益与物质利益的互换是最常见的事情。\n“钱”就是沟通精神利益与物质利益的重要纽带。\n比如：\n 亲子关系：也许在有些人看来，“亲子关系”不会涉及到利益。但实际上，亲子关系是很典型的精神利益与物质利益的互换。 施舍行为：施予者获得的是精神上的愉悦，受助者获得的是物质上的帮助 + 精神上的愉悦。只要双方都是自愿，这就是个互利双赢的事。 文艺演出：看演出的人得不到任何物质利益，但依然愿意花钱买票。这就是精神利益的价值体现。  所以说“人与人交往的本质是利益交换”是一种很合理的说法。\n不要认为理智会伤害感情，实际上只有以理智为前提，才能拿捏好各种感情的分寸，让大家都过得开心。\n功利社交 功利社交是指为了达成某一目的，或是从对方身上获得利益而产生的社交行为。**\n这种功利性社交在小孩子一开始挑选玩伴的时候就已经产生了：\n比如在班级里面大家都倾向于和零食最多、玩具最多的小孩做朋友；\n我们都喜欢和不会欺负我们、不会抢我们东西的人一块玩；\n如果你的干脆面每天都分给一个小朋友一半而他却从来不分给你，那你最后会放弃这个朋友；\n随着一个人心智的完善和社会地位的提升，他会越来越注重社交的「效益性」。\n即一段社交关系能带给他怎样的利益，和这个朋友继续交往有没有价值，甚至是和一群老朋友一起吃饭还有没有必要。\n「功利社交」有两个基本前提：\n有效信息的交互传递 这个信息是广义的，在人际交往中的如语言、情感、物质、知识等都可以包括在这个信息的范畴内。\n沟通的本质就是信息的传递。\n而有效是功利性社交的一个基本要素。人们产生功利社交行为之前基本上都是抱有一定的目的性的，\n当我和你产生社交时，我们的交流应该是有价值的，而不是毫无意义的闲扯和浪费时间的各说各话。\n一个最起码的前提是，我们能够理解双方所表达的意思。\n你和一个没玩过 LOL 的人谈论补刀和打野技巧，和一个不懂金融的人谈股票，\n你给一个廉洁公正的领导送礼希望提拔你，那么这样的“沟通”就是无意义的。\n较为对等的价值水平 这个价值水平并不仅仅只是指社会地位。它依据的是具体情况和个人的评判标准。\n比如你是个百万富翁，你最喜欢看别人翻跟头，那么一个翻得一手好跟头的乞丐或是白领或是小商贩对你而言都是有价值的。\n那如果这个翻得一手好跟头的人也同时渴望一个有钱的朋友，那你们的价值水平就算是“对等”的。\n而如果这个翻得一手好跟头的人视金钱如粪土，他只喜欢会踩高跷的朋友，\n那你这个百万富翁对他而言就是无意义的，你们的价值水平就并不对等。\n功利性社交的根本目的就是能够从对方那里获得一定的利益或是得到帮助，\n如果一个人和你的差距极大，你很清楚这个人在未来的生活中不可能给你带来丝毫的利益，\n那么这段社交关系对于你而言就是无价值的，所以你本能的就会舍弃。\n一个人的心智成熟到一定程度后，他对共情社交的需求会下降到几乎为零。\n旧的社交关系只有在两个人还能够产生有效交流的前提下才能继续维持。\n大多数情况是：\n你的那些比你强的朋友在默默地舍弃了你，而你也悄悄地舍弃了那些比你弱的朋友。","title":"社交的本质"},{"content":"祁克果 与其寻找那唯一的真理，不如去寻找那些对个人声明具有意义的真理。\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E7%A5%81%E5%85%8B%E6%9E%9C/","summary":"祁克果 与其寻找那唯一的真理，不如去寻找那些对个人声明具有意义的真理。","title":"祁克果"},{"content":"穷人为什么要生孩子 明明很多父母连一个最基本的经济条件都给不了孩子，比如没有房，没有车，甚至没有稳定的工作，但他们依旧会决定生孩子。\n我觉得这是非常不理智的行为，因为明明两个人都无法做到维持一个良好的生活水准，更别提三个甚至四个，\n彩票心理 你去贫穷落后一点的农村去体验一下生活、观察对比一下就知道了，因为他们生的并不是“孩子”，而是在买一张彩票。\n这一张彩票会随机开出：低成本的劳动力/没人要的箩底橙/换嫁妆的好货色/草窝生的金凤凰/没心肝的亏本货/憨厚的养老保险/……\n这一张彩票的成本说低不低，起码得十月怀胎，不过一旦开出好的一注，收益率就会很高。\n特别是每一个人买彩票都会觉得自己能中五百万，这是人之常情，\n对于精神层面与物质层面越贫乏的人来说，他们对于这种“一注赌票、一飞冲天”的渴求就更高。\n尤其是这一份彩票的投资还可以经过“人力”来控制：\n对于底子不好的，一眼就知道她是箩底橙，只需要给最低的资源，尝试将她转化成“低成本的劳动力”；\n或者干脆将 Ta 抛了，不要计较沉没成本，还能继续搏下一注。\n对于底子好的，可以多给一些资源，培养成换嫁妆的好货色，这就是稳赚不赔了。\n草窝生的金凤凰是 500 万，贪心不得，不过憨厚的养老保险好弄。\n尤其是当整个社会都处于被封建儒教的规矩桎梏的环境下，更是有着地利人和的培养条件。\n古代人物质条件那么差为什么还愿意生孩子？其实现在也有很多人愿意生孩子，只不过你看不到罢了。\n为什么有钱的国家生育率都很低？因为他们的人终于意识到了自己是在生孩子，而不是买彩票。\n当然有一点是很重要的，必须要提出来，姑且称之为“大事惯性问题”。\n就是说大部分古代人其实既没有思考、也没有选择，只能随波逐流，伴随着一种“大家都在生，我也要生”的状况。\n这其实就是时代因素影响的一个体现了，这当然是非常重要的。\n最后再解释一下，因为“彩票心理”看起来有些冰冷阴沉，而且原文本比较简单、不够严谨，所以会容易产生误解，\n以为我是在愤世骇俗，批判“孝”文化、批判亲情什么的。\n这里想要说一下的，我并不批判“孝”文化，并不批判亲情，并不批判生儿育女。\n繁衍后代是所有生物与生俱来必然需要遵守的自然规律，没有繁衍后代功能的，\n要么是永生不死的神灵，要么已经消失在这个世界了，我自然不会批判繁衍后代。\n我认为人生而平等。一对父母，生下了一下孩子，无论 TA 是男的、女的，应该平等对待。\n你生了 TA 下来，不该把 TA 当成商品/牲口/彩票/……而是应该把 TA 当成人，那么 TA 才会、才应该报答你，孝敬你。\n否则，这对孩子来说不公平。我想说的是，现在有很多人都没有意识到这样的问题，\n也有很多人自己已经处于这样的环境中，却以为这是“理所当然、天经地道”的，事实上并非如此。\n我们都需要思考，如果你有能力，可以尝试改变。\n其实如果是一直在城市里生活长大的，我认为真的可以去一些稍微贫穷、落后一些的郊区啊、农村啊之类的地方去看一下，\n这对于认识世界真的很有好处。\n投入少，回报多 首先确定一个问题，贫困家庭即使一个不生，也改变不了贫困家庭的处境。\n然后，多生几个孩子，如果单纯把孩子养活拉扯大，\n其实对于贫困家庭来说还是能办到的，无非一天两顿饭，东拼西凑凑几套衣服。\n老大穿好了传老二老三老四最后打补丁继续用。\n我们现在觉得孩子养大是很大的负担因为考虑的太多，从怀孕开始，甚至孕前，\n做一系列检查，生产后还要定期检查，打疫苗，买进口奶粉，辅食，营养品；\n一次性纸尿布，衣服，儿童用的洗发精，肥皂，牙膏牙刷，玩具等等。\n长大一点了要投入补课，兴趣班甚至花几十万去弄个好学校或者买套学区房；\n而这些，对于只想把一个人养大，可以说是通通不需要。\n说不好听的，一个小孩子饭量还不如一条大狗，等孩子的饭量超过一条大狗了，也基本能当劳力用了。\n等到自己老的干不动活，也有孩子给自己提供吃喝，完美。\n孩子大一点要读书了，有义务教育，再大一点如果运气好考进大学了，家里有钱就凑凑，没钱就不让去读了，很正常。\n或者初中毕业就不让读书了，也差不多能当大半个劳力了。\n平时省一口，养个十几年，能给家里多一个可以用几十年的壮劳力，这个买卖是很划算的。\n所以为什么重男轻女，这是其中之一，对他们来说女的是赔钱货，要负责养活大，大了什么都捞不到，因为要嫁人。\n而且这样家庭长大的孩子还特别容易感恩，贫困家庭意味着没有存款，没什么家当，\n也就意味着父母老去之后是没办法自己给自己养老的。\n所以父母从小灌输一个思想，我们那么不容易还拉扯你们长大，你们长大了可要对我们好。\n孩子从小感受到的也是这个，因为从小耳闻目染看到的一切都是一个字：穷。\n父母在那么穷的情况下，还能把我拉扯大，父母多不容易，加上父母从小到大不断的洗脑，\n所以我长大了要对父母好，我将来赚钱了要先给他们花。\n凤凰男，扶地魔不就是这么来的嘛。\n你跟他们讲道理，没道理讲的，因为他们觉得孝敬父母，给家人好处就是天经地义的真理，\n在真理面前是没有对错的，真理是永远正确的。\n现在很多人不愿意生孩子，因为他们看到孩子等于看到负担，也就是投入大回报未必大，甚至是负回报，\n那感觉这个买卖不划算，所以选择不生。但如果看到生孩子是小投入大回报，那就肯定很乐意生了，生越多回报越大。\n这个是本质的区别，一个看投入，一个看产出。\n再说的难听点，贫困家庭你白给他们几头小牛犊，他们会不会要？\n肯定会要，因为投入一点点把小牛犊养大了就是几头壮牛，能干活，能换钱，对于贫困家庭来说这个就是财富。\n但对于贫困家庭来说，牛不可能免费给，但孩子可以基本免费的给，在自己床上就能解决问题，反正闲着也是闲着。\n所以越穷越要生，因为孩子是他们能力范围内能得到的最大资源和财富。\n","permalink":"https://note.yxzi.xyz/note/view/society/%E7%A9%B7%E4%BA%BA%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%9F%E5%AD%A9%E5%AD%90/","summary":"穷人为什么要生孩子 明明很多父母连一个最基本的经济条件都给不了孩子，比如没有房，没有车，甚至没有稳定的工作，但他们依旧会决定生孩子。\n我觉得这是非常不理智的行为，因为明明两个人都无法做到维持一个良好的生活水准，更别提三个甚至四个，\n彩票心理 你去贫穷落后一点的农村去体验一下生活、观察对比一下就知道了，因为他们生的并不是“孩子”，而是在买一张彩票。\n这一张彩票会随机开出：低成本的劳动力/没人要的箩底橙/换嫁妆的好货色/草窝生的金凤凰/没心肝的亏本货/憨厚的养老保险/……\n这一张彩票的成本说低不低，起码得十月怀胎，不过一旦开出好的一注，收益率就会很高。\n特别是每一个人买彩票都会觉得自己能中五百万，这是人之常情，\n对于精神层面与物质层面越贫乏的人来说，他们对于这种“一注赌票、一飞冲天”的渴求就更高。\n尤其是这一份彩票的投资还可以经过“人力”来控制：\n对于底子不好的，一眼就知道她是箩底橙，只需要给最低的资源，尝试将她转化成“低成本的劳动力”；\n或者干脆将 Ta 抛了，不要计较沉没成本，还能继续搏下一注。\n对于底子好的，可以多给一些资源，培养成换嫁妆的好货色，这就是稳赚不赔了。\n草窝生的金凤凰是 500 万，贪心不得，不过憨厚的养老保险好弄。\n尤其是当整个社会都处于被封建儒教的规矩桎梏的环境下，更是有着地利人和的培养条件。\n古代人物质条件那么差为什么还愿意生孩子？其实现在也有很多人愿意生孩子，只不过你看不到罢了。\n为什么有钱的国家生育率都很低？因为他们的人终于意识到了自己是在生孩子，而不是买彩票。\n当然有一点是很重要的，必须要提出来，姑且称之为“大事惯性问题”。\n就是说大部分古代人其实既没有思考、也没有选择，只能随波逐流，伴随着一种“大家都在生，我也要生”的状况。\n这其实就是时代因素影响的一个体现了，这当然是非常重要的。\n最后再解释一下，因为“彩票心理”看起来有些冰冷阴沉，而且原文本比较简单、不够严谨，所以会容易产生误解，\n以为我是在愤世骇俗，批判“孝”文化、批判亲情什么的。\n这里想要说一下的，我并不批判“孝”文化，并不批判亲情，并不批判生儿育女。\n繁衍后代是所有生物与生俱来必然需要遵守的自然规律，没有繁衍后代功能的，\n要么是永生不死的神灵，要么已经消失在这个世界了，我自然不会批判繁衍后代。\n我认为人生而平等。一对父母，生下了一下孩子，无论 TA 是男的、女的，应该平等对待。\n你生了 TA 下来，不该把 TA 当成商品/牲口/彩票/……而是应该把 TA 当成人，那么 TA 才会、才应该报答你，孝敬你。\n否则，这对孩子来说不公平。我想说的是，现在有很多人都没有意识到这样的问题，\n也有很多人自己已经处于这样的环境中，却以为这是“理所当然、天经地道”的，事实上并非如此。\n我们都需要思考，如果你有能力，可以尝试改变。\n其实如果是一直在城市里生活长大的，我认为真的可以去一些稍微贫穷、落后一些的郊区啊、农村啊之类的地方去看一下，\n这对于认识世界真的很有好处。\n投入少，回报多 首先确定一个问题，贫困家庭即使一个不生，也改变不了贫困家庭的处境。\n然后，多生几个孩子，如果单纯把孩子养活拉扯大，\n其实对于贫困家庭来说还是能办到的，无非一天两顿饭，东拼西凑凑几套衣服。\n老大穿好了传老二老三老四最后打补丁继续用。\n我们现在觉得孩子养大是很大的负担因为考虑的太多，从怀孕开始，甚至孕前，\n做一系列检查，生产后还要定期检查，打疫苗，买进口奶粉，辅食，营养品；\n一次性纸尿布，衣服，儿童用的洗发精，肥皂，牙膏牙刷，玩具等等。\n长大一点了要投入补课，兴趣班甚至花几十万去弄个好学校或者买套学区房；\n而这些，对于只想把一个人养大，可以说是通通不需要。\n说不好听的，一个小孩子饭量还不如一条大狗，等孩子的饭量超过一条大狗了，也基本能当劳力用了。\n等到自己老的干不动活，也有孩子给自己提供吃喝，完美。\n孩子大一点要读书了，有义务教育，再大一点如果运气好考进大学了，家里有钱就凑凑，没钱就不让去读了，很正常。\n或者初中毕业就不让读书了，也差不多能当大半个劳力了。\n平时省一口，养个十几年，能给家里多一个可以用几十年的壮劳力，这个买卖是很划算的。\n所以为什么重男轻女，这是其中之一，对他们来说女的是赔钱货，要负责养活大，大了什么都捞不到，因为要嫁人。\n而且这样家庭长大的孩子还特别容易感恩，贫困家庭意味着没有存款，没什么家当，\n也就意味着父母老去之后是没办法自己给自己养老的。\n所以父母从小灌输一个思想，我们那么不容易还拉扯你们长大，你们长大了可要对我们好。\n孩子从小感受到的也是这个，因为从小耳闻目染看到的一切都是一个字：穷。\n父母在那么穷的情况下，还能把我拉扯大，父母多不容易，加上父母从小到大不断的洗脑，\n所以我长大了要对父母好，我将来赚钱了要先给他们花。\n凤凰男，扶地魔不就是这么来的嘛。\n你跟他们讲道理，没道理讲的，因为他们觉得孝敬父母，给家人好处就是天经地义的真理，","title":"穷人为什么要生孩子"},{"content":"笛卡尔 我思故我在 在他开始构建终究的哲学体系之前，必须先挣脱前人理论的影响。\n他怀疑每一件事，而这正是他唯一能够确定的事情——有一件事情必定是真实的，那就是他怀疑。当他怀疑时，它必然是在思考，而由于他在思考，那么他必定是个会思考的存在者。\n如果世上没有所谓的完美实体，我们也不会具有完美实体的概念。因为我们本身是不完美的，所以完美的概念不可能来自于我们（一个本身并不完美的人）。\n一个概念的存在，那么这个概念的实体也必定存在，否则这个概念就不存在。\n二元论者，他认为灵魂和物质（扩延）是分别独立的，其中物质是可以被分解的，但灵魂却不能被分解。\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E7%AC%9B%E5%8D%A1%E5%B0%94/","summary":"笛卡尔 我思故我在 在他开始构建终究的哲学体系之前，必须先挣脱前人理论的影响。\n他怀疑每一件事，而这正是他唯一能够确定的事情——有一件事情必定是真实的，那就是他怀疑。当他怀疑时，它必然是在思考，而由于他在思考，那么他必定是个会思考的存在者。\n如果世上没有所谓的完美实体，我们也不会具有完美实体的概念。因为我们本身是不完美的，所以完美的概念不可能来自于我们（一个本身并不完美的人）。\n一个概念的存在，那么这个概念的实体也必定存在，否则这个概念就不存在。\n二元论者，他认为灵魂和物质（扩延）是分别独立的，其中物质是可以被分解的，但灵魂却不能被分解。","title":"笛卡尔"},{"content":"绿幕抠像  导入图像。 新建合成——右击图层中的图像——效果——Keying——Keylight(1.2)。 Screen Color——吸管——点击图像中的绿色部分——关闭切换透明网格。 View——下拉框 Screen-Matte——增加 Screen Gain。 Screen-Matte——调整 Clip black/Clip White（使图像中的黑色和白色更加纯粹）。 View——下拉框 Final Result。 消除图像边缘的锯齿。 右击图层中的图像——效果——遮罩——简单阻塞工具——调整阻塞遮罩（使图像边缘的锯齿消除）。  ","permalink":"https://note.yxzi.xyz/note/technology/software/after-effects/%E7%BB%BF%E5%B9%95%E6%8A%A0%E5%83%8F/","summary":"绿幕抠像  导入图像。 新建合成——右击图层中的图像——效果——Keying——Keylight(1.2)。 Screen Color——吸管——点击图像中的绿色部分——关闭切换透明网格。 View——下拉框 Screen-Matte——增加 Screen Gain。 Screen-Matte——调整 Clip black/Clip White（使图像中的黑色和白色更加纯粹）。 View——下拉框 Final Result。 消除图像边缘的锯齿。 右击图层中的图像——效果——遮罩——简单阻塞工具——调整阻塞遮罩（使图像边缘的锯齿消除）。  ","title":"绿幕抠像"},{"content":"关于自控力 很多人觉得自己计划完不成，拖延，生活中养成种种恶习的根源在于自制力不强，\n以为增强了自制力，一切问题就能迎刃而解——这个想法是错的，自制力并不是解决这些问题的关键。\n自控力的假象与真相 不知道大家有没有这样一种感觉：\n高考前是自己学习力和自控力的巅峰，那时候每天都要做好多题，学到很晚，但第二天还是精神抖擞，继续奋战；\n上了大学之后，时间宽裕了，反而变得懒散了，没有之前学习的劲头和毅力了，\n到了假期更是懒得一发不可收拾，熬夜看剧、晚睡晚起、暴饮暴食那都是家常便饭。\n为什么会这样呢？难道时间越宽裕，自控力就越薄弱？这显然不科学。\n那就是因为时间越宽裕，我们越容易懈怠和堕落？但这是结果，并不是原因。\n我们以为自己的自控力曾经很强，上大学后变弱了，放假后则因为懈怠愈发孱弱——这其实这个假象。那真相是什么？\n因为保证我们高效运转的其实是习惯，而不是自控力。\n想想在高考之前的那种紧张的学习氛围里，我们被动的养成了很多习惯：\n每天规律的上课、自习、吃饭和睡觉，我们目标明确——每个月、每个星期乃至每天复习什么，老师们都替我们安排好了。\n这些我们习以为常，就像你每天早上起床都会自动去刷牙一样自然。\n你想想想你起床后刷牙的过程：穿衣服（好吧我知道有人不穿），拿起杯子和牙刷，走到卫生间，接水，挤牙膏，开始刷。\n即使你可能还睡眼惺忪，但这一套流程你仍然能精确无比、毫不费力的执行下来。\n这个过程需要一丢丢的自控力吗？基本不需要对不对？\n所以高中的那些学习，其实并不需要太多自控力。\n而当你进了大学，课程安排变得自由了，你丧失了那些被动习惯，开始自己规划学习和生活时，才是需要自控力的时候。\n而此时，很多人不得不面对第二个真相：\n人的自控力是有限的 自控力和肌肉力量一样是有限的。\n这个结论被大量的心理学实验证明，大家上网搜索一下就能看到，我这里不做赘述，\n我只打个比方，相信能帮你更好的理解这个结论：\n想象下，当你搬宿舍、或是换教室时，你把一摞又一摞沉重的书本，吃力的从这个屋子搬到那个屋子之后，\n你双臂酸软，腰酸背疼，严重者可能连一杯水都举不起来，这是因为你的肌肉力量耗尽了。\n自控力也一样，我们在日常生活中要面对各种各样的诱惑：\n桌上昨天新买的一大堆零食，双十一淘宝主页玲琅满目的商品，男神胡歌的新剧又开播了……\n我们要反复抵抗这些诱惑才能专注于那些重要的目标——比如学习和减肥。\n每拒绝一次诱惑，你的自制力就消耗一分，如果面临的诱惑太多，\n总会有一个时刻，我们会累到无力抵抗，任由暴饮暴食、刷爆淘宝、熬夜看剧这些行为支配我们的生活。\n当然现实没有那么可怕，肌肉酸痛过两天会恢复，自制力嘛，你睡个好觉也能回归正常。\n有意思的是，不同人天生力气不一样，自制力强弱也不一样，\n自制力超群或是弱到掉渣的，在人群中都占很小的比例，大多数人都处在中间那个状态——不好也不坏。\n所以我们得出的结论是：学霸就是那群天生自制力超群的人？如果是这样，那这篇文章也太没意思了。\n有机智的童鞋马上反应过来了：\n哦！既然我们可以锻炼肌肉，自制力也是可以锻炼的，对吧！我们只要把自制力锻炼到很强就可以了！\n这话没错，然而肌肉力量有极限，自制力也是有极限的。\n生活中，我们面临的诱惑如此之多，靠后天锻炼出来的自制力依然会不够用。\n另一方面：\n无论是校园里的“学霸”，还是社会里的精英人士，其高效的学习和生活，\n并不像我们往常以为的那样，依赖于强大的自制力，而是得益于后天构建起来的习惯体系。\n如何利用我们有限的自制力，去构建这样一套体系，才是这篇文章最想说的东西。\n但是构建习惯体系，并不是一件轻松的事情，原因有两个：\n1.很多人没有意识到，有一个看不见的敌人在阻挠我们的行动，\n2.很多人不知道，习惯背后的原理。\n看不见的敌人 很多人都想要减肥，想要健身，但大多数人的状况是：\n决定要减肥或健身后，制定了详细的计划，买了一堆装备，办了几千块的健身卡，却在去了不到三次后，将这些东西都束之高阁。\n为什么建立一个锻炼的习惯这么难呢？因为太多人不了解习惯背后的原理，更重要的原因是：\n太多人太急了，太想在短期内看到显著的改变。\n是的，我们都希望一夜暴富，一朝成名。\n都喜欢看“穷小子白手起家创业成功，一年变身亿万富翁”，\n“胖女孩半年瘦身八十斤俘获男神芳心”的故事。但这些不是我们的错，\n我们之所以天生短视，喜欢即时的反馈和满足感，是因为大脑里，住着一个看不见的敌人在捣乱。\n首先你得意识到它的存在，然后才能战胜它。\n在几百万年前，我们的祖先还茹毛饮血的时候，资源稀缺，吃了上顿没下顿，大脑需要持续的分泌化学物质，\n它们促使人们去寻找并摄入食物，热量越高越好，把自身的脂肪储存的越多越好；如果不是这种机制，人类很可能存活不到今天。\n可我们不是原始人，我们进化出了更高级的控制单元，\n所以我们学会了计划，学会了为达成长期目标放弃短期利益。\n但原始的那部分大脑并没有消亡，它依然在时刻争夺着身体的控制权，促使我们孜孜不倦的寻求即时的满足感。\n所以你明白了吗？为什么在认真学习时，忽然会冒出“学这么久了，看一集美剧吧！”的念头；\n为什么晚饭吃了不少，睡前还是管不住自己伸向零食的手；\n为什么你打开手机想要背单词，却鬼使神差的戳开了微博；\n这些的本质都是原始大脑在作怪。\n好了，看到这里，你意识到敌人的存在了，即大脑的原始部分；\n你也意识到它惯用的伎俩——即时满足感。但这还不够，要打败它，你得掌握科学的武器，也就是习惯的原理。\n习惯的原理 习惯的养成，依赖于四个部分：触机（cue）、惯性行为（routine）、奖励（reward）和信念（belief）：\n **触机：**即触发习惯的原因，你可以想象成手枪的扳机，按下扳机，子弹就打出去了。习惯的触机有很多，可能是时间、地点或场景。你早上刷牙的触机是起床这个动作；去吃午饭是因为时间到了（额，好吧，还有肚子饿了）；有人习惯睡前刷微博，那么触机可能是你躺下来盖上被子。触机本身没有好坏之分，决定习惯好坏的，是它引发的惯性行为。 **惯性行为：**之所以叫惯性，是因为它是无意识的，比如一打开电脑就先上网看看娱乐新闻；比如睡前一定要刷一下朋友圈。在建立新习惯的过程中，我们的自制力，就用于修正那些引起拖延的旧行为，将其替换为新的惯性。在更正坏习惯时，你需要格外留意引发它的触机，同时关注自己的行为，不断提醒自己不要重蹈覆辙。这一步是最消耗时间和精力的过程，可能要与旧习惯反复拉锯，因为良好惯性行为的建立不仅需要有自制力去克服旧的行为，还需要在行为结束时获得正向的反馈，也就是下面要说的“奖励”。 奖励：这是习惯养成中至关重要的一环，它往往被人们忽略。为什么坏习惯容易养成且难以改变？因为它们的奖励往往即时而明显：打游戏、刷网页、吃零食这些哪个不是这样？好习惯难以形成，也恰恰因为短期的奖励不够明显。背单词、健身、练书法这些行为往往需要较长的时间才能看到效果，有些人天生能从过程中获得精神激励，但很多人不行，那我们需要人为的赋予自己奖励：比如记录自己的成长和进步、时不时发个微博鼓励下自己、达成一些小目标时吃顿好的庆祝下等等（啊喂也不要暴饮暴食啊！） 关于奖励，稍稍多说几句。诸如学习、健身这种事本身是有点反人性的，有没有什么办法能快速建立正向奖励机制呢？这个展开能写两本书\u0026hellip;知乎上有很多学习、健身相关的优质答案了，我这里不赘述。我想提供一种思维：积极的、开放性的、成长性的思维。即多去看看那些享受学习、享受健身的人是怎么做到这些事情的，尝试去学习他们的方法，把目光放在积极面上，而不是怀疑自己能力不行，觉得自己做不好。 此外，强化你的“信念”有助于你获得精神上的正反馈。 信念： 这是支撑你建立习惯的内在动力：你想要每天背单词，是为了干掉英语考试；你想要学会弹吉他，是为了能在各种晚会上一显身手；你想要规律饮食、早睡早起，是为了身体健康；你想要健身减肥，可能是想俘获女神/男神的芳心。总之，你是想成为一个更好的人。信念能让你你在养成好的习惯时获得精神上的正向反馈，同时，你的信念越强烈，就越能忍受改变过程中的痛苦与反复。\n 接受自己是个普通人 真的，大家都是普通人，承认这一点没啥可耻的。\n拿我最喜欢的肌肉模型举例子吧，我始终觉得，建立习惯也好，培养能力也好，都跟锻炼肌肉是一码事：\n你今天只能举 30 斤的哑铃，下周你最多举 35 斤，你不能说明天我就要举 60 斤。\n如果你之前从没去过健身房，不要指望刚开始一周能去三次，更科学的计划，是从一周去一次做起；\n如果你之前沉迷游戏，一周打七天，不要指望明天就能戒掉它，科学一点的目标，是下周只打六天。\n对于一般人，一个月能建立一到两个习惯就很不错了\n不要太贪心，你真能做到，一年下来至少养成 12 个习惯，你能够爆掉大多数人了。\n允许自己失败，允许自己休息。\n少一些苛责，多一些鼓励 我们从小到大接受的教育，太过于强调严格自律和自我批评，却很少教我们如何鼓励自己。\n太多人放弃改变，是因为在反复的失败后，用批评和苛责扑灭了自己内心的火种。\n计划失败了，大多数人会羞愧，会痛苦，会责骂自己。\n但少有人去安慰自己，告诉自己“没关系，你是个普通人，你总会有脆弱的时候”；\n少有人像鼓励朋友一样鼓励自己，跟自己说“加油，还有机会，来！想一想下次怎么可以做得更好”。\n真的，在与欲望和弱点搏斗的过程中，我们大多数时候是没有队友的，你只有自己给自己打气。\n嗯，有人担心过多的自我安慰会让自己松懈，所以我要强调的最后一点，是行动。\n行动起来，从现在开始 无论你苛责还是鼓励自己，最后引发改变的，是行动。\n想做什么，现在就开始做吧，不要等到以后。在我的认知中，90%的“明天再说”等于“明天就忘” 。\n想看书的，今晚睡前就拿起来，哪怕只看一页；\n想锻炼的，今天就蹦跶起来，哪怕只是一组 4 分钟的燃脂训练；\n想学画画的，今天就画起来，哪怕就画一个水杯。\n只要你做了，无论多少，你都是在行动，都是改变，而如上一点所说：再微小的改变，都值得褒奖。\n这里贴一段特别喜欢的一段话：\n 没有人生来完美，每一个趋近于优秀的人格，都是经过了多次自我改造的结果。\n没有试图去改变的人，继续重复着自己日复一日的生活，看着那些早已看过的烂熟于心的风景，\n而对于正在改变的人来说，每一天都是新的。\n ","permalink":"https://note.yxzi.xyz/note/view/grow/%E5%85%B3%E4%BA%8E%E8%87%AA%E6%8E%A7%E5%8A%9B/","summary":"关于自控力 很多人觉得自己计划完不成，拖延，生活中养成种种恶习的根源在于自制力不强，\n以为增强了自制力，一切问题就能迎刃而解——这个想法是错的，自制力并不是解决这些问题的关键。\n自控力的假象与真相 不知道大家有没有这样一种感觉：\n高考前是自己学习力和自控力的巅峰，那时候每天都要做好多题，学到很晚，但第二天还是精神抖擞，继续奋战；\n上了大学之后，时间宽裕了，反而变得懒散了，没有之前学习的劲头和毅力了，\n到了假期更是懒得一发不可收拾，熬夜看剧、晚睡晚起、暴饮暴食那都是家常便饭。\n为什么会这样呢？难道时间越宽裕，自控力就越薄弱？这显然不科学。\n那就是因为时间越宽裕，我们越容易懈怠和堕落？但这是结果，并不是原因。\n我们以为自己的自控力曾经很强，上大学后变弱了，放假后则因为懈怠愈发孱弱——这其实这个假象。那真相是什么？\n因为保证我们高效运转的其实是习惯，而不是自控力。\n想想在高考之前的那种紧张的学习氛围里，我们被动的养成了很多习惯：\n每天规律的上课、自习、吃饭和睡觉，我们目标明确——每个月、每个星期乃至每天复习什么，老师们都替我们安排好了。\n这些我们习以为常，就像你每天早上起床都会自动去刷牙一样自然。\n你想想想你起床后刷牙的过程：穿衣服（好吧我知道有人不穿），拿起杯子和牙刷，走到卫生间，接水，挤牙膏，开始刷。\n即使你可能还睡眼惺忪，但这一套流程你仍然能精确无比、毫不费力的执行下来。\n这个过程需要一丢丢的自控力吗？基本不需要对不对？\n所以高中的那些学习，其实并不需要太多自控力。\n而当你进了大学，课程安排变得自由了，你丧失了那些被动习惯，开始自己规划学习和生活时，才是需要自控力的时候。\n而此时，很多人不得不面对第二个真相：\n人的自控力是有限的 自控力和肌肉力量一样是有限的。\n这个结论被大量的心理学实验证明，大家上网搜索一下就能看到，我这里不做赘述，\n我只打个比方，相信能帮你更好的理解这个结论：\n想象下，当你搬宿舍、或是换教室时，你把一摞又一摞沉重的书本，吃力的从这个屋子搬到那个屋子之后，\n你双臂酸软，腰酸背疼，严重者可能连一杯水都举不起来，这是因为你的肌肉力量耗尽了。\n自控力也一样，我们在日常生活中要面对各种各样的诱惑：\n桌上昨天新买的一大堆零食，双十一淘宝主页玲琅满目的商品，男神胡歌的新剧又开播了……\n我们要反复抵抗这些诱惑才能专注于那些重要的目标——比如学习和减肥。\n每拒绝一次诱惑，你的自制力就消耗一分，如果面临的诱惑太多，\n总会有一个时刻，我们会累到无力抵抗，任由暴饮暴食、刷爆淘宝、熬夜看剧这些行为支配我们的生活。\n当然现实没有那么可怕，肌肉酸痛过两天会恢复，自制力嘛，你睡个好觉也能回归正常。\n有意思的是，不同人天生力气不一样，自制力强弱也不一样，\n自制力超群或是弱到掉渣的，在人群中都占很小的比例，大多数人都处在中间那个状态——不好也不坏。\n所以我们得出的结论是：学霸就是那群天生自制力超群的人？如果是这样，那这篇文章也太没意思了。\n有机智的童鞋马上反应过来了：\n哦！既然我们可以锻炼肌肉，自制力也是可以锻炼的，对吧！我们只要把自制力锻炼到很强就可以了！\n这话没错，然而肌肉力量有极限，自制力也是有极限的。\n生活中，我们面临的诱惑如此之多，靠后天锻炼出来的自制力依然会不够用。\n另一方面：\n无论是校园里的“学霸”，还是社会里的精英人士，其高效的学习和生活，\n并不像我们往常以为的那样，依赖于强大的自制力，而是得益于后天构建起来的习惯体系。\n如何利用我们有限的自制力，去构建这样一套体系，才是这篇文章最想说的东西。\n但是构建习惯体系，并不是一件轻松的事情，原因有两个：\n1.很多人没有意识到，有一个看不见的敌人在阻挠我们的行动，\n2.很多人不知道，习惯背后的原理。\n看不见的敌人 很多人都想要减肥，想要健身，但大多数人的状况是：\n决定要减肥或健身后，制定了详细的计划，买了一堆装备，办了几千块的健身卡，却在去了不到三次后，将这些东西都束之高阁。\n为什么建立一个锻炼的习惯这么难呢？因为太多人不了解习惯背后的原理，更重要的原因是：\n太多人太急了，太想在短期内看到显著的改变。\n是的，我们都希望一夜暴富，一朝成名。\n都喜欢看“穷小子白手起家创业成功，一年变身亿万富翁”，\n“胖女孩半年瘦身八十斤俘获男神芳心”的故事。但这些不是我们的错，\n我们之所以天生短视，喜欢即时的反馈和满足感，是因为大脑里，住着一个看不见的敌人在捣乱。\n首先你得意识到它的存在，然后才能战胜它。\n在几百万年前，我们的祖先还茹毛饮血的时候，资源稀缺，吃了上顿没下顿，大脑需要持续的分泌化学物质，\n它们促使人们去寻找并摄入食物，热量越高越好，把自身的脂肪储存的越多越好；如果不是这种机制，人类很可能存活不到今天。\n可我们不是原始人，我们进化出了更高级的控制单元，\n所以我们学会了计划，学会了为达成长期目标放弃短期利益。\n但原始的那部分大脑并没有消亡，它依然在时刻争夺着身体的控制权，促使我们孜孜不倦的寻求即时的满足感。\n所以你明白了吗？为什么在认真学习时，忽然会冒出“学这么久了，看一集美剧吧！”的念头；\n为什么晚饭吃了不少，睡前还是管不住自己伸向零食的手；\n为什么你打开手机想要背单词，却鬼使神差的戳开了微博；\n这些的本质都是原始大脑在作怪。\n好了，看到这里，你意识到敌人的存在了，即大脑的原始部分；\n你也意识到它惯用的伎俩——即时满足感。但这还不够，要打败它，你得掌握科学的武器，也就是习惯的原理。\n习惯的原理 习惯的养成，依赖于四个部分：触机（cue）、惯性行为（routine）、奖励（reward）和信念（belief）：","title":"自控力"},{"content":"苏格拉底 苏格拉底是谁？ 苏格拉底从未留下任何文字，但却是对欧洲思想影响最重大的人物之一。\n我们所知道的苏格拉底，事实上是柏拉图笔中的苏格拉底。\n以人为中心 人是衡量一切的尺度。\n一件事情是对是错、是好是坏，完全要看它与人类的需求有何关系而定。\n人的很多行为都是由社会规范的制约所致。\n谈话的艺术 假装自己一无所知，并与对方讨论，在这讨论的过程中设法使对手承认自己理论上的漏洞。\n他的工作就是帮助人们 生出 正确的思想。\n神圣的声音 耶稣与苏格拉底都相信自己是某一种更高力量的代言人（神明的指引），他们批判各种形式的不公不义与腐败现象，最后皆因此丧命。其实他们都可以通过求饶而活命，但最终却皆选择了成仁取义。\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95/","summary":"苏格拉底 苏格拉底是谁？ 苏格拉底从未留下任何文字，但却是对欧洲思想影响最重大的人物之一。\n我们所知道的苏格拉底，事实上是柏拉图笔中的苏格拉底。\n以人为中心 人是衡量一切的尺度。\n一件事情是对是错、是好是坏，完全要看它与人类的需求有何关系而定。\n人的很多行为都是由社会规范的制约所致。\n谈话的艺术 假装自己一无所知，并与对方讨论，在这讨论的过程中设法使对手承认自己理论上的漏洞。\n他的工作就是帮助人们 生出 正确的思想。\n神圣的声音 耶稣与苏格拉底都相信自己是某一种更高力量的代言人（神明的指引），他们批判各种形式的不公不义与腐败现象，最后皆因此丧命。其实他们都可以通过求饶而活命，但最终却皆选择了成仁取义。","title":"苏格拉底"},{"content":"萨特 人的的存在比任何其他事情都要重要。\n人并没有一种不变的本性。\n在道德的抉择上也是如此我们永远不能把错误归咎于\u0026quot;人性\u0026quot;或\u0026quot;人的软弱\u0026quot;等等我们可以发现时常有成年男子做出种种令人厌恶的行为，却把这样的行为归咎于\u0026quot;男人天生的坏毛病\u0026quot;可是世上没有\u0026quot;男人天生的坏毛病\u0026quot;这种东西，那只是我们用来避免为自己的行为负责的借口罢了。\n所谓哲学问题的定义就是每一个世代，甚至每一个人，都必须要一再地问自己的问题。\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E8%90%A8%E7%89%B9/","summary":"萨特 人的的存在比任何其他事情都要重要。\n人并没有一种不变的本性。\n在道德的抉择上也是如此我们永远不能把错误归咎于\u0026quot;人性\u0026quot;或\u0026quot;人的软弱\u0026quot;等等我们可以发现时常有成年男子做出种种令人厌恶的行为，却把这样的行为归咎于\u0026quot;男人天生的坏毛病\u0026quot;可是世上没有\u0026quot;男人天生的坏毛病\u0026quot;这种东西，那只是我们用来避免为自己的行为负责的借口罢了。\n所谓哲学问题的定义就是每一个世代，甚至每一个人，都必须要一再地问自己的问题。","title":"萨特"},{"content":"行到极处便是知，知到极处便是行 当你感觉自己知道的很多，却都做不到的时候，这不是因为你知道得太多，而是因为你知道的不够多：\n你没能从心智模式、思维习惯、适用情境等各个方面真正深入透彻地理解一件事情。\n你没有理解到极致的事情，怎么可能做得到呢？\n这也是王阳明先生所说：“知到极处便是行，行到极处便是知。”\n每个人都说“知道那么多大道理，却仍然过不好一生”，反过来想想，\n也许正是因为我们知道的大道理既不够多、也不够深，才让我们无法再思想中融会贯通，\n形成一套自己的思维习惯和行为习惯，从而在自相矛盾的道理中无法前行。\n当你不能采取积极的行动去学习，说明你根本就没有真正懂得学习对你的重要性\n就像，你知道自己应该早起，需要早起，然后你订了一个 5 点起床的计划，无法执行，于是你很难过。\n一个透彻地知道早起的人，应该深入细致地了解自己的睡眠习惯，了解自己的常态睡眠方式，\n然后深刻地了解自己怎么样一步一步地把起床时间慢慢向前拨，\n更重要的是配合分析自己 24 小时中的精力状况，饮食、运动和情绪状况，\n才能找到真正适合自己又能保证精力充沛的 5 点起床方案。\n想一想，这中间需要投入多少知识，和多少努力，才能做到？\n相反地，每当我们责怪自己不能“践行”，或是“执行力”不佳的时候，我们其实就掉入了“用蛮干代替策略”的思维模式。\n须知，大多数相对复杂的事情，都得靠顺着性子的策略来，而不是一蹴而就地蛮干就能成。\n任何需要比较复杂的认知系统的事情，都不是靠“执行力”实现的。\n当你觉得自己执行力不足的时候，一定要反过来思考：\n明白道理只是第一步，后面两步叫做：取势（认识对自己而言的客观规律）、优术（后期不断优化执行方式）。\n很多道理人类都是共通的，关键是执行力，对道理的思考和超强的执行力，才是人与人存在差距的原因\n","permalink":"https://note.yxzi.xyz/note/view/thinking/%E8%A1%8C%E5%88%B0%E6%9E%81%E5%A4%84%E4%BE%BF%E6%98%AF%E7%9F%A5%E7%9F%A5%E5%88%B0%E6%9E%81%E5%A4%84%E4%BE%BF%E6%98%AF%E8%A1%8C/","summary":"行到极处便是知，知到极处便是行 当你感觉自己知道的很多，却都做不到的时候，这不是因为你知道得太多，而是因为你知道的不够多：\n你没能从心智模式、思维习惯、适用情境等各个方面真正深入透彻地理解一件事情。\n你没有理解到极致的事情，怎么可能做得到呢？\n这也是王阳明先生所说：“知到极处便是行，行到极处便是知。”\n每个人都说“知道那么多大道理，却仍然过不好一生”，反过来想想，\n也许正是因为我们知道的大道理既不够多、也不够深，才让我们无法再思想中融会贯通，\n形成一套自己的思维习惯和行为习惯，从而在自相矛盾的道理中无法前行。\n当你不能采取积极的行动去学习，说明你根本就没有真正懂得学习对你的重要性\n就像，你知道自己应该早起，需要早起，然后你订了一个 5 点起床的计划，无法执行，于是你很难过。\n一个透彻地知道早起的人，应该深入细致地了解自己的睡眠习惯，了解自己的常态睡眠方式，\n然后深刻地了解自己怎么样一步一步地把起床时间慢慢向前拨，\n更重要的是配合分析自己 24 小时中的精力状况，饮食、运动和情绪状况，\n才能找到真正适合自己又能保证精力充沛的 5 点起床方案。\n想一想，这中间需要投入多少知识，和多少努力，才能做到？\n相反地，每当我们责怪自己不能“践行”，或是“执行力”不佳的时候，我们其实就掉入了“用蛮干代替策略”的思维模式。\n须知，大多数相对复杂的事情，都得靠顺着性子的策略来，而不是一蹴而就地蛮干就能成。\n任何需要比较复杂的认知系统的事情，都不是靠“执行力”实现的。\n当你觉得自己执行力不足的时候，一定要反过来思考：\n明白道理只是第一步，后面两步叫做：取势（认识对自己而言的客观规律）、优术（后期不断优化执行方式）。\n很多道理人类都是共通的，关键是执行力，对道理的思考和超强的执行力，才是人与人存在差距的原因","title":"行到极处便是知，知到极处便是行"},{"content":"裁剪图形  导入图像。 解锁当前图像所在的图层。 菜单栏——图像——画布大小——调整参数——确定。 调整图像将要被被保留的部分。  ","permalink":"https://note.yxzi.xyz/note/technology/software/photoshop/%E8%A3%81%E5%89%AA%E5%9B%BE%E5%83%8F/","summary":"裁剪图形  导入图像。 解锁当前图像所在的图层。 菜单栏——图像——画布大小——调整参数——确定。 调整图像将要被被保留的部分。  ","title":"裁剪图形"},{"content":"要理解真正的需求后才去努力 在你努力做出东西，抛出鱼饵之前，你很难理解真正的需求。\n而这世界上有很多需求，全部是被创造者自己创造出来的。\n比如：\n汽车发明以前，你去问人们需要什么交通工具，他们会说需要一匹更快的马。\n电灯发明以前，你去问人们需要什么照明工具，他们会说需要更长更大的蜡烛。\n就如同在乔布斯之前，永远没有人会告诉你，我需要一部 iPhone，而今天，我们已经完全无法离开 iPhone。\n","permalink":"https://note.yxzi.xyz/note/view/thinking/%E8%A6%81%E7%90%86%E8%A7%A3%E7%9C%9F%E6%AD%A3%E7%9A%84%E9%9C%80%E6%B1%82%E5%90%8E%E6%89%8D%E5%8E%BB%E5%8A%AA%E5%8A%9B/","summary":"要理解真正的需求后才去努力 在你努力做出东西，抛出鱼饵之前，你很难理解真正的需求。\n而这世界上有很多需求，全部是被创造者自己创造出来的。\n比如：\n汽车发明以前，你去问人们需要什么交通工具，他们会说需要一匹更快的马。\n电灯发明以前，你去问人们需要什么照明工具，他们会说需要更长更大的蜡烛。\n就如同在乔布斯之前，永远没有人会告诉你，我需要一部 iPhone，而今天，我们已经完全无法离开 iPhone。","title":"要理解真正的需求后才去努力"},{"content":"读书能赚钱吗 做生意赚钱靠读书激发？作者有那本事还写书？有写书的时间早赚钱去了，成功了雇几个枪手给他写《我的成功也能\u0026hellip;\u0026hellip;》。\n这里不是说读书不好，但读书和做生意是两条路，自古就是两条路，很多富翁都是大学休学。\n所谓白手起家，一个是资金上白手，一个是做生意经验上白手。\n读书越多，想的越多，想的越多，做事越谨慎，做生意靠谨慎只会越做越小，勉强原地踏步。\n一般都是捞到一票了才开始谨慎，一开始要捞一票，谨慎很难捞到。\n读书多不代表做生意能成，搞原子弹的不如卖茶叶蛋的歇后语听过没。\n做生意是一个行当，做学术也是一个行当，这是两个不同的行当。\n除非能把全世界所有学科的书都烂熟于胸，否则只读很窄一面的书，或者就读成功学，那我只能祝你好运了。\n","permalink":"https://note.yxzi.xyz/note/view/read/%E8%AF%BB%E4%B9%A6%E8%83%BD%E8%B5%9A%E9%92%B1%E5%90%97/","summary":"读书能赚钱吗 做生意赚钱靠读书激发？作者有那本事还写书？有写书的时间早赚钱去了，成功了雇几个枪手给他写《我的成功也能\u0026hellip;\u0026hellip;》。\n这里不是说读书不好，但读书和做生意是两条路，自古就是两条路，很多富翁都是大学休学。\n所谓白手起家，一个是资金上白手，一个是做生意经验上白手。\n读书越多，想的越多，想的越多，做事越谨慎，做生意靠谨慎只会越做越小，勉强原地踏步。\n一般都是捞到一票了才开始谨慎，一开始要捞一票，谨慎很难捞到。\n读书多不代表做生意能成，搞原子弹的不如卖茶叶蛋的歇后语听过没。\n做生意是一个行当，做学术也是一个行当，这是两个不同的行当。\n除非能把全世界所有学科的书都烂熟于胸，否则只读很窄一面的书，或者就读成功学，那我只能祝你好运了。","title":"读书能赚钱吗"},{"content":"很多人认为，轻易得来的，不会懂得珍惜。\n我是这么看的：如果得来的东西不是我所需要的，那珍不珍惜对我来说都无所谓。\n“非常需要”才会想要珍惜，怎么得来的是其次。\n有人不懂得珍惜，那不是因为得来有多“轻易”，而是因为他不知道自己有多“需要”。\n有一句话说“失去后才懂得珍惜”。\n当你非常需要的东西极自然而然地融入了你的生活，你感受不到自己有多需要它，自然就不会意识到该去珍惜。\n即使别人告诉你应该珍惜，你也很可能因为没有切身感受那种非常需要的感觉而满不在意。\n可一旦某天你失去了它，你立刻就会发现，你的生活缺了什么东西，而它就像是空气。\n有些人不知道自己需要什么就想方设法去“得到”某样东西 ，得到后渐渐发觉自己并没有想象中那样需要它。\n即使得到的过程非常艰辛，他最终也不会明白什么是珍惜。\n只有明白自己有多需要，你才会懂得珍惜。\n","permalink":"https://note.yxzi.xyz/note/view/gam/%E8%BD%BB%E6%98%93%E5%BE%97%E5%88%B0%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%A2%AB%E7%8F%8D%E6%83%9C/","summary":"很多人认为，轻易得来的，不会懂得珍惜。\n我是这么看的：如果得来的东西不是我所需要的，那珍不珍惜对我来说都无所谓。\n“非常需要”才会想要珍惜，怎么得来的是其次。\n有人不懂得珍惜，那不是因为得来有多“轻易”，而是因为他不知道自己有多“需要”。\n有一句话说“失去后才懂得珍惜”。\n当你非常需要的东西极自然而然地融入了你的生活，你感受不到自己有多需要它，自然就不会意识到该去珍惜。\n即使别人告诉你应该珍惜，你也很可能因为没有切身感受那种非常需要的感觉而满不在意。\n可一旦某天你失去了它，你立刻就会发现，你的生活缺了什么东西，而它就像是空气。\n有些人不知道自己需要什么就想方设法去“得到”某样东西 ，得到后渐渐发觉自己并没有想象中那样需要它。\n即使得到的过程非常艰辛，他最终也不会明白什么是珍惜。\n只有明白自己有多需要，你才会懂得珍惜。","title":"轻易得到就不会被珍惜"},{"content":"达尔文 适者生存，物竞天择。\n进化是生存竞争钟自然淘汰的结果，在这个过程中，哪些最能够适应环境的人就存活了下来。\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E8%BE%BE%E5%B0%94%E6%96%87/","summary":"达尔文 适者生存，物竞天择。\n进化是生存竞争钟自然淘汰的结果，在这个过程中，哪些最能够适应环境的人就存活了下来。","title":"达尔文"},{"content":"阈值自控意识 阈值又叫临界值，指释放一个行为反应所需要的最小刺激强度。\n A 片害了无数正常的男青年。\n没有 A 片的岁月里，男孩子满脑邪念充盈。\n可是在这个网络色情泛滥的当今，他们居然对生活中的女人没了想法，这不能不成为信息时代人类异化的经典案例。\n何以至此？阈值使然。\n也就是不断的持续刺激，抬高了男人们欲望的触发点。\n上个世纪初女人旗袍坐下时偶尔可一瞥的白花花大腿就可以触发老夫子们的欲念；\n可是 100 年后，看着满屏的器官进出，很多人居然会叹上一句：没意思。\n这就是时代的变迁，使得阈值不断上升的最好例证。\n 顺便提下：\n频繁观看色情片造成的过度刺激，会抑制大脑内对性刺激做出神经反应的奖赏机制，与药物成瘾相似，\n这种神经抑制会促使强迫的色情成瘾行为，并对正常的性意愿和性欲造成影响。\n可惜，对于有些人，这些话来的有点晚了。\n举个极端的例子，\n 释迦牟尼本是个迦毗罗卫国的王子，很早就过着锦衣玉食的生活。\n其父为其修筑春、夏、冬三幢宫殿。\n但他活的很厌世。\n其父为其选来印度最妖艳美丽的女子来取悦他。\n但是美酒美女对他的边际效用已经小到忽略，食欲肉欲的一切无法使他获得更高的满足，只有离开世俗创造佛教去了。\n 他一出生就享受物质的极大满足，导致他的阈值高到普通人难以想象的程度，最后凡是物质都无法使他快活。\n中国的例子是贾宝玉，从小活在女人堆里，最后也做和尚去了。\n反而自小出家的人却未必能忘俗。\n所以施耐庵会有和尚最淫一说，潘巧云与裴如海那一段有很精妙的点评。\n因自幼出家的人，从未享受过世俗的快感，所以阈值很低，一点就着。\n能大彻大悟的慧根人士，往往反而是富家子弟，也就不奇怪了。\n女人亦然。\n泛滥的韩剧将正常的女生活生生逼成大龄剩女，归根到底也是阈值作怪。\n本来少女看见年轻男子怀春，是老天爷安排的正常心理活动。\n现在这个自然的程序被突然打断，横插 10 部韩剧，部部男一号多金英俊完美，还有若干男二男三争抢。\n电视机前的女人们于是看傻了，爱情阈值被活生生地抬到天上，身边的男人自然再也看不上。\n当你深刻理解了阈值对个人幸福与快乐的影响后，你就知道这个概念不仅用在性和爱情上，更可以推广到人生幸福的方方面面。\n了解边际效用递减的规律，并学会一定程度的禁欲和自控，是防止阈值升高的不二法门.\n这绝对是需要在人生早期就要着力培养和锻炼的素质与意识，尤其对于男性。\n","permalink":"https://note.yxzi.xyz/note/view/thinking/%E9%98%88%E5%80%BC%E8%87%AA%E6%8E%A7%E6%84%8F%E8%AF%86/","summary":"阈值自控意识 阈值又叫临界值，指释放一个行为反应所需要的最小刺激强度。\n A 片害了无数正常的男青年。\n没有 A 片的岁月里，男孩子满脑邪念充盈。\n可是在这个网络色情泛滥的当今，他们居然对生活中的女人没了想法，这不能不成为信息时代人类异化的经典案例。\n何以至此？阈值使然。\n也就是不断的持续刺激，抬高了男人们欲望的触发点。\n上个世纪初女人旗袍坐下时偶尔可一瞥的白花花大腿就可以触发老夫子们的欲念；\n可是 100 年后，看着满屏的器官进出，很多人居然会叹上一句：没意思。\n这就是时代的变迁，使得阈值不断上升的最好例证。\n 顺便提下：\n频繁观看色情片造成的过度刺激，会抑制大脑内对性刺激做出神经反应的奖赏机制，与药物成瘾相似，\n这种神经抑制会促使强迫的色情成瘾行为，并对正常的性意愿和性欲造成影响。\n可惜，对于有些人，这些话来的有点晚了。\n举个极端的例子，\n 释迦牟尼本是个迦毗罗卫国的王子，很早就过着锦衣玉食的生活。\n其父为其修筑春、夏、冬三幢宫殿。\n但他活的很厌世。\n其父为其选来印度最妖艳美丽的女子来取悦他。\n但是美酒美女对他的边际效用已经小到忽略，食欲肉欲的一切无法使他获得更高的满足，只有离开世俗创造佛教去了。\n 他一出生就享受物质的极大满足，导致他的阈值高到普通人难以想象的程度，最后凡是物质都无法使他快活。\n中国的例子是贾宝玉，从小活在女人堆里，最后也做和尚去了。\n反而自小出家的人却未必能忘俗。\n所以施耐庵会有和尚最淫一说，潘巧云与裴如海那一段有很精妙的点评。\n因自幼出家的人，从未享受过世俗的快感，所以阈值很低，一点就着。\n能大彻大悟的慧根人士，往往反而是富家子弟，也就不奇怪了。\n女人亦然。\n泛滥的韩剧将正常的女生活生生逼成大龄剩女，归根到底也是阈值作怪。\n本来少女看见年轻男子怀春，是老天爷安排的正常心理活动。\n现在这个自然的程序被突然打断，横插 10 部韩剧，部部男一号多金英俊完美，还有若干男二男三争抢。\n电视机前的女人们于是看傻了，爱情阈值被活生生地抬到天上，身边的男人自然再也看不上。\n当你深刻理解了阈值对个人幸福与快乐的影响后，你就知道这个概念不仅用在性和爱情上，更可以推广到人生幸福的方方面面。\n了解边际效用递减的规律，并学会一定程度的禁欲和自控，是防止阈值升高的不二法门.\n这绝对是需要在人生早期就要着力培养和锻炼的素质与意识，尤其对于男性。","title":"阈值自控意识"},{"content":"马克思 一个社会的是非标准是由那个社会里的统治阶级来决定的，因为，人类社会的历史就是一部阶级斗争史。\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E9%A9%AC%E5%85%8B%E6%80%9D/","summary":"马克思 一个社会的是非标准是由那个社会里的统治阶级来决定的，因为，人类社会的历史就是一部阶级斗争史。","title":"马克思"},{"content":"黑格尔 人类的认知的基础会变化，因此世界上没有永恒的真理，没有永恒的理性。\n历史就像一条流动的河，河里任何一处河水的流动都受到上游河水的涨落与漩涡的影响。但上游河水的涨落与漩涡又受到你观察之处的岩石与河湾的影响。\n理性的历史就像一条河，你的思考方式乃是受到宛如河水般向前推进的传统思潮与当时的物质条件的影响。因此你永远无法宣称任何一种思想是永远对的。只不过就你所置神之处而言，这种思想可能是正确的。\n事情的对错要看历史的情况而定。\n你不可能将任何哲学家或任何思想抽离他们的历史背景。\n人类的知识在不断的扩张，在进步。\n每一种新思想通常都是以前人的旧思想为基础，而一旦有一种新思想被提出来，马上就会出现另外一种和它抵触的思想，于是这两种对立的思想之间就会产生一种紧张状态，但这种紧张状态又会因为有人提出另外一种融合了两种思想长处的思想而消除。黑格尔把这个现象称为一种辩证过程。\n辩证法 假设一种观点是正，那么必定有与他相反的观点反存在，因此便产生了两种观点之间的矛盾，之后这两种观点再被第三种观点合给消除，这时的合就变为了正，而这个正也会有另一个反与其相矛抵触。\n","permalink":"https://note.yxzi.xyz/note/afterthought/book/philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6/%E9%BB%91%E6%A0%BC%E5%B0%94/","summary":"黑格尔 人类的认知的基础会变化，因此世界上没有永恒的真理，没有永恒的理性。\n历史就像一条流动的河，河里任何一处河水的流动都受到上游河水的涨落与漩涡的影响。但上游河水的涨落与漩涡又受到你观察之处的岩石与河湾的影响。\n理性的历史就像一条河，你的思考方式乃是受到宛如河水般向前推进的传统思潮与当时的物质条件的影响。因此你永远无法宣称任何一种思想是永远对的。只不过就你所置神之处而言，这种思想可能是正确的。\n事情的对错要看历史的情况而定。\n你不可能将任何哲学家或任何思想抽离他们的历史背景。\n人类的知识在不断的扩张，在进步。\n每一种新思想通常都是以前人的旧思想为基础，而一旦有一种新思想被提出来，马上就会出现另外一种和它抵触的思想，于是这两种对立的思想之间就会产生一种紧张状态，但这种紧张状态又会因为有人提出另外一种融合了两种思想长处的思想而消除。黑格尔把这个现象称为一种辩证过程。\n辩证法 假设一种观点是正，那么必定有与他相反的观点反存在，因此便产生了两种观点之间的矛盾，之后这两种观点再被第三种观点合给消除，这时的合就变为了正，而这个正也会有另一个反与其相矛抵触。","title":"黑格尔"},{"content":"XMLHttpRequest 该对象用于与服务器交互；通过它可以在不重新刷新页面的情况下请求特定 URL，获取数据，这样就可以使得网页在不影响用户操作的情况下，更新页面的局部内容。\n判断浏览器是否支持 XHR // 如果浏览器支持 XHR if (Xhr) { ... }else{  alert(\u0026#39;Sorry, your browser doesn\\\u0026#39;t support XMLHttpXhr\u0026#39;); } 创建 XHR 对象 const xhr = new XMLHttpRequest(); 方法 readyState 返回 XMLHttpRequest 的当前所处状态的 状态码。\n 0 表示 XHR 对象已经被创建，但尚未调用 open() 方法。 1 表示 open 方法已经被调用完毕。 2 表示 send 方法已经被调用完毕，并且头部和状态已经可获得。 3 表示服务端已经返回了部分结果，但并没有返回所有结果，且 ResponseText 属性已经包含部分数据。 4 表示服务端已经返回了所有结果。  status 返回 XMLHttpRequest 响应时的数字状态码。\n200，状态码 \u0026gt;= 200 且 \u0026gt; 300 都算请求成功。\n404\n403\n401\n500\nstatusText 状态字符串\nresponseText 当一个请求被发送后，该属性会返回服务器端的文本。\nonreadystatechange 事件绑定，处理服务器返回的结果\n该属性会在当 readyState 属性发生改变的时候被调用。\n方法 open() 用于初始化一个请求，设置请求方式与请求路径、请求参数。\nxhr.open(\u0026#39;GET\u0026#39;, \u0026#39;http://localhost:8000/server?a=100\u0026amp;b=300\u0026#39;); ?a=100\u0026amp;b=300就是请求参数 a 和 b，多个参数用\u0026amp;隔开。\nsend() 将 xhr 的请求发送到服务端。\ngetAllResponseHeaders() 获取所有响应头。\nsetRequestHeader 设置请求头信息。\n预定义的请求头，浏览器不会报错。\n自定义的请求头，浏览器会有安全机制，会报错。\n注意 如果是异步请求（默认为异步请求），则此方法会在请求发送后立即返回（不会等待响应返回）；如果是同步请求，则此方法会直到响应返回到达后才会返回。\n","permalink":"https://note.yxzi.xyz/note/technology/internet/ajax/xmlhttprequest/","summary":"XMLHttpRequest 该对象用于与服务器交互；通过它可以在不重新刷新页面的情况下请求特定 URL，获取数据，这样就可以使得网页在不影响用户操作的情况下，更新页面的局部内容。\n判断浏览器是否支持 XHR // 如果浏览器支持 XHR if (Xhr) { ... }else{  alert(\u0026#39;Sorry, your browser doesn\\\u0026#39;t support XMLHttpXhr\u0026#39;); } 创建 XHR 对象 const xhr = new XMLHttpRequest(); 方法 readyState 返回 XMLHttpRequest 的当前所处状态的 状态码。\n 0 表示 XHR 对象已经被创建，但尚未调用 open() 方法。 1 表示 open 方法已经被调用完毕。 2 表示 send 方法已经被调用完毕，并且头部和状态已经可获得。 3 表示服务端已经返回了部分结果，但并没有返回所有结果，且 ResponseText 属性已经包含部分数据。 4 表示服务端已经返回了所有结果。  status 返回 XMLHttpRequest 响应时的数字状态码。\n200，状态码 \u0026gt;= 200 且 \u0026gt; 300 都算请求成功。\n404\n403","title":"Ajax XMLHttpRequest"},{"content":"A4 纸泛背法 适用于在短时间内记住某个单词的中文翻译等。\n开始  在一张空白 A4 纸的任意地方写出这个单词 看着单词并默念五遍其翻译 接着找一个空白处写出下一个单词，执行步骤 2 回到上一个单词，执行步骤 2，相当于将上一个单词复习一遍 根据自身情况可以改变单词默念的次数以及复习的次数  核心 快速的记忆，多次的重复。\n睡前复习一次旧单词，醒来复习一次旧单词，日常复习一次旧单词，并背当天的 新单词\n每次背单词注意力一定要高度集中，努力去看单词长啥样。\n缺点 大概率不会读也不会写，但你在阅读中碰见了能知道它的意思。\n艾宾浩斯记忆周期\n","permalink":"https://note.yxzi.xyz/note/subject/english/a4-%E7%BA%B8%E6%B3%9B%E8%83%8C%E5%8D%95%E8%AF%8D%E6%B3%95/","summary":"A4 纸泛背法 适用于在短时间内记住某个单词的中文翻译等。\n开始  在一张空白 A4 纸的任意地方写出这个单词 看着单词并默念五遍其翻译 接着找一个空白处写出下一个单词，执行步骤 2 回到上一个单词，执行步骤 2，相当于将上一个单词复习一遍 根据自身情况可以改变单词默念的次数以及复习的次数  核心 快速的记忆，多次的重复。\n睡前复习一次旧单词，醒来复习一次旧单词，日常复习一次旧单词，并背当天的 新单词\n每次背单词注意力一定要高度集中，努力去看单词长啥样。\n缺点 大概率不会读也不会写，但你在阅读中碰见了能知道它的意思。\n艾宾浩斯记忆周期","title":"English A4 纸泛背单词法"},{"content":"How how +形容词/副词 + 主语 + 谓语\nHow careful he is！（他多细心啊！)\nHow fast he runs！（他跑得多快啊！）\nhow + 形容词 + 冠词(a、an) + 可数名词的单数 + 主语 + 谓语\nHow cute a dog it is!(它是多么可爱的一只狗啊！)\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E6%84%9F%E5%8F%B9%E5%8F%A5/how/","summary":"How how +形容词/副词 + 主语 + 谓语\nHow careful he is！（他多细心啊！)\nHow fast he runs！（他跑得多快啊！）\nhow + 形容词 + 冠词(a、an) + 可数名词的单数 + 主语 + 谓语\nHow cute a dog it is!(它是多么可爱的一只狗啊！)","title":"English How"},{"content":"What what + 冠词（a、an） + 形容词 + 可数名词的单数 + 主语 + 谓语\nWhat a beautiful photo it is!（这照片它多美啊！）\nwhat + 形容词 + 不可数名词/名词复数 + 主语 + 谓语\nWhat cleanly water it is!（多干净的水啊！）\nWhat brilliant dogs they are!（多聪明的狗啊！）\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E6%84%9F%E5%8F%B9%E5%8F%A5/what/","summary":"What what + 冠词（a、an） + 形容词 + 可数名词的单数 + 主语 + 谓语\nWhat a beautiful photo it is!（这照片它多美啊！）\nwhat + 形容词 + 不可数名词/名词复数 + 主语 + 谓语\nWhat cleanly water it is!（多干净的水啊！）\nWhat brilliant dogs they are!（多聪明的狗啊！）","title":"English What"},{"content":"一般疑问句 可以用 yes、no 回答。\n一般疑问句通常是由陈述句变过来的，下面列举陈述句变一般疑问句的几种方式。\n提前系动词（be 动词、感官动词） 主 + 系 + 表 ——\u0026gt; 系 + 主 + 表\n陈述句：You are an idiot.（你是个笨蛋）\n一般疑问句：Are you an idiot?（你是不是个笨蛋？）\n回答：Yes,i am./No,i am not.\n提前助动词（do、have、shall 等） 主 + 谓 +（宾）——\u0026gt; 助动词 + 主 + 动词原形 + 其他\n陈述句：You（have got light bulbs.（你有灯泡）\n一般疑问句：（Have）you got light bulbs?（你有灯泡吗？）\n回答：Yes,i have./No,i have not.\n提前情态动词（can、may、will） 主 + 情态动词 + 动词原形 + 其他 ——\u0026gt; 情态动词 + 主+ 动词原形 + 其他\n陈述句：You (can) play football.（你会踢足球）\n一般疑问句：Can you play football.（你会踢足球吗？）\n回答：Yes,i can./No,i can not.\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E4%B8%80%E8%88%AC%E7%96%91%E9%97%AE%E5%8F%A5/","summary":"一般疑问句 可以用 yes、no 回答。\n一般疑问句通常是由陈述句变过来的，下面列举陈述句变一般疑问句的几种方式。\n提前系动词（be 动词、感官动词） 主 + 系 + 表 ——\u0026gt; 系 + 主 + 表\n陈述句：You are an idiot.（你是个笨蛋）\n一般疑问句：Are you an idiot?（你是不是个笨蛋？）\n回答：Yes,i am./No,i am not.\n提前助动词（do、have、shall 等） 主 + 谓 +（宾）——\u0026gt; 助动词 + 主 + 动词原形 + 其他\n陈述句：You（have got light bulbs.（你有灯泡）\n一般疑问句：（Have）you got light bulbs?（你有灯泡吗？）\n回答：Yes,i have./No,i have not.\n提前情态动词（can、may、will） 主 + 情态动词 + 动词原形 + 其他 ——\u0026gt; 情态动词 + 主+ 动词原形 + 其他","title":"English 一般疑问句"},{"content":"主系表 主语 ＋ 系动词 ＋ 表语（形容主语）\n系动词用于链接前面的主语和后面的表语。\n所谓的“主系表”句型是描述静态的世界，即：什么是什么；\n系动词 = be 动词（is、are、am） + 感官动词（看、听、闻、尝、感觉、似乎、抱持、证明）\n系动词后面大部分是表语。\n例句  The food is delicious. They are students. He fell asleep She is rich now. i am in Chinese now.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E7%B3%BB%E8%A1%A8/","summary":"主系表 主语 ＋ 系动词 ＋ 表语（形容主语）\n系动词用于链接前面的主语和后面的表语。\n所谓的“主系表”句型是描述静态的世界，即：什么是什么；\n系动词 = be 动词（is、are、am） + 感官动词（看、听、闻、尝、感觉、似乎、抱持、证明）\n系动词后面大部分是表语。\n例句  The food is delicious. They are students. He fell asleep She is rich now. i am in Chinese now.  ","title":"English 主系表"},{"content":"主语 一个句子的主体，也可以说是一句话主要叙述的对象或者这句话主要讲的内容。\n大部分代词都可以作主语，尤其是人称代词的主格，宾格不能作主语。\n例句  I like watching TV Chinese is hard.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E4%B8%BB%E8%AF%AD/","summary":"主语 一个句子的主体，也可以说是一句话主要叙述的对象或者这句话主要讲的内容。\n大部分代词都可以作主语，尤其是人称代词的主格，宾格不能作主语。\n例句  I like watching TV Chinese is hard.  ","title":"English 主语"},{"content":"主谓 主语 ＋ 不及物动词。\n The universe remains. I can draw. He likes singing. I work every day. I run every day.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93/","summary":"主谓 主语 ＋ 不及物动词。\n The universe remains. I can draw. He likes singing. I work every day. I run every day.  ","title":"English 主谓"},{"content":"主谓双宾 主语 ＋ 谓语（双及物动词） + 间宾 ＋直宾。\n双宾的特点是两个宾语都能承受这个动作（双及物动词），以及两个宾语都能被作为主语。如果不能都被作为主语，那这个句子就是宾补。\n一个句子中的间宾和直宾都能被作为被动语态主语，且双宾必须是一个人一个物，那么这个句子就是双宾，否则是宾补。\n I give you money. Her father bought her a dictionary. I gave her a book yesterday.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93%E5%8F%8C%E5%AE%BE/","summary":"主谓双宾 主语 ＋ 谓语（双及物动词） + 间宾 ＋直宾。\n双宾的特点是两个宾语都能承受这个动作（双及物动词），以及两个宾语都能被作为主语。如果不能都被作为主语，那这个句子就是宾补。\n一个句子中的间宾和直宾都能被作为被动语态主语，且双宾必须是一个人一个物，那么这个句子就是双宾，否则是宾补。\n I give you money. Her father bought her a dictionary. I gave her a book yesterday.  ","title":"English 主谓双宾"},{"content":"主谓宾 主体 ＋ 谓语（单及物动词） ＋ 动作的承受者。\n所谓的“主谓宾”句型是描述动态的世界，即：什么做了什么。\n I love you. He took his bag and left. I read English every morning.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93%E5%AE%BE/","summary":"主谓宾 主体 ＋ 谓语（单及物动词） ＋ 动作的承受者。\n所谓的“主谓宾”句型是描述动态的世界，即：什么做了什么。\n I love you. He took his bag and left. I read English every morning.  ","title":"English 主谓宾"},{"content":"主谓宾宾补 主语 + 谓语（少数特定的及物动词） ＋ 宾语 + 宾语补足语。\n为什么要跟一个宾补，因为如果不跟宾补的话，句子的意思会不完整。\n宾补中的宾语和宾补都是指同一个人或同一个事物，它们通常是同位语关系。\n I call her Mary. They ordered hamburger their lunch. I made her happy yesterday.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93%E5%AE%BE%E5%AE%BE%E8%A1%A5/","summary":"主谓宾宾补 主语 + 谓语（少数特定的及物动词） ＋ 宾语 + 宾语补足语。\n为什么要跟一个宾补，因为如果不跟宾补的话，句子的意思会不完整。\n宾补中的宾语和宾补都是指同一个人或同一个事物，它们通常是同位语关系。\n I call her Mary. They ordered hamburger their lunch. I made her happy yesterday.  ","title":"English 主谓宾宾补"},{"content":"介词 用于表示位置，方向等，使句子形成结构，介词没有实际意义\n主要用来表明名词和代词与其他句子成分的关系。\n I ate three apple with chopsticks.  介词也叫前置词，是一种虚词，不能单独做句子成分，一般只能用在名词或者代词、数词和动名词的前面。介词可以与这些词语构成介词短语，才能在句子红充当一个句子成分。\n In Guangxi. In the school. in 2023.  介词虽然数量不多，但是通常因为一个介词有好几十个意思，甚至是上百个，所以很难掌握，也很难区别。\n比如最常用的介词 in，它的意义至少就有 6 个。\nIn 在\u0026hellip;地方 in China.\n在\u0026hellip;里面  in my room.  表时间，在某年，某月  in 2023. in May.  在\u0026hellip;之后  in three days.  穿什么颜色的衣服  in red.  用\u0026hellip;语言  in English  介词的分类 简单介词 由一个单词组成的介词。\n in. after.  复合介词 由两个单词组成一个新词的介词。\n inside. into. throughout.  分词介词 由分词充当的介词。\n including. following.  短语介词 由一个词组构成的介词。它是由几个单词构成一个很长的介词。需要注意的是，**虽然短语介词通常很长，但是一定要当成一个介词去理解。**不能当成短语去理解。\n in the middle of. according to.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D/","summary":"介词 用于表示位置，方向等，使句子形成结构，介词没有实际意义\n主要用来表明名词和代词与其他句子成分的关系。\n I ate three apple with chopsticks.  介词也叫前置词，是一种虚词，不能单独做句子成分，一般只能用在名词或者代词、数词和动名词的前面。介词可以与这些词语构成介词短语，才能在句子红充当一个句子成分。\n In Guangxi. In the school. in 2023.  介词虽然数量不多，但是通常因为一个介词有好几十个意思，甚至是上百个，所以很难掌握，也很难区别。\n比如最常用的介词 in，它的意义至少就有 6 个。\nIn 在\u0026hellip;地方 in China.\n在\u0026hellip;里面  in my room.  表时间，在某年，某月  in 2023. in May.  在\u0026hellip;之后  in three days.  穿什么颜色的衣服  in red.  用\u0026hellip;语言  in English  介词的分类 简单介词 由一个单词组成的介词。\n in. after.  复合介词 由两个单词组成一个新词的介词。\n inside. into.","title":"English 介词"},{"content":"代词 用于代替名词的词，从而避免对话或语句中重复名词。\n I am person. she is beautiful.  人称代词 用于指代人，当然，也有些人称代词页可以指代事物\ni、it、you、he、she、we、they 等等都是人称代词。\n它有主格和宾格，以及有第一人称（我）、第二人称、（你）第三人称（他）\n主格 作主语的格式，主格才可以作主语，宾格不行。\n人称代词的主格只有：i、we、you、she、he、it、they.\n在句子里做主语或者表语\n They are students. He is very handsome. It is cheap.  注意，两个或者两个以上的人称代词主格的单数作并列主语的时候顺序为：\n第二人称（你）——\u0026gt; 第三人称（他）——\u0026gt; 第一人称（我）\n如果是复数，顺序是: we、you and they，比如：\n He and i are both form China. You and i both like beautiful girls. You and he and me are all good students.  宾格 作宾格的格式，宾格才可以作宾语。\n做及物动词或者介词之后的宾语\n I tell her my name.  我告诉她我的名字\n I should apologize to her.  我应该向她道歉\n物主代词 形容词性物主代词 my、your、her、his、its、our、their.\n它只有一个作用，就是作前置定语，它可以修饰单数、复数、或是不可数名词，比如：\n My house. Its house. My money.  名词性物主代词 mine、yours、hers、his、its、ours、theirs.\n它相当于一个名词，所以可以作主语、表语和宾语，但不能作定语，因为形容词性物主代词本身就是定语。\n  my car is very good.\nmine is better.（mine = my car）\n  my car is very good.\nI want yours.（yours = your car）\n  Whose is this house？\nIt is hers.（hers = her house）\n  My computer is better than yours.（yours = your compute）\n  他们的区别  这是我的书。（这里的“我的在中文里是定语，修饰名词“书”，所以这里的“我的”翻译成英语，就是一个形容词词性物主代词： This is my book.） 你的书比我的贵。（这里的“我的”在中文里面含义是：“我的书”实际上是指“书”，也就是属于名词的意义）。  所以这里的**我的（mine）**翻译成英语就是一个名词性物主代词： Your book is more expensive than mine.（mine = my book）\n指示代词 this、these 表示比较近的事物，that 和 those 表示较远的事物。\nthis、that 只能修饰单数和不可数名词。\n This computer is cheap. That student is very tall. This money is brand new. I want this. i like that.  these、those 则只能修饰可数名词的复数形式。\n These houses is big. Those girls is beautiful. I support these boys. I will buy these.  it 可以表示 天气 It is cloudy.\n多云\n时间 It is 6 o’clock.\n6 点整\n距离 It is 5 miles.\n5 英里\n环境 It is desert.\n沙漠\n上文提过的某物 I have a cute cat, and it has blue eyes.我有一只猫，它有蓝色的眼睛\n不知道性别的人 She has a cute baby, and it has blue eyes.她有一个可爱的宝宝，宝宝有蓝色的眼睛\n停下某个事物，这个事物可能是已经发生的或正在发生的 Stop it\n停下\n打电话时分辨人 Hello, Peter, It’s Jack here.\n你好，皮特，我是杰克\n做形式主语 It is confident that he will win the match.\n他有信心赢得比赛\n做形式宾语 I realized it tough to learn ski well.\n我意识到学好滑雪很难\n 反身代词  This 和 that\n例句  This is my pen That is her computer  疑问代词 whether\nwhere\nwhen\nhow\nwho\nwhat\n不定代词 相互代词 关系代词 链接代词 ","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%A3%E8%AF%8D/","summary":"代词 用于代替名词的词，从而避免对话或语句中重复名词。\n I am person. she is beautiful.  人称代词 用于指代人，当然，也有些人称代词页可以指代事物\ni、it、you、he、she、we、they 等等都是人称代词。\n它有主格和宾格，以及有第一人称（我）、第二人称、（你）第三人称（他）\n主格 作主语的格式，主格才可以作主语，宾格不行。\n人称代词的主格只有：i、we、you、she、he、it、they.\n在句子里做主语或者表语\n They are students. He is very handsome. It is cheap.  注意，两个或者两个以上的人称代词主格的单数作并列主语的时候顺序为：\n第二人称（你）——\u0026gt; 第三人称（他）——\u0026gt; 第一人称（我）\n如果是复数，顺序是: we、you and they，比如：\n He and i are both form China. You and i both like beautiful girls. You and he and me are all good students.  宾格 作宾格的格式，宾格才可以作宾语。\n做及物动词或者介词之后的宾语\n I tell her my name.","title":"English 代词"},{"content":"冠词 用于说明名词的意义，通常在名词前后，形成特指或泛指的作用，不能单独使用。\n定冠词 定冠词 the，表示这个或那个，特指某个名词。可以修饰可数名词单数/复数名词，或不可数名词。\n凡是特指某个事物的名词，都要加定冠词 a、an、the，反之，如果时泛指某类事物的名词，则不需要加冠词。\n上文中重新提及的人或物之前  This car is popular, but the car isn’t cheap. I bought a book yesterday.The book is interesting. I know a friend.The friend is a doctor.  在谈话观方都知道的人或物之前  pass me the book, please! pass me the books, please! Pass the salt to me, please!  在有限定性后置定语修饰的名词之前  The center of the city. The people in the park.  在序数词之前  the first. the second. the third.  表示唯一存在的事物之前  The earth. The sun. The moon.  表示时间或其他情况的习惯用语起之前  In the end. In the morning/afternoon/evening. In the same.  形容词和副词的最高级之前  The most important. The best. This is the best cup of coffee  某些形容词之前，会变成名词  The old/young. The weak/wise. The poor/rich.  姓氏的复数形式之前，表示一家人或夫妇  The Smiths. The Chens.  一般来说，有孩子就指一家人，没有孩子就指夫妇。\n乐器之前  I like to play the piano. I like to play The guitar. I like to play The violin.  地理位置之前  We are based in the Beijing.  江河湖海等专有名称之前  The Yellow River.  强调某种东西的时候  Beijing is the capital of China.  不能用冠词的情况 专有名词 人名（Marx）、地名（Asia）、国名（China）、节日（National Day）、月份（January）和星期（Monday）、Spring\n表示泛指而不是特指的意义的时候  Teachers are great.（泛指所有的老师，而不是某些老师） Water is important.（泛指所有的水，而不是某些水）  称呼语 当自己称呼别人时所用的词语。\n Good morning, guys! Where is Uncle Tom ? Daddy/Father Mother/mommy! Honey darling!  表示职位、身份、头衔的名词前面  President Lincoln.  表示学科、疾病、球类、游戏、颜色和感官名词的词语之前  Economic is different from politics. English is an important subject in China school. He died of cancer two years ago. I like basketball. Mars Green is a beautiful color. Smell is one of the five senses.  注意，有些表示疾病的名词需要加不定冠词。\n I had a fever lase week. She has a bad cold.  表示餐名  Dinner is ready. Did you have breakfast. What did you have for supper?  加冠词或不加冠词 很多时候，一个词加不加冠词，所表达的意思是不一样的，有时候甚至是差别很大，比如：\n By sea（乘船）/By the sea（在海边） Go to sea（当水手）/ go to the sea（去海边） in front of（在\u0026hellip;外部的前面）/ in the front of（在\u0026hellip;内部的前面）  不定冠词 不定冠词 a、an，泛指人和物，表示一个，后面加单数可数名词，辅音发音前面加 a，元音发音前面加 an。\na、an 都是不定冠词，意思一样。只是 a 用在以辅音开头的名词前面，an 用在以元音开头的名词前面。\n另外，a、an 都只能修饰可数名词单数，不能修饰不可数名词或可数名词复数\n He is a doctor. He is studying in a university. I bought a book yesterday.  如果名词前面有一个形容词或者名词作定语，而这个形容词或者名词的发音也是原因开头，那么也要用 an.\nI am an English teacher.\nhe is an old man.\n使用场景 第一次提到的人和物 it’s a cat（这个一只猫）\n如果是对唯一事物具体情况说明 Their dream is to go on a world tour（他们的梦想是去全世界巡回演出）\n和名词连用作表语或者同位语，代表职业 I am an engineer（我是一个工程师）\n表示价格、速度、频率 80 miles an hour（80 英里每小时）\n固定短语会用 have a good time（玩的开心）\n零冠词 有的情况下可以不需要加任何冠词\n使用场景 很广泛的概念 Sichuan dishes are spicy（四川菜很辣）\n书名、人名 I am reading “Journey to the West”（我正在读西游记）\n某些城市、国家 China is a big country（中国是一个大国）\n某些山河湖海洲 Asia（亚洲）\n星球 Mars（火星）\n语言、球类、学科、棋牌 I have studied English for ten years（我学了十年英语）\n三餐、日期、季节（一般也不加冠词，如果要特指可以加 the） It’s September 1th（这是九月一日）\n注意 冠词不能和代词连用\nThis car is popular（对）\nThis the car is popular（错，代词 this 和 冠词 the 重复了，在这里，要么用冠词，要么用代词）\n这车很热门\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%86%A0%E8%AF%8D/","summary":"冠词 用于说明名词的意义，通常在名词前后，形成特指或泛指的作用，不能单独使用。\n定冠词 定冠词 the，表示这个或那个，特指某个名词。可以修饰可数名词单数/复数名词，或不可数名词。\n凡是特指某个事物的名词，都要加定冠词 a、an、the，反之，如果时泛指某类事物的名词，则不需要加冠词。\n上文中重新提及的人或物之前  This car is popular, but the car isn’t cheap. I bought a book yesterday.The book is interesting. I know a friend.The friend is a doctor.  在谈话观方都知道的人或物之前  pass me the book, please! pass me the books, please! Pass the salt to me, please!  在有限定性后置定语修饰的名词之前  The center of the city. The people in the park.  在序数词之前  the first.","title":"English 冠词"},{"content":"副词从句 将简单句修改，使它成为另一个句子的状语，也叫状语从句。\n根据用途，可以将副词从句分为九大类：\n 表时间（在\u0026hellip;前） 表地点（在\u0026hellip;地方) 表条件（如果\u0026hellip;） 表让步（虽然\u0026hellip;但是\u0026hellip;） 表方式（就好像\u0026hellip;） 表比较（比\u0026hellip;） 表原因（因为\u0026hellip;所以\u0026hellip;） 表目的（为了\u0026hellip;） 表结果（所以\u0026hellip;）  时间副词从句 在某一时间点之前 before\n Before the wolf stopped by, the rabbit ate a carrot at home.  在某一时间点之中（当时） when，突然的某个时间点。\n The rabbit was eating a carrot when I reached home.  while，强调在一个时间段内。\n The rabbit was eating a carrot while I was making a vide.  as，强调同时进行两个动作。\n l ate a carrot as I made the video.  在某一时间点之后 after\n The rabbit ate a carrot after the wolf stopped by.  从之前某一时间点开始 一般暗示了对之后的事情有影响。\nsince\n The rabbit has shared three carrots since the wolf stopped by.  直到之后的某一时间点 until\nThe rabbit waited until the wolf stopped by.\n一\u0026hellip;就\u0026hellip; 一个动作紧跟另一个动作发生。\nas soon as The rabbit will eat a carrot as soon as the wolf leaves.\n下次\u0026hellip; the next time\n The rabbit will share the biggest carrot the next time the wolf stops by.  地点副词从句 引导词 where + 强调形式\n The rabbit ate the carrot where he found it.  wherever 强调不管哪里\neverywhere 强调所有地方\nanywhere 强调任何地方\n比较副词从句 用比较的方式，对前面的主句进行补充说明。\n He is smarter than i am. This carrot is bigger than that on is. He is as smart as i am. The more you practice English, the moref luent you become.  条件副词从句 if\n If the rabbit sees a carrot, he will eat it.  unless\n Unless you like this video,you will not give it a thumbs-up.  让步副词从句  Even if I see a carrot, I will not eat it. Although l see a carrot, I will not eat it. No matter what happens,I will not eat the carrot.  方式副词从句  l feel good as if I had just eaten a carrot. You spend (so much) money as if you were a millionaire. You spend money the way in which millionaires do.  原因副词从句 因果关系，即 A 导致 B。\nbecause，实实在在的因果关系。\n The rabbit ate the carrot because he was hungry. Because this video is excellent, you should give it a thumbs-up.  since，引入大家都知道的情况。\n Since you are hungry, you can eat the carrot. Since all my videos are excellent, you should give this video athumbs-up.  as，引出显而易见的事实\n As you were not here, we ate the carrot without you As I have thick skin, I\u0026rsquo;m begging you for a thumbs-up.  目的副词从句 因为要达到目的 A，所以做了事件 B 。\n In order that I could finish the video in time,I pulled an all-nighter.  为了体验目的性，一般使用情态助词 can、could、may、might、should、would 等。\n结果副词从句 A 导致 B，B 是 A 产生的结果\n l ate a lot of carrots for lunch so that I wasn\u0026rsquo;thungry at all in the afternoon. l ate a lot of carrots for lunch so that I wasn\u0026rsquo;thungry at all in the afternoon.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%89%AF%E8%AF%8D%E4%BB%8E%E5%8F%A5/","summary":"副词从句 将简单句修改，使它成为另一个句子的状语，也叫状语从句。\n根据用途，可以将副词从句分为九大类：\n 表时间（在\u0026hellip;前） 表地点（在\u0026hellip;地方) 表条件（如果\u0026hellip;） 表让步（虽然\u0026hellip;但是\u0026hellip;） 表方式（就好像\u0026hellip;） 表比较（比\u0026hellip;） 表原因（因为\u0026hellip;所以\u0026hellip;） 表目的（为了\u0026hellip;） 表结果（所以\u0026hellip;）  时间副词从句 在某一时间点之前 before\n Before the wolf stopped by, the rabbit ate a carrot at home.  在某一时间点之中（当时） when，突然的某个时间点。\n The rabbit was eating a carrot when I reached home.  while，强调在一个时间段内。\n The rabbit was eating a carrot while I was making a vide.  as，强调同时进行两个动作。\n l ate a carrot as I made the video.","title":"English 副词从句"},{"content":"反义疑问句 可以用 yes，no 回答。\n前肯后否，前否后肯 陈述句部分是肯定，疑问句部分用否定句 He is your teacher, isn‘t he？(他是你的老师，不是吗？)\n根据事实回答：Yes, he is\n陈述句部分是否定，反义疑问句用肯定句 He isn‘t your teacher, is he？(他不是你的老师，是吗？)\n根据事实回答：No, he isn’t\n有祈使句的情况 用 will you 和 won’t you\nOpen the door, won’t you?\n打开开门，不好吗？\nDon’t open the door, will you?\n不打开门，好吗？\n不管否定肯定，let’s 开头结尾就是 shall we，Let us 开头结尾就是 will you\n肯定：Let‘s go to school, shall we? Let us go outside, will you?\n否定：Let‘s don’t go out, shall we? Don\u0026rsquo;t let us go there, will you?\n含有 must 的情况 must 表示必须的时候，反义疑问用 mustn’t ?/needn’t?\nHe must study hard at English, mustn\u0026rsquo;t he？\n他必须努力学英语，不是吗？\nmust 表示推测（肯定）时候，反义疑问用 must 后动词的否定提问\nYou must be joking, aren\u0026rsquo;t you？\n你肯定是在开玩笑，不是吗？\n含有感叹句的情况 全部是，用感叹句陈述，用否定式提问\n前肯后否\nWhat a lovely girl, isn’t she?\n多么可爱的女孩，不是吗？\n含有否定词的情况 常见发的否定词 hardly、never、seldom、little、few, nowhere、nothing\n陈述句有否定词的时候，反义疑问用肯定提问，因为前否后肯\nHe hardly goes to school, does he?\n他几乎不去学校，是吗？\n含有复合句的情况 复合句反义疑问，都是对主句提问进行提问\nShe never told you that she had a baby, did she?\n她从来没有告诉过你她有一个孩子，是吗？\n含有宾语从句的情况 全部复合句里，只有宾语从句的反义疑问句，是和从句相关的\nI don’t think/believe/imagine/suppose\n引导的宾语从句，反义疑问句与从句主语，主谓一致，用肯定提问\nI don’t imagine he has got it, has he?\n我没有想过他有它，他有吗？\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E5%8F%8D%E4%B9%89%E7%96%91%E9%97%AE%E5%8F%A5/","summary":"反义疑问句 可以用 yes，no 回答。\n前肯后否，前否后肯 陈述句部分是肯定，疑问句部分用否定句 He is your teacher, isn‘t he？(他是你的老师，不是吗？)\n根据事实回答：Yes, he is\n陈述句部分是否定，反义疑问句用肯定句 He isn‘t your teacher, is he？(他不是你的老师，是吗？)\n根据事实回答：No, he isn’t\n有祈使句的情况 用 will you 和 won’t you\nOpen the door, won’t you?\n打开开门，不好吗？\nDon’t open the door, will you?\n不打开门，好吗？\n不管否定肯定，let’s 开头结尾就是 shall we，Let us 开头结尾就是 will you\n肯定：Let‘s go to school, shall we? Let us go outside, will you?\n否定：Let‘s don’t go out, shall we?","title":"English 反义疑问句"},{"content":"同位语 用于将主语或宾语重新说一遍。使得两个不同的词语都表示同一个事物或人。\n Rainy,an english teacher,is very strict.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%90%8C%E4%BD%8D/","summary":"同位语 用于将主语或宾语重新说一遍。使得两个不同的词语都表示同一个事物或人。\n Rainy,an english teacher,is very strict.  ","title":"English 同位语"},{"content":"名词 表示人或物的名称。\n Rainy is a person  名词所有格 表示一种所有关系。\n比如小明的书包，其中小明的就是所有格，因为书包是属于小明的。\n表示人或动物的名词 + \u0026rsquo;s 这种名词所有格，构成的方式很容易，直接子表示人或动物的名词后面**+\u0026rsquo;s**就可以了，这里的 \u0026rsquo;s 相当于中文里的”的“。\n一个普通名词，在变成所有格的时候，，要注意可数名词不能单独使用，比如 friend\u0026rsquo;s ；需要加一个限定词 my，变成My friend\u0026rsquo;s这样才能构成名词所有格。\n作前置定语 Jack \u0026rsquo;s book\nJack \u0026rsquo;s books\nThe boss’s car\n同时它作前置定语的时候可以修饰可数名词（单数和复数形式）和不可数名词。\n复数名词 s 结尾，后加’ 如果名词是s结尾的复数或名词本身是s结尾， 直接加**\u0026rsquo;就可以了，当然也可以加\u0026rsquo;s**。\nMy boss\u0026rsquo;s 相当于 My boss\u0026rsquo;\nof + 无生命的名词 不可数名词或复数直接+of。 Of water\nOf oil\n可数名词不能直接加 of，需要加限定词或冠词或变复数。 of相当于中文**“的”的意思，the相当于“这”**的意思\nOf the house\nOf my house\nOf this coat\nOf the carrot\n被名词所有格作后置定语修饰的名词，都必须在这个名词前面+ the The price of the house.\nThe color of the carrot.\nThe price of oil.\nThe center of the city.\n用 and 连接并列名词时候 表示各自的所有关系，分别加’s\n共同所有关系，只在 最后一个名词加’s\nTom’s and Jack’s rooms（汤姆的房间和杰克的房间）\nTom and Jack’s room（汤姆和杰克的房间）\n日程时间后 3 days’ holiday（3 天的假期）\n国家城市后 Beijing’s policy（北京的政策）\n地方机构后 The airport’s service guide（机场的服务指南）\n各种单位后面 100 kilogram’s weight（100 千克的重量）\n天体后面 The Jupiter’s aura（木星的光环）\nof 所有格（中英语序相反） 修饰前面的名词，表两个名词之间的所属关系\nThe content of the book = The book’s content\n这本书的内容\n\u0026rsquo;s + of 双重所有格 of + 名词 \u0026rsquo;s 所有格\nThis is a photo of my cat\u0026rsquo;s\n这是我猫的照片\nof + 名词性物主代词\nHe is a friend of mine\n他是我的朋友\n复合名词 一个复合名词的可数与不可数，取决于后面的那个名词。\n复合名词前面的那个名词都是用原型。\n如果复合名词前面的那个名词是可数名词，那么这个名词不能是复数的形式，只能是单数的格式。\n具体名词和抽象名词 具体名词（看得见摸得着，可数不可数都有）\nman、Beijing、book、car、water、fire 等等\n抽象名词（无形的各种事物，大多数是不可数）\ntime、hope、knowledge、love、anger 等等\n名词单复数变化 规则变化的名词 大部分名词，直接加 s—————————————————day-days\n以 o, s, x, ch, sh 结尾，加 es—————————————hero-heroes\n辅音+y，变 y 为 i 加 es—————————————————city-cities\n元音+y，加 s————————————————————boy-boys\nf 或者 fe 结尾，变 f 为 v 加 es——————————————half-halves\n直接加 s———————————————roof-roofs\nch 结尾发/k/，直接加 s————————————stomach-stomachs\n辅音+oo 结尾加 s——————————————bamboo-bamboos\n辅音+o，加 es——————————————————echo-echoes\nvolcano, mango, banjo, grotto, halo, archipelago 加 es 和 s 都可以\nvolcano-volcanos/volcanoes\n不规则变化的名词 man-men\nwoman ——\u0026gt; women\ngoose ——\u0026gt; geese\nfoot ——\u0026gt; feet\ntooth ——\u0026gt; teeth\nchild ——\u0026gt; children\nmouse ——\u0026gt; mice\nfish ——\u0026gt; fish\nsheep ——\u0026gt; sheep\ndeer ——\u0026gt; deer\n一直是复数的名词 scissors 剪刀\ntweezers 镊子\nglasses 眼镜\ncongratulations 祝贺\nclothes 衣服\ntrousers 裤子\namends 赔偿\nshenanigans 恶作剧\ncahoots 同伙\nsmithereens 碎片\n复合名词的变化 符合名词时两个名词合在一起\n不可数名词结尾，无复数形式\nhomework, newspaper, greenhouse\nman 或 woman 做前缀，前后都要复数\nman actor ——\u0026gt; men actors\n两个名词，后面变复数\nboy friend ——\u0026gt; boy friends\n可数名词+介词（短语），前面名词复数\nsister in law ——\u0026gt; sisters in law\n动词/过去分词+副词，加 s\nstand by ——\u0026gt; stand bys\n主谓一致 什么时主谓一致 主语的单复数和谓语的单复数要保持一致。\nI（单数） am（单数） student\n我是学生\nThey（复数） are（复数）students\n他们是学生\n国家、机构、书名等专有名词的复数形式看作整体，谓语用单数 The United States was founded in 1776\n美国建立于 1776 年\n“Three Kingdoms” is a good story\n三国演义是个好故事\nmany a\u0026hellip;或 more than one+名词做主语，谓语用单数。 Many a man is smoking\n很多男人在抽烟\nMore than one man is smoking\n不止一个男人在抽烟\none and a half + 复数名词做主语，谓语用单数 One and a half watermelons is in the fridge\n冰箱里有一个半西瓜\n时间、钱、距离等各种单位看作整体，谓语用单数 Two dollars is no big deal\n两美元没什么大不了\nFour miles is not a long way\n四英里的路不远\n加减乘除运算中，谓语用单数 Five times five is twenty-five\n5 乘 5 是 25\nOne plus one is two\n1 加 1 是 2\neach, one, no one, some(any, no, every)+body(one, thing)作主语或作限定词，谓语用单数 Each student is in the classroom\n每个学生都在教室里\nSomeone student is in the classroom\n某个学生在教室里\none+of+复数名词结构中，谓语用单数 One of the students in our school is from the United States\n我们学校有一名来自美国的学生\n含有集体概念的名词，根据上下文判断，整体概念谓语用单数，个体概念谓语用复数 The family was in a poor way\n这个家庭生活贫困（整体概念——这个家庭”）\nThe family goes to the movies together\n这家人一起去看电影（个体概念——这个家的所有人）\n含有单复数形式一样的名词作主语，根据上下文判断，谓语用单数还是复数 A fish was back in the water\n一条鱼回到了水中\nSome fish are still alive\n有些鱼还活着\na number of + 可数名词复数作主语，泛指许多不一定多少，谓语用复数 A number of scientists are single\n许多科学家都是单身\nthe number of+可数名词复数作主语，特指数量是多少，谓语用单数 The number of scientists in the lab is five\n实验室里的科学家人数是五人\nand 或者 both\u0026hellip;and.. 连接两个单数名词做主语，代表复数的概念，大多数情况谓语用复数 He and him families are at the funeral\n他和他的家人在参加葬礼\nBoth China and the United States are big countries\n中国和美国都是大国\nand 连接两个单数词，指同一人同一事物或同一概念，两个名词共用一个冠词，谓语动词用单数 The Youtuber and traveler is he friend\n这位旅行家兼 YouTube 视频博主是他的朋友\nand 连接两个单数词，主语前有 every，each，no，many a 修饰时，谓语用单数 Each day and night is busy\n每天都从早忙到晚\na/an+单数名词+or two 做主语，谓语用单数；one or two+复数名词做主语，谓语用复数 An apple or two is not enough\n一两个苹果是不够的\nOne or two apples are not enough\n一两个苹果是不够的\nsome of, plenty of, a lot of, lots of, most of, the rest of, all of, half of, part of ,分数/百分百 + of + 名词短语，作主语，谓语动词与 of 后的名词，保持单复数 Most of the student was gone\n大多数学生都走了\nMost of the students were gone\n大多数学生都走了\nfew、many、several、all、some 后面加名词做主语，谓语用复数 The few words are difficult\n这几句话好难\n就近原则（距离谓语近的名词，决定谓语单复数） There be/Here be 句型 There is one computer and two phones\n那有一台电脑和两台手机\nThere are two computers and one phone\n那有两台电脑和一台手机\nHere is one apple and two bananas\n这有一个苹果和两个香蕉\nHere are two apples and one banana\n这有两个苹果和一个香蕉\n就近原则（距离谓语近的名词，决定谓语单复数），or，either\u0026hellip;or\u0026hellip;(二选一),neither\u0026hellip;nor\u0026hellip;（两个都不选，选另外一个）,not only\u0026hellip;but\u0026hellip;(also)（不仅而且，两个都）连接并列作主语 His friends or he was dead（他的朋友们或者他已经死了）\nHe or his friends were dead （他或者他的朋友们已经死了）\nEither my brothers or mother is going to the garden（我弟弟或者妈妈要去花园）\nEither mother or my brothers are going to the garden（妈妈或者我弟弟要去花园）\nNeither two apples nor one banana is vegetable（两个苹果和一个香蕉都不是蔬菜）\nNeither one apple nor two bananas are vegetables（一个苹果和两个香蕉都不是蔬菜）\nNot only my friends but also my girlfriend was wrong（不仅是我朋友我女朋友也错了）\nNot only my girlfriend but also my friends were wrong（不仅是我女朋友我朋友也错了）\n就远原则（距离谓语远的名词，决定谓语单复数）四除（but，except，besides，in addition to）五和（with，along with，together with，combined with，as well as）包括（including）而不是（rather than，instead of） Peter, but his roommates, is friendly.（皮特人很好，除了他室友）\nPeter, except his roommates, is friendly. （皮特人很好，除了他室友）\nPeter, besides his roommates, is friendly. （皮特人很好，除了他室友）\nPeter, in addition to his roommates, is friendly. （皮特人很好，除了他室友）\nPeter, with his roommates, is friendly. （皮特和他室友人都很好）\nPeter, along with his roommates, is friendly. （皮特和他室友人都很好）\nPeter, together with his roommates, is friendly. （皮特和他室友人都很好）\nPeter, combined with his roommates, is friendly. （皮特和他室友人都很好）\nPeter, as well as his roommates, is friendly. （皮特和他室友人都很好）\nPeter, including his roommates, is friendly. （皮特人很好，包括他室友也很好）\nPeter, rather than his roommates, is friendly. （皮特人很好而不是他室友）\nPeter, instead of his roommates, is friendly. （皮特人很好而不是他室友）\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E5%90%8D%E8%AF%8D/","summary":"名词 表示人或物的名称。\n Rainy is a person  名词所有格 表示一种所有关系。\n比如小明的书包，其中小明的就是所有格，因为书包是属于小明的。\n表示人或动物的名词 + \u0026rsquo;s 这种名词所有格，构成的方式很容易，直接子表示人或动物的名词后面**+\u0026rsquo;s**就可以了，这里的 \u0026rsquo;s 相当于中文里的”的“。\n一个普通名词，在变成所有格的时候，，要注意可数名词不能单独使用，比如 friend\u0026rsquo;s ；需要加一个限定词 my，变成My friend\u0026rsquo;s这样才能构成名词所有格。\n作前置定语 Jack \u0026rsquo;s book\nJack \u0026rsquo;s books\nThe boss’s car\n同时它作前置定语的时候可以修饰可数名词（单数和复数形式）和不可数名词。\n复数名词 s 结尾，后加’ 如果名词是s结尾的复数或名词本身是s结尾， 直接加**\u0026rsquo;就可以了，当然也可以加\u0026rsquo;s**。\nMy boss\u0026rsquo;s 相当于 My boss\u0026rsquo;\nof + 无生命的名词 不可数名词或复数直接+of。 Of water\nOf oil\n可数名词不能直接加 of，需要加限定词或冠词或变复数。 of相当于中文**“的”的意思，the相当于“这”**的意思\nOf the house\nOf my house\nOf this coat\nOf the carrot\n被名词所有格作后置定语修饰的名词，都必须在这个名词前面+ the The price of the house.","title":"English 名词"},{"content":"名词从句 主语从句 将简单句修改，使其可以充当另一个句子的主语。\n The fact is obvious. ——\u0026gt; That the rabbit ate a carrot is obvious. ——\u0026gt; It is obvious that the rabbit ate a carrot.  主语从句从都有引导词：that、whether、when、what、how 等。\n That the hungry rabbit had already eaten a carrot for dinner this evening is obvious.  这个句子显然头重脚轻了，因此得改为：\n It is obvious that the hungry rabbit had already carrot for dinner the evening is obvious.  这句话中的 It 指代的是 that the hungry rabbit had already carrot for dinner the evening。\n宾语从句 将简单句修改，使其可以充当另一个句子的宾语。\n I saw that the rabbit ate a carrot.  宾语从句的引导词 that 往往可以省略  I know the rabbit ate a carrot.  但有时候 that 也不可以省略：\n l didn\u0026rsquo;t know that the rabbit atethe carrot and that you saw it.  否定词加在谓语动词前，而非从句中  I don not think that the rabbit is smart.  而非：\n I don not think that the rabbit is not smart.  主从时态一致 主句的时态要和从句的时态一致。\n I didn\u0026rsquo;t think that you were right.  表语从句 将简单句修改，使其可以充当另一个句子的表语。\n The problem is that the rabbit is hungry. The reason is that there\u0026rsquo;s no more carrot.  主语从句和表语从句 表达的意思大致一致，区别在于强调的信息不一样。\n 主语从句：That the rabbit ate a carrot is a secret. 表语从句：The secret is that the rabbit ate a carrot。  系动词非 be 动词  lt seems that the rabbit is hungry. lt feels that you\u0026rsquo;re not telling the truth  同位语从句 将简单句修改，使其可以充当另一个句子的同位语。\n The fact that the rabbit ate the carrot did not surprise me.  宾语补语从句 将简单句修改，使其可以充当另一个句子的宾语补语。\n You can call me what you like My education made me who I am today.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%90%8D%E8%AF%8D%E4%BB%8E%E5%8F%A5/","summary":"名词从句 主语从句 将简单句修改，使其可以充当另一个句子的主语。\n The fact is obvious. ——\u0026gt; That the rabbit ate a carrot is obvious. ——\u0026gt; It is obvious that the rabbit ate a carrot.  主语从句从都有引导词：that、whether、when、what、how 等。\n That the hungry rabbit had already eaten a carrot for dinner this evening is obvious.  这个句子显然头重脚轻了，因此得改为：\n It is obvious that the hungry rabbit had already carrot for dinner the evening is obvious.  这句话中的 It 指代的是 that the hungry rabbit had already carrot for dinner the evening。","title":"English 名词从句"},{"content":"命令、警告 Get out！（滚！）\nBe quiet, please.（请安静）\nBe careful（小心）\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%A5%88%E4%BD%BF%E5%8F%A5/%E5%91%BD%E4%BB%A4%E8%AD%A6%E5%91%8A/","summary":"命令、警告 Get out！（滚！）\nBe quiet, please.（请安静）\nBe careful（小心）","title":"English 命令、警告"},{"content":"复合句 也叫并列句， 句与句之间没有主次之分\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E5%90%88%E5%8F%A5/%E5%A4%8D%E5%90%88%E5%8F%A5/","summary":"复合句 也叫并列句， 句与句之间没有主次之分","title":"English 复合句"},{"content":"复杂句 表示用简单句所组成的从属关系的句子；也就是表示一个句子套另一个句子，这两个句子分别叫做主句和从句。\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%A4%8D%E6%9D%82%E5%8F%A5/","summary":"复杂句 表示用简单句所组成的从属关系的句子；也就是表示一个句子套另一个句子，这两个句子分别叫做主句和从句。","title":"English 复杂句"},{"content":"定语 用于修饰名词或代词，也可以说定语是广义的形容词，通常情况，哪里有名词，哪里就有定语。\n定语可以将名词具体化，缩小名词的范围.比如你去帮我买香蕉，这句话并不具体，因为没有表示要买多少根香蕉，或者买什么种类的香蕉，因此，我们需要加上一些具体的词，使我们的句子更加合理化，这些词就是定语。\n在英语中，普通名词才能用定语修饰 ，专有名词是不能用定语修饰的，特殊情况除外。\n同一个普通名词，可以有多个定语修饰。\n The little white rabbit ate a large carrot. One book a bottle of water Two beautiful girls  前置定语 放在名词前面修饰名词的词语。\n后置定语 放在名词后面修饰名词的词语。\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%AE%9A%E8%AF%AD/","summary":"定语 用于修饰名词或代词，也可以说定语是广义的形容词，通常情况，哪里有名词，哪里就有定语。\n定语可以将名词具体化，缩小名词的范围.比如你去帮我买香蕉，这句话并不具体，因为没有表示要买多少根香蕉，或者买什么种类的香蕉，因此，我们需要加上一些具体的词，使我们的句子更加合理化，这些词就是定语。\n在英语中，普通名词才能用定语修饰 ，专有名词是不能用定语修饰的，特殊情况除外。\n同一个普通名词，可以有多个定语修饰。\n The little white rabbit ate a large carrot. One book a bottle of water Two beautiful girls  前置定语 放在名词前面修饰名词的词语。\n后置定语 放在名词后面修饰名词的词语。","title":"English 定语"},{"content":"宾补 对宾语进行补充说明，使得句子意思完整。\n宾补只跟宾语有关系，跟主语没关系。\n He made the English class funny I make you rich. We keep the room clean.  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%AE%BE%E8%A1%A5/","summary":"宾补 对宾语进行补充说明，使得句子意思完整。\n宾补只跟宾语有关系，跟主语没关系。\n He made the English class funny I make you rich. We keep the room clean.  ","title":"English 宾补"},{"content":"宾语 指动作（谓语）的承受者。\n能作主语的词都可以作宾语，不能作主语的，也不能作宾语。但要注意的是，如果是人称代词作宾语，则必须用宾格，不能用主格。\n I buy a book every year. You believe us I want two apples.  和表语不同，宾语前面不需要也不能有系动词 be.\n间宾 一般来说， 我们把表示人的称为间接宾语。\n间宾和直宾的位置是可以换的，如果间宾放直宾的后面，那么要在间宾的前面＋ to.\n Rainy teaches you English I gave a book to her I gave them books  直宾 我们把表示物的称为直接宾语。\n Rainy teaches you English  与宾补的区别 主语 + 及物动词 + 宾语 + 名词（作宾语）\n主语 + 及物动词 + 宾语 + 名词（作宾补）\n  I gave her a book.\n  I call her Mary.\n  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%AE%BE%E8%AF%AD/","summary":"宾语 指动作（谓语）的承受者。\n能作主语的词都可以作宾语，不能作主语的，也不能作宾语。但要注意的是，如果是人称代词作宾语，则必须用宾格，不能用主格。\n I buy a book every year. You believe us I want two apples.  和表语不同，宾语前面不需要也不能有系动词 be.\n间宾 一般来说， 我们把表示人的称为间接宾语。\n间宾和直宾的位置是可以换的，如果间宾放直宾的后面，那么要在间宾的前面＋ to.\n Rainy teaches you English I gave a book to her I gave them books  直宾 我们把表示物的称为直接宾语。\n Rainy teaches you English  与宾补的区别 主语 + 及物动词 + 宾语 + 名词（作宾语）\n主语 + 及物动词 + 宾语 + 名词（作宾补）\n  I gave her a book.","title":"English 宾语"},{"content":"形容词 用于修饰名词的词，简称 adj.\n普通形容词 单独一个单词的形容词。\n当形容词作定语的时候，前面必须加一个冠词 。\n She is a beautifu girl. he has a big house. He was angry now. I am very sad right now. I am smart person.  复合形容词 指的是由两个单词构成的一个新的形容词，两个单词之间有一个符号“-”\n sky-blue good-looking man-made second-hand  形容词的先后顺序 当出现几个形容词同时修饰名词作前置定语的时候，这时候我们就要考虑这些形容词在一句话中的先后顺序。\n 冠词（a、an、the ）、物主代词（my）、数词（three）、指示代词等 描绘性的形容词 beautiful 表示形状、大小、长短、高矮。 表示年龄或者新旧。 表示颜色。 表示出处、来源。 表示材料，物质 表示用途  但一般情况下，同时修饰一个名词的形容词数量不会超过 4 个，多了就不是特别好了。、\n形容词的比较级和最高级 大部分的形容词都有三个格式：原级、比较级、最高级。比较级就是相当于中文里面”更”的意思，最高级就相当于“最”的意思。\n比如：漂亮的是一个形容词，更漂亮是一个比较级，最漂亮是一个最高级。\n一个形容词的比较级和最高级的用法和原级是一样的，都可以作定语、表语和宾补。\nA 超过 B A + be + 形容词比较级 + than + B.\n I am taller than he. My girlfriend is more beautiful than her. My boss is richer than yours.  A 不如 B A + be not + 形容词的比较级 + than + B.\n I am not taller than he. My girlfriend is not more beautiful than her. My boss is not richer than yours.  A 与 B A + be + as + 形容词的原级 + as + B.\n I am as tall as he. She is as fat as me.  A 最 \u0026hellip; A + be + the + 形容词的最高级 + 表示范围的词.\nHe is the richest in Guangxi.\nThe house is the highest in Chongqin.\nI am the tallest in the class.\nMy girlfriend is the most beautiful in the heart.\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%BD%A2%E5%AE%B9%E8%AF%8D/","summary":"形容词 用于修饰名词的词，简称 adj.\n普通形容词 单独一个单词的形容词。\n当形容词作定语的时候，前面必须加一个冠词 。\n She is a beautifu girl. he has a big house. He was angry now. I am very sad right now. I am smart person.  复合形容词 指的是由两个单词构成的一个新的形容词，两个单词之间有一个符号“-”\n sky-blue good-looking man-made second-hand  形容词的先后顺序 当出现几个形容词同时修饰名词作前置定语的时候，这时候我们就要考虑这些形容词在一句话中的先后顺序。\n 冠词（a、an、the ）、物主代词（my）、数词（three）、指示代词等 描绘性的形容词 beautiful 表示形状、大小、长短、高矮。 表示年龄或者新旧。 表示颜色。 表示出处、来源。 表示材料，物质 表示用途  但一般情况下，同时修饰一个名词的形容词数量不会超过 4 个，多了就不是特别好了。、\n形容词的比较级和最高级 大部分的形容词都有三个格式：原级、比较级、最高级。比较级就是相当于中文里面”更”的意思，最高级就相当于“最”的意思。\n比如：漂亮的是一个形容词，更漂亮是一个比较级，最漂亮是一个最高级。\n一个形容词的比较级和最高级的用法和原级是一样的，都可以作定语、表语和宾补。\nA 超过 B A + be + 形容词比较级 + than + B.","title":"English 形容词"},{"content":"形容词从句 将简单句修改，使它成为另一个句子的定语。也叫定语从句或关系从句。\n定语从句都是后置的。\n从句由先行词 + 关系词，组成，关系词可以分为关系代词和关系副词。\n a carrot that I bought.  关系词 先行词 + 关系代词\n先行词是唯一的，用 that.\n The rebbit ate the largest carrot that I\u0026rsquo;ve ever seen. The only rebbit that ate a carrot  先行词多选一，用 which.\n The rebbit ate a carrot which I bought.  关系副词 关系副词相当于介词+关系副词\nwhere、why 、when\n限定性形容词性从句 The rabbit ate the carrot which was on the table.\n其中 **which was on the table **限定了 carrot 的范围，which 相当于 the carrot\n非限定性形容词从句 The rabbit ate the carrot, which was on the table.\n这句话表达了一前一后两个意思： The rabbit ate the carrot 和 which was on the table 。\n非限定性形容词从句指代整句话  The rabbit ate the carrot, which was not surprising.  which 指代 The rabbit ate the carrot\n限定性和非限定性  I have a head which is round.  我有好几个头，其中一个头是圆的。\n I have a head, which is round.  我有一个头，这个头是圆的。\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%BD%A2%E5%AE%B9%E8%AF%8D%E4%BB%8E%E5%8F%A5/","summary":"形容词从句 将简单句修改，使它成为另一个句子的定语。也叫定语从句或关系从句。\n定语从句都是后置的。\n从句由先行词 + 关系词，组成，关系词可以分为关系代词和关系副词。\n a carrot that I bought.  关系词 先行词 + 关系代词\n先行词是唯一的，用 that.\n The rebbit ate the largest carrot that I\u0026rsquo;ve ever seen. The only rebbit that ate a carrot  先行词多选一，用 which.\n The rebbit ate a carrot which I bought.  关系副词 关系副词相当于介词+关系副词\nwhere、why 、when\n限定性形容词性从句 The rabbit ate the carrot which was on the table.\n其中 **which was on the table **限定了 carrot 的范围，which 相当于 the carrot","title":"English 形容词从句"},{"content":"感叹词 用于表示感叹或发出某种情感，通常处于句子的最前面或最后面，一般与句子本身没有实际的直接联系，简称 int.\n比如 What、yum、blah 等都是叹词。\n在 Ah，the apple is tasty 中，Ah 是叹词。\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E6%84%9F%E5%8F%B9%E8%AF%8D/","summary":"感叹词 用于表示感叹或发出某种情感，通常处于句子的最前面或最后面，一般与句子本身没有实际的直接联系，简称 int.\n比如 What、yum、blah 等都是叹词。\n在 Ah，the apple is tasty 中，Ah 是叹词。","title":"English 感叹词"},{"content":"数词 用于表示数量、数字、第几的词.\n例句  The first is important. Eight is a number  基数词 表示数量的数词，比如一、二、三。\n100 ~ 999 一 = one\n十 = ten\n百 = hundred\n千 = thousand\n万 = ten thousand\n十万 = one hundred\n百万 = one million\n一亿 = one hundred million\n十亿 = one billion\n百亿 = ten billion\n千亿 = myriads\n特点 作数词时候，前面可以加数词，后面不能加 s，two thousand，three thousands（错）\n如果数词用作名词时候，意思是好几…的时候，前面可以加 some、many、several 这种词或者加数词，后面可以加 of\nhundreds of（好几百）\nfive hundreds of（五百左右）\nmany millions of （数百万）\n表示年龄 I’m twenty (我 20 岁)\n表示编号 Room 101=Room one 0 one（101 房间）\nBus No.10=Bus Number ten（10 路公交车）\n表示年代 1940’s=nineteen forty’s (20 世纪 40 年代)\n表示年份 2008=twenty thousand and eight\n1949=nineteen forty-nine\n2019.9.10=Sep.10th,2019=September, tenth, twenty nineteen\n表示时刻 中国人描述时间习惯精确到个位分钟，外国人描述时间习惯精确到十位分钟，几分钟一般省略）\n6：00=six o’clock=six on the dot（6 点整）\n6：05=six o five=five past six（6 点 05 分，6 点过 5 分）\n6：15=six fifteen=a quarter past six（6 点 15 分，6 点过一刻）\n6：30=six thirty=half past six（6 点 30 分，6 点半）\n6：45=six forty-five=a quarter to（till） seven（6 点 45 分，7 点差一刻）\n6：55=six fifty-five=five to（till） seven（6 点 55 分，7 点差 5 分）\n时区：time zones\n上午：ante meridiem=a.m.\n下午：post meridiem=p.m.\n24 小时制=24-hour clock=military time（北美不太使用 24 小时制，都是说 12 小时制加 am 和 pm）\n21：00=twenty one hours\n21：20=twenty one twenty\n电话号码直接读数字，北美电话，区号（3 位）+用户号（7 位） 647-300-2516=six four seven-three double o-two five one six\n说价格 (经常省略 dollars 和 cents) nine thirty= nine dollars and thirty cents (9.30$)\nninety-nine ninety-eight= ninety-nine dollars and ninety-eight cents (99.98$)\n表示小数（经常省略 zero，或者读成 o） 0.5=（zero）point five (零点五)\n0.05=（zero）point o five (零点零五)\n两个一样数字，三个一样数字（double、triple ） 007=double o seven （零零七）\nboeing 777=boeing triple seven （波音 777）\n序数词 表示顺序的数词，比如第一、第二、第三。\n十位 十位用基数词，个位用序数词\n百位以上 整数的后面加 th，如果不是整数，就保留基数词，只把个位变为序数词即可。\n使用序数词时，一般前面要加定冠词 the I’m in the second room（我在第二个房间）\n表示时间日期 The first of September=Sep 1st (九月一日)\n表示楼层 The first floor(一楼)\n特点 序数词表示几分之几，分子大于一，分母有复数形式。\n序数词前面加 a/an 表示再一次（又一次），序数词前面加 the 表示顺序\nWe read the book a third times\n我们读了三遍这本书\nThe second door of the room is closed\n房间的第二扇门是关的\n数字表达规律 从右往左，每三位加一个逗号，\n倒数第一个逗号之前（逗号的左边）是 thousand，\n倒数第二个逗号之前是 million，\n倒数第三个逗号之前是 billion，\n倒数第四个逗号之前是 trillion.\n逗号与逗号之间的百位和十位要加 and\n数字之间隔零要加 and\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E6%95%B0%E8%AF%8D/","summary":"数词 用于表示数量、数字、第几的词.\n例句  The first is important. Eight is a number  基数词 表示数量的数词，比如一、二、三。\n100 ~ 999 一 = one\n十 = ten\n百 = hundred\n千 = thousand\n万 = ten thousand\n十万 = one hundred\n百万 = one million\n一亿 = one hundred million\n十亿 = one billion\n百亿 = ten billion\n千亿 = myriads\n特点 作数词时候，前面可以加数词，后面不能加 s，two thousand，three thousands（错）\n如果数词用作名词时候，意思是好几…的时候，前面可以加 some、many、several 这种词或者加数词，后面可以加 of\nhundreds of（好几百）\nfive hundreds of（五百左右）","title":"English 数词"},{"content":"特殊疑问句 不可以用 yes、no 回答的疑问句。\n特殊疑问句是对句子中的某个句子成分提问，用特殊疑问词开头，下面列举一些特殊疑问词。\n特殊疑问词 Who 提问人，是谁？\n Who’s next? Who is the richet? Who is in my room?  Whose 提问所属，谁的？。\n Whose car is this? Whose money do you spend? Whose car will Jeff drive after class?  Whom 提问宾格人 Who 的宾格。\n Whom did you choose for our them leader?     Whom do you love?      What 提问事情属性，是什么？\n What time is it? Whom has he fallen in love with? What makes you unhappy? What made you angry? What is in your pocket? What cellphone do you like?  When 提问时间，什么时候?\n When can we start working? When do you get up every morning? When is your birthday?  Where 提问地点，在哪里？\n Where is the bathroom?  Why 提问原因，为什么？\n Why did he do it?  How 提问方式数量，如何？怎么样？\n How heavy is it? How is your father? How does she do business? How will you bake corn tomorrow? How far is your home from your school?  How much/many 提问数量，多少？\nhow much 用来询问事物的数量，后接不可数名词\nhow many 用来询问事物的数量，后接可数名词复数。\n How much longer? How much is your computer? How much money do you have? How many boys like you?  Which 提问选择，哪个？\n Which is your choice? Which girl do you like? Which book dou you read? Who wife is woman？  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E7%89%B9%E6%AE%8A%E7%96%91%E9%97%AE%E5%8F%A5/","summary":"特殊疑问句 不可以用 yes、no 回答的疑问句。\n特殊疑问句是对句子中的某个句子成分提问，用特殊疑问词开头，下面列举一些特殊疑问词。\n特殊疑问词 Who 提问人，是谁？\n Who’s next? Who is the richet? Who is in my room?  Whose 提问所属，谁的？。\n Whose car is this? Whose money do you spend? Whose car will Jeff drive after class?  Whom 提问宾格人 Who 的宾格。\n Whom did you choose for our them leader?     Whom do you love?      What 提问事情属性，是什么？\n What time is it?","title":"English 特殊疑问句"},{"content":"状语 用于修饰谓语动词，它只跟谓语有关系。\nxxx 的执行某个动作，xxx 就是状语。\n The rabbit ate quickly I teach English in Beijing I am happy in Guizhou I am happy today I am busy now I will buy a book tomorrow I speak English slowly  一句话里面可以使用多个状语，但有的时候可能逻辑不对。\n I always eat bread every day.  这个句子语法没问题，但是逻辑有矛盾，因为“总是吃”不代表“每天吃”，两者的频率是不同的“每天吃”的频率比“总是吃”要高很多。\n如果改成下面这个句子就对了：\n I always eat bread in the morning.  把 every day 换成 in the morning，就不会和 always 逻辑冲突了。\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E7%8A%B6%E8%AF%AD/","summary":"状语 用于修饰谓语动词，它只跟谓语有关系。\nxxx 的执行某个动作，xxx 就是状语。\n The rabbit ate quickly I teach English in Beijing I am happy in Guizhou I am happy today I am busy now I will buy a book tomorrow I speak English slowly  一句话里面可以使用多个状语，但有的时候可能逻辑不对。\n I always eat bread every day.  这个句子语法没问题，但是逻辑有矛盾，因为“总是吃”不代表“每天吃”，两者的频率是不同的“每天吃”的频率比“总是吃”要高很多。\n如果改成下面这个句子就对了：\n I always eat bread in the morning.  把 every day 换成 in the morning，就不会和 always 逻辑冲突了。","title":"English 状语"},{"content":"简单句 陈述句 肯定式 i have money\n肯定式边否定式，助动词（do）后面，加否定词（not）\n否定式 i don’t have money\n疑问句 感叹句 祈使句 ","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%AE%80%E5%8D%95%E5%8F%A5/","summary":"简单句 陈述句 肯定式 i have money\n肯定式边否定式，助动词（do）后面，加否定词（not）\n否定式 i don’t have money\n疑问句 感叹句 祈使句 ","title":"English 简单句"},{"content":"表语 说明主语怎么怎么样，是谓语的一部分。\n表语和系动词 be 不能分开使用，没有系动词就没有表语，没有表语就没有系动词，因此，系动词后面的词大部分都是表语。\n  I am rich\n  You are my friend\n  We are in the classroom\n  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E8%A1%A8%E8%AF%AD/","summary":"表语 说明主语怎么怎么样，是谓语的一部分。\n表语和系动词 be 不能分开使用，没有系动词就没有表语，没有表语就没有系动词，因此，系动词后面的词大部分都是表语。\n  I am rich\n  You are my friend\n  We are in the classroom\n  ","title":"English 表语"},{"content":"语气词 + 感叹号 Wow! That’s totally awesome!\n哇！真是厉害！\nOh! You’re Peter！\n哇！你是皮特！\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E6%84%9F%E5%8F%B9%E5%8F%A5/%E8%AF%AD%E6%B0%94%E8%AF%8D-+-%E6%84%9F%E5%8F%B9%E5%8F%B7/","summary":"语气词 + 感叹号 Wow! That’s totally awesome!\n哇！真是厉害！\nOh! You’re Peter！\n哇！你是皮特！","title":"English 语气词 + 感叹号"},{"content":"请求、祝愿 Have a good day（祝你有美好的一天）\nLet me help you（让我帮你）\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%A5%88%E4%BD%BF%E5%8F%A5/%E8%AF%B7%E6%B1%82%E7%A5%9D%E6%84%BF/","summary":"请求、祝愿 Have a good day（祝你有美好的一天）\nLet me help you（让我帮你）","title":"English 请求、祝愿"},{"content":"谓语 一般在主语之后，用于说明主语的动作、状态、特征和行为。\n动作型谓语 用于说明主语做什么。\n一般由谓语动词构成。\n例句  I eat an apple everyday  简单谓语 由实义动词或复合动词构成。\n例句  I wrok every day. I run every run. I love you. She looks after her brother. I git up at six  复合谓语 由简单谓语 + 其他词语，共同作谓语的情况。\n情态动词 + 实义动词/复合动词的原形  I can speak Cantonese I can look after her  助动词 ＋ 实义动词/复合动词的原形  I will buy a new book tomorrow. I will get up early tomorrow.  助动词 + 其他动词形式（be + doing 或 have/has + done）  I am working now. I have learned English for 10 years  状态型谓语 用于说明主语是什么或怎么怎么样。\n一般由系动词 + 表语构成，也是一种复合谓语。\n I am an English teacher She is very beautiful He is a doctor  ","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E8%B0%93%E8%AF%AD/","summary":"谓语 一般在主语之后，用于说明主语的动作、状态、特征和行为。\n动作型谓语 用于说明主语做什么。\n一般由谓语动词构成。\n例句  I eat an apple everyday  简单谓语 由实义动词或复合动词构成。\n例句  I wrok every day. I run every run. I love you. She looks after her brother. I git up at six  复合谓语 由简单谓语 + 其他词语，共同作谓语的情况。\n情态动词 + 实义动词/复合动词的原形  I can speak Cantonese I can look after her  助动词 ＋ 实义动词/复合动词的原形  I will buy a new book tomorrow. I will get up early tomorrow.","title":"English 谓语"},{"content":"连词 用来连接词与词、词组与词组、句子与句子，使得形成某种逻辑关系或语法结构的词。简称 conj.\n连词可以表并列、承接、转折、因果、选择、假设、比较、让步等关系。\n1、并列连词\nand 和，那么，渐渐\nor 或，否则，不管是…，还是\nbut 但是，而是，的确…但\nnor 也不\nso 也是，因此，所以，那么，这样看来\nfor 因为（表示推测），由于\n2、相关连词\nboth A and B 既是 A 又是 B\neither A or B 不是 A 就是 B\nneither A nor B 既不是 A 也不是 B，两者皆非\nnot only A but also B 不但 A 而且 B\nA as well as B 不但 A 而且 B ,与，和\n3、准连词\n而且 besides, furthermore, moreover, in addition\n然而 yet, still, however, nevertheless\n否则 else, otherwise\n因此，所以 thus, hence, therefore, accordingly, consequently\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E8%BF%9E%E8%AF%8D/","summary":"连词 用来连接词与词、词组与词组、句子与句子，使得形成某种逻辑关系或语法结构的词。简称 conj.\n连词可以表并列、承接、转折、因果、选择、假设、比较、让步等关系。\n1、并列连词\nand 和，那么，渐渐\nor 或，否则，不管是…，还是\nbut 但是，而是，的确…但\nnor 也不\nso 也是，因此，所以，那么，这样看来\nfor 因为（表示推测），由于\n2、相关连词\nboth A and B 既是 A 又是 B\neither A or B 不是 A 就是 B\nneither A nor B 既不是 A 也不是 B，两者皆非\nnot only A but also B 不但 A 而且 B\nA as well as B 不但 A 而且 B ,与，和\n3、准连词\n而且 besides, furthermore, moreover, in addition\n然而 yet, still, however, nevertheless","title":"English 连词"},{"content":"选择疑问句 不可以用 yes，no 回答\n选择疑问句用 or 连接，一般是提问两个以上的句子内容，我们选择其中一个进行回答。\n选择疑问句：Do you like to play football or basketball?（你喜欢踢球还是打篮球？）\n回答：I like to play football./I like to play basketball.\n","permalink":"https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E9%80%89%E6%8B%A9%E7%96%91%E9%97%AE%E5%8F%A5/","summary":"选择疑问句 不可以用 yes，no 回答\n选择疑问句用 or 连接，一般是提问两个以上的句子内容，我们选择其中一个进行回答。\n选择疑问句：Do you like to play football or basketball?（你喜欢踢球还是打篮球？）\n回答：I like to play football./I like to play basketball.","title":"English 选择疑问句"},{"content":"git add 将我们需要提交的代码从工作区添加到暂存区，也就是告诉 git ，我们要提交哪些文件。之后就可以使用git commit命令进行提交了。\ngit add . 添加当前目录所有的文件，. 表示当前目录的所有文件夹。\ngit add FileName 添加文件名为 FileNmae 的文件，FileNmae 代表需要被添加的文件的名字，比如 git add ReadMe.txt，即表示添加这个 ReadMe.txt 文件，\n添加多个文件时，文件名使用空格分开即可 git add FileName1 FileName2 FileName3 多次 git add git add FileName1 git add FileName2 git add FileName3 git add -f git add .不会添加被**.gitignore忽略的文件，而git add -f . 强制添加所有文件，即使是被.gitignore**忽略的文件也添加。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-add/","summary":"git add 将我们需要提交的代码从工作区添加到暂存区，也就是告诉 git ，我们要提交哪些文件。之后就可以使用git commit命令进行提交了。\ngit add . 添加当前目录所有的文件，. 表示当前目录的所有文件夹。\ngit add FileName 添加文件名为 FileNmae 的文件，FileNmae 代表需要被添加的文件的名字，比如 git add ReadMe.txt，即表示添加这个 ReadMe.txt 文件，\n添加多个文件时，文件名使用空格分开即可 git add FileName1 FileName2 FileName3 多次 git add git add FileName1 git add FileName2 git add FileName3 git add -f git add .不会添加被**.gitignore忽略的文件，而git add -f . 强制添加所有文件，即使是被.gitignore**忽略的文件也添加。","title":"Git git add"},{"content":"git branch 一般用于对分支的操作，比如创建分支，查看分支等等，\ngit branch 不带参数：列出本地已经存在的分支，并且在当前分支的前面用*****标记\n一个新的本地仓库，必须在git add且git commit之后，再使用git branch命令，才能显示出本地分支master。\ngit branch BranchName 创建名为BranchName的分支，创建分支时需要是最新（当前分支的代码已经git commit）的环境，并且创建分支后依然停留在当前分支。\ngit branch -d BranchName 删除名为BranchName的分支，如果在分支中有一些未merge的提交，那么会删除分支失败，此时可以使用git branch -D BranchName强制删除名为BranchName的分支\ngit branch \u0026ndash;set-upstream-to=origin/dev LocalDev 将名为LocalDev的本地分支与名为origin/dev的远程分支相关联。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-branch/","summary":"git branch 一般用于对分支的操作，比如创建分支，查看分支等等，\ngit branch 不带参数：列出本地已经存在的分支，并且在当前分支的前面用*****标记\n一个新的本地仓库，必须在git add且git commit之后，再使用git branch命令，才能显示出本地分支master。\ngit branch BranchName 创建名为BranchName的分支，创建分支时需要是最新（当前分支的代码已经git commit）的环境，并且创建分支后依然停留在当前分支。\ngit branch -d BranchName 删除名为BranchName的分支，如果在分支中有一些未merge的提交，那么会删除分支失败，此时可以使用git branch -D BranchName强制删除名为BranchName的分支\ngit branch \u0026ndash;set-upstream-to=origin/dev LocalDev 将名为LocalDev的本地分支与名为origin/dev的远程分支相关联。","title":"Git git add"},{"content":"git checkout $ git checkout \u0026ndash;File 清空名为File文件的修改，注意不要忘记中间的 \u0026ndash;，，如果不加 \u0026ndash;，就变成了切换到 FileName 分支的命令。\n$ git checkout -- ReadMe.txt git checkout . 清空在工作区中，对文件所作的所有修改，**.**表示当前目录的所有文件夹。\ngit checkout Branch to track remote branch \u0026#39;BranchName\u0026#39; from \u0026#39;origin\u0026#39;. 将当前分支切换到名为BranchName的分支\ngit checkout -b BranchName -b 参数相当于以下两条命令\ngit branch BranchName git checkout BranchName git checkout -b LocalBranch origin/RemoteBranch 在本地创建一个名为LocalBranch的分支，并创建一个名为RemoteBranch的远程分支。\n这个远程分支和本地分支相对应，另外，本地和远程分支的名称最好一致。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-checkout/","summary":"git checkout $ git checkout \u0026ndash;File 清空名为File文件的修改，注意不要忘记中间的 \u0026ndash;，，如果不加 \u0026ndash;，就变成了切换到 FileName 分支的命令。\n$ git checkout -- ReadMe.txt git checkout . 清空在工作区中，对文件所作的所有修改，**.**表示当前目录的所有文件夹。\ngit checkout Branch to track remote branch \u0026#39;BranchName\u0026#39; from \u0026#39;origin\u0026#39;. 将当前分支切换到名为BranchName的分支\ngit checkout -b BranchName -b 参数相当于以下两条命令\ngit branch BranchName git checkout BranchName git checkout -b LocalBranch origin/RemoteBranch 在本地创建一个名为LocalBranch的分支，并创建一个名为RemoteBranch的远程分支。\n这个远程分支和本地分支相对应，另外，本地和远程分支的名称最好一致。","title":"Git git checkout"},{"content":"git cherry-pick 对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。\n这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（git merge）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。\ngit cherry-pick commitHash 将指定的commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-cherry-pick/","summary":"git cherry-pick 对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。\n这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（git merge）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。\ngit cherry-pick commitHash 将指定的commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。","title":"Git git cherry-pick"},{"content":"git clone 拷贝一个远程库到本地，让自己能够查看该项目，或者进行修改。\ngit clone RemoteAddress 克一个RemoteAddress到本地。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-clone/","summary":"git clone 拷贝一个远程库到本地，让自己能够查看该项目，或者进行修改。\ngit clone RemoteAddress 克一个RemoteAddress到本地。","title":"Git git clone"},{"content":"git commit 将暂存区中的内容添加到本地仓库，相当于确认提交暂存区中的内容。\n每次使用git commit命令我们都会在本地版本库生成一个 40 位的哈希值，这个哈希值也叫 commit-id， commit-id 在版本回退的时候是非常有用的，它相当于一个快照，可以在未来的任何时候通过与git reset的组合命令回到这里.\ngit commit -m ‘message’ -m 参数表示可以直接输入后面的 “message”，如果不加 -m 参数，那么是不能直接输入 message 的，而是会调用一个编辑器一般是 vim 来让你输入这个 message。message 即是我们用来简要说明这次提交的语句，比如对文件进行了哪些修改、谁进行的修改等等。\n常见错误 用 git 提交的时候，报错:\npathspec \u0026#39;commit\u0026#39;\u0026#39; did not match any file(s) known to git 后来发现用单引号提交报错，改成双引号就成功了\ngit commit -m \u0026#34;first commit\u0026#34; ","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-commit/","summary":"git commit 将暂存区中的内容添加到本地仓库，相当于确认提交暂存区中的内容。\n每次使用git commit命令我们都会在本地版本库生成一个 40 位的哈希值，这个哈希值也叫 commit-id， commit-id 在版本回退的时候是非常有用的，它相当于一个快照，可以在未来的任何时候通过与git reset的组合命令回到这里.\ngit commit -m ‘message’ -m 参数表示可以直接输入后面的 “message”，如果不加 -m 参数，那么是不能直接输入 message 的，而是会调用一个编辑器一般是 vim 来让你输入这个 message。message 即是我们用来简要说明这次提交的语句，比如对文件进行了哪些修改、谁进行的修改等等。\n常见错误 用 git 提交的时候，报错:\npathspec \u0026#39;commit\u0026#39;\u0026#39; did not match any file(s) known to git 后来发现用单引号提交报错，改成双引号就成功了\ngit commit -m \u0026#34;first commit\u0026#34; ","title":"Git git commit"},{"content":"git config alias git config alias.ShorthandName OriginalName 将git OriginalName命令修改（通常为简写）为git ShorthandName，且只对当前 Git 仓库有效，配置文件在当前仓库的**.git/config**中。\ngit config \u0026ndash;global alias.ShorthandName OriginalName 加上--global参数可以对当前用户下的所有仓库起作用，配置文件在 C 盘用户目录下的一个**.gitconfig**文件中。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-config-alias/","summary":"git config alias git config alias.ShorthandName OriginalName 将git OriginalName命令修改（通常为简写）为git ShorthandName，且只对当前 Git 仓库有效，配置文件在当前仓库的**.git/config**中。\ngit config \u0026ndash;global alias.ShorthandName OriginalName 加上--global参数可以对当前用户下的所有仓库起作用，配置文件在 C 盘用户目录下的一个**.gitconfig**文件中。","title":"Git git config alias"},{"content":"git config user git config user.name \u0026ldquo;UserName\u0026rdquo; git config user.email \u0026ldquo;Email\u0026rdquo; 对当前仓库设置名为UserName的用户名和名为Email的邮箱。\ngit config \u0026ndash;global user.name \u0026ldquo;UserName\u0026rdquo; git config \u0026ndash;global user.email \u0026ldquo;Email\u0026rdquo; git config命令的–global参数，表示你这台机器上所有的 Git 仓库都会使用这个配置，当然也可以对不同的仓库指定不同的用户名和 Email 地址。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-config-user/","summary":"git config user git config user.name \u0026ldquo;UserName\u0026rdquo; git config user.email \u0026ldquo;Email\u0026rdquo; 对当前仓库设置名为UserName的用户名和名为Email的邮箱。\ngit config \u0026ndash;global user.name \u0026ldquo;UserName\u0026rdquo; git config \u0026ndash;global user.email \u0026ldquo;Email\u0026rdquo; git config命令的–global参数，表示你这台机器上所有的 Git 仓库都会使用这个配置，当然也可以对不同的仓库指定不同的用户名和 Email 地址。","title":"Git git config user"},{"content":"git diff git diff 比较暂存区与工作区中文件之间的差异，可以让我们知道这些文件具体修改了些什么。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-diff/","summary":"git diff git diff 比较暂存区与工作区中文件之间的差异，可以让我们知道这些文件具体修改了些什么。","title":"Git git diff"},{"content":"git log 可以让我们查看从最近到最远所有的历史提交日志，每条日志中有对应的版本号，这个版本号可以让我们回退到指定版本号的那个版本。\ngit log \u0026ndash;pretty=oneline 每条日志都只显示一行 多屏显示控制方式空格向下翻页 b 向上翻页 q 退出\ngit log \u0026ndash;graph 用于查看分支的合并图，也叫做点线图。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-log/","summary":"git log 可以让我们查看从最近到最远所有的历史提交日志，每条日志中有对应的版本号，这个版本号可以让我们回退到指定版本号的那个版本。\ngit log \u0026ndash;pretty=oneline 每条日志都只显示一行 多屏显示控制方式空格向下翻页 b 向上翻页 q 退出\ngit log \u0026ndash;graph 用于查看分支的合并图，也叫做点线图。","title":"Git git log"},{"content":"git merge 用于合并指定分支到当前分支\ngit merge BranchName 将名为 BranchName 的分支合并到当前分支。\ngit merge \u0026ndash;no-ff -m \u0026ldquo;merge with no-ff\u0026rdquo; BranchName 合并名为 BranchName 的分支到当前分支，并创建一个新的 commit，所以加上-m参数，将 commit 的描述写进去。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-merge/","summary":"git merge 用于合并指定分支到当前分支\ngit merge BranchName 将名为 BranchName 的分支合并到当前分支。\ngit merge \u0026ndash;no-ff -m \u0026ldquo;merge with no-ff\u0026rdquo; BranchName 合并名为 BranchName 的分支到当前分支，并创建一个新的 commit，所以加上-m参数，将 commit 的描述写进去。","title":"Git git merge"},{"content":"git pull 用于从远程获取代码并合并本地。\ngit pull origin master:dev 将远程仓库origin的master分支拉取过来，与本地的dev分支合并。\ngit pull origin master 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。\n将远程仓库 master 分支中的内容同步到本地仓库 master 分支中\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-pull/","summary":"git pull 用于从远程获取代码并合并本地。\ngit pull origin master:dev 将远程仓库origin的master分支拉取过来，与本地的dev分支合并。\ngit pull origin master 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。\n将远程仓库 master 分支中的内容同步到本地仓库 master 分支中","title":"Git git pull"},{"content":"git push 在使用git commit命令将你进行的修改从暂存区提交到本地版本库后，只剩下最后一步将本地版本库的分支推送到远程服务器上对应的分支了。\ngit push的一般形式为git push \u0026lt;远程主机名\u0026gt; \u0026lt;本地分支名\u0026gt; \u0026lt;远程分支名\u0026gt;，例如git push origin master：refs/for/master，即是将本地的 master 分支推送到远程主机 origin 上的 master 分支， origin 是远程主机名。第一个 master 是本地分支名，第二个 master 是远程分支名，分支名是可以修改的。\ngit push origin master 将本地master分支内容推送到远程库origin的master分支上，这里的master表示是远程服务器上的master分支和本地分支重名后的简写。\ngit push -u origin master. -u 表示 Git 不但会将本地 master 分支内容推送到远程库 origin 的 master 分支上，还会把本地的master分支和远程的master分支关联起来，在以后推送内容时就可以直接使用git push命令了，即可以省略origin master。\ngit push origin ：refs/for/master 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于git push origin –delete master\ngit push origin TagName 推送名为TagName的标签到远程库。\ngit push origin :refs/tags/TagName 删除名为TagName的远程标签。\ngit push origin \u0026ndash;tags 推送全部未推送到远程库的本地标签。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-push/","summary":"git push 在使用git commit命令将你进行的修改从暂存区提交到本地版本库后，只剩下最后一步将本地版本库的分支推送到远程服务器上对应的分支了。\ngit push的一般形式为git push \u0026lt;远程主机名\u0026gt; \u0026lt;本地分支名\u0026gt; \u0026lt;远程分支名\u0026gt;，例如git push origin master：refs/for/master，即是将本地的 master 分支推送到远程主机 origin 上的 master 分支， origin 是远程主机名。第一个 master 是本地分支名，第二个 master 是远程分支名，分支名是可以修改的。\ngit push origin master 将本地master分支内容推送到远程库origin的master分支上，这里的master表示是远程服务器上的master分支和本地分支重名后的简写。\ngit push -u origin master. -u 表示 Git 不但会将本地 master 分支内容推送到远程库 origin 的 master 分支上，还会把本地的master分支和远程的master分支关联起来，在以后推送内容时就可以直接使用git push命令了，即可以省略origin master。\ngit push origin ：refs/for/master 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于git push origin –delete master\ngit push origin TagName 推送名为TagName的标签到远程库。\ngit push origin :refs/tags/TagName 删除名为TagName的远程标签。\ngit push origin \u0026ndash;tags 推送全部未推送到远程库的本地标签。","title":"Git git push"},{"content":"git rebase 用于把一个分支的所有修改（commit）合并到当前分支。\nrebase 操作可以把本地未 push 的分叉提交历史整理成直线；\ngit rebase BranchName git rebase会把当前分支master的每个 commit 丢弃掉，并且把它们临时保存为patch(这些patch放到**.git/rebase目录中)，然后将BranchName分支上的commit更新到master分支上，最后把保存的这些补丁应用到更新后的master**分支上。\n当master分支更新之后，它会指向原来BranchName分支上的commit，而那些原本在自己身上的commit已经被丢弃了。如果运行垃圾收集命令, 这些被丢弃的提交就会删除。\n因为原本在master分支上的 commit 被丢弃了，因此，这时候的分支就变为了一条直线，\n与 git merge 的区别 当我们使用Git log来参看commit时，其commit的顺序也有所不同。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-rebase/","summary":"git rebase 用于把一个分支的所有修改（commit）合并到当前分支。\nrebase 操作可以把本地未 push 的分叉提交历史整理成直线；\ngit rebase BranchName git rebase会把当前分支master的每个 commit 丢弃掉，并且把它们临时保存为patch(这些patch放到**.git/rebase目录中)，然后将BranchName分支上的commit更新到master分支上，最后把保存的这些补丁应用到更新后的master**分支上。\n当master分支更新之后，它会指向原来BranchName分支上的commit，而那些原本在自己身上的commit已经被丢弃了。如果运行垃圾收集命令, 这些被丢弃的提交就会删除。\n因为原本在master分支上的 commit 被丢弃了，因此，这时候的分支就变为了一条直线，\n与 git merge 的区别 当我们使用Git log来参看commit时，其commit的顺序也有所不同。","title":"Git git rebase"},{"content":"git reflog 可以查看所有分支的所有操作记录（包括已经被删除的git commit记录和git reset的操作）\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-reflog/","summary":"git reflog 可以查看所有分支的所有操作记录（包括已经被删除的git commit记录和git reset的操作）","title":"Git git reflog"},{"content":"git remote git remote add origin git@github.com:YxzRainy/YxzRainy.github.io.git 将一个已有的本地仓库与远程库相关联。\ngit remote -v 查看远程库信息\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-remote/","summary":"git remote git remote add origin git@github.com:YxzRainy/YxzRainy.github.io.git 将一个已有的本地仓库与远程库相关联。\ngit remote -v 查看远程库信息","title":"Git git remote"},{"content":"git reset 用于回退版本。\ngit reset \u0026ndash;hard VersionNumber 可以指定回退到某一次提交后的版本号上，VersionNumber 为commit id\ngit reset HEAD FileNmae 将 FileName 在暂存区的修改回退到工作区，即把 FileNmae 在暂存区中删除。这里的 HEAD 表示 FileNmae 最新的版本。\ngit reset \u0026ndash;hard HEAD^ 在 Git 中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上 100 个版本写 100 个**^比较不方便，所以我们写成HEAD~100**。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-reset/","summary":"git reset 用于回退版本。\ngit reset \u0026ndash;hard VersionNumber 可以指定回退到某一次提交后的版本号上，VersionNumber 为commit id\ngit reset HEAD FileNmae 将 FileName 在暂存区的修改回退到工作区，即把 FileNmae 在暂存区中删除。这里的 HEAD 表示 FileNmae 最新的版本。\ngit reset \u0026ndash;hard HEAD^ 在 Git 中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上 100 个版本写 100 个**^比较不方便，所以我们写成HEAD~100**。","title":"Git git reset"},{"content":"git show 查看最新的 commit 提交。\ngit show TagName 查看标签名为TagName的 commit 提交。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-show/","summary":"git show 查看最新的 commit 提交。\ngit show TagName 查看标签名为TagName的 commit 提交。","title":"Git git show"},{"content":"git stash 将当前工作区的文件先暂存起来，等 bug 修改完成后，再将暂存的工作区文件内容拿出来继续工作。\ngit stash apply 恢复后，stash内容并不删除，你需要用git stash drop来删除；\ngit stash pop 恢复的同时把stash内容也删了。\ngit stash list 查看将前被暂存的工作区。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-stash/","summary":"git stash 将当前工作区的文件先暂存起来，等 bug 修改完成后，再将暂存的工作区文件内容拿出来继续工作。\ngit stash apply 恢复后，stash内容并不删除，你需要用git stash drop来删除；\ngit stash pop 恢复的同时把stash内容也删了。\ngit stash list 查看将前被暂存的工作区。","title":"Git git stash"},{"content":"git switch 用于切换分支。与git checkout命令的区别在于，使用新的git switch命令，比git checkout要更容易理解。\ngit switch -c Dev 创建并切换到新的Dev分支。\ngit switch Dev 直接切换到名为Dev的分支。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-switch/","summary":"git switch 用于切换分支。与git checkout命令的区别在于，使用新的git switch命令，比git checkout要更容易理解。\ngit switch -c Dev 创建并切换到新的Dev分支。\ngit switch Dev 直接切换到名为Dev的分支。","title":"Git git switch"},{"content":"git tag 用于查看本地仓库的所有标签。tag 是 git 版本库的一个标记，指向某个 commit 提交的指针，它比commit id方便我们记忆。\ngit tag TagName 给当前分支上的HEAD打上名为TagName的标签。\ngit tag TagName CommitId 给 commit id 为CommitId的提交打上名为TagName的标签。\ngit tag -a TagName -m \u0026ldquo;Instruction\u0026rdquo; CommitId 给 commit id 为CommitId的提交打上名为TagName的标签，并添加说明文字Instruction。\ngit tag -d TagName 删除名为TagName的本地标签。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-tag/","summary":"git tag 用于查看本地仓库的所有标签。tag 是 git 版本库的一个标记，指向某个 commit 提交的指针，它比commit id方便我们记忆。\ngit tag TagName 给当前分支上的HEAD打上名为TagName的标签。\ngit tag TagName CommitId 给 commit id 为CommitId的提交打上名为TagName的标签。\ngit tag -a TagName -m \u0026ldquo;Instruction\u0026rdquo; CommitId 给 commit id 为CommitId的提交打上名为TagName的标签，并添加说明文字Instruction。\ngit tag -d TagName 删除名为TagName的本地标签。","title":"Git git tag"},{"content":"Git 与 Github Git Git 是一款免费、开源、并且是目前世界上最先进的分布式版本控制系统。\n它是 Linus 花了两周时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！何为大佬？\nGit 迅速成为最流行的分布式版本控制系统，尤其是 2008 年，GitHub 网站上线了，Github 是一个 Git 做版本控制的代码托管平台，Github 为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub，包括 jQuery，PHP，Ruby 等等。\n历史就是这么偶然，如果不是当年 BitMover 公司威胁 Linux 社区，可能现在我们就没有免费而超级好用的 Git 了。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/git-%E4%B8%8E-github/","summary":"Git 与 Github Git Git 是一款免费、开源、并且是目前世界上最先进的分布式版本控制系统。\n它是 Linus 花了两周时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！何为大佬？\nGit 迅速成为最流行的分布式版本控制系统，尤其是 2008 年，GitHub 网站上线了，Github 是一个 Git 做版本控制的代码托管平台，Github 为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub，包括 jQuery，PHP，Ruby 等等。\n历史就是这么偶然，如果不是当年 BitMover 公司威胁 Linux 社区，可能现在我们就没有免费而超级好用的 Git 了。","title":"Git 与 Github"},{"content":"临时分支 在开发过程中，Bug 就像家常便饭一样，在 Git 中，当你接到一个修复一个代号 19 的 bug 的任务时，或者接到了一个新任务，开发代号为 R 的新功能时，但现在手头上的工作进度还没有完成，这时候该怎么办呢？\n这种时候我们通常可以创建一个临时的分支，在这个临时的分支上进行修复 bug 或开发新功能，最后在将这个分支合并到主分支。\n暂存当前的工作进度 git stash 我们当前处于dev分支上，在这个分支上暂存工作进度\n创建临时分支 git checkout -b bug18 创建一个临时分支，然后我们在这个分支上修复 bug 或开发新功能，完成后进行commit。\n合并到主分支 git switch master\rgit merge --no-ff -m \u0026#34;merged bug fix 101\u0026#34; issue-101 切换回主分支master，再将临时分支合并到主分支，合并完成后你可以删除临时分支。\n恢复工作进度 git switch dev git stash pop 切换到 dev 分支，通常用git stash pop命令之前的恢复工作进度。\n另一种恢复 git cherry-pick 4c805e2 也可以使用git cherry-pick命令恢复到指定的commitHash提交到当前分支，这样就可以避免多余的操作了。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E4%B8%B4%E6%97%B6%E5%88%86%E6%94%AF/","summary":"临时分支 在开发过程中，Bug 就像家常便饭一样，在 Git 中，当你接到一个修复一个代号 19 的 bug 的任务时，或者接到了一个新任务，开发代号为 R 的新功能时，但现在手头上的工作进度还没有完成，这时候该怎么办呢？\n这种时候我们通常可以创建一个临时的分支，在这个临时的分支上进行修复 bug 或开发新功能，最后在将这个分支合并到主分支。\n暂存当前的工作进度 git stash 我们当前处于dev分支上，在这个分支上暂存工作进度\n创建临时分支 git checkout -b bug18 创建一个临时分支，然后我们在这个分支上修复 bug 或开发新功能，完成后进行commit。\n合并到主分支 git switch master\rgit merge --no-ff -m \u0026#34;merged bug fix 101\u0026#34; issue-101 切换回主分支master，再将临时分支合并到主分支，合并完成后你可以删除临时分支。\n恢复工作进度 git switch dev git stash pop 切换到 dev 分支，通常用git stash pop命令之前的恢复工作进度。\n另一种恢复 git cherry-pick 4c805e2 也可以使用git cherry-pick命令恢复到指定的commitHash提交到当前分支，这样就可以避免多余的操作了。","title":"Git 临时分支"},{"content":"什么是分支 分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习 Git 的时候，另一个你正在另一个平行宇宙里努力学习 SVN。\n当两个平行宇宙互不干扰时，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了 Git 又学会了 SVN！\n分支有什么用 假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了 50% 的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人无法干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。\n现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E6%94%AF/","summary":"什么是分支 分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习 Git 的时候，另一个你正在另一个平行宇宙里努力学习 SVN。\n当两个平行宇宙互不干扰时，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了 Git 又学会了 SVN！\n分支有什么用 假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了 50% 的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人无法干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。\n现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。","title":"Git 什么是分支"},{"content":"什么是版本控制系统 所有的版本控制系统，其实 只能跟踪文本文件的改动，比如 TXT 文件，HTML，所有的程序代码文档等等，Git 也不例外。版本控制系统可以告诉你每次的改动，比如在第 5 行加了一个单词 Linux ，在第 8 行删了一个单词 Windows 。\n而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件内容（二进制编码）的变化，只能把二进制文件每次改动串起来，也就是只知道图片从 100KB 改成了 120KB，但具体改了啥，在文件的哪里作了修改，版本控制系统并不知道，也没法知道。这里值得注意的是，Microsoft 的 Word 格式是二进制格式，因此，版本控制系统是没法跟踪 Word 文件的改动的。\n因此，我这里比较推荐使用 markdown 作为文本编辑的格式，以及我个人比较喜欢使用 Typora 编辑 markdown 文件，之后再用 Vs code + git，推送到 GitHub 上，非常的方便。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E4%BB%80%E4%B9%88%E6%98%AF%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/","summary":"什么是版本控制系统 所有的版本控制系统，其实 只能跟踪文本文件的改动，比如 TXT 文件，HTML，所有的程序代码文档等等，Git 也不例外。版本控制系统可以告诉你每次的改动，比如在第 5 行加了一个单词 Linux ，在第 8 行删了一个单词 Windows 。\n而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件内容（二进制编码）的变化，只能把二进制文件每次改动串起来，也就是只知道图片从 100KB 改成了 120KB，但具体改了啥，在文件的哪里作了修改，版本控制系统并不知道，也没法知道。这里值得注意的是，Microsoft 的 Word 格式是二进制格式，因此，版本控制系统是没法跟踪 Word 文件的改动的。\n因此，我这里比较推荐使用 markdown 作为文本编辑的格式，以及我个人比较喜欢使用 Typora 编辑 markdown 文件，之后再用 Vs code + git，推送到 GitHub 上，非常的方便。","title":"Git 什么是版本控制系统"},{"content":"克隆远程库 通常，当我们在 Github 上创建了一个远程库时，有时候需要多个人协作共同修改这个远程库，这时候我们就可以在多台设备上克隆这个远程库，并将它放到本地\n克隆远程库 接下来我们使用git clone RemoteAddress命令将我们刚刚创建的远程库克隆到本地。\ngit clone git@github.com:YxzRainy/YxzRainy.github.io.git GitHub 给出的克隆地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git 支持多种协议，默认的git://使用 ssh，但也可以使用https等其他协议。\n使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用ssh协议而只能用https。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%85%8B%E9%9A%86%E8%BF%9C%E7%A8%8B%E5%BA%93/","summary":"克隆远程库 通常，当我们在 Github 上创建了一个远程库时，有时候需要多个人协作共同修改这个远程库，这时候我们就可以在多台设备上克隆这个远程库，并将它放到本地\n克隆远程库 接下来我们使用git clone RemoteAddress命令将我们刚刚创建的远程库克隆到本地。\ngit clone git@github.com:YxzRainy/YxzRainy.github.io.git GitHub 给出的克隆地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git 支持多种协议，默认的git://使用 ssh，但也可以使用https等其他协议。\n使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用ssh协议而只能用https。","title":"Git 克隆远程库"},{"content":"分支是如何工作的 主分支 在 Git 里，有一个默认的主分支，即master。HEAO严格来说并不是指向当前版本，而是指向的master，master才是指向当前版本的。所以，HEAD指向的就是当前分支，而当前分支的指针就是指向的当前版本。\ncommit 后分支的变化 每次提交，master都会向前进一个版本，这样，随着你不断提交，master的线也越来越长。\n当我们新建一个dev分支，指向与master相同的提交，再把HEAD指向dev，就表示我们当前在dev上工作。\n新增分支 从现在开始，对工作区的修改和提交就是在dev分支上了，比如再一次提交后，dev分支就往前进一个版本，而master分支不变。\n合并分支 现在，我们在dev上的工作完成了，可以把dev合并到master上，直接把master指向dev的当前版本，就完成了合并。\n删除分支 合并分支后，你可以删掉dev分支，删掉后，我们就只剩下master分支。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%88%86%E6%94%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/","summary":"分支是如何工作的 主分支 在 Git 里，有一个默认的主分支，即master。HEAO严格来说并不是指向当前版本，而是指向的master，master才是指向当前版本的。所以，HEAD指向的就是当前分支，而当前分支的指针就是指向的当前版本。\ncommit 后分支的变化 每次提交，master都会向前进一个版本，这样，随着你不断提交，master的线也越来越长。\n当我们新建一个dev分支，指向与master相同的提交，再把HEAD指向dev，就表示我们当前在dev上工作。\n新增分支 从现在开始，对工作区的修改和提交就是在dev分支上了，比如再一次提交后，dev分支就往前进一个版本，而master分支不变。\n合并分支 现在，我们在dev上的工作完成了，可以把dev合并到master上，直接把master指向dev的当前版本，就完成了合并。\n删除分支 合并分支后，你可以删掉dev分支，删掉后，我们就只剩下master分支。","title":"Git 分支是如何工作的"},{"content":"分支管理策略 在实际开发中，我们应该按照几个基本原则进行分支管理：\n首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；\n那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；\n你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。\n所以，团队合作的分支看起来就像这样：\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/","summary":"分支管理策略 在实际开发中，我们应该按照几个基本原则进行分支管理：\n首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；\n那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；\n你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。\n所以，团队合作的分支看起来就像这样：","title":"Git 分支管理策略"},{"content":"创建并合并分支 创建文件 目前我们处于 Git 给我们创建的默认 maser 分支下，我们需要在这个分支下进行一些工作。\n我们先创建一个文件 ReadMe.txt 来作为我们的本次的工作文件。\n提交文件 我们需要在maser分支上进行一次提交，以确保我们在默认分支下是进行过提交的。\ngit add ReadMe.txt git commit -m \u0026#34;这是第二个分支\u0026#34; 创建分支 接下来创建另一个dev分支。\ngit branch dev 切换分支 切换到刚才新建的dev分支。\n git checkout dev 修改文件并提交 我们在新创建的dev分支上工作，修改 ReadMe.txt，在文件中加上文本内容：“这是第二个分支”。\ngit add ReadMe.txt git commit -m \u0026#34;这是第二个分支\u0026#34; 再次切换分支 现在我们已经再dev分支上完成了工作，现在我们需要切换辉原分支master\ngit checkout master 重新查看文件 这时候会发现在master分支上，ReadMe.txt 文件中并没有文本：“这是第二个分支”。\n合并分支 Fast Forward 模式合并分支 现在，我们将刚刚在dev分支上的工作成果（文件中加上文本内容：“这是第二个分支”。）合并到master分支上。\ngit merge dev 再查看 readme.txt 的内容，就可以看到，当前maser分支上的内容和dev分支的最新提交是完全一样的。\nno Fast Forward 模式合并分支 通常，合并分支时，Git 会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。\n如果要强制禁用Fast forward模式，Git 就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\ngit merge --no-ff -m \u0026#34;merge describe\u0026#34; dev 删除分支 合并完成后，就可以放心地删除dev分支了\ngit branch -d dev no Fast Forward 模式合并分支 ","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/","summary":"创建并合并分支 创建文件 目前我们处于 Git 给我们创建的默认 maser 分支下，我们需要在这个分支下进行一些工作。\n我们先创建一个文件 ReadMe.txt 来作为我们的本次的工作文件。\n提交文件 我们需要在maser分支上进行一次提交，以确保我们在默认分支下是进行过提交的。\ngit add ReadMe.txt git commit -m \u0026#34;这是第二个分支\u0026#34; 创建分支 接下来创建另一个dev分支。\ngit branch dev 切换分支 切换到刚才新建的dev分支。\n git checkout dev 修改文件并提交 我们在新创建的dev分支上工作，修改 ReadMe.txt，在文件中加上文本内容：“这是第二个分支”。\ngit add ReadMe.txt git commit -m \u0026#34;这是第二个分支\u0026#34; 再次切换分支 现在我们已经再dev分支上完成了工作，现在我们需要切换辉原分支master\ngit checkout master 重新查看文件 这时候会发现在master分支上，ReadMe.txt 文件中并没有文本：“这是第二个分支”。\n合并分支 Fast Forward 模式合并分支 现在，我们将刚刚在dev分支上的工作成果（文件中加上文本内容：“这是第二个分支”。）合并到master分支上。\ngit merge dev 再查看 readme.txt 的内容，就可以看到，当前maser分支上的内容和dev分支的最新提交是完全一样的。\nno Fast Forward 模式合并分支 通常，合并分支时，Git 会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。\n如果要强制禁用Fast forward模式，Git 就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\ngit merge --no-ff -m \u0026#34;merge describe\u0026#34; dev 删除分支 合并完成后，就可以放心地删除dev分支了","title":"Git 创建并合并分支"},{"content":"创建标签 切换到需要打标签的分支上\ngit checkout master 使用命令git tag \u0026lt;name\u0026gt;就可以打一个新标签：\ngit tag v1.0 可以用命令git tag查看所有标签\ngit tag 忘记打标签 有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？\n方法是找到历史提交的commit id，然后打上对应标签就可以了。\ngit log --pretty=oneline --abbrev-commit\rgit tag v2.0 c0e9bf4 创建带说明的标签 git tag -a v0.1 -m \u0026#34;version 0.1 \u0026#34; 1094adb -a指定标签名，-m指定说明文字。\n标签总是和某个commit id挂钩。如果这个commit id既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE/","summary":"创建标签 切换到需要打标签的分支上\ngit checkout master 使用命令git tag \u0026lt;name\u0026gt;就可以打一个新标签：\ngit tag v1.0 可以用命令git tag查看所有标签\ngit tag 忘记打标签 有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？\n方法是找到历史提交的commit id，然后打上对应标签就可以了。\ngit log --pretty=oneline --abbrev-commit\rgit tag v2.0 c0e9bf4 创建带说明的标签 git tag -a v0.1 -m \u0026#34;version 0.1 \u0026#34; 1094adb -a指定标签名，-m指定说明文字。\n标签总是和某个commit id挂钩。如果这个commit id既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。","title":"Git 创建标签"},{"content":"创建版本库 什么是版本库 版本库又名仓库（Repository），你可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除，Git 都能跟踪，以便任何时刻都可以追踪历史，并且以后随时回退到某个历史版本。\n初始化 Git 目录 我们创建一个文件夹 GitFolder（文件名随意），并进入到这个文件夹，然后在命令行输入git init命令将这个目录变成可以用 Git 来管理的仓库。\ngit init 当目录中出现一个 .git 文件夹，就说明你的 Git 仓库初始化完成了。\n这个目录是 Git 来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把 Git 仓库给破坏了。\n如果你没有看到 .git 目录，那是因为这个目录默认是隐藏的，在当前文件夹输入ls -ah命令就可以看见，或者直接打开显示隐藏文件的选项。\n把文件添加到版本库 现在我们编写一个 Readme.txt 文件，内容如下：\nGit is a version control system. Git is free software. 一定要放到你刚才目录下创建的文件夹 GitFolder 中，子目录也行，因为这是一个 Git 仓库，放到其他地方 Git 再厉害也找不到这个文件。\n把文件添加到暂存区 用命令git add告诉 Git，把文件添加到暂存区\ngit add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix 的哲学是：没有消息就是好消息，说明文件已经成功添加到暂存区了。\n提交暂存区的文件 接下来，我们用命令git commit告诉 Git，把文件提交到本地仓库\ngit commit -m \u0026#34;Description of this submission\u0026#34; 执行成功后，大概率会出现类似下面的提示\nInitial commit Untracked files:  (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed)  ReadMe.txt nothing added to commit but untracked files present (use \u0026#34;git add\u0026#34; to track) ","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/","summary":"创建版本库 什么是版本库 版本库又名仓库（Repository），你可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除，Git 都能跟踪，以便任何时刻都可以追踪历史，并且以后随时回退到某个历史版本。\n初始化 Git 目录 我们创建一个文件夹 GitFolder（文件名随意），并进入到这个文件夹，然后在命令行输入git init命令将这个目录变成可以用 Git 来管理的仓库。\ngit init 当目录中出现一个 .git 文件夹，就说明你的 Git 仓库初始化完成了。\n这个目录是 Git 来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把 Git 仓库给破坏了。\n如果你没有看到 .git 目录，那是因为这个目录默认是隐藏的，在当前文件夹输入ls -ah命令就可以看见，或者直接打开显示隐藏文件的选项。\n把文件添加到版本库 现在我们编写一个 Readme.txt 文件，内容如下：\nGit is a version control system. Git is free software. 一定要放到你刚才目录下创建的文件夹 GitFolder 中，子目录也行，因为这是一个 Git 仓库，放到其他地方 Git 再厉害也找不到这个文件。\n把文件添加到暂存区 用命令git add告诉 Git，把文件添加到暂存区\ngit add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix 的哲学是：没有消息就是好消息，说明文件已经成功添加到暂存区了。\n提交暂存区的文件 接下来，我们用命令git commit告诉 Git，把文件提交到本地仓库\ngit commit -m \u0026#34;Description of this submission\u0026#34; 执行成功后，大概率会出现类似下面的提示","title":"Git 创建版本库"},{"content":"合并冲突 有时候，我们在使用git merge命令进行合并的时候，会出现以下提示。\nAuto-merging Rainy.txt CONFLICT (content): Merge conflict in Rainy.txt Automatic merge failed; fix conflicts and then commit the result. 会发现使用git merge自动合并失败了，git 提示我们需要手动 修复冲突，然后提交结果。\n如何解决冲突 我们只需要把 Git 合并失败的文件手动编辑为我们希望的内容，再git commit即可。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81/","summary":"合并冲突 有时候，我们在使用git merge命令进行合并的时候，会出现以下提示。\nAuto-merging Rainy.txt CONFLICT (content): Merge conflict in Rainy.txt Automatic merge failed; fix conflicts and then commit the result. 会发现使用git merge自动合并失败了，git 提示我们需要手动 修复冲突，然后提交结果。\n如何解决冲突 我们只需要把 Git 合并失败的文件手动编辑为我们希望的内容，再git commit即可。","title":"Git 合并冲突"},{"content":"工作区与暂存区 工作区 工作区就是你在电脑中看到的一个文件夹。它包括你实际更改的文件和当前修改但未使用git add存入暂存区的文件。\n这个文件夹中有一个隐藏的目录**.git**，这个不算是工作区，它只是 Git 的版本库。\n这个版本库 .git 里存了许多东西，其中最重要的就是我们的暂存区和一个 Git 自动为我们创建的第一个分支 master，以及指向这个master的一个指针HEAD。\n暂存区 暂存区是一个名为 index 的文件，当我们使用git add命令添加文件的时候，实际上就是将我们的文件添加到暂存区。\n接着再用git commit提交文件时，实际上就是吧暂存区里的所有文件提交到当前分支，默认这个分支为 master.\n因此，当我们git commit时，就是将暂存区中的文件添加到 master 上。\n你可以简单理解为，将需要提交的文件修改通通先放到暂存区，然后，再一次性提交暂存区的所有修改到分支上。\n一旦提交后，如果你提交后又没有对工作区做任何修改，那么工作区就是“干净”的。\n执行git status.\nOn branch master nothing to commit, working tree clean ","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%B8%8E%E6%9A%82%E5%AD%98%E5%8C%BA/","summary":"工作区与暂存区 工作区 工作区就是你在电脑中看到的一个文件夹。它包括你实际更改的文件和当前修改但未使用git add存入暂存区的文件。\n这个文件夹中有一个隐藏的目录**.git**，这个不算是工作区，它只是 Git 的版本库。\n这个版本库 .git 里存了许多东西，其中最重要的就是我们的暂存区和一个 Git 自动为我们创建的第一个分支 master，以及指向这个master的一个指针HEAD。\n暂存区 暂存区是一个名为 index 的文件，当我们使用git add命令添加文件的时候，实际上就是将我们的文件添加到暂存区。\n接着再用git commit提交文件时，实际上就是吧暂存区里的所有文件提交到当前分支，默认这个分支为 master.\n因此，当我们git commit时，就是将暂存区中的文件添加到 master 上。\n你可以简单理解为，将需要提交的文件修改通通先放到暂存区，然后，再一次性提交暂存区的所有修改到分支上。\n一旦提交后，如果你提交后又没有对工作区做任何修改，那么工作区就是“干净”的。\n执行git status.\nOn branch master nothing to commit, working tree clean ","title":"Git 工作区与暂存区"},{"content":"忽略特殊文件 在某些情况下，我们不想某些在工作区中的文件被提交，也就是不被git add .命令添加到暂存区，就非常有要将这些文件忽略掉（让 Git 对他们视而不见）。\n我们可以在 Git 工作区的根目录下创建一个特殊的**.gitignore**文件，然后把要忽略的文件名填进去，Git 就会在git add的时候忽略这些文件。\n.gitignore文件可以放到版本库里，这样可以对**.gitignore**做版本管理。\n忽略文件的原则  忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。  编写 .gitignore 规则 # Windows: Thumbs.db ehthumbs.db Desktop.ini  # Python: *.py[cod] *.so *.egg *.egg-info dist build  # My configurations: db.ini deploy_key_rsa 编写完成后，最后就是把**.gitignore也提交到 Git，就完成了！当然检验.gitignore的标准是使用git status命令会不会提示working directory clean**。\n无法添加文件 有些时候，你想添加一个文件到 Git，但发现添加不了，原因是这个文件被**.gitignore**忽略了：\ngit add Rainy.class\rThe following paths are ignored by one of your .gitignore files:\rRainy.class\rUse -f if you really want to add them. 如果你确实想添加该文件，可以用git add -f FileName命令将文件强制添加到 Git：\ngit add -f Rainy.class 检查 .gitignore 规则 或者你发现，可能是**.gitignore**写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：\n$ git check-ignore -v App.class\r.gitignore:3:*.class\tApp.class Git 会告诉我们，.gitignore的第 3 行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。\n将指定文件排除到 .gitignore 规则之外 还有些时候，当我们编写了规则排除了部分文件时：\n# 排除所有.开头的隐藏文件:\r.*\r# 排除所有.class文件:\r*.class 但是我们发现.*这个规则把.gitignore也排除了，并且App.class需要被添加到版本库，但是被*.class规则排除了。\n虽然可以用git add -f强制添加进去，但有强迫症的童鞋还是希望不要破坏.gitignore规则，这个时候，可以添加两条例外规则：\n# 排除所有.开头的隐藏文件:\r.*\r# 排除所有.class文件:\r*.class\r# 不排除.gitignore和App.class:\r!.gitignore\r!App.class 把指定文件排除在.gitignore规则之外的写法就是! + 文件名，所以，只需把例外文件添加进去即可。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%BF%BD%E7%95%A5%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6/","summary":"忽略特殊文件 在某些情况下，我们不想某些在工作区中的文件被提交，也就是不被git add .命令添加到暂存区，就非常有要将这些文件忽略掉（让 Git 对他们视而不见）。\n我们可以在 Git 工作区的根目录下创建一个特殊的**.gitignore**文件，然后把要忽略的文件名填进去，Git 就会在git add的时候忽略这些文件。\n.gitignore文件可以放到版本库里，这样可以对**.gitignore**做版本管理。\n忽略文件的原则  忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。  编写 .gitignore 规则 # Windows: Thumbs.db ehthumbs.db Desktop.ini  # Python: *.py[cod] *.so *.egg *.egg-info dist build  # My configurations: db.ini deploy_key_rsa 编写完成后，最后就是把**.gitignore也提交到 Git，就完成了！当然检验.gitignore的标准是使用git status命令会不会提示working directory clean**。\n无法添加文件 有些时候，你想添加一个文件到 Git，但发现添加不了，原因是这个文件被**.gitignore**忽略了：\ngit add Rainy.class\rThe following paths are ignored by one of your .gitignore files:\rRainy.class\rUse -f if you really want to add them.","title":"Git 忽略特殊文件"},{"content":"推送分支 添加文件并提交 git add . git commit -m \u0026#34;提交信息\u0026#34; 拉取分支 git pull origin master 为什么要先拉取分支呢？是因为远程库的最新提交和你试图推送的本地库不同步所导致的，因此需要先用git pull把最新的提交从origin/master上拉取到本地即可。\n分支名的问题 在使用git pull origin master命令将本地分支与远程分支同步，结果出现下面的报错信息：\nfatal: couldn\u0026#39;t find remote ref master 大致意思就是找不到 master 这个远程分支。\n解决 只需要到你的 GitHub 上，查看仓库的默认分支即可，比如我的是main，所以我只需要将命令修改为git pull origin main即可，最后在git pull origin master，就可以将本地分支的内容推送到远程分支master上了。\n合并冲突 这时候使用git pull 后合并有冲突，我们只需要把 Git 合并失败的文件手动编辑为我们希望的内容就可以解决冲突，再git commit即可。\n推送分支 git push origin master 将本地库master分支上的内容推送到远程库master上去，用git push命令。\n推送成功后，可以立刻在 GitHub 页面中看到远程库的内容已经和本地的一模一样了。\n推送失败 有时候，当我们在用git push origin master命令时，会出现以下错误信息，通常是因为远程库的最新提交和你试图推送的本地库不同步所导致的。\nmaster master (fetch first)\rUpdates were rejected because the remote contains work that you do\rnot have locally. This is usually caused by another repository pushing\rto the same ref. You may want to first integrate the remote changes\r(e.g., \u0026#39;git pull\r. . before pushing again.\rsee the \u0026#39;Note about fast-forwards\u0026#39; in \u0026#39;qit push --help\u0026#39; for details. 解决 git pull origin master git push origin master 只需要使用git pull origin master命令将远程库的最新提交拉去到本地库，之后本地会多出之前不同步的文件，再用git push origin master将本地分支推送到远程分支即可。\nSSH 警告 当你第一次使用 Git 的clone或者push命令连接 GitHub 时，会得到一个警告：\nThe authenticity of host \u0026#39;github.com (xx.xx.xx.xx)\u0026#39; can\u0026#39;t be established. RSA key fingerprint is xx.xx.xx.xx.xx. Are you sure you want to continue connecting (yes/no)? 这是因为 Git 使用 SSH 连接，而 SSH 连接在第一次验证 GitHub 服务器的 Key 时，需要你确认 GitHub 的 Key 的指纹信息是否真的来自 GitHub 的服务器，输入yes回车即可\n接着 Git 会输出一个警告，告诉你已经把 GitHub 的 Key 添加到本机的一个信任列表里了：\nWarning: Permanently added \u0026#39;github.com\u0026#39; (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%8E%A8%E9%80%81%E5%88%86%E6%94%AF/","summary":"推送分支 添加文件并提交 git add . git commit -m \u0026#34;提交信息\u0026#34; 拉取分支 git pull origin master 为什么要先拉取分支呢？是因为远程库的最新提交和你试图推送的本地库不同步所导致的，因此需要先用git pull把最新的提交从origin/master上拉取到本地即可。\n分支名的问题 在使用git pull origin master命令将本地分支与远程分支同步，结果出现下面的报错信息：\nfatal: couldn\u0026#39;t find remote ref master 大致意思就是找不到 master 这个远程分支。\n解决 只需要到你的 GitHub 上，查看仓库的默认分支即可，比如我的是main，所以我只需要将命令修改为git pull origin main即可，最后在git pull origin master，就可以将本地分支的内容推送到远程分支master上了。\n合并冲突 这时候使用git pull 后合并有冲突，我们只需要把 Git 合并失败的文件手动编辑为我们希望的内容就可以解决冲突，再git commit即可。\n推送分支 git push origin master 将本地库master分支上的内容推送到远程库master上去，用git push命令。\n推送成功后，可以立刻在 GitHub 页面中看到远程库的内容已经和本地的一模一样了。\n推送失败 有时候，当我们在用git push origin master命令时，会出现以下错误信息，通常是因为远程库的最新提交和你试图推送的本地库不同步所导致的。\nmaster master (fetch first)\rUpdates were rejected because the remote contains work that you do\rnot have locally.","title":"Git 推送分支"},{"content":"撤销修改 人哪有不犯错的，因此，当你修改了一个文件时，之后发现这次修改不太合理，想撤销这次修改的时候，怎么办呢？\n这个时候，你可以直接使用git checkout -- FileName 来撤销 FileName 文件在工作区的全部修改。这个命令分为几种情况\n文件未被添加到暂存区 对文件FileName进行修改后，但还没有将它添加到暂存区，我们这个时候使用git checkout -- FileName，FileName就会回到修改前的状态。\n文件被添加到了暂存区 对文件FileName进行第一次修改后，并且将它添加到了暂存区（这个时候的状态为被添加到暂存区后），接着再次对FileName进行修改，我们这个时候使用git checkout -- FileName，FileName就会回到被添加到暂存区后的状态。\n总之，git checkout -- FileName就是让文件 FileName 回到最近一次git commit或git add时的状态。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9/","summary":"撤销修改 人哪有不犯错的，因此，当你修改了一个文件时，之后发现这次修改不太合理，想撤销这次修改的时候，怎么办呢？\n这个时候，你可以直接使用git checkout -- FileName 来撤销 FileName 文件在工作区的全部修改。这个命令分为几种情况\n文件未被添加到暂存区 对文件FileName进行修改后，但还没有将它添加到暂存区，我们这个时候使用git checkout -- FileName，FileName就会回到修改前的状态。\n文件被添加到了暂存区 对文件FileName进行第一次修改后，并且将它添加到了暂存区（这个时候的状态为被添加到暂存区后），接着再次对FileName进行修改，我们这个时候使用git checkout -- FileName，FileName就会回到被添加到暂存区后的状态。\n总之，git checkout -- FileName就是让文件 FileName 回到最近一次git commit或git add时的状态。","title":"Git 撤销修改"},{"content":"操作标签 删除标签 git tag -d v0.1 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。\n如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除，然后，从远程删除。\ngit push origin :refs/tags/v0.9 要看看是否真的从远程库删除了标签，可以登陆 GitHub 查看。\n推送标签 推送指定标签到远程库。\ngit push origin v1.0 推送全部尚未推送到远程的本地标签到远程库。\n git push origin --tags ","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%93%8D%E4%BD%9C%E6%A0%87%E7%AD%BE/","summary":"操作标签 删除标签 git tag -d v0.1 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。\n如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除，然后，从远程删除。\ngit push origin :refs/tags/v0.9 要看看是否真的从远程库删除了标签，可以登陆 GitHub 查看。\n推送标签 推送指定标签到远程库。\ngit push origin v1.0 推送全部尚未推送到远程的本地标签到远程库。\n git push origin --tags ","title":"Git 操作标签"},{"content":"标签管理 发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。\nGit 的标签虽然是版本库的快照，但其实它就是指向某个 commit 的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。\nGit 有 commit，为什么还要引入 tag？ 请把上周一的那个版本打包发布，commit 号是 6a5819e\u0026hellip;\n一串乱七八糟的数字不好找！\n如果换一个办法：\n请把上周一的那个版本打包发布，版本号是 v1.2\n“好的，按照 tag v1.2 查找 commit 就行！”\n所以，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/","summary":"标签管理 发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。\nGit 的标签虽然是版本库的快照，但其实它就是指向某个 commit 的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。\nGit 有 commit，为什么还要引入 tag？ 请把上周一的那个版本打包发布，commit 号是 6a5819e\u0026hellip;\n一串乱七八糟的数字不好找！\n如果换一个办法：\n请把上周一的那个版本打包发布，版本号是 v1.2\n“好的，按照 tag v1.2 查找 commit 就行！”\n所以，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起。","title":"Git 标签管理"},{"content":"添加第一个远程库 什么是远程仓库 当我们需要多个人协助开发时，必然会遇到一个问题，就是双方的信息如何进行传递同步。 这个时候，就需要搭建一个远程服务器，每个人都从这个远程服务器克隆一份到自己的电脑上，并且把自己需要提交推送到服务器仓库里，也可以从服务器仓库中拉取别人的提交。\n创建远程库 注册一个 Github 账号 创建 Github Repository 在 Github 上创建一个仓库，仓库名随意， 。\n关联远程库 我们使用git remote add origin命令把本地库与一个远程库关联起来。\ngit remote add origin git@github.com:YxzRainy/YxzRainy.github.io.git 远程库的名字就是origin，这是默认的名字，你也可以将它改成别的。\n将 Git 与 Github 关联 下载并安装 Git 配置个人信息 git config --global user.name \u0026#34;Your UserName\u0026#34; git config --global user.email \u0026#34;YourEmail@qq.com\u0026#34; 生成 ssh 密钥文件 hexo d 到远程仓库，因为每一台电脑中的私钥只有只有一个，因此当你想给另一个 github 账号配置博客时，必须重新生成公钥和私钥\nssh-keygen -t rsa -C \u0026#34;1971438937@qq.com\u0026#34; 输入后，三个回车，默认不需要设置密码，之后到所显示的路径中找到生成的 ssh 的文件夹中的id_rsa.pub文件中的密钥，将其中内容全部复制。\nnew SSH Key 打开你的 Github 的主页，点击头像，选择 Settings，再选择 SSH and GPG keys，找到 SSH keys，点击 New SSH Key，Title 为标题，任意填写，将刚刚复制的 id_rsa pub 文件中的密钥文本粘贴进去，最后 Add SSH key。\n检测 GitHub 公钥设置是否成功 ssh git@github com\r 设置 GitHub 密钥原因 因为 GitHub 需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而 Git 支持 SSH 协议，所以，GitHub 只要知道了你电脑上的私钥，就可以确认只有你自己才能推送。\n当然，GitHub 允许你添加多个 公钥。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的公钥都添加到 GitHub，就可以在每台电脑上往 GitHub 推送了。\n当你推送的时候，git 就会匹电脑上的私钥跟 GitHub 上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。\n删除远程库 如果添加的时候地址写错了，或者就是想删除远程库，可以用git remote rm WarehouseName命令。使用前，建议先用git remote -v查看远程库信息。\n然后，根据远程库的名字删除，比如删除origin\ngit remote rm origin 注意，此处的删除其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到 GitHub，在后台页面找到删除按钮再删除。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%A6%96%E6%AC%A1%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E5%BA%93/","summary":"添加第一个远程库 什么是远程仓库 当我们需要多个人协助开发时，必然会遇到一个问题，就是双方的信息如何进行传递同步。 这个时候，就需要搭建一个远程服务器，每个人都从这个远程服务器克隆一份到自己的电脑上，并且把自己需要提交推送到服务器仓库里，也可以从服务器仓库中拉取别人的提交。\n创建远程库 注册一个 Github 账号 创建 Github Repository 在 Github 上创建一个仓库，仓库名随意， 。\n关联远程库 我们使用git remote add origin命令把本地库与一个远程库关联起来。\ngit remote add origin git@github.com:YxzRainy/YxzRainy.github.io.git 远程库的名字就是origin，这是默认的名字，你也可以将它改成别的。\n将 Git 与 Github 关联 下载并安装 Git 配置个人信息 git config --global user.name \u0026#34;Your UserName\u0026#34; git config --global user.email \u0026#34;YourEmail@qq.com\u0026#34; 生成 ssh 密钥文件 hexo d 到远程仓库，因为每一台电脑中的私钥只有只有一个，因此当你想给另一个 github 账号配置博客时，必须重新生成公钥和私钥\nssh-keygen -t rsa -C \u0026#34;1971438937@qq.com\u0026#34; 输入后，三个回车，默认不需要设置密码，之后到所显示的路径中找到生成的 ssh 的文件夹中的id_rsa.pub文件中的密钥，将其中内容全部复制。\nnew SSH Key 打开你的 Github 的主页，点击头像，选择 Settings，再选择 SSH and GPG keys，找到 SSH keys，点击 New SSH Key，Title 为标题，任意填写，将刚刚复制的 id_rsa pub 文件中的密钥文本粘贴进去，最后 Add SSH key。","title":"Git 添加第一个远程库"},{"content":"添加第二个远程库 将 GitHub 上的远程库与一个本地库关联起来。\n关联远程库 我们使用git remote add origin命令把本地库与一个远程库关联起来。\ngit remote add origin git@github.com:YxzRainy/YxzRainy.github.io.git # 远程库链接 添加文件并提交 git add . git commit -m \u0026#34;提交信息\u0026#34; 推送分支 git push origin master 将本地库master分支上的内容推送到远程库master上去.\n推送成功后，可以立刻在我们的 GitHub 仓库种中看到远程库的内容已经和本地的一模一样了。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%BF%9C%E7%A8%8B%E5%BA%93/","summary":"添加第二个远程库 将 GitHub 上的远程库与一个本地库关联起来。\n关联远程库 我们使用git remote add origin命令把本地库与一个远程库关联起来。\ngit remote add origin git@github.com:YxzRainy/YxzRainy.github.io.git # 远程库链接 添加文件并提交 git add . git commit -m \u0026#34;提交信息\u0026#34; 推送分支 git push origin master 将本地库master分支上的内容推送到远程库master上去.\n推送成功后，可以立刻在我们的 GitHub 仓库种中看到远程库的内容已经和本地的一模一样了。","title":"Git 添加第二个远程库"},{"content":"清空远程分支 将清空后的本地分支推送到远程分支，以达到清空远程分支的目的。\n删除全部文件 打开本地仓库文件夹，删除不需要的文件，仅保留 .git 文件夹和 ReadMe.md 文件.\n输入命令 git add . git commit -m \u0026#39;清空远程仓库\u0026#39; git push origin master ","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%B8%85%E7%A9%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/","summary":"清空远程分支 将清空后的本地分支推送到远程分支，以达到清空远程分支的目的。\n删除全部文件 打开本地仓库文件夹，删除不需要的文件，仅保留 .git 文件夹和 ReadMe.md 文件.\n输入命令 git add . git commit -m \u0026#39;清空远程仓库\u0026#39; git push origin master ","title":"Git 清空远程分支"},{"content":"版本回退 类似存档 现在我们新建一个文件text.txt，并对这个文件进行第一次修改和提交，得到text.txt 1.0 版本。\n 重复以上步骤，对text.txt进行修改和提交，得到text.txt 2.0版本， 再次对text.txt进行修改和提交，得到text.txt 3.0版本。 目前为止，我们对这个文件修改并提交了三次，分别得到1.0、2.0、3.0三个版本。  不知道你有没有发现，修改一个文件后并提交与通过一关游戏并存档有着相似之处。\n这就好比玩闯关游戏时，每通过一关，系统就会自动把游戏进度存档，如果某一关没过去，你还可以选择读取前一关的存档，有些时候，在打 Boss 之前，你会手动存档，以便万一打 Boss 失败了，可以从最近的地方重新开始。\nGit 也是一样，每当你觉得文件修改到一定程度的时候，就可以保存一个快照，这个快照在 Git 中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。\n在 Git 中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上 100 个版本写 100 个**^比较容易数不过来，所以我们写成HEAD~100或者HEAD~50**。\n回退的上一个版本 再次回到我们的text.txt文件上，假设我们目前是版本 3.0，也就是最新版本，现在用git reset --hard HEAD^ 命令将文件退回到上一个版本。\ngit reset --hard HEAD^ OK，现在文件已经被还原到上一个版本 2.0了，当然，你还可以继续回退到上一个版本1.0，不过先别着急。\n这时候你也许会有个疑惑，如果你还想回到版本 3.0应该怎么办呢？\n回退的指定版本 这个操作需要知道指定版本的版本号，比如想回退到指定版本 3.0的版本号为1098b，那么使用git reset --hard commit id\ngit reset --hard commit id 版本号没必要写全，前几位就可以了，Git 会自动去找。当然也不能只写前面一两位，因为这样的话，Git 可能会找到不止一个版本号，就无法确定你具体想回退到哪一个版本了。\n这时候再查看text.txt的内容，你会发现我们的版本 3.0又回来了。\nGit 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的HEAD 指针，HEAD指向的版本就是当前版本，因此，当你回退到某个版本的时候，Git 仅仅是把 HEAD 重新指向了版本 3.0.\n只 commit 过一次代码会出现的问题 使用git reset --hard \u0026quot;HEAD^\u0026quot;命令时遇到以下错误：\nfatal: ambiguous argument \u0026#39;HEAD^\u0026#39;: unknown revision or path not in the working tree. Use \u0026#39;--\u0026#39; to separate paths from revisions, like this: \u0026#39;git \u0026lt;command\u0026gt; [\u0026lt;revision\u0026gt;...] -- [\u0026lt;file\u0026gt;...]\u0026#39; 这是因为当前仓库到目前为止只git commit过一次代码，故已经是 HEAD （当前最新）版本，没有历史版本，自然是不能回退。\n解决 只需要继续 commit 几次，使得有多个历史版本。\n找不到 commit id 怎么办 现在，你回退到了某个指定版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本，但却找不到新版本的commit id怎么办？\n当你用git reset --hard HEAD^将版本 3.0回退到版本 2.0时，再想恢复到版本 3.0，就必须找到版本 3.0的 commit id，然而因为你已经关了电脑，无法通过命令的历史记录找到commit id\nGit 提供了一个命令git reflog用来查看你每一次git commit和git reset的记录\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/","summary":"版本回退 类似存档 现在我们新建一个文件text.txt，并对这个文件进行第一次修改和提交，得到text.txt 1.0 版本。\n 重复以上步骤，对text.txt进行修改和提交，得到text.txt 2.0版本， 再次对text.txt进行修改和提交，得到text.txt 3.0版本。 目前为止，我们对这个文件修改并提交了三次，分别得到1.0、2.0、3.0三个版本。  不知道你有没有发现，修改一个文件后并提交与通过一关游戏并存档有着相似之处。\n这就好比玩闯关游戏时，每通过一关，系统就会自动把游戏进度存档，如果某一关没过去，你还可以选择读取前一关的存档，有些时候，在打 Boss 之前，你会手动存档，以便万一打 Boss 失败了，可以从最近的地方重新开始。\nGit 也是一样，每当你觉得文件修改到一定程度的时候，就可以保存一个快照，这个快照在 Git 中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。\n在 Git 中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上 100 个版本写 100 个**^比较容易数不过来，所以我们写成HEAD~100或者HEAD~50**。\n回退的上一个版本 再次回到我们的text.txt文件上，假设我们目前是版本 3.0，也就是最新版本，现在用git reset --hard HEAD^ 命令将文件退回到上一个版本。\ngit reset --hard HEAD^ OK，现在文件已经被还原到上一个版本 2.0了，当然，你还可以继续回退到上一个版本1.0，不过先别着急。\n这时候你也许会有个疑惑，如果你还想回到版本 3.0应该怎么办呢？\n回退的指定版本 这个操作需要知道指定版本的版本号，比如想回退到指定版本 3.0的版本号为1098b，那么使用git reset --hard commit id\ngit reset --hard commit id 版本号没必要写全，前几位就可以了，Git 会自动去找。当然也不能只写前面一两位，因为这样的话，Git 可能会找到不止一个版本号，就无法确定你具体想回退到哪一个版本了。\n这时候再查看text.txt的内容，你会发现我们的版本 3.0又回来了。\nGit 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的HEAD 指针，HEAD指向的版本就是当前版本，因此，当你回退到某个版本的时候，Git 仅仅是把 HEAD 重新指向了版本 3.0.","title":"Git 版本回退"},{"content":"管理修改 你也许很疑惑为什么 Git 比其他版本控制系统设计得优秀，那是因为 Git 跟踪并管理的是修改，而非文件。\n第二次修改为什么没有被提交 现在假设我我们对一个文件 ReadMe.txt 进行了以下操作：\n修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本\ngit add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3.0 版本\ngit commit ReadMe.txt 接着你会发现被提交的版本为什么不是ReadMe.txt 3.0？\n这是因为 Git 管理的是修改，而非文件，因此，当你使用git add命令将 2.0 版本放入暂存区后，准备提交，但是，之后得到的版本 3.0 并没有被放入暂存区，所以，最后的git commit只负责把暂存区的修改提交了。\n 也就是将 2.0 版本提交了，因为版本 2.0 被添加到了暂存区 但版本 3.0 却并没有被提交，因为版本 3.0 没有被添加到暂存区  如何提交第二次修改 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了。\n修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本\ngit add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3.0 版本\ngit add ReadMe.txt\rgit commit ReadMe.txt ","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E7%AE%A1%E7%90%86%E4%BF%AE%E6%94%B9/","summary":"管理修改 你也许很疑惑为什么 Git 比其他版本控制系统设计得优秀，那是因为 Git 跟踪并管理的是修改，而非文件。\n第二次修改为什么没有被提交 现在假设我我们对一个文件 ReadMe.txt 进行了以下操作：\n修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本\ngit add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3.0 版本\ngit commit ReadMe.txt 接着你会发现被提交的版本为什么不是ReadMe.txt 3.0？\n这是因为 Git 管理的是修改，而非文件，因此，当你使用git add命令将 2.0 版本放入暂存区后，准备提交，但是，之后得到的版本 3.0 并没有被放入暂存区，所以，最后的git commit只负责把暂存区的修改提交了。\n 也就是将 2.0 版本提交了，因为版本 2.0 被添加到了暂存区 但版本 3.0 却并没有被提交，因为版本 3.0 没有被添加到暂存区  如何提交第二次修改 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了。\n修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本\ngit add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3.","title":"Git 管理修改"},{"content":"配置别名 命令简写 $ git config --global alias.st status $ git config --global alias.co checkout $ git config --global alias.ci commit $ git config --global alias.br branch 以上命令将：\ngit status简写为git st；\ngit checkout简写为git co；\ngit commit简写为git ci\ngit branch简写为git br\n以后提交就可以输入：\n$ git ci -m \u0026#34;this is shorthand\u0026#34; 配置别名 配置 Git 的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。\n配置文件放哪了？每个仓库的 Git 配置文件都放在当前仓库的.git/config文件中：\n[core]\rrepositoryformatversion = 0\rfilemode = false\rbare = false\rlogallrefupdates = true\rsymlinks = false\rignorecase = true\r[alias]\rlast = log -1 用户的配置文件自行寻找，我的是在C:\\Users\\Rainy目录下\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%85%8D%E7%BD%AE%E5%88%AB%E5%90%8D/","summary":"配置别名 命令简写 $ git config --global alias.st status $ git config --global alias.co checkout $ git config --global alias.ci commit $ git config --global alias.br branch 以上命令将：\ngit status简写为git st；\ngit checkout简写为git co；\ngit commit简写为git ci\ngit branch简写为git br\n以后提交就可以输入：\n$ git ci -m \u0026#34;this is shorthand\u0026#34; 配置别名 配置 Git 的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。\n配置文件放哪了？每个仓库的 Git 配置文件都放在当前仓库的.git/config文件中：\n[core]\rrepositoryformatversion = 0\rfilemode = false\rbare = false\rlogallrefupdates = true\rsymlinks = false\rignorecase = true\r[alias]\rlast = log -1 用户的配置文件自行寻找，我的是在C:\\Users\\Rainy目录下","title":"Git 配置别名"},{"content":"配置用户信息 安装好 Git 后，在命令行或终端中使用下面的命令可以设置 Git 自己的名字和电子邮件。这是因为 Git 是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和 Email 地址。\ngit config --global user.name \u0026#34;YxzRainy\u0026#34;\rgit config --global user.email \u0026#34;1@qq.com\u0026#34; 查看配置 配置好之后可以使用git config -l查看配置：\ngit config -l ","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/","summary":"配置用户信息 安装好 Git 后，在命令行或终端中使用下面的命令可以设置 Git 自己的名字和电子邮件。这是因为 Git 是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和 Email 地址。\ngit config --global user.name \u0026#34;YxzRainy\u0026#34;\rgit config --global user.email \u0026#34;1@qq.com\u0026#34; 查看配置 配置好之后可以使用git config -l查看配置：\ngit config -l ","title":"Git 配置用户信息"},{"content":"重命名远程库后 我们在 Github 上更改仓库的默认分支后，或更改了分支名后，我们需要在本地库下执行以下代码：\ngit branch -m Old_branch_name New_branch_name git fetch origin git branch -u origin/New_branch_name New_branch_name git remote set-head origin -a ","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%87%8D%E5%91%BD%E5%90%8D%E8%BF%9C%E7%A8%8B%E5%BA%93%E5%90%8E/","summary":"重命名远程库后 我们在 Github 上更改仓库的默认分支后，或更改了分支名后，我们需要在本地库下执行以下代码：\ngit branch -m Old_branch_name New_branch_name git fetch origin git branch -u origin/New_branch_name New_branch_name git remote set-head origin -a ","title":"Git 重命名远程库后"},{"content":"集中式与分布式的区别 前言 集中式版本控制系统最大的毛病就是必须联网才能工作，如果网速快还好，上传的也快，可当遇到网速慢的时候，可能提交一个 10M 的文件就需要 5 分钟，这还不得把人给憋死啊。\n联网性 首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件 A，你的同事也在他的电脑上改了文件 A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。\n安全性 与集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。\n分布式的优点 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而 SVN 在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"集中式与分布式的区别 前言 集中式版本控制系统最大的毛病就是必须联网才能工作，如果网速快还好，上传的也快，可当遇到网速慢的时候，可能提交一个 10M 的文件就需要 5 分钟，这还不得把人给憋死啊。\n联网性 首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件 A，你的同事也在他的电脑上改了文件 A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。\n安全性 与集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。\n分布式的优点 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而 SVN 在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步。","title":"Git 集中式与分布式的区别"},{"content":"arguments 它是一个与函数的实参有映射关系的类数组。\n若函数的实参和形参数量一致，那么函数的形参与函数的 argments 之间为映射关系，即形参改变后，与之映射的 arguments[x] 也会改变。\n若传入的实参比形参少，多余的形参和 argments 没有映射关系。\nfunction demo(a, b) { \t// return 20 \tconsole.log(b); \tb = 200;  \t// return 200 \tconsole.log(b); \targuments[1] = 2000; \t// return 2000 \tconsole.log(b); } demo(1, 20); 属性 Callee 该属性包含当前正在执行的函数。在哪个函数中调用的方法 arguments.calle，该 calle 中就包含这个函数的函数体。\n注意 arguments 对象是所有（非箭头）函数中都可用的局部变量。你可以使用 arguments 对象在函数中引用函数的实参；此对象包含传递给函数的每个实参，第一个实参的索引为 0。\narguments 对象不是一个 Array ；但它类似于 Array，但除了有 length 属性和索引的特性之外没有任何其他 Array 属性。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/arguments/","summary":"arguments 它是一个与函数的实参有映射关系的类数组。\n若函数的实参和形参数量一致，那么函数的形参与函数的 argments 之间为映射关系，即形参改变后，与之映射的 arguments[x] 也会改变。\n若传入的实参比形参少，多余的形参和 argments 没有映射关系。\nfunction demo(a, b) { \t// return 20 \tconsole.log(b); \tb = 200;  \t// return 200 \tconsole.log(b); \targuments[1] = 2000; \t// return 2000 \tconsole.log(b); } demo(1, 20); 属性 Callee 该属性包含当前正在执行的函数。在哪个函数中调用的方法 arguments.calle，该 calle 中就包含这个函数的函数体。\n注意 arguments 对象是所有（非箭头）函数中都可用的局部变量。你可以使用 arguments 对象在函数中引用函数的实参；此对象包含传递给函数的每个实参，第一个实参的索引为 0。\narguments 对象不是一个 Array ；但它类似于 Array，但除了有 length 属性和索引的特性之外没有任何其他 Array 属性。","title":"JavaScript arguments"},{"content":"eval() 它会将传入的字符串当做 JavaScript 代码来执行。\n在 JavaScript 中，有一句话叫：\neval 是魔鬼。\nconsole.log(eval(\u0026#39;2 + 2\u0026#39;)); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/eval/","summary":"eval() 它会将传入的字符串当做 JavaScript 代码来执行。\n在 JavaScript 中，有一句话叫：\neval 是魔鬼。\nconsole.log(eval(\u0026#39;2 + 2\u0026#39;)); ","title":"JavaScript eval()"},{"content":"Function 每个 JavaScript 函数实际上都是一个 Function 对象。\nFunction 构造函数创建一个新的 Function 对象。\n全局的 Function 对象没有自己的属性和方法，但是，因为它本身也是一个函数，所以它也会通过原型链从自己的原型链 Function.prototype 上继承一些属性和方法。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/function/function/","summary":"Function 每个 JavaScript 函数实际上都是一个 Function 对象。\nFunction 构造函数创建一个新的 Function 对象。\n全局的 Function 对象没有自己的属性和方法，但是，因为它本身也是一个函数，所以它也会通过原型链从自己的原型链 Function.prototype 上继承一些属性和方法。","title":"JavaScript Function"},{"content":"function 它可以用来在一个表达式中定义一个函数。\nfunction Fun(parameter) { \tconsole.log(\u0026#39;我是一个函数\u0026#39;); } ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E4%B8%BB%E8%A6%81%E8%A1%A8%E8%BE%BE%E5%BC%8F/function/","summary":"function 它可以用来在一个表达式中定义一个函数。\nfunction Fun(parameter) { \tconsole.log(\u0026#39;我是一个函数\u0026#39;); } ","title":"JavaScript function"},{"content":"Function 方法 call() 改变调用它的构造函数的 this 指向。并指定构造函数的采纳书\nfunction Demo(name, age) { \tthis.name = name; \tthis.age = age; } var huge = new Demo(\u0026#39;Su\u0026#39;, 100); console.log(huge);  var test = {};  // 改变 Demo() 中 this 的指向为对象 test， Demo.call(test, \u0026#39;Rainy\u0026#39;, 100);  console.log(test); 实现继承 function Tyre(size, style) { \tthis.size = size; \tthis.style = style; }  function Interior(color, texture) { \tthis.color = color; \tthis.texture = texture; }  function Model(height, width, length, type) { \tthis.height = height; \tthis.width = width; \tthis.length = length; \tthis.type = type; }  function Car(size, style, color, comfort, length, width, height, type) { \tTyre.call(this, size, style); \tInterior.call(this, color, comfort); \tModel.call(this, length, width, height, type); } var Lamborghini = new Car(50, \u0026#39;线性\u0026#39;, \u0026#39;black\u0026#39;, \u0026#39;真皮\u0026#39;, 1.7, 2.5, 5.2, \u0026#39;SuperRun\u0026#39;);  console.log(Lamborghini); apply() 用于调用一个构造函数并改变该函数 this 的指向，并指定一个类数组作为构造函数的参数列表。\n该方法的语法和作用与 apply() 方法类似，唯一的区别就是传参的列表不同， call() 方法接收的是函数的形参列表，而 apply() 方法接收的是函数的 arguments。\nfunction Demo(name, age) { \tthis.name = name; \tthis.age = age; } var house = new Demo(\u0026#39;Rainy\u0026#39;, 100); console.log(house); var test = {};  Demo.apply(test, [\u0026#39;zxy\u0026#39;, 100]); console.log(test); 实现继承 function Tyre(size, style) { \tthis.size = size; \tthis.style = style; }  function Interior(color, texture) { \tthis.color = color; \tthis.texture = texture; }  function Model(height, width, length, type) { \tthis.height = height; \tthis.width = width; \tthis.length = length; \tthis.type = type; }  function Car(size, style, color, comfort, length, width, height, type) { \tTyre.apply(this, [size, style]); \tInterior.apply(this, [color, comfort]); \tModel.apply(this, [length, width, height, type]); } var Lamborghini = new Car(50, \u0026#39;线性\u0026#39;, \u0026#39;black\u0026#39;, \u0026#39;真皮\u0026#39;, 1.7, 2.5, 5.2, \u0026#39;SuperRun\u0026#39;); console.log(Lamborghini); bind() 返回一个新的函数，并改变新函数的 this 指向，而其余参数将作为新函数的参数，供调用时使用。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/function/function-%E6%96%B9%E6%B3%95/","summary":"Function 方法 call() 改变调用它的构造函数的 this 指向。并指定构造函数的采纳书\nfunction Demo(name, age) { \tthis.name = name; \tthis.age = age; } var huge = new Demo(\u0026#39;Su\u0026#39;, 100); console.log(huge);  var test = {};  // 改变 Demo() 中 this 的指向为对象 test， Demo.call(test, \u0026#39;Rainy\u0026#39;, 100);  console.log(test); 实现继承 function Tyre(size, style) { \tthis.size = size; \tthis.style = style; }  function Interior(color, texture) { \tthis.color = color; \tthis.texture = texture; }  function Model(height, width, length, type) { \tthis.","title":"JavaScript Function 方法"},{"content":"IIFE 立即执行函数，是一种在被定义后就会立即执行的函数，不需要被调用，执行完毕后就会被立即释放。\n用于创建一个独立的作用域，主要用于初始化功能。这个作用域中的变量，外面的任何位置访问不到，用于避免变量污染和命名冲突。\n它具有普通的函数一样的功能（参数、返回值、执行期上下文等）。\n只有函数表达式可以被执行符 () 执行，被执行符所执行的函数表达式的函数名会被自动忽略，即该函数表达式变为了 IIFE。\n多个 IIFE 之间要加分号。\nvar demo = (function (a, b) { \t// 用变量 demo 接收 IIFE 的返回值 \ta = Number(a); \tb = Number(b); \tvar c = (a + b) * 10; \t// 将变量 a 与 b 的和乘 10 的结果赋给变量 c \treturn c; \t// 将变量 c 作为该 IIFE 的返回值 })(10, 20); // 10 与 20 为实参 console.log(demo); 立即释放的特性 var a = (function demo() { \t// 用变量 a 接收函数 demo，因函数 demo 执行一次后就会被释放，则会导致变量 a 的值变为 undefined \t// 因此再次调用变量 a 会返回 undefined \tconsole.log(\u0026#39;函数的第一次调用\u0026#39;); })(); // 使用执行符 () 执行这个函数表达式，使得这个函数变为 IIFE。 console.log(\u0026#39;函数的第二次调用:\u0026#39; + a); // 因为变量 a 的值在执行一次后被释放了，所以再次调用变量 a 会返回 undefined ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/iife/","summary":"IIFE 立即执行函数，是一种在被定义后就会立即执行的函数，不需要被调用，执行完毕后就会被立即释放。\n用于创建一个独立的作用域，主要用于初始化功能。这个作用域中的变量，外面的任何位置访问不到，用于避免变量污染和命名冲突。\n它具有普通的函数一样的功能（参数、返回值、执行期上下文等）。\n只有函数表达式可以被执行符 () 执行，被执行符所执行的函数表达式的函数名会被自动忽略，即该函数表达式变为了 IIFE。\n多个 IIFE 之间要加分号。\nvar demo = (function (a, b) { \t// 用变量 demo 接收 IIFE 的返回值 \ta = Number(a); \tb = Number(b); \tvar c = (a + b) * 10; \t// 将变量 a 与 b 的和乘 10 的结果赋给变量 c \treturn c; \t// 将变量 c 作为该 IIFE 的返回值 })(10, 20); // 10 与 20 为实参 console.log(demo); 立即释放的特性 var a = (function demo() { \t// 用变量 a 接收函数 demo，因函数 demo 执行一次后就会被释放，则会导致变量 a 的值变为 undefined \t// 因此再次调用变量 a 会返回 undefined \tconsole.","title":"JavaScript IIFE"},{"content":"isNaN() isNaN(value) 用于判定 value 是否为 NaN，是则返回 true，否则返回 false。\n如果 value 不是 Number 类型，那么该函数会用 Number() 方法将 value 隐式转换，然后再判断转换后的结果是否为 NaN。因此，被测试的值在被强制转换成数值时会不会返回 IEEE-754 中所谓的不是数值，隐式转换调用的都是显式转换方法。\n返回 false 的值  0 除以 0 NaN undefined {}（空对象）  ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/isnan/","summary":"isNaN() isNaN(value) 用于判定 value 是否为 NaN，是则返回 true，否则返回 false。\n如果 value 不是 Number 类型，那么该函数会用 Number() 方法将 value 隐式转换，然后再判断转换后的结果是否为 NaN。因此，被测试的值在被强制转换成数值时会不会返回 IEEE-754 中所谓的不是数值，隐式转换调用的都是显式转换方法。\n返回 false 的值  0 除以 0 NaN undefined {}（空对象）  ","title":"JavaScript isNaN()"},{"content":"Math 它是一个内置对象，它拥有一些数字常数属性和数学函数方法，它不是一个函数对象。\n引用圆周率的写法是 Math.PI，调用正余弦函数的写法是 Math.sin(x)，x 是要传入的参。\n计算时精度不准 0.14 * 100 = 14.000000000000002；0.1 + 0.2 = 0.30000000000000004；这些运算后的值都是因为 js 计算精度不准的导致。\n在 js 中整数和浮点数都属于 Number 数据类型，所有数字都是以 64 位浮点数形式储存。JavaScript 里的数字是采用 IEEE 754 标准的 64 位双精度浮点数，计算机进行计算的时候，会把数字转换为二进制，进行运算之后再转换为十进制，但是运算过程中小数部分最多支持 52 位，就会出现运算精度不准的问题。\n1000000000000001 + 1000000000000001 = 2000000000000002，即在 JavaScript 中，可正常计算范围在小数点前 16 位与后 16 位。\nfunction One() { \tfor (var c = 0; c \u0026lt; 18; c++) { \tvar d = Math.random().toFixed(2) * 100; \t// 首先取 0-1 的随机数，然后取这个数小数点后的两位数，最后乘 100，并赋给变量 d \tvar e = Math.floor(Math.random() * 100); \t// 首先取 0-1 之间的随机数，然后乘 100 后并向下取整，最后再赋给变量 e \tconsole.log(d); \t// 变量 d 可能会返回一些精度不准的值 \tconsole.log(e); \t// 变量 e 不会返回精度不准的值 \t} } One(); //执行这个函数，变量 d 会返回若干个精度不准的数值，变量 e 则不会。 使用 Math.floor() 方法或 Math.ceil() 方法即可解决这个问题。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/math/math/","summary":"Math 它是一个内置对象，它拥有一些数字常数属性和数学函数方法，它不是一个函数对象。\n引用圆周率的写法是 Math.PI，调用正余弦函数的写法是 Math.sin(x)，x 是要传入的参。\n计算时精度不准 0.14 * 100 = 14.000000000000002；0.1 + 0.2 = 0.30000000000000004；这些运算后的值都是因为 js 计算精度不准的导致。\n在 js 中整数和浮点数都属于 Number 数据类型，所有数字都是以 64 位浮点数形式储存。JavaScript 里的数字是采用 IEEE 754 标准的 64 位双精度浮点数，计算机进行计算的时候，会把数字转换为二进制，进行运算之后再转换为十进制，但是运算过程中小数部分最多支持 52 位，就会出现运算精度不准的问题。\n1000000000000001 + 1000000000000001 = 2000000000000002，即在 JavaScript 中，可正常计算范围在小数点前 16 位与后 16 位。\nfunction One() { \tfor (var c = 0; c \u0026lt; 18; c++) { \tvar d = Math.random().toFixed(2) * 100; \t// 首先取 0-1 的随机数，然后取这个数小数点后的两位数，最后乘 100，并赋给变量 d \tvar e = Math.","title":"JavaScript Math"},{"content":"new 用于创建一个对象类型的实例或一个具有构造函数的内置对象的实例。\nnew 实例 创建或返回一个新的对象实例，并将构造函数的作用域赋给新的对象实例（因此构造函数中的 this 的指向就变为了这个新的对象实例）。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%B7%A6%E4%BE%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F/new/","summary":"new 用于创建一个对象类型的实例或一个具有构造函数的内置对象的实例。\nnew 实例 创建或返回一个新的对象实例，并将构造函数的作用域赋给新的对象实例（因此构造函数中的 this 的指向就变为了这个新的对象实例）。","title":"JavaScript new"},{"content":"Number 该对象是经过封装的能被处理数字值的对象；该对象由 Number() 构造器创建。\nNumber 的方法 toString() NumObj.toString(radix)\n 将 NumObj 转为为 radix 进制的数，若 NumObj 无法被转换为 radix 进制的数，则返回 string 类型的 NaN；rRadix 的取值范围为 2 - 36，如果未指定 radix 参数，则默认值为 10。 当在 NumObj 中，遇到不在 radix 中的字符，则将忽略该字符以及所有后续字符，并返回在这之前已解析的整数值。 因为 Number 对象覆盖了 Object 对象上的 toString() 方法（系统将 Number 对象的 toString 方法重写了），因此它并不继承自 Object.prototype.toString()。  十进制转十六进制 var a = 1971; var b = 10; var c = 16; var d = parseInt(a, b); // 将变量 a 当做 b 进制的数，并将 b 转换为十进制的数。 var e = d.toString(c); // 将变量 d 转换为 c 进制的数。 var f = e; console.log(f); Number(mix) 将 mix 显式转换为 number 类型的数值；若 mix 无法被转换为数字，则返回 number 类型的 NaN。\n// 字符串转 number-------------------------------------------------- var n = \u0026#39;18\u0026#39;; // 这是一个字符串 18。 var a = Number(n); // 将变量 n 转换为数字类型的数据。 var b = typeof a + \u0026#39;：\u0026#39; + a; console.log(b); // 返回变量 a 的数据类型和变量 a 的值。 ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/number/","summary":"Number 该对象是经过封装的能被处理数字值的对象；该对象由 Number() 构造器创建。\nNumber 的方法 toString() NumObj.toString(radix)\n 将 NumObj 转为为 radix 进制的数，若 NumObj 无法被转换为 radix 进制的数，则返回 string 类型的 NaN；rRadix 的取值范围为 2 - 36，如果未指定 radix 参数，则默认值为 10。 当在 NumObj 中，遇到不在 radix 中的字符，则将忽略该字符以及所有后续字符，并返回在这之前已解析的整数值。 因为 Number 对象覆盖了 Object 对象上的 toString() 方法（系统将 Number 对象的 toString 方法重写了），因此它并不继承自 Object.prototype.toString()。  十进制转十六进制 var a = 1971; var b = 10; var c = 16; var d = parseInt(a, b); // 将变量 a 当做 b 进制的数，并将 b 转换为十进制的数。 var e = d.","title":"JavaScript Number()"},{"content":"Object 创建一个对象包装器；它的每个值都是对象的属性，且每个属性必须要有属性值，属性值的类型可以是任何数据类型。\n创建方式 对象字面量 var n = \u0026#39;世雨\u0026#39;; var a = \u0026#39;\u0026#39;; var object = { \t//var obj ={} 相当于 var obj = new Object()，一般情况都使用前者。 \tb: \u0026#39;臣\u0026#39;, \t// b 为属性名，臣为属性值 \tc: n, }; a = object.b + object.c; // 用变量 a 接收对象 object 的属性 b 与 c 的值。 console.log(a); // 返回臣世雨 工厂模式 function ThreeOne(color) { \tthis.color = color; \t// color为可选参数 \tthis.name = \u0026#39;bird\u0026#39;; \tthis.width = \u0026#39;500\u0026#39;; \tthis.height = \u0026#39;1000\u0026#39;; \tthis.weight = \u0026#39;666kg\u0026#39;; \tthis.health = \u0026#39;100\u0026#39;; \tthis.damage = function () { \tthis.health--; \tconsole.log(\u0026#39;我被损坏了\u0026#39;); \t}; } var b = new ThreeOne(\u0026#39;red\u0026#39;); // 用 new 调用构造函数 ThreeOne，并返回一个对象实例，再将这个对象实例赋给变量 b。 // 使用 new 时，它后面的函数调用就不是正常的调用，而是依次执行下面的步骤： // var this = { } 隐式创建一个空对象 this // AO{ this: { color : \u0026#34;demo\u0026#34;} } 执行构造函数中的代码，并将形参实参统一，this.xxx = xxx // return this; 最后隐式返回 this，这里可以手动使用 return 将隐式返回变为显式返回， // 但用 new 创建的对象必须 return 引用值（对象），若 return 原始值的话则无效。 var c = new ThreeOne(\u0026#39;yellow\u0026#39;); // 虽然对象 c 与对象 b 都是用的构造函数 ThreeOne 所构造出的对象，但它们是完全不一样的两个对象。 console.log(b.color); // 返回 red。 console.log(c.color); // 返回 yellow。  b.damage(); // 调用对象 b 的 damage 的属性。 console.log(b.health); // 返回 99。 create() Object.create()方法是 ECMAScript 5 中新增的方法，这个方法用于创建一个新对象。被创建的对象继承另一个对象的原型，在创建新对象时可以指定一些属性。\n注意\n使用 Object.create() 方法创建对象时，如果不是继承一个原有的对象，而是创建一个全新的对象，就要把 proto 设置为 null。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/object/object/","summary":"Object 创建一个对象包装器；它的每个值都是对象的属性，且每个属性必须要有属性值，属性值的类型可以是任何数据类型。\n创建方式 对象字面量 var n = \u0026#39;世雨\u0026#39;; var a = \u0026#39;\u0026#39;; var object = { \t//var obj ={} 相当于 var obj = new Object()，一般情况都使用前者。 \tb: \u0026#39;臣\u0026#39;, \t// b 为属性名，臣为属性值 \tc: n, }; a = object.b + object.c; // 用变量 a 接收对象 object 的属性 b 与 c 的值。 console.log(a); // 返回臣世雨 工厂模式 function ThreeOne(color) { \tthis.color = color; \t// color为可选参数 \tthis.name = \u0026#39;bird\u0026#39;; \tthis.","title":"JavaScript Object"},{"content":"parseFloat() parseFloat(string)，将 string 显式转换为 number 类型浮点数（小数）。若 string 无法被转换为浮点数，则返回 number 类型的 NaN。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/parsefloat/","summary":"parseFloat() parseFloat(string)，将 string 显式转换为 number 类型浮点数（小数）。若 string 无法被转换为浮点数，则返回 number 类型的 NaN。","title":"JavaScript parseFloat()"},{"content":"parseInt() parseInt(string, radix) 函数解析一个字符串并返回指定基数的十进制整数。\n将 string 看作 radix 进制的数，并将 string 显式转换为十进制且为 number 的整数（radix 为介于 2-36 之间的数，它是可选值，表示被解析字符串的基数），若 string 无法被转换为整数，则返回 number 类型的 NaN。\n当在 string 中，遇到不在 radix 进制中的字符，则将忽略该字符以及所有后续字符，并返回在这之前已解析的整数值。\n若 radix 为 0 时，部分浏览器（比如 IE）会报错，部分浏览器会将 0 当做 10 进行转换。\nN 进制转十进制 var n = 10010; var c = 2; // 变量 n 可为 8，16，32。 var a = parseInt(n, c); // 将 n 当作 c 进制的数，并将 n 显式转换为十进制的整数。 console.log(a); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/parselnt/","summary":"parseInt() parseInt(string, radix) 函数解析一个字符串并返回指定基数的十进制整数。\n将 string 看作 radix 进制的数，并将 string 显式转换为十进制且为 number 的整数（radix 为介于 2-36 之间的数，它是可选值，表示被解析字符串的基数），若 string 无法被转换为整数，则返回 number 类型的 NaN。\n当在 string 中，遇到不在 radix 进制中的字符，则将忽略该字符以及所有后续字符，并返回在这之前已解析的整数值。\n若 radix 为 0 时，部分浏览器（比如 IE）会报错，部分浏览器会将 0 当做 10 进行转换。\nN 进制转十进制 var n = 10010; var c = 2; // 变量 n 可为 8，16，32。 var a = parseInt(n, c); // 将 n 当作 c 进制的数，并将 n 显式转换为十进制的整数。 console.log(a); ","title":"JavaScript parselnt()"},{"content":"return 用于终止函数的执行，并指定函数的返回值。若没有指定返回值，则返回 undefined。\n字符串转数字 var n = \u0026#39;18\u0026#39;; function demo(n) { \treturn +n; \t// 用加号 + 隐式调用 Number() 方法，将字符串 n 转换为数字并作为返回值 } var a = demo(n); console.log(typeof a + \u0026#39;:\u0026#39; + a); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/return/","summary":"return 用于终止函数的执行，并指定函数的返回值。若没有指定返回值，则返回 undefined。\n字符串转数字 var n = \u0026#39;18\u0026#39;; function demo(n) { \treturn +n; \t// 用加号 + 隐式调用 Number() 方法，将字符串 n 转换为数字并作为返回值 } var a = demo(n); console.log(typeof a + \u0026#39;:\u0026#39; + a); ","title":"JavaScript return"},{"content":"this 在全局中，无论是否在严格模式下，this 指的都是全局对象（window）。\n通常情况，函数的调用方式决定了 this 的值；严格模式下， this 一般指向一个调用它的对象（即 this 的调用者，哪个对象的方法调用了 this，那么这个 this 就指向调用这个方法的对象 ），即第一人称我，\n严格模式下可以指向任意值。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E4%B8%BB%E8%A6%81%E8%A1%A8%E8%BE%BE%E5%BC%8F/this/","summary":"this 在全局中，无论是否在严格模式下，this 指的都是全局对象（window）。\n通常情况，函数的调用方式决定了 this 的值；严格模式下， this 一般指向一个调用它的对象（即 this 的调用者，哪个对象的方法调用了 this，那么这个 this 就指向调用这个方法的对象 ），即第一人称我，\n严格模式下可以指向任意值。","title":"JavaScript this"},{"content":"Window Window 对象表示一个包含 DOM 文档的窗口，其 document 属性指向窗口中载入的 DOM 文档 。\n如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/window/window/","summary":"Window Window 对象表示一个包含 DOM 文档的窗口，其 document 属性指向窗口中载入的 DOM 文档 。\n如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。","title":"JavaScript Window"},{"content":"作用域 作用域（scope）定义了代码在运行时的某些特定的变量、函数、对象的可调用范围。\n每个函数都会创建 scope（作用域对象），scope 中储存是一个个的全局作用域与局部作用域），即 scope 中存储的是作用域的集合（作用域链）。\n父函数不能调用子函数的变量 当调用一个变量时，调用者会去作用域链（scope）的顶端依次向下寻找这个变量；又因为子函数的 AO 中含有父函数 AO 的引用地址，所以子函数可以调用父函数的变量；反之，因为父函数的 AO 不能含有子函数 AO 的引用，所以父函数不能调用子函数的变量。\n作用域都是独立的 声明多个同级函数时，这些函数的作用域链都是独立的，即每个同级函数中的局部变量不可以公用，但它们都可以使用全局中的变量；这些作用域链会随着对应函数的执行完毕而依次释放。\n全局作用域 在全局作用域（GO 对象）中的变量为全局变量，全局变量的的作用域为整个脚本，这类变量在脚本中的任何地方（包括函数内部）能被调用。\n它们通常指在全局中定义的变量或没有使用 var 声明的暗示全局变量。\n这些变量都在全局作用域中：  函数外声明的变量。 函数中没有使用 var 声明的变量。  局部作用域 局部作用域（AO 对象）中的变量为局部变量，局部变量的作用域仅限于某个特定的函数，这类变量可以在特定的函数中调用。\n每个函数内部都会创建一个局部作用域，当一个函数（父函数）中包含另一个函数（子函数），则父函数不能调用子函数的变量，但子函数可以调用父函数的变量；并且两个独立且同级的函数中的局部变量不能公用，只能各用各的局部变量。\n这些变量都在局部作用域中：  它们通常指在函数中定义的变量或函数的形式参数。 函数中使用 var 声明的变量。 函数中的形式参数。  累加器 function One() { \tvar b = 0; \tfunction Two() { \tb++; \tconsole.log(b); \t} \ta = Two; \t// 变量 a 是一个暗示全局变量，用变量 a 接收函数 Two } One(); //调用函数 One，使暗示全局变量 a 可以执行 a(); // 执行变量 a，相当于执行函数 Two，每执行一次变量 a，就会使 b 在原来的的结果上自增一次。 a(); a(); 作用域链 function One() { \t// 声明函数 One 时，系统会隐式创建 One.[[scope]]，这是一个隐式的属性，我们并不能调用。 \tb = 20; \t// 全局变量 b。 \tvar a = 30; \t// 变量 a，它是局部变量，函数中局部变量优先于全局变量。 \tTwo(); \t// 调用函数 One，返回 70。 \tconsole.log(c); \t// 返回 30 。 \tconsole.log(typeof d); \t// 变量 d 为函数 Two 中的局部变量，通常情况，在全局中调用该变量会报错， \t// 但使用 typeof 操作符则不会报错，并且还会返回 undefined。 \tfunction Two() { \tvar e = 50; \tconsole.log(b + e); \t// 返回全局变量 b 与局部变量 e 的和 70。 \tc = \u0026#39;30\u0026#39;; \t// 全局变量 c。 \tvar d = 40; \t// 局部变量 d。 \t} \tTwo(); \t// 在次调用函数 Two } One();  // 声明函数 One------创建函数 One 的scope------在 scope 的作用域链里第零位创建一个 GO， // 也就是全局的环境栈 // 0：GO // 执行函数 One------将函数 One 创建的 AO 放在作用域链的第零位， // 全局创建的 GO 移动到了作用域链的第一位， // 这是函数 One 的环境栈 // 0：One 的 AO // 1：GO // 声明函数 Two------创建函数 Two 的 scope------ 它可以使用函数 One 的环境栈 // 0：One 的 AO // 1：GO // 执行函数 One------创建函数 Two 的 scope------将函数 Two 创建的 AO 放在作用域链的第零位， // 并将函数 One 的 AO 移动到作用域链的第一位，再将全局的 GO 移动到作用域链的第二位， // 这是函数 Two 的环境栈 // 0：Two 的 AO // 1：One 的 AO // 2：GO // 函数 Two 执行完毕后------销毁函数 Two 创建的 AO，并再次调用函数 Two， // 0：new Two 的 AO（原函数 Two 已被销毁，这是一个新的函数 Two 的 new Two ） // 1：One 的 AO // 2：GO // 新的函数 Two 执行完毕后------销毁新的函数 Two 创建的 new AO， // 函数 One 执行完毕后------销毁函数 One 创建的 AO // 全局执行完后------销毁全局创建的 GO ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E4%BD%9C%E7%94%A8%E5%9F%9F/","summary":"作用域 作用域（scope）定义了代码在运行时的某些特定的变量、函数、对象的可调用范围。\n每个函数都会创建 scope（作用域对象），scope 中储存是一个个的全局作用域与局部作用域），即 scope 中存储的是作用域的集合（作用域链）。\n父函数不能调用子函数的变量 当调用一个变量时，调用者会去作用域链（scope）的顶端依次向下寻找这个变量；又因为子函数的 AO 中含有父函数 AO 的引用地址，所以子函数可以调用父函数的变量；反之，因为父函数的 AO 不能含有子函数 AO 的引用，所以父函数不能调用子函数的变量。\n作用域都是独立的 声明多个同级函数时，这些函数的作用域链都是独立的，即每个同级函数中的局部变量不可以公用，但它们都可以使用全局中的变量；这些作用域链会随着对应函数的执行完毕而依次释放。\n全局作用域 在全局作用域（GO 对象）中的变量为全局变量，全局变量的的作用域为整个脚本，这类变量在脚本中的任何地方（包括函数内部）能被调用。\n它们通常指在全局中定义的变量或没有使用 var 声明的暗示全局变量。\n这些变量都在全局作用域中：  函数外声明的变量。 函数中没有使用 var 声明的变量。  局部作用域 局部作用域（AO 对象）中的变量为局部变量，局部变量的作用域仅限于某个特定的函数，这类变量可以在特定的函数中调用。\n每个函数内部都会创建一个局部作用域，当一个函数（父函数）中包含另一个函数（子函数），则父函数不能调用子函数的变量，但子函数可以调用父函数的变量；并且两个独立且同级的函数中的局部变量不能公用，只能各用各的局部变量。\n这些变量都在局部作用域中：  它们通常指在函数中定义的变量或函数的形式参数。 函数中使用 var 声明的变量。 函数中的形式参数。  累加器 function One() { \tvar b = 0; \tfunction Two() { \tb++; \tconsole.log(b); \t} \ta = Two; \t// 变量 a 是一个暗示全局变量，用变量 a 接收函数 Two } One(); //调用函数 One，使暗示全局变量 a 可以执行 a(); // 执行变量 a，相当于执行函数 Two，每执行一次变量 a，就会使 b 在原来的的结果上自增一次。 a(); a(); 作用域链 function One() { \t// 声明函数 One 时，系统会隐式创建 One.","title":"JavaScript 作用域"},{"content":"函数 函数又叫方法，它是用来执行某些特定功能的代码；且允许我们在程序中随时进行调用。\n每一个函数其实都是一个 Function 类型的对象。\n函数中若没有使用 return 语句，则它默认返回 undefined；要想返回一个指定的值，则需使用 return 语句来指定一个返回值（使用 new 关键字调用一个构造函数除外）。\n基本方式 直接通过 function 关键字进行声明。\nfunction demo(a, b) { \t// 声明一个函数，demo 为函数名，a 与 b为形式参数（形参）。 \tconsole.log(a + b); \t// 返回形参 a 与 b 的和 3。 } demo(1, 2); // 使用执行符 () 调用函数 demo，1 与 2 为实际参数（实参） var c = demo.name; // 函数 demo 的属性 name 为指定函数的（这里为 demo）名字， // 该属性的值永远等于跟在 function 关键字后面的标识符（变量名），匿名函数的属性 name 为空。 console.log(c); // 返回函数 demo 的函数名  //匿名函数方式-------------------------------------------------- var demo = function () { \tconsole.log(456); }; demo(); var c = demo.name; console.log(c); 函数表达式 函数表达式类似于函数声明，并且两者拥有几乎相同的语法；\n函数表达式与函数声明的最主要区别是函数名称，在函数表达式中可省略它，从而创建匿名函数。\nb\n命名函数表达式 var demo = function test(a, b) { \tconsole.log(\u0026#39;命名函数表达式\u0026#39;); }; 函数的属性 name var a = function () {}; console.log(a.name); // ES5 是返回空字符串 \u0026#34;\u0026#34;。 // ES6 是返回接收匿名函数的变量名。 ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/","summary":"函数 函数又叫方法，它是用来执行某些特定功能的代码；且允许我们在程序中随时进行调用。\n每一个函数其实都是一个 Function 类型的对象。\n函数中若没有使用 return 语句，则它默认返回 undefined；要想返回一个指定的值，则需使用 return 语句来指定一个返回值（使用 new 关键字调用一个构造函数除外）。\n基本方式 直接通过 function 关键字进行声明。\nfunction demo(a, b) { \t// 声明一个函数，demo 为函数名，a 与 b为形式参数（形参）。 \tconsole.log(a + b); \t// 返回形参 a 与 b 的和 3。 } demo(1, 2); // 使用执行符 () 调用函数 demo，1 与 2 为实际参数（实参） var c = demo.name; // 函数 demo 的属性 name 为指定函数的（这里为 demo）名字， // 该属性的值永远等于跟在 function 关键字后面的标识符（变量名），匿名函数的属性 name 为空。 console.log(c); // 返回函数 demo 的函数名  //匿名函数方式-------------------------------------------------- var demo = function () { \tconsole.","title":"JavaScript 函数"},{"content":"函数参数 形参 指在定义函数时使用的参数，用于接收调用该函数时传入的实参。\n在调用函数时，实参将赋值给形参；因而，必须使实参的个数与类型应与形参一一的对应，且传入的实参必须要有确定的值。若为给形参传入对应的实参，那么该形参默认为undefined。\n实参 调用函数时传递给函数的参数，一般与实参一一对应。\n变量传值 指的是将一个变量的值赋给另外一个变量。\n值传递 将一个变量的值复制一份， 然后将新的值赋给另外一个变量（两个变量没有关系）。\n引用传递 将一个变量的值的内存地址，传递给另外一个变量，两个变量的内存地址所指向的是同一块内存空间（两个变量所指向的都是同一个值，他们互相影响，其中一个变量被改变，另一个也会跟着被改变）。\n形参默认值 定义函数的同时可以给形参赋默认值，当我们调用该函数时，若未给形参传入对应的实参，那么这个默认值会被当作该函数的实参。\n形参默认值一般设置在形参末尾。\nfunction fun(a = 1, b = 2, c = 3) { \tconsole.log(a, b, c); }  fun(10, 20); rest rest 中包含了没有对应形参的实参，或者说多余的实参。\nrest 只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。\nrest 是一个真数组，而不是一个类数组。\nrest 必须放到形参末尾。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/","summary":"函数参数 形参 指在定义函数时使用的参数，用于接收调用该函数时传入的实参。\n在调用函数时，实参将赋值给形参；因而，必须使实参的个数与类型应与形参一一的对应，且传入的实参必须要有确定的值。若为给形参传入对应的实参，那么该形参默认为undefined。\n实参 调用函数时传递给函数的参数，一般与实参一一对应。\n变量传值 指的是将一个变量的值赋给另外一个变量。\n值传递 将一个变量的值复制一份， 然后将新的值赋给另外一个变量（两个变量没有关系）。\n引用传递 将一个变量的值的内存地址，传递给另外一个变量，两个变量的内存地址所指向的是同一块内存空间（两个变量所指向的都是同一个值，他们互相影响，其中一个变量被改变，另一个也会跟着被改变）。\n形参默认值 定义函数的同时可以给形参赋默认值，当我们调用该函数时，若未给形参传入对应的实参，那么这个默认值会被当作该函数的实参。\n形参默认值一般设置在形参末尾。\nfunction fun(a = 1, b = 2, c = 3) { \tconsole.log(a, b, c); }  fun(10, 20); rest rest 中包含了没有对应形参的实参，或者说多余的实参。\nrest 只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。\nrest 是一个真数组，而不是一个类数组。\nrest 必须放到形参末尾。","title":"JavaScript 函数参数"},{"content":"分支与循环 为什么 if 语句中不能进行函数声明 因为程序执行时，程序会在本页代码之内寻找函数声明，并进行函数声明提升，而不会去查找需要条件的 if 之内的内容，\n另外，可以用函数表达式定义函数？\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF/","summary":"分支与循环 为什么 if 语句中不能进行函数声明 因为程序执行时，程序会在本页代码之内寻找函数声明，并进行函数声明提升，而不会去查找需要条件的 if 之内的内容，\n另外，可以用函数表达式定义函数？","title":"JavaScript 分支与循环"},{"content":"包装类 在 JavaScript 中，因为原始值不能有属性和方法，所以当给原始值添加属性与方法时，系统会自动且隐式的将原始类型的数据转换为对象，然后再调用这个对象的属性和方法，调用完以后，在将其转换为原始值，这个过程叫做包装类。\n因为 undefined 与 null 不能有属性，所以它们不能进行包装类。\nNumber 将原始类型的数值，转换为 Number 对象，它的原型是 Number.prototyp。\n数字类型的对象可以进行学运算，但运算的结果，这个对象会变回原始类型的数值。\nString 将原始类型的字符串，转换为 String 对象，它的原型是 String.prototyp。\n当原始值字符串直接调用属性 length 时，系统会对这个原始值字符串进行包装类，使之变为对象字符串，又因为字符串对象自带属性 length，因此系统不会将这个属性 delete 删掉，所以最终将属性 length 的值返回。\nBoolean 将原始类型的布尔值，转换为 boolean 对象，它的原型是 Boolean.prototyp。\n注意 因为 Number、String、boolean 它们本身重写了（用一个同名不同功能的方法覆盖系统自带的方法）一个 xxx.prototype.toString 方法，所以它们不会用原型上 Object.prototype 的 toString 方法。\nvar a = new Number(123); var b = new String(\u0026#39;yxz\u0026#39;); var c = new Boolean(\u0026#39;true\u0026#39;); console.log(typeof a); console.log(typeof b); console.log(typeof c); // 返回三个 object 数值包装类运算 var num = new Number(123); //原始值 num 被进行包装类，因此它变成了 对象 123。 console.log(typeof num + \u0026#39;:\u0026#39; + num); //返回 object 123，即对象类型的 123 num = num * 3; // 虽然这个时候的 num 是对象类型的，但它也可以进行数学运算，但运算之后的结果又会变回原始类型。 console.log(typeof num + \u0026#39;:\u0026#39; + num); //返回 number 369，即对象 num 在进行运算之后又变回了原始类型。 数值包装类 var a = 1234; a.length = 2; // 系统会自动创建数值对象 new Number(1234).length = 2， // 之后系统判定变量 a 没有属性 length，因此系统自动添加了这个属性（弥补操作的不足）， // 但又因为原始值不能有属性与方法，所以最终系统又 delete 删掉了属性 length console.log(a.length); // 返回 undefined，系统会再次自动创建数值对象 new Number(1234).length， // 之后系统判定字符串 a 没有属性 length，因此系统又 delete 删掉了属性 length。 // 这个时候调用对象 a.length， // 相当于调用一个对象所没有的 length 属性（之前被 delete 删除了）。 字符串包装类 var a = \u0026#39;1234\u0026#39;; a.length = 2; // 系统会自动创建字符串对象 new String(\u0026#34;1234\u0026#34;).length = 2， // 之后系统判定变量 a 没有属性 length，因此系统自动添加了这个属性（弥补操作的不足）， // 并将这个字符串对象截断成 2 个值，但又因为原始值不能有属性与方法， // 所以最终系统又 delete 删掉了属性 length。 console.log(a.length); // 系统会再次自动创建 new String(\u0026#34;1234\u0026#34;).length， // 之后系统判定字符串对象 a 有属性 length，所以系统不会删除这个属性， // 最后因为字符串 a 可以有属性 length，所以会返回字符串 a 的字符串长度。 深入理解包装类 var a = \u0026#39;abc\u0026#39;; a += 1; // 变量 变 a 为 abc1 var b = typeof a; // 将变量 a 的数据类型 string 赋给变量 b if (b.length == 6) { \t// 变量 b 调用 String() 包装类，然后判定字符串 string 的字符长度 6， \t// 该条件为 true，则返回 6，即该条件为 true，则继续执行后面代码块 \tb.sing = \u0026#39;成功\u0026#39;; \t// 再次调用 String() 包装类，这个包装类和之前的不同， \t// 系统会自动创建 new String(b).sing = \u0026#34;成功\u0026#34;， \t// 之后系统判定变量 b 没有属性 sing，因此系统自动添加了这个属性， \t// 但又因为原始值不能有属性和方法，所以最终系统又 delete 删掉了属性 sing。 } console.log(b.sing); // 再次调用包装类，这个包装类和前面两次的包装类不同， // 系统会自动创建 new String(b).sing， // 相当于调用一个对象没有的属性（因为属性 sing 在这之前已经被系统 delete 删除了）， // 所以最后返回 undefined。 ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%8C%85%E8%A3%85%E7%B1%BB/","summary":"包装类 在 JavaScript 中，因为原始值不能有属性和方法，所以当给原始值添加属性与方法时，系统会自动且隐式的将原始类型的数据转换为对象，然后再调用这个对象的属性和方法，调用完以后，在将其转换为原始值，这个过程叫做包装类。\n因为 undefined 与 null 不能有属性，所以它们不能进行包装类。\nNumber 将原始类型的数值，转换为 Number 对象，它的原型是 Number.prototyp。\n数字类型的对象可以进行学运算，但运算的结果，这个对象会变回原始类型的数值。\nString 将原始类型的字符串，转换为 String 对象，它的原型是 String.prototyp。\n当原始值字符串直接调用属性 length 时，系统会对这个原始值字符串进行包装类，使之变为对象字符串，又因为字符串对象自带属性 length，因此系统不会将这个属性 delete 删掉，所以最终将属性 length 的值返回。\nBoolean 将原始类型的布尔值，转换为 boolean 对象，它的原型是 Boolean.prototyp。\n注意 因为 Number、String、boolean 它们本身重写了（用一个同名不同功能的方法覆盖系统自带的方法）一个 xxx.prototype.toString 方法，所以它们不会用原型上 Object.prototype 的 toString 方法。\nvar a = new Number(123); var b = new String(\u0026#39;yxz\u0026#39;); var c = new Boolean(\u0026#39;true\u0026#39;); console.log(typeof a); console.log(typeof b); console.log(typeof c); // 返回三个 object 数值包装类运算 var num = new Number(123); //原始值 num 被进行包装类，因此它变成了 对象 123。 console.","title":"JavaScript 包装类"},{"content":"区分对象与数组 Constructor var arr = []; var obj = {}; var a = arr.constructor; console.log(a); // 返回数组。 var b = obj.constructor; console.log(b); // 返回对象。 Instanceof var arr = [];  var obj = {};  var a = arr instanceof Array; console.log(a); // 返回 true，因为变量 arr 是一个数组。 var a = arr instanceof Object; console.log(a); // 返回 true，因为变量 arr 是一个数组类对象。 var b = obj instanceof Array; console.log(b); // 返回 flase，因为变量 obj 不是一个数组。 var b = obj instanceof Object; console.log(b); // 返回 true，因为变量 obj 是一个对象。 Object.prototype.toString.call() var arr = []; var obj = {}; var a = Object.prototype.toString.call(arr); console.log(a); // 返回 object Array，即 arr 是一个数组。 var b = Object.prototype.toString.call(obj); console.log(b); // 返回 object Object，即 obj 是一个对象。 ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%8C%BA%E5%88%86%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%95%B0%E7%BB%84/","summary":"区分对象与数组 Constructor var arr = []; var obj = {}; var a = arr.constructor; console.log(a); // 返回数组。 var b = obj.constructor; console.log(b); // 返回对象。 Instanceof var arr = [];  var obj = {};  var a = arr instanceof Array; console.log(a); // 返回 true，因为变量 arr 是一个数组。 var a = arr instanceof Object; console.log(a); // 返回 true，因为变量 arr 是一个数组类对象。 var b = obj instanceof Array; console.log(b); // 返回 flase，因为变量 obj 不是一个数组。 var b = obj instanceof Object; console.","title":"JavaScript 区分对象与数组"},{"content":"原型 原型对象，它是只有函数才拥有的隐式属性（使用 null 作为构造函数的原型的情况下，原型不能通过自定义进行添加）\n通过原型对象这种机制，可以使一个对象从其他的对象那里继承一属性或方法。\nprototype 显式原型属性，每一个对象都有一个 prototype，这个属性指向该对象的原型对象。\n它和proto指向的都是同一个原型对象。\n我们一般通过prototype去操作一个对象的原型对象。而系统调用的时候，会通过proto去调用。\n__proto__  隐式原型属性，每一个对象都有一个proto，这个属性指向该对象的原型对象。 proto 的指向（值）可以修改，即一个用构造函数创建出的对象实例的原型是可以通过该属性修改的。 当调用一个对象的属性时，如果这个对象没有这个属性，那么就会到构造该对象的构造函数的原型所指向的对象（可以称之为父对象）中去寻找这个属性，如果父对象也没有这个属性，则到该父对象的构造函数的原型所指向的对象（可以称之为为爷爷对象）里去寻找这个属性，如果还没找到，则继续往上找…，直到原型链终端为 Object.prototype；Object.prototype 中有一个 null，相当于到 null 中去取值，即调用一个对象所没有的值，会返回 undefined；这种通过属性 proto 连接原型对象直到 Object.prototype（null）的一条链为原型链。 通常情况，大部分对象最终都会继承自 Object.prototype，因为 Object.create() 方法中可以将 null 放进去当做原型。 在 JavaScript 中，null 与 undefined 没有原型且不是对象。  作用 可以让一个构造函数所创建的多个对象都可以使用公用的属性和方法。\n声明一个构造函数之后，该构造函数中会有一个属性 prototype，这个属性指向的就是该构造函数对应的原型对象。\n原型对象中有一个属性 constructor，该属性用于指向这个对象的构造函数。\n// Demo.prototype = {} 是构造函数 Demo 的原型，它默认是一个空对象（原型对象） // 当构造函数 Demo 被定义完成时，同时该函的原型对象 Demo.prototype = {} 也被定义完成； // Demo.prototype.name = \u0026#34;原型的名字\u0026#34;; // Demo.prototype.size = \u0026#34;500\u0026#34;; // Demo.prototype.height = \u0026#34;1400\u0026#34;; // Demo.prototype.width = \u0026#34;800\u0026#34;; //上面代码可以简化为： Demo.prototype = { \tname: \u0026#39;简化后原型的名字\u0026#39;, \tsize: \u0026#39;500\u0026#39;, \theight: \u0026#39;1400\u0026#39;, \twidth: \u0026#39;800\u0026#39;, }; // 给构造函数 Demo 的原型添加公用属性和函数，减少代码冗余， // 使该构造函数所构造的对象都可以使用这些公有属性和函数。 Demo.prototype.say = function () { \t// 给函数 Demo 的原型添加一个函数 \tconsole.log(\u0026#39;apple\u0026#39;); };  function Demo(color, value) { \t// this.name = \u0026#34;yxz\u0026#34;; \t// this.size = \u0026#34;500\u0026#34;; \t// this.height = \u0026#34;1400\u0026#34;; \t// this.width = \u0026#34;800\u0026#34;; \t// 可以将以上冗余（重复且不变）的属性放到自身的原型中，使得代码更加简洁高效 \tthis.color = color; \tthis.name = value; \t// 构造函数中的的属性 name 优先级高于自身原型中的 name 属性， \t// 若构造函数本身有的属性，同时其原型中也有，则优先使用本身的属性。 } var a = new Demo(\u0026#39;red\u0026#39;, \u0026#39;a的参数\u0026#39;); var b = new Demo(\u0026#39;orange\u0026#39;, \u0026#39;b的参数\u0026#39;); //对象 a、b 的原型是一样的，即它们的属性与方法都继承自同一个原型（Demo.prototype） console.log(a.name); // 调用对象 a 的属性 name，先到对象 a 中寻找属性 name， // 自身有这个属性，则使用自己的，若自身没有，则继续到其原型中去寻找，直到返回 null。 console.log(a.size); console.log(b.height); console.log(b.say); // 调用对象 a、b 的属性，若它们自身没有，则到它们共同的原型中去寻找这些属性， // 即用同一个构造函数所创建出来的多个对象实例，这些对象的原型都是一样的。 改变 prototype 上的属性 Demo.prototype.name = \u0026#39;apple\u0026#39;; function Demo() { \t// var this = { \t// __proto__ : Demo.prototype \t// } \t// 构造函数 Demo 的属性 __proto__ 的指向为原型对象 Demo.prototype。 \t// } }  Demo.prototype = { \tname: \u0026#39;bird\u0026#39;, }; // 这个时候的构造函数 Demo 还没有构造出对象实例， // 所以在这个时候修改构造函数 Demo 的属性 __proto__ 的指向会影响 // 之后用该构造函数创建的对象的原型的指向。 var a = new Demo();  Demo.prototype = { \tname: \u0026#39;desk\u0026#39;, }; // 这个时候的构造函数 Demo 已经构造出了对象实例， // 所以在这个时候修改构造函数 Demo 的属性 __proto__ 指向不会影响 // 之前用该构造函数创建的对象的原型的指向。  console.log(a.name); // 返回 bird 原型的增删改查 Demo.prototype.width = \u0026#39;800\u0026#39;;  function test() {} Demo.prototype = { \tconstructor: test, }; // 修改构造函数 Demo 的原型上的属性 constructor， // 使在这之后使用构造函数 Demo 构造出的对象的属性 constructor 的值变为函数 test。 function Demo(color, parameter) { \tthis.name = \u0026#39;yxz\u0026#39;; \tthis.color = color; \tthis.name = parameter; } var a = new Demo(\u0026#39;red\u0026#39;, \u0026#39;a的参数\u0026#39;); var b = new Demo(\u0026#39;orange\u0026#39;, \u0026#39;b的参数\u0026#39;); //通常情况，不能间接通过一个对象操作该对象原型中的属性，只能直接对该函数的原型进行操作。 console.log(a.constructor); //返回函数 test，它是对象 a 原型的属性 constructor 的指向。 Demo.prototype.size = \u0026#39;50\u0026#39;; // 给构造函数 Demo 的原型增加属性 size。 console.log(Demo.prototype.size); // 返回 50。 Demo.prototype.width = \u0026#39;1000\u0026#39;; // 修改构造函数 Demo 原型的属性 width。 console.log(Demo.prototype.width); // 返回 1000。 delete Demo.prototype.width; // 删除构造函数 Demo 原型的属性 width。 console.log(Demo.prototype.width); //因为构造函数 Demo 原型的属性 with 已经被删除了， //因此这个时候相当于调用了一个对象所没有的属性，则返回 undefined。  // __proto__-------------------------------------------------- Demo.prototype.name = \u0026#39;orange\u0026#39;; // 给构造函数 Demo 的原型添加属性 name。 function Demo() { \t// 声明一个函数时，系统会隐式 \t// var this = { \t// __proto__: Demo.prototype; \t// 函数 Demo 的 __proto__ 指向的是函数 Demo 的原型对象，这个指向可以更改 \t// } } var obj = { \tname: \u0026#39;blue\u0026#39;, }; var a = new Demo();  console.log(a.name); // 返回 orange，虽然对象 a 自身没有属性 name，但它继承了自身原型上的属性 name。 a.__proto__ = obj; // 修改对象 a 属性的 __proto__ 指向，使对象 a 继承对象 obj 的属性 name。 console.log(a.name); // 返回 blue。 ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B/","summary":"原型 原型对象，它是只有函数才拥有的隐式属性（使用 null 作为构造函数的原型的情况下，原型不能通过自定义进行添加）\n通过原型对象这种机制，可以使一个对象从其他的对象那里继承一属性或方法。\nprototype 显式原型属性，每一个对象都有一个 prototype，这个属性指向该对象的原型对象。\n它和proto指向的都是同一个原型对象。\n我们一般通过prototype去操作一个对象的原型对象。而系统调用的时候，会通过proto去调用。\n__proto__  隐式原型属性，每一个对象都有一个proto，这个属性指向该对象的原型对象。 proto 的指向（值）可以修改，即一个用构造函数创建出的对象实例的原型是可以通过该属性修改的。 当调用一个对象的属性时，如果这个对象没有这个属性，那么就会到构造该对象的构造函数的原型所指向的对象（可以称之为父对象）中去寻找这个属性，如果父对象也没有这个属性，则到该父对象的构造函数的原型所指向的对象（可以称之为为爷爷对象）里去寻找这个属性，如果还没找到，则继续往上找…，直到原型链终端为 Object.prototype；Object.prototype 中有一个 null，相当于到 null 中去取值，即调用一个对象所没有的值，会返回 undefined；这种通过属性 proto 连接原型对象直到 Object.prototype（null）的一条链为原型链。 通常情况，大部分对象最终都会继承自 Object.prototype，因为 Object.create() 方法中可以将 null 放进去当做原型。 在 JavaScript 中，null 与 undefined 没有原型且不是对象。  作用 可以让一个构造函数所创建的多个对象都可以使用公用的属性和方法。\n声明一个构造函数之后，该构造函数中会有一个属性 prototype，这个属性指向的就是该构造函数对应的原型对象。\n原型对象中有一个属性 constructor，该属性用于指向这个对象的构造函数。\n// Demo.prototype = {} 是构造函数 Demo 的原型，它默认是一个空对象（原型对象） // 当构造函数 Demo 被定义完成时，同时该函的原型对象 Demo.prototype = {} 也被定义完成； // Demo.prototype.name = \u0026#34;原型的名字\u0026#34;; // Demo.prototype.size = \u0026#34;500\u0026#34;; // Demo.prototype.height = \u0026#34;1400\u0026#34;; // Demo.","title":"JavaScript 原型"},{"content":"原型链 每个实例对象（ object ）都有一个私有属性（ proto ），用于指向它的构造函数的原型对象（prototype）；该原型对象也有一个自己的私有属性（proto ），层层向上直到原型对象 Object.prototype 为 null；而 null 没有原型，它作为这个原型链的终端，它的值为 undefined。\n几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。\n可以使用对象的属性 proto 实现继承。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE/","summary":"原型链 每个实例对象（ object ）都有一个私有属性（ proto ），用于指向它的构造函数的原型对象（prototype）；该原型对象也有一个自己的私有属性（proto ），层层向上直到原型对象 Object.prototype 为 null；而 null 没有原型，它作为这个原型链的终端，它的值为 undefined。\n几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。\n可以使用对象的属性 proto 实现继承。","title":"JavaScript 原型链"},{"content":"命名空间 命名空间（package），它可以帮助我们更好地整理代码，并可避免变量命名冲突。\n简单地说，我们可以创建一个简单对象字面量来打包所有的相关函数和变量。这个简单对象字面量模拟了命名空间的作用。\n作用 私有化变量 function Demo() { \tvar healthy = 0; \t// 该变量为私有化变量，这个变量只能通过构造函数的指定方法进行调用， \t// 不能直接作为对象的属性或变量进行调用。 \tthis.cure = function () { \thealthy++; \t};  \tthis.injured = function () { \thealthy--; \t};  \tthis.view = function () { \tconsole.log(healthy); \t}; }  var demo = new Demo();  demo.view(); // 返回 0，调用构造函数的属性 view。 demo.cure(); // 调用构造函数的属性 cure。，使变量 healthy 自增 1。 demo.view(); //返回 1，调用构造函数的属性 view。 demo.injured(); // 调用构造函数的属性 injured，使变量 healthy 自减 1。 demo.view(); // 返回 0，调用构造函数的属性 view。 模块化开发 var a = \u0026#39;cold\u0026#39;; // 全局中的变量 a 并不会影响函数 init 中的变量 a。 var init = (function () { \tvar a = \u0026#39;weather\u0026#39;; \t// 私有化变量 a。 \tthis.fun = function () { \tconsole.log(a); \t// 返回 weather，尽管这里的变量 a 与全局中的变量 a 重复， \t// 但这里依旧返回函数 init 的私有化变量 a。 \t}; \treturn function () { \t// 将函数返回，即将该方法赋给变量 init。 \tthis.fun(); \t// 调用函数表达式的属性 fun。 \t}; })();  init(); // 执行函数表达式 init，即执行该函数表达式的属性 fun。  var inits = (function () { \tvar a = \u0026#39;summerly\u0026#39;; \t// 私有化变量 a \tthis.fun = function () { \tconsole.log(a); \t// 返回 summerly，尽管这里的变量 a 与全局中的变量 a 重复， \t// 但这里依旧返回函数 inits 的私有化变量 a。 \t}; \treturn function () { \t// 将函数返回，即将该函数赋给变量 inits。 \tthis.fun(); \t// 调用函数表达式的属性 fun。 \t}; })(); inits(); // 执行函数表达式 inits，即执行该函数表达式的属性 fun。 ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","summary":"命名空间 命名空间（package），它可以帮助我们更好地整理代码，并可避免变量命名冲突。\n简单地说，我们可以创建一个简单对象字面量来打包所有的相关函数和变量。这个简单对象字面量模拟了命名空间的作用。\n作用 私有化变量 function Demo() { \tvar healthy = 0; \t// 该变量为私有化变量，这个变量只能通过构造函数的指定方法进行调用， \t// 不能直接作为对象的属性或变量进行调用。 \tthis.cure = function () { \thealthy++; \t};  \tthis.injured = function () { \thealthy--; \t};  \tthis.view = function () { \tconsole.log(healthy); \t}; }  var demo = new Demo();  demo.view(); // 返回 0，调用构造函数的属性 view。 demo.cure(); // 调用构造函数的属性 cure。，使变量 healthy 自增 1。 demo.","title":"JavaScript 命名空间"},{"content":"属性调用 通常调用属性的格式一般为 fun.arr，实际上系统会隐式将 fun.arr 变为 fun[\u0026ldquo;arr\u0026rdquo;]，因为前者调用更加灵活且简洁。\nvar demo = { \twife1: { name: \u0026#39;lei\u0026#39; }, \twife2: { name: \u0026#39;zheng\u0026#39; }, \twife3: { name: \u0026#39;xing\u0026#39; }, \twife4: { name: \u0026#39;zhu\u0026#39; }, \tfun: function (num) { \tvar a = [\u0026#39;wife\u0026#39; + num]; \tconsole.log(a); \treturn this[\u0026#39;wife\u0026#39; + num]; \t// 看不太懂 \t}, };  demo.fun(1); demo.fun(2); demo.fun(3); demo.fun(4); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%B1%9E%E6%80%A7%E8%B0%83%E7%94%A8/","summary":"属性调用 通常调用属性的格式一般为 fun.arr，实际上系统会隐式将 fun.arr 变为 fun[\u0026ldquo;arr\u0026rdquo;]，因为前者调用更加灵活且简洁。\nvar demo = { \twife1: { name: \u0026#39;lei\u0026#39; }, \twife2: { name: \u0026#39;zheng\u0026#39; }, \twife3: { name: \u0026#39;xing\u0026#39; }, \twife4: { name: \u0026#39;zhu\u0026#39; }, \tfun: function (num) { \tvar a = [\u0026#39;wife\u0026#39; + num]; \tconsole.log(a); \treturn this[\u0026#39;wife\u0026#39; + num]; \t// 看不太懂 \t}, };  demo.fun(1); demo.fun(2); demo.fun(3); demo.fun(4); ","title":"JavaScript 属性调用"},{"content":"开发原则 渐进增强 不要使用 JavaScript 代码添加网页的核心内容，应该先保证核心内容脱离与 CSS 与 JavaScript 代码之外。\n平稳退化 确保网页在没有 JavaScript 与 CSS 的情况下也能使用核心功能，而且渐进增强的实现必然支持平稳退化。\n向后兼容 使用对象检测的方式来检测浏览器对 JavaScript 的支持程度，确保老版本的浏览器不会因为不支持某些 JavaScript 代码而报错。\n性能考虑 减少访问 DOM 的和文档中标记的元素；过多的页面元素只会增大 DOM 树的规模。\n将多个 JavaScript 文件合并为一个；减少加载页面时发送的请求数量。\n压缩已完成的 JavaScript 脚本；将文件中的不必要的字节（空格、注释、回车符）统统删除，从而减少整体文件大小。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/","summary":"开发原则 渐进增强 不要使用 JavaScript 代码添加网页的核心内容，应该先保证核心内容脱离与 CSS 与 JavaScript 代码之外。\n平稳退化 确保网页在没有 JavaScript 与 CSS 的情况下也能使用核心功能，而且渐进增强的实现必然支持平稳退化。\n向后兼容 使用对象检测的方式来检测浏览器对 JavaScript 的支持程度，确保老版本的浏览器不会因为不支持某些 JavaScript 代码而报错。\n性能考虑 减少访问 DOM 的和文档中标记的元素；过多的页面元素只会增大 DOM 树的规模。\n将多个 JavaScript 文件合并为一个；减少加载页面时发送的请求数量。\n压缩已完成的 JavaScript 脚本；将文件中的不必要的字节（空格、注释、回车符）统统删除，从而减少整体文件大小。","title":"JavaScript 开发原则"},{"content":"原始值和引用值 在 ECMAScript 中，数据类型有两种，即原始类型和引用类型。\n原始类型 一种非对象也没有方法和属性的数据类型，也叫基本类型（基本数值或基本数据类型）。所有的原始值都是不可改变的。\nNumber 数值，用整数或浮点数表示，它允许任意位的小数。\nString 字符串，由零个或多个字符构成，它必须被包含在双引号或双引号内。\n与数组一样的是，字符串中的每个字符都有一个下标，这些下标从 0 开始。因此，它有属性 length。\nBoolean 布尔，表示一个逻辑值，只有 true 或 false 两个值。\nBigInt 任何精度格式的整数，是一种比 Number 数据类型支持的范围更大的整数值。用于安全地存储和操作大整数。\nSymbol 符号，它是唯一的并且是不可修改的。\nundefined 未定义，它只有一个值 undefined，指一个声明未描述的变量的初始值或一个变量直接赋值为 undefined，或没有实际参数的形式参数\nNull 空指针，它也只有一个值 null，表示一个不存在的或无效 object 和地址引用。因为历史遗留性问题，它是的数据类型为 Object。\n原始值的储存原理 a = 10; // 在栈内存第一层创建一个变量 a ，然后将数值 10 放进变量 a 中。 // 栈内存： // a ： 10 var b = a; // 在栈内存第二层创建一个变量 b，然后将变量 a 中的数值 10 拷贝到变量 b 中。 // 栈内存： // a ：10 // 拷贝变量 10 // b ：10 a = 20; // 在栈内存第三层重新创建一个变量 a，然后将数值 10 放入这个第三层的变量 a 中，之后关闭在第一层的变量 a。 // 栈内存： // a ：10（已关闭） // b ：10 // a ：20 （新的变量 a） 引用类型 引用类型都是对象，每个对象都有属性和方法。它指的是存储在堆内存中的实际对象。每一个引用变量中都存放着指针，这个指针指向其堆内存中的实际对象。\nArray 数组，用于构造数组的全局对象，它是类似于列表的高阶对象。\nFunction 函数，所有的函数都是一个 Function 对象。Function 构造函数创建一个新的 Function 对象。\nObject 对象，Object 构造函数用于创建一个对象包装器。\nRegExp 正则表达式，用于将文本与一个模式匹配。\nData 日期，用于呈现时间中的某一时刻。\n原始值的储存原理 // 储存模式-------------------------------------------------- arr = [1, 2]; // 在栈内存的第一层中创建一个 变量 arr，然后在变量 arr 中放一个指向堆内存第一层的链接地址， // 再将数组 [1 , 2] 放到堆内存的第一层中。 // 栈内存 堆内存 // arr：指向 [1, 2] 的地址 [ 1 , 2 ] var brr = arr; // 在栈内存第二层中创建一个变量 brr，然后将栈内存第一层中变量 arr 中的链接地址拷贝到变量 brr 中， // 则变量 brr 与 变量 arr 中的链接地址都指向堆内存第一层中的数组[ 1 , 2 ]。 // 栈内存 堆内存 // arr：指向 [ 1 , 2 ] 的地址 [ 1 , 2 ] // ? 拷贝 // brr：指向 [ 1 , 2 ] 的地址 arr.push(3); // 通过栈内存第一层的变量 arr 中的链接地址找到堆内存的第一层中的数组 [1 , 2]， // 然后向这个数组中添加一个数值 3，则堆内存第一层中的的数组变为了 [ 1 , 2 , 3 ]。 // 因此栈内存第一层的 变量 arr 与第二层的变量 brr 中的链接地址都指向堆内存第一层中的数组 [1,2,3]。 // 栈内存 堆内存 // arr：指向[1 , 2 ,3]的地址 [1 , 2 ,3] // brr：指向[1 , 2 ,3]的地址 arr = [4, 5]; // 找到栈内存第一层中的 变量 arr，将该变量中的链接地址改为指向堆内存第二层中的数组 [4 , 5] 的地址， // 再将数组 [ 4 , 5 ] 放到堆内存第二层中。 // 此时变量 arr 中链接地址指向的是堆内存第二层中的数组[ 4 , 5 ]， // 但变量 brr 中的链接地址依旧指向堆内存第一层中的数组 [ 1 , 2 , 3 ]。 // 栈内存 堆内存 // arr：指向[ 4, 5 ]的地址 [ 1 , 2 , 3 ] // brr：指向[ 1 , 2 ,3 ]的地址 [4 , 5] ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","summary":"原始值和引用值 在 ECMAScript 中，数据类型有两种，即原始类型和引用类型。\n原始类型 一种非对象也没有方法和属性的数据类型，也叫基本类型（基本数值或基本数据类型）。所有的原始值都是不可改变的。\nNumber 数值，用整数或浮点数表示，它允许任意位的小数。\nString 字符串，由零个或多个字符构成，它必须被包含在双引号或双引号内。\n与数组一样的是，字符串中的每个字符都有一个下标，这些下标从 0 开始。因此，它有属性 length。\nBoolean 布尔，表示一个逻辑值，只有 true 或 false 两个值。\nBigInt 任何精度格式的整数，是一种比 Number 数据类型支持的范围更大的整数值。用于安全地存储和操作大整数。\nSymbol 符号，它是唯一的并且是不可修改的。\nundefined 未定义，它只有一个值 undefined，指一个声明未描述的变量的初始值或一个变量直接赋值为 undefined，或没有实际参数的形式参数\nNull 空指针，它也只有一个值 null，表示一个不存在的或无效 object 和地址引用。因为历史遗留性问题，它是的数据类型为 Object。\n原始值的储存原理 a = 10; // 在栈内存第一层创建一个变量 a ，然后将数值 10 放进变量 a 中。 // 栈内存： // a ： 10 var b = a; // 在栈内存第二层创建一个变量 b，然后将变量 a 中的数值 10 拷贝到变量 b 中。 // 栈内存： // a ：10 // 拷贝变量 10 // b ：10 a = 20; // 在栈内存第三层重新创建一个变量 a，然后将数值 10 放入这个第三层的变量 a 中，之后关闭在第一层的变量 a。 // 栈内存： // a ：10（已关闭） // b ：10 // a ：20 （新的变量 a） 引用类型 引用类型都是对象，每个对象都有属性和方法。它指的是存储在堆内存中的实际对象。每一个引用变量中都存放着指针，这个指针指向其堆内存中的实际对象。","title":"JavaScript 数据类型"},{"content":"继承方式 原型链继承 缺点\n会使一个对象过多继承一些没用或不需要的属性，则会导致代码的执行效率大大降低。反对反对反对法大幅度发反对发的\nGrand.prototype.blue = \u0026#39;blue\u0026#39;;  function Grand() {}  var grandfather = new Grand();  Father.prototype = grandfather;  function Father() { \tthis.red = \u0026#39;red\u0026#39;; \tthis.money = { \tcard: \u0026#39;pencil\u0026#39;, \t}; \tthis.value = \u0026#39;100\u0026#39;; }  var father = new Father();  Son.prototype = father;  function Son() { \tthis.orange = \u0026#39;orange\u0026#39;; } var son = new Son();  console.log(son.orange);  // 返回 son 的原型 father 上的 red。 console.log(son.red);  // 返回 son 的原型 father 的原型 grand 上的 blue。 console.log(son.blue);  // 调用 son 给原型对象 father 的属性 money（money 的值必须是引用值）增加一个 box。 son.money.box = \u0026#39;bear\u0026#39;;  console.log(son.money.box);  // 先将原型 father 的 value 拷贝给自身，然后拿着拷贝过来的 value 进行自增。 // 因此自增结果并不会影响原型 father 上的 value。 son.value++; son.value++;  console.log(son.value); // return 102 console.log(father.value); // return 100 未改变 构造函数继承 使用 call() 与 apply() 实现继承（伪造对象）。\n有需求时可以使用该方法实现继承。\n缺点\n不能借用其构造函数的原型（不算继承，只是借用）。\n视觉上省去了部分代码，但调用对象时，该对象的构造函数则会多调用一个或多个构造函数，因此也会使代码的执行效率大大降低。\n共享原型继承 将一个函数的原型指向共享给另一个函数的原型，使这个两个原型都指向同一个原型（即它们都继承自同一个原型），即这两个函数的原型共用一个原型。\n缺点\n不能单独给其中一个函数的原型添加私有属性，即添加一个函数的原型的属性时，另一个函数的原型也可以调用这个属性。\n// Demo() 和 Test() 的共有原型对象 Demo.prototype.name = \u0026#39;windy\u0026#39;; Demo.prototype.age = 18; function Demo() { \tthis.name = \u0026#39;tiger\u0026#39;; }  function Test() {}  // 用函数 inherit 封装一个有继承功能的函数。 function inherit(a, b) { \ta.prototype = b.prototype; }  // 将 Demo() 的原型共享给 Test() , 使这两个函数共用一个原型。 inherit(Test, Demo);  // 公共属性 male Test.prototype.male = \u0026#39;boy\u0026#39;;  // 构造实例 let demo = new Demo(); let test = new Test();  // return 18 console.log(demo.age);  // return 18 console.log(test.age);  // return windy console.log(test.name);  // return boy ，公共属性 console.log(demo.male); console.log(test.male); 圣杯模式继承 用来继承已有原型对象（A.prototype）中的成员（主要是公用方法），同时根据自己的需求修改原型对象（A.prototype），以定制符合我们要求的构造函数 B，这个修改对已有的实例（a1，a2，…）不会产生影响。\n基本没有缺点\n// 但建议使用这种写法： var inherit = (function () { \t// 私有化 Rain，用作于中间层 \tfunction Rain() {}  \treturn function (a, b) { \tRain.prototype = b.prototype; \ta.prototype = new Rain(); \ta.prototype.constructor = a; \ta.prototype.uber = b.prototype; \t}; })();  Demo.prototype.name = \u0026#39;windy\u0026#39;; Demo.prototype.age = 18;  function Demo() { \tthis.name = \u0026#39;tiger\u0026#39;; }  function Test() {}  inherit(Test, Demo);  // 给 TestI() 添加私有属性 male Test.prototype.male = \u0026#39;boy\u0026#39;;  var test = new Test(); var demo = new Demo();  // return boy console.log(test.male);  // return undefined，该属性没有被对象 test 共享给对象 demo console.log(demo.male); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/","summary":"继承方式 原型链继承 缺点\n会使一个对象过多继承一些没用或不需要的属性，则会导致代码的执行效率大大降低。反对反对反对法大幅度发反对发的\nGrand.prototype.blue = \u0026#39;blue\u0026#39;;  function Grand() {}  var grandfather = new Grand();  Father.prototype = grandfather;  function Father() { \tthis.red = \u0026#39;red\u0026#39;; \tthis.money = { \tcard: \u0026#39;pencil\u0026#39;, \t}; \tthis.value = \u0026#39;100\u0026#39;; }  var father = new Father();  Son.prototype = father;  function Son() { \tthis.orange = \u0026#39;orange\u0026#39;; } var son = new Son();  console.log(son.orange);  // 返回 son 的原型 father 上的 red。 console.","title":"JavaScript 继承方式"},{"content":"节点 在文档中，几乎每一样东西都是一个节点（Node），包括空格和换行符都会被解释为节点。\n文档的根节点不是 html，而是 document。\n分类 元素节点 文档中的元素，nodeType 的值为 1。\n属性节点 文档中元素节点的属性，属性节点都被包含在元素节点中。\nnodeType 的值为 2。\n文本节点 文档中元素所包含的文本。 nodeType 的值为 3。\n注释节点 文档中的注释。\nnodeType 的值为 8.\ndocument 节点 nodeType 的值为 9。\n属性 每一个节点都有四个基本属性。\nnodeValue 返回或设置指定点的值。\n只用文本节点或注释节点才有 nodeValue。\n而其他节点的 nodeValue 是 null 。\nnodeName 返回指定节点的大写字母形式的节点名，它是一个只读属性。\nnodeType 返回指定节点的类型，只读属性。\n元素节点返回 1。\n属性节点返回 2。\n文本节点返回 3。\n注释节点返回 8。\ndocument 节点返回 9。\nattributes 返回指定节点的所有属性节点。\n方法 hasChildNodes() 判断一个元素是否包含子节点，返回一个布尔值。\n","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E8%8A%82%E7%82%B9/","summary":"节点 在文档中，几乎每一样东西都是一个节点（Node），包括空格和换行符都会被解释为节点。\n文档的根节点不是 html，而是 document。\n分类 元素节点 文档中的元素，nodeType 的值为 1。\n属性节点 文档中元素节点的属性，属性节点都被包含在元素节点中。\nnodeType 的值为 2。\n文本节点 文档中元素所包含的文本。 nodeType 的值为 3。\n注释节点 文档中的注释。\nnodeType 的值为 8.\ndocument 节点 nodeType 的值为 9。\n属性 每一个节点都有四个基本属性。\nnodeValue 返回或设置指定点的值。\n只用文本节点或注释节点才有 nodeValue。\n而其他节点的 nodeValue 是 null 。\nnodeName 返回指定节点的大写字母形式的节点名，它是一个只读属性。\nnodeType 返回指定节点的类型，只读属性。\n元素节点返回 1。\n属性节点返回 2。\n文本节点返回 3。\n注释节点返回 8。\ndocument 节点返回 9。\nattributes 返回指定节点的所有属性节点。\n方法 hasChildNodes() 判断一个元素是否包含子节点，返回一个布尔值。","title":"JavaScript 节点"},{"content":"运算符 算数运算符 算术运算符都会将操作数用 Number() 隐式转换，然后再进行运算；若遇到无法转换的值，则会返回 number 类型的 NaN。\n++ a++ 或 ++a，自增（递增）。使操作数加 1，并返回自增后的值。\n操作数前置或后置\n若位于数值的之后（a++），则会自增之前返回数值。\n若位于数值的之前（++a），则会自增之后返回数值。\n\u0026ndash; a\u0026ndash; 或 \u0026ndash;a， 递减（自减）。使操作数减 1，并返回自减后的值。\n操作数前置或后置\n若位于数值的之后（a\u0026ndash;），则会递减之前返回数值。\n若位于数值的之前（\u0026ndash;a），则会递减之后返回数值。\n比较运算符 JavaScript 有两种比较方式：严格比较和转换类型比较。\n对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为 true。\n对于比较运算符（==）来说，会先将将两个操作数转换成相同的类型，再进行值的比较运算。\n对于关系运算符（ \u0026lt;=）来说，会先将操作数转为原始值，使它们类型相同，再进行值的比较运算。\n字符串比较则是使用基于标准字典的 Unicode 值来进行比较的。\n原始值比较的是值，引用值比较的是引用地址。\nIn 用于判断一个对象的指定的属性是否在该对象或其原型链中，在则 in 运算符返回 true，不在则返回 false。\nInstanceof 用于判断一个对象是否是由指定构造函数构造出来的。\n// 如果 mycar 不是 vue 的实例对象 if (!(mycar instanceof Car)) { \tconsole.log(\u0026#39;No\u0026#39;); } 也可以用于判断一个实例对象的原型链中有没有另一个变量的原型。\nfunction Car(make, model, year) { \tthis.make = make; \tthis.model = model; \tthis.year = year; } const auto = new Car(\u0026#39;Honda\u0026#39;, \u0026#39;Accord\u0026#39;, 1998);  console.log(auto instanceof Car); // expected output: true  console.log(auto instanceof Object); // expected output: true 2 \u0026gt; 3 \u0026lt; 1\n先对 2 \u0026gt; 3 进行比较，比较完成之后返回 false，又因为 false = 0，在用 0 与 1 比较，因 0 \u0026lt; 1 ，会返回 true，所以最终返回 true。\nNaN == NaN\n当 NaN == NaN 进行比较时，会返回 false，因为 NaN 是非数，它不等于任何值（包括它本身）。\nundefined == null，返回 true。\nundefined === null，返回 false。\n逻辑运算符 通常情况，该运算符会将表达式转换为一个布尔值，然后返回这个布尔值；特殊情况，会返回一个指定操作数的值。\n逻辑运算符的特殊情况\n 若匹配到不能转换的值，则返回 number 类型的 NaN。 若匹配到 null，则会返回 object 类型的 null。 若匹配到 undefined，则会返回 undefined 类型的 undefined。  转换后逻辑值为 false 的值有：  null NaN 0 空字符串（\u0026quot;\u0026quot;、\u0026rsquo;\u0026rsquo;） undefined  || a || b || c，逻辑或；若匹配到隐式转换后为 true 的表达式，则返回该表达式的值；若表达式都为 false，则返回最后一个 false 表达式的值。\n\u0026amp;\u0026amp; a \u0026amp;\u0026amp; b \u0026amp;\u0026amp; c，逻辑与；若匹配到隐式转换后为 false 的表达式，则返回该表达式的值；若表达式隐式转换后都为 true，则返回最后一个 true 表达式的值\n短路语句 var a = 0; var b = -1; a \u0026gt; b \u0026amp;\u0026amp; console.log(\u0026#39;前面的表达式为 true，你才能看到我\u0026#39;); // 如果表达式 a \u0026gt; b 隐式转换后为 true，那么会执行该表达式之后的语句，否则不执行之后的语句。 ！ ! a， 逻辑非；将操作数转换为布尔值，然后返回这个布尔值的反。\n按位运算符 \u0026amp; 按位与\n如何运算\n规则：上下一与，相同为 1，不同为 0。\nvar a = 1 \u0026amp; 3; // 1 // 1 在二进制里表示为 1 // 3 在二进制里表示为 11 // 对 1 进行补位：00000001 // 对 11 进行补位：00000011 // 根据与运算的规则：上下一与，相同为 1，不同为 0 // 1： 00000001 // 3： 00000011 // 结果：00000001 //因 00000001 转为十进制等于 1，因此最终结果为 1 三目运算符 a ? b : c 相当于 if 语句\nif (a) { \tb; } else { \tc; } 展开语法 展开语法...，也叫扩展运算符，用于取出对象的所有可遍历属性，拷贝到当前对象之中。\n常用于合并数组\n可以用于克隆数组，若数组中有引用类型的数据，则为浅拷贝。\n将类数组变为真数组。\nfunction fun(a, b) { \tconsole.log(arguments); \tlet arr = [...arguments]; \tconsole.log(arr); \tconsole.log(arr instanceof Array); } fun(1, 2, 3); ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E8%BF%90%E7%AE%97%E7%AC%A6/","summary":"运算符 算数运算符 算术运算符都会将操作数用 Number() 隐式转换，然后再进行运算；若遇到无法转换的值，则会返回 number 类型的 NaN。\n++ a++ 或 ++a，自增（递增）。使操作数加 1，并返回自增后的值。\n操作数前置或后置\n若位于数值的之后（a++），则会自增之前返回数值。\n若位于数值的之前（++a），则会自增之后返回数值。\n\u0026ndash; a\u0026ndash; 或 \u0026ndash;a， 递减（自减）。使操作数减 1，并返回自减后的值。\n操作数前置或后置\n若位于数值的之后（a\u0026ndash;），则会递减之前返回数值。\n若位于数值的之前（\u0026ndash;a），则会递减之后返回数值。\n比较运算符 JavaScript 有两种比较方式：严格比较和转换类型比较。\n对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为 true。\n对于比较运算符（==）来说，会先将将两个操作数转换成相同的类型，再进行值的比较运算。\n对于关系运算符（ \u0026lt;=）来说，会先将操作数转为原始值，使它们类型相同，再进行值的比较运算。\n字符串比较则是使用基于标准字典的 Unicode 值来进行比较的。\n原始值比较的是值，引用值比较的是引用地址。\nIn 用于判断一个对象的指定的属性是否在该对象或其原型链中，在则 in 运算符返回 true，不在则返回 false。\nInstanceof 用于判断一个对象是否是由指定构造函数构造出来的。\n// 如果 mycar 不是 vue 的实例对象 if (!(mycar instanceof Car)) { \tconsole.log(\u0026#39;No\u0026#39;); } 也可以用于判断一个实例对象的原型链中有没有另一个变量的原型。\nfunction Car(make, model, year) { \tthis.make = make; \tthis.","title":"JavaScript 运算符"},{"content":"链式调用 模仿一个 jQuery 链式调用的方式。\nvar demo = { \ta: function () { \tconsole.log(123); \treturn this; \t// 将函数自身返回。 \t},  \tb: function () { \tconsole.log(456); \treturn this; \t// 将函数自身返回。 \t},  \tc: function () { \tconsole.log(789); \treturn this; \t//将函数自身返回。 \t}, }; demo.a().b().c(); // 呈链式(连续)的调用对象 demo 的属性。 ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/","summary":"链式调用 模仿一个 jQuery 链式调用的方式。\nvar demo = { \ta: function () { \tconsole.log(123); \treturn this; \t// 将函数自身返回。 \t},  \tb: function () { \tconsole.log(456); \treturn this; \t// 将函数自身返回。 \t},  \tc: function () { \tconsole.log(789); \treturn this; \t//将函数自身返回。 \t}, }; demo.a().b().c(); // 呈链式(连续)的调用对象 demo 的属性。 ","title":"JavaScript 链式调用"},{"content":"闭包 在函数（父函数）中创建另一个函数（子函数）时；当子函数被父函数 return 到了外部时，会生成闭包。\n生成了闭包后，虽然父函数的 AO 已经被释放了，但子函数却保存了父函数的 AO，且这个 AO 不会因为父函数的执行完毕而被释放，因为父函数的 AO 已经被子函数给保存了起来，且可以随意调用。\n闭包的优缺点 优点 避免全局变量的污染。\n使变量长期储存在内存中。\n缺点 使用不当会导致原有的作用域链不释放，造成内存泄露（过多占用内存的剩余空间，导致可用空间越来越少）。\nfunction demo() { \tfunction test() { \tvar d = 345; \tconsole.log(c); \t// 虽然函数 test 中没有变量 c，但因为函数 test 可以使用函数 demo 的 AO， \t// 所以它会到函数 demo 的作用域中去寻找变量 c，然后返回 123 \t} \tvar c = 123; \treturn test; \t// 将函数 test 返回，即将函数 test 与它的作用域一起保存到了外部， \t// 使的函数 demo 可以使用函数 test 的 AO } var e = demo(); // 用变量 e 接收函数 demo 的返回值，也就是接收函数 test 以及它的 AO e(); // 调用变量 e，即相当于执行函数 demo 的返回值 // 父函数 demo 执行完毕后，释放了自己的 AO，但子函数 test 在这之前已经将父函数 demo 的 AO 保存了起来， // 所以它会到函数 demo 的作用域中去寻找变量 c，然后返回 123 function demo() { \tvar b = \u0026#39;apple\u0026#39;; \tvar obj = { \tc: function () { \t// 给对象 obj 添加一个属性 c ，属性值为一个函数 \tif (b != \u0026#39;\u0026#39;) { \tconsole.log(b); \tb = \u0026#39;\u0026#39;; \t} else { \tconsole.log(\u0026#39;b 为空字符串\u0026#39;); \t} \t}, \td: function (e) { \t// 给对象 obj 添加一个属性 d ，属性值为一个函数 \t// 给属性 d 一个形参 e \tb = e; \t// 将 变量 b变为函数的参数 e \t}, \t}; \treturn obj; \t// 将对象 obj 保存到外部，使对象 obj 可以使用函数 demo 的 AO。 } var f = demo(); // 用变量 f 接收函数 demo 的返回值，也就是接收对象 obj，使变量 f 变为对象 f。 f.c(); // 返回 apple 后，将变量 b 变为空字符串。 f.c(); // 返回空字符串。 f.d(\u0026#39;banana\u0026#39;); // 调用对象 f 的属性 d，并传入实参 banana，将变量 b 从空字符串变为 banana。 f.c(); // 返回 banana。 f.c(); // 返回空字符串。 闭包实现累加器 function demo() { \tvar a = 0; \tfunction test() { \ta++; \tconsole.log(a); \t} \treturn test; \t// 将函数 test 保存到外部，使函数 test 也可以使用函数 demo 的 AO。 } var b = demo(); // 用变量 b 接收函数 demo 的返回值。 b(); // 返回 1，每次调用变量 b 时，都会使变量 a 在上一次的值的大小上再次自增 1。 b(); // 返回 2。 b(); // 返回 3。 共同作用域 function demo() { \tvar b = 100; \tfunction c() { \tb++; \tconsole.log(b); \t} \tfunction d() { \tb--; \tconsole.log(b); \t} \treturn [c, d]; \t// 将函数 c 与 d 以数组的形式保存到外部，使这函数 c 与 d 都可以使用函数 demo 的 AO。 } var arr = demo(); // 用变量 arr 接收函数 demo 的返回值，即接收了一个含有函数 c 与 d 的数组。 arr[0](); // 使变量 b 自增之后变为 101，因为调用数组 arr 中下标为 0 的值，相当于执行一次函数 c。 arr[1](); // 使变量 b 自减之后变为 100，调用数组 arr 中下标为 1 的值，相当于执行一次函数 d。 // 因为函数 c 与 d 都可以使用函数 demo 的 AO，所以函数 d 的自减会在函数 c 自增后的结果上进行运算。 闭包的内存泄露问题 function demo() { \tvar arr = [];  // 用 for 往 arr 中添加 10 个函数，该循环结束后变量 i 为 10。 \tfor (var i = 0; i \u0026lt; 10; i++)  // 虽然外部 for 中的 i 会自增到 10 才结束循环，但其内部的 10 个函数并没有执行， \t// 因此这个函数中的 i 虽然随着外部的 i 而变化， \t// console.log(i) 并没有 i 变化一次 console.log(i) 就执行一次 \tarr[i] = function () { \tconsole.log(i); \t}; \treturn arr; } var b = demo(); // 用变量 b 接收函数 demo 的返回值，即接收数组 arr，使变量 b 变为数组 b。 for (var c = 0; c \u0026lt; 10; c++) { \t// 用 for 语句执行 10 次 在这之后的代码块。 \tb[c](); \t// 返回 10 个 10，因为变量 i 已经被函数 demo 中的 for 语句变为了 10， \t// 因此这里的循环会返回 10 个 10，造成这样的结果就叫做内存泄露。 } 使用立即执行函数解决闭包内存泄露的问题 function demo() { \tvar arr = []; \tfor (var i = 0; i \u0026lt; 10; i++) { \t(function (j) { \t// 定义一个立即执行函数（IIFE），函数的形参 j 与实参 i 相对应； \t// 这里的形参 j 会对应实参 i ，而实参 i 则对应 for 语句中的变量 i； \t// 每执行一次 for 循环，其变量 i 也会自增一次，且在这其中的立即执行函数也会执行一次； \t// 则变量 i 进行 i++ 后从 0 变为了 1，其内部的语句 console.log 就会返回 1； \t// 该立即执行函数执行结束后会自动释放，之后开始 第二次 for 循环； \t// 重新创建一个立即执行函数，再次执行，则变量 i 进行 i++ 之后从 1 变为 2， \t// 其内部的语句 console.log 就会返回 2； \t// 该立即执行函数执行完毕后自动释放。之后开始第三次 for 语句的循环，以此类推； \t// 即 for 循环多少次，立即执行函数就会执行多少次，且会在自身执行结束后自动释放； \t// 待下次 for 循环时被重新创建。 \t// 直到 for 循环在不满足其循环条件时结束执行。  \tarr[j] = function () { \t// 这里的变量 j 对应立即执行函数的形参 j。 \tconsole.log(j); \t// 因为该语句被包含在立即执行函数中； \t// 所以这里的变量 j 会随着 for 循环中的变量 i 自增而自增； \t// 并且该变量每次自增后都会被 console.log 返回。 \t}; \t})(i); \t// 实参 i，对应 for 循环中里的变量 i。 \t} \treturn arr; \t// for 语句执行完毕，将数组 arr 返回。 } var b = demo(); // 用变量 b 接受函数 demo 的返回值，使变量 b 变为数组 b。 for (var c = 0; c \u0026lt; 10; c++) { \t// 用 for 循环执行在此之后的代码块 \tb[c](); \t// 返回 0 到 9，因为这个数组被包含在立即执行函数之中，所以 for 循环每执行一次， \t// 其中的立即执行函数也会执行一次，在这之中的语句 console.log 也会返回一次结果， } ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E9%97%AD%E5%8C%85/","summary":"闭包 在函数（父函数）中创建另一个函数（子函数）时；当子函数被父函数 return 到了外部时，会生成闭包。\n生成了闭包后，虽然父函数的 AO 已经被释放了，但子函数却保存了父函数的 AO，且这个 AO 不会因为父函数的执行完毕而被释放，因为父函数的 AO 已经被子函数给保存了起来，且可以随意调用。\n闭包的优缺点 优点 避免全局变量的污染。\n使变量长期储存在内存中。\n缺点 使用不当会导致原有的作用域链不释放，造成内存泄露（过多占用内存的剩余空间，导致可用空间越来越少）。\nfunction demo() { \tfunction test() { \tvar d = 345; \tconsole.log(c); \t// 虽然函数 test 中没有变量 c，但因为函数 test 可以使用函数 demo 的 AO， \t// 所以它会到函数 demo 的作用域中去寻找变量 c，然后返回 123 \t} \tvar c = 123; \treturn test; \t// 将函数 test 返回，即将函数 test 与它的作用域一起保存到了外部， \t// 使的函数 demo 可以使用函数 test 的 AO } var e = demo(); // 用变量 e 接收函数 demo 的返回值，也就是接收函数 test 以及它的 AO e(); // 调用变量 e，即相当于执行函数 demo 的返回值 // 父函数 demo 执行完毕后，释放了自己的 AO，但子函数 test 在这之前已经将父函数 demo 的 AO 保存了起来， // 所以它会到函数 demo 的作用域中去寻找变量 c，然后返回 123 function demo() { \tvar b = \u0026#39;apple\u0026#39;; \tvar obj = { \tc: function () { \t// 给对象 obj 添加一个属性 c ，属性值为一个函数 \tif (b !","title":"JavaScript 闭包"},{"content":"预编译 JavaScript 是脚本语言，因此不会进行传统的预编译，但它会经过一个特殊的预编译过程，这个预编译过程发生在代码执行前的极短时间内。\n预编译发生在代码执行之前的一瞬间，用于在内存中创建一些空间来存储一些变量与函数；预编译时，会无视 if 语句中的条件，会直接将 if 语句中的代码块内的变量的声明与函数声明进行提升。\n函数声明提升 定义一个函数时，该函数会被提升到当前作用域链的顶端，即调用该函数时，不管在哪调用该函数，都可以调用成功；但函数表达式并不会。\n变量声明提升 使用 var 声明的变量，不管在这之前还是之后调用该变量，并不会报错，会返回 undefined。\n暗示全局变量 暗示全局变量（imply global），一个变量未声明就赋值，那么此变量就是 window（全局对象）的属性； 任何全局变量，都是 window 的属性，即可以通过 window 对象调用全局变量。window 就是全局的域，它包括了全局变量和全局函数。\n暗示全局变量不会进行变量声明提升。\na = 10; // 一个变量未声明就赋值，那么此变量就是 window（全局对象）的属性，也叫暗示全局变量 // 相当于 window.a = 10; // 相当于 window = { \ta: 10, };  //一切声明了的全局变量，都是 window 的属性 var b = 20; // 相当于 window.b = 20; // 相当于 window = { \tb: 20, }; // 调用变量 b，相当于调用全局对象 window 的属性 b，即 console.log(b) 相当于 console.log(window.b) 函数预编译 函数预编译发生在函数执行的前一刻，即预编译结束后函数开始执行，也叫局部预编译。\n函数的执行期上下文 指 AO 对象（Active Object），也叫执行期上下文；GO 先创建，AO 后创建。\n函数调用的最终值都将储存在 AO 中（AO 定义了函数执行时的环境），即当函数调用一个变量，该函数会去 AO 中寻找这个变量；准确点说就是去该函数的作用域链顶端依次向下寻找这个变量。\n若多次调用同一个函数，则会创建多个相同的 AO，但每一个 AO 都是独一无二的，AO 将在创建它的函数执行完后被释放。\n函数预编译的过程 创建 AO 对象，将函数的形参与函数中的变量声明作为 AO 的属性名，属性值为 undefined，并将其书写到 AO 中（该过程就是变量的声明提升）。\n将形参与实参统一，即将实参的值赋给对应的形参。\n寻找函数中的函数声明，将其函数名作为 AO 的属性名（若函数声明的函数名与 AO 中的属性名重复，则只保留一个），属性值为与函数名相对应的函数体，并将其书写到 AO 中。\n将对象 arguments 作为 AO 的属性名，并且将函数的实参以数组的形式作为属性值，并将其书写到 AO 中。\n将 this 作为 AO 的属性名，并默认将 window 作为属性值（指向），并将其书写到 AO 中（函数预编译过程中，this 默认指向 window）；若该函数使用了 new 运算符创建了一个对象实例，则默认的属性值 window 会变为该对象实例的名称。\n函数声明提升 One(); // 先调用函数 One 再书写函数声明，该函数也可以使用，因为该函数的函数声明会提升到该作用域链的顶端。 function One() { \tconsole.log(\u0026#39;执行成功\u0026#39;); }  // 变量声明提升-------------------------------------------------- console.log(a); // 在变量 a 声明之前调用该变量，并不会报错，会返回 undefined。 var a = 10; 函数声明覆盖 var a = 1, \tb = (c = 0);  function One(n) { \treturn (n = n + 1); } b = One(a);  function One(n) { \treturn (n = n + 3); } // 函数 One 的声明提升，相同的两个函数 One，书写靠后的会覆盖之前的。 c = One(a); console.log(b); console.log(c); 全局预编译 全局预编译发生在全局（每个 script 元素或外部 js 文件）执行的前一刻。\n全局执行期上下文 指 GO 对象（Global Object），也就是 window 对象。\nGO 对象中的 this，默认值为 window，它默认指向 window。\n全局预编译时发生了些什么 创建 GO 对象，将全局中的变量声明作为 GO 的属性名，属性值为 undefined，并将其书写到 GO 中。\n寻找全局中的函数声明，并将函数名作为 GO 对象的属性名，属性值为与函数名相对应的函数体，并将其书写到 GO 中。\n变量声明提升 console.log(a); var a = 10; // 变量的声明（var a）会提升到该作用域链的顶端，但赋值 （= 10）并没有提升，所以这里返回 undefined。 变量的连续赋值 function One() { \tvar a = (b = 10); \t// 因为变量赋值是从右向左的，所以这段代码是先将数值 10 赋给变量 b，再声明局部变量 a，再将变量 b 的值赋给变量 a， \t// 即变量 b 就是一个暗示全局变量（window 的属性）。 } One(); console.log(window.a); // 返回 undefined，因为变量 a 是函数 One 的局部变量，它不是全局对象 window 的属性。 console.log(window.b); // 返回 10，因为变量 b 是全局变量，它是全局对象 window 的属性。 预编译过程 console.log(a); // 因为在这之后的变量 a 的声明提升了，所以返回 undefined。 var a = 100; // 全局变量 a。 console.log(a); // 返回 100。 f = 200; // 暗示全局变量 f。 g = 300; // 暗示全局变量 g。 function f() {} // 函数声明 f One(5); // 调用函数声明提升后的函数 One function One(a, b) { \tconsole.log(f); \t// 返回 200，因为函数 One 中没有局部变量 f，然后到全局中寻找变量 f。 \tconsole.log(d); \t// 返回 function d(){}（本应该返回 undefined，），在这之后的函数声明 d 提升了（函数声明提升优先级高于变量的声明提升）。 \tconsole.log(a); \t//返回 function a(){}（本应该返回实参 5），在这之后的函数声明 a 提升了。 \tvar a = 10; \t// 将实参 a 从 function a(){} 变为 10。 \tconsole.log(a); \t// 返回 10。 \targuments[0] = 11; \t// 选择实参列表中的第一个值（a），将这个值变为 11 \tconsole.log(a); \t// 返回 11 \tconsole.log(i); \t// 返回 undefined，因为在这之后的 if 语句中的的变量声明 i 提升了。 \tif (g == 300) { \t// 如果变量 g 为真，则执行在这之后的代码。 \tvar i; \t// 不管 if 语句的返回值是否为 true，其语句中的变量都会先进行声明提升。 \tconsole.log(g); \t// 返回 300，虽然函数 One 中没有变量 g，但全局里有变量 g \tconsole.log(h); \t// 返回 undefined，因为函数 One 中没有变量 h，但全局里里有变量 h，虽然全局里的变量 h 在这之后，但变量 h 提升了。 \t} \tfunction a() {} \tconsole.log(a); \t// 返回 11。 \ti = 50; \t// 将变量 i 从 undefined 变为 50。 \tif (i) { \tconsole.log(i); \t// 返回 50。 \t} \tconsole.log(c); \t// 返回 undefined，因为在这之后的变量声明 c 提升了。 \tvar c = (e = 30); \t// 将数值 30 赋给暗示全局变量，之后声明变量 c，最后再将暗示全局变量 e 的值赋给变量 c。 \tconsole.log(c); \tconsole.log(e); \t// 返回 30。 \tif (j) { \t//因为变量 j 为 undefined，所以变量 j 为 false，因此不会执行在这之后的语句。 \tconsole.log(\u0026#39;我执行不\u0026#39;); \t} \tconsole.log(b); \t// 返回 undefined，在这之后的变量声明 b 提升了。 \tb = 20; \t// 将变量 b 从 undefined 变为 20。 \tconsole.log(b); \t// 返回 20。 \tvar b = function b() {}; \t// 这里的变量 b 是变量声明，也是函数表达式，将变量 b 从 20 变为了 function b( ){}。 \tconsole.log(b); \t// 返回 function b( ){}。 \tvar d = 40; \t// 将变量 d 从 function d(){} 变为 40。 \tfunction d() {} \tconsole.log(d); \t// 返回 40。 \tvar j; } var h = 400; // 声明全局变量 h。 console.log(h); // 返回 400。 ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E9%A2%84%E7%BC%96%E8%AF%91/","summary":"预编译 JavaScript 是脚本语言，因此不会进行传统的预编译，但它会经过一个特殊的预编译过程，这个预编译过程发生在代码执行前的极短时间内。\n预编译发生在代码执行之前的一瞬间，用于在内存中创建一些空间来存储一些变量与函数；预编译时，会无视 if 语句中的条件，会直接将 if 语句中的代码块内的变量的声明与函数声明进行提升。\n函数声明提升 定义一个函数时，该函数会被提升到当前作用域链的顶端，即调用该函数时，不管在哪调用该函数，都可以调用成功；但函数表达式并不会。\n变量声明提升 使用 var 声明的变量，不管在这之前还是之后调用该变量，并不会报错，会返回 undefined。\n暗示全局变量 暗示全局变量（imply global），一个变量未声明就赋值，那么此变量就是 window（全局对象）的属性； 任何全局变量，都是 window 的属性，即可以通过 window 对象调用全局变量。window 就是全局的域，它包括了全局变量和全局函数。\n暗示全局变量不会进行变量声明提升。\na = 10; // 一个变量未声明就赋值，那么此变量就是 window（全局对象）的属性，也叫暗示全局变量 // 相当于 window.a = 10; // 相当于 window = { \ta: 10, };  //一切声明了的全局变量，都是 window 的属性 var b = 20; // 相当于 window.b = 20; // 相当于 window = { \tb: 20, }; // 调用变量 b，相当于调用全局对象 window 的属性 b，即 console.","title":"JavaScript 预编译"},{"content":"一次函数 解析式 $ y = kx + b$（$k$ 与 $b$ 为常数 $k \\neq 0$），当 $b$ 等于 $0$ 时，这个函数为正比例函数。\n图像  一次函数的图像都是一条直线，因此只需要两点就可以画出。 $ y = kx + b$ 的图像可以由 $y = kx$ 向上或向下平移 |b| 个单位得到，当 $b$ 大于 0 则向上；小于 0 则向下。  与方程、不等式的关系  因为任何一个一元一次方程都可以变为 $ax + b = 0$ 的形式，所以解这个一元一次方程，相当于求与这个一元一次方程对应的 $y = ax + b$ 的函数值为 $0$ 时，自变量 $x$ 的值；例如： $3x + 5 = 6 =\u0026gt; 3x + 5 - 6$。 每个一含有 $x$ 和 $y$ 的二元一次方程都对应一个一次函数，同样也对应一条在坐标系中的直线，因此这条线上的每一个点（$x$，$y$）都是这个二元一次方程的解。 二元一次方程组则对应两个一次函数，同时也对应两条在坐标系中的直线，因此解这个二元一次方程组，相当于找出这两条直线在坐标系中的交点的坐标。  ","permalink":"https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/","summary":"一次函数 解析式 $ y = kx + b$（$k$ 与 $b$ 为常数 $k \\neq 0$），当 $b$ 等于 $0$ 时，这个函数为正比例函数。\n图像  一次函数的图像都是一条直线，因此只需要两点就可以画出。 $ y = kx + b$ 的图像可以由 $y = kx$ 向上或向下平移 |b| 个单位得到，当 $b$ 大于 0 则向上；小于 0 则向下。  与方程、不等式的关系  因为任何一个一元一次方程都可以变为 $ax + b = 0$ 的形式，所以解这个一元一次方程，相当于求与这个一元一次方程对应的 $y = ax + b$ 的函数值为 $0$ 时，自变量 $x$ 的值；例如： $3x + 5 = 6 =\u0026gt; 3x + 5 - 6$。 每个一含有 $x$ 和 $y$ 的二元一次方程都对应一个一次函数，同样也对应一条在坐标系中的直线，因此这条线上的每一个点（$x$，$y$）都是这个二元一次方程的解。 二元一次方程组则对应两个一次函数，同时也对应两条在坐标系中的直线，因此解这个二元一次方程组，相当于找出这两条直线在坐标系中的交点的坐标。  ","title":"Math 一次函数"},{"content":"二次函数 解析式 一般式：$y = ax^2 + bx + c$\n顶点式：$y = a(x - h)^2 + k$\n从 $y = ax^2$ 的图像可以看出  当 $a \u0026gt; 0$ 时，开口向上；当 $a \u0026lt; 0$ 时，开口向下，$|a|$越大，则图像的开口越小。 如果 $a \u0026gt; 0$ ，当 $x \u0026lt; 0$ 时，$y$ 随 $x$ 的增大而减小，当 $x \u0026gt; 0$ 时，$y$ 随 $x$ 的增大而增大；如果 $a \u0026lt; 0$ 时，当 $x \u0026gt; 0$ 时，$y$ 随 $x$ 的增大而减小。  从 $y = ax^2 + k$ 的图像可以看出 当 $k \u0026gt; 0$ 时，图像向上平移 $k$ 个单位；当 $k \u0026lt; 0$，图像则向下平移 $|k|$ 个单位长度。\n从 $y = ax(x - h)^2$ 的图像可以看出 当 h \u0026gt; 0 时，图像向右平移 h 个单位；当 h \u0026lt; 0 时，图像则向左平移 $|h|$个单位。\n从 $y = ax(x - h)^2 + k$ 的图像可以看出 当 $h \u0026gt; 0$，图像向右移动 $h$ 个单位，当 $h \u0026lt; 0$ ，图像则向左移动 $|h|$ 个单位；当 $k \u0026gt; 0$时，图像则向上移动 $k$ 个单位，当 $k \u0026lt; 0$ 时，图像则向下移动 $|k|$ 个单位。\n一般地，$y = ax(x - h)^2$ 与 $y = ax^2$ 的图像的形状时相同的，将 $y = ax^2$ 向上或下平移 $|k|$个单位，再向左或右平移 $|h|$个单位，即可得到 $y = ax(x - h)^2$。\n$y = ax(x - h)^2$ 的特点   当 $a \u0026gt; 0$ 时，开口向上；当 $a \u0026lt; 0$ 时，开口向下\n  对称轴时 x = h（这里为什么要 $x = 1$，因为该对称轴上的所有的点都满足 $x = 1$）。\n  抛物线的顶点为（$h$，$k$）\n  从 $y = ax^2 + bx + c$ 的图像可以看出   $y = ax^2 + bx + c$ 的图像与 $x$ 轴的三种关系：没有公共点，有一个公共点，有两个公共点。\n  这三种关系分别对应着 $ax^2 + bx + c = 0$ 的根的三种情况：没有实数根，有两个相等的实数根，有两个不等的实数根。\n  一般式化顶点式 配方法。\n$$ y = ax^2 + bx + c $$\n$$ y = a(x^2 + (\\frac{b} {a})^2) + c $$\n$$ y = a(x^2 + (\\frac{b}{a})^2 - (\\frac{b}{2a})^2) + c $$\n$$ y = a(x + \\frac{b}{2a})^2 + a \\times(-\\frac{b^2}{4a^2}) + c $$\n$$ y = a(x + \\frac{b}{2a})^2 + (\\frac{a - b^2}{4a^2}) + c $$\n$$ y = a(x + \\frac{b}{2a}^2) + (\\frac{-b^2}{4a}) + \\frac{c \\times 4a}{1 \\times 4a } $$\n$$ y = a(x + \\frac{b}{2a})^2 + (\\frac{-b^2}{4a}) + (\\frac{4ac}{4a}) $$\n$$ y = a(x + \\frac{b}{2a})^2 + (\\frac{4ac - b^2}{4a}) $$\n根据 $y = ax^2 + bx + c$ 用配方法化成的以 $y = a(x - h)^2 +k$ 形式的 $y = a(x +\\frac{b}{2a})^2 + (\\frac{4ac - b^2}{4a})$ ,可以看出 $y = ax^2 + bx + c$ 的对称轴为 $x = h$，则 $x = -\\frac{b}{2a}$，顶点为 $(h,k)$，则 $(-\\frac{b}{2a},\\frac{4ac - b^2}{4a})$\n求二次函数的解析式 已知该二次函数图像上的三个点的坐标，列出关于 $a$，$b$，$c$ 的三元一次方程组，并求 $a$，$b$，$c$ 的值。\n根据 $y = ax^2 + bx + c$，将坐标（$x$，$y$）中 $x$ 与 $y$ 的值代入 $y = ax^2 + bx + c$ 并分别列出方程即可。\n最后用配方法将这个三元一次方程化为二元一次方程，再化为二元一次方程求出其中一个未知数的值即可。\n","permalink":"https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0/","summary":"二次函数 解析式 一般式：$y = ax^2 + bx + c$\n顶点式：$y = a(x - h)^2 + k$\n从 $y = ax^2$ 的图像可以看出  当 $a \u0026gt; 0$ 时，开口向上；当 $a \u0026lt; 0$ 时，开口向下，$|a|$越大，则图像的开口越小。 如果 $a \u0026gt; 0$ ，当 $x \u0026lt; 0$ 时，$y$ 随 $x$ 的增大而减小，当 $x \u0026gt; 0$ 时，$y$ 随 $x$ 的增大而增大；如果 $a \u0026lt; 0$ 时，当 $x \u0026gt; 0$ 时，$y$ 随 $x$ 的增大而减小。  从 $y = ax^2 + k$ 的图像可以看出 当 $k \u0026gt; 0$ 时，图像向上平移 $k$ 个单位；当 $k \u0026lt; 0$，图像则向下平移 $|k|$ 个单位长度。","title":"Math 二次函数"},{"content":"反比例函数 解析式 $y = \\frac{k}{x}$\n图像 当 $k$ \u0026gt; 0，时，图像位于一、三象限，且 $y$ 随 $x$ 增大而减小。\n当 $k$ \u0026lt; 0，时，图像位于二、四象限，且 $y$ 随 $x$ 增大而增大。\n","permalink":"https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E5%8F%8D%E6%AF%94%E4%BE%8B%E5%87%BD%E6%95%B0/","summary":"反比例函数 解析式 $y = \\frac{k}{x}$\n图像 当 $k$ \u0026gt; 0，时，图像位于一、三象限，且 $y$ 随 $x$ 增大而减小。\n当 $k$ \u0026lt; 0，时，图像位于二、四象限，且 $y$ 随 $x$ 增大而增大。","title":"Math 反比例函数"},{"content":"正比例函数 解析式 $y = kx$（$k$ 为常数，$k$ ≠ $0$），其中 $k$ 叫做比例系数。\n","permalink":"https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E6%AD%A3%E6%AF%94%E4%BE%8B%E5%87%BD%E6%95%B0/","summary":"正比例函数 解析式 $y = kx$（$k$ 为常数，$k$ ≠ $0$），其中 $k$ 叫做比例系数。","title":"Math 正比例函数"},{"content":"同时推送到 Gtihub 和 Gitee 修改 Git 的配置文件config\n找到**[remote \u0026ldquo;origin\u0026rdquo;]下的url**\n增加需要添加的远程库 url 即可\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%90%8C%E6%97%B6%E6%8E%A8%E9%80%81%E5%88%B0gtihub%E5%92%8Cgitee/","summary":"同时推送到 Gtihub 和 Gitee 修改 Git 的配置文件config\n找到**[remote \u0026ldquo;origin\u0026rdquo;]下的url**\n增加需要添加的远程库 url 即可","title":"同时推送到Gtihub和Gitee"},{"content":"如何学习历史 当你读一本历史书，读到书中的古人面临重要的抉择关头时，请你这时立刻把书合上。\n好好想一想，如果你身处对方的位置时，\n你会如何决定？\n做什么样的决定？\n把一切都想清楚后，再把书打开，看看这个人物是怎么做的，\n他最后做了什么样的决定？\n他的决定带来的是成功还是失败？\n原因何在？\n然后比较自己与古人，在选择和方法上有何异同之处？\n这种学习历史的方法，所重视的不是记忆，而是思辨。\n","permalink":"https://note.yxzi.xyz/note/view/study/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E5%8E%86%E5%8F%B2/","summary":"如何学习历史 当你读一本历史书，读到书中的古人面临重要的抉择关头时，请你这时立刻把书合上。\n好好想一想，如果你身处对方的位置时，\n你会如何决定？\n做什么样的决定？\n把一切都想清楚后，再把书打开，看看这个人物是怎么做的，\n他最后做了什么样的决定？\n他的决定带来的是成功还是失败？\n原因何在？\n然后比较自己与古人，在选择和方法上有何异同之处？\n这种学习历史的方法，所重视的不是记忆，而是思辨。","title":"如何学习历史"},{"content":"安装 Git 官网下载并安装 Git (git-scm.com)，下载完成后，默认选项安装即可。\n安装完成后，右击后在菜单中选择 Git Bash ，蹦出一个类似命令行窗口的东西，就说明 Git 安装成功了！\nRainy@Rainy MINGW64 /e/Rainy 配置个人信息 因为 Git 是分布式版本控制系统，所以，每台设备都必须自报家门，也就是在命令行输入你的 Github 用户名和 Email 地址。\n首先，找一个合适的文件夹，右击 Git Bash，在命令行输入\ngit config --global user name \u0026#34;Your Github UserName\u0026#34; git config --global user email \u0026#34;Your Github Email\u0026#34; 注意git config命令的--global参数，用了这个参数，表示你这台设备上所有的 Git 仓库都会使用这个配置，当然也可以对某个仓库指定不同的 UserName 和 Email 地址。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%AE%89%E8%A3%85-git/","summary":"安装 Git 官网下载并安装 Git (git-scm.com)，下载完成后，默认选项安装即可。\n安装完成后，右击后在菜单中选择 Git Bash ，蹦出一个类似命令行窗口的东西，就说明 Git 安装成功了！\nRainy@Rainy MINGW64 /e/Rainy 配置个人信息 因为 Git 是分布式版本控制系统，所以，每台设备都必须自报家门，也就是在命令行输入你的 Github 用户名和 Email 地址。\n首先，找一个合适的文件夹，右击 Git Bash，在命令行输入\ngit config --global user name \u0026#34;Your Github UserName\u0026#34; git config --global user email \u0026#34;Your Github Email\u0026#34; 注意git config命令的--global参数，用了这个参数，表示你这台设备上所有的 Git 仓库都会使用这个配置，当然也可以对某个仓库指定不同的 UserName 和 Email 地址。","title":"安装 Git"},{"content":"递归 简单地说，就是如果在函数中存在着调用函数本身的情况，这种现象就叫递归。\n从所需结果出发不断回溯前一运算直到回到初值再递推得到所需结果。从未知到已知，从大到小，再从小到大。\n用计算阶乘函数举例，factorial()中存在着factorial(n - 1)的调用，所以此函数就是递归函数。\nvar n = 5; function factorial(n) { \tif (n == 1) { \treturn 1; \t} \treturn (n = n * factorial(n - 1)); } console.log(factorial(n)); 使用递归的思路   找规律（符合人的思维过程）。\n  找出口（用已知的条件当做终止条件，用实际性的数去返回结果），避免无限递归（即无限循环），导致浏览器崩溃。\n     递归的一般格式为 return + 有规律公式。      递归优缺点 优点\n 使代码更加简洁。  缺点\n 影响程序的效率与性能，因此，复杂的程序一定不要使用递归。  ","permalink":"https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%80%92%E5%BD%92/","summary":"递归 简单地说，就是如果在函数中存在着调用函数本身的情况，这种现象就叫递归。\n从所需结果出发不断回溯前一运算直到回到初值再递推得到所需结果。从未知到已知，从大到小，再从小到大。\n用计算阶乘函数举例，factorial()中存在着factorial(n - 1)的调用，所以此函数就是递归函数。\nvar n = 5; function factorial(n) { \tif (n == 1) { \treturn 1; \t} \treturn (n = n * factorial(n - 1)); } console.log(factorial(n)); 使用递归的思路   找规律（符合人的思维过程）。\n  找出口（用已知的条件当做终止条件，用实际性的数去返回结果），避免无限递归（即无限循环），导致浏览器崩溃。\n     递归的一般格式为 return + 有规律公式。      递归优缺点 优点\n 使代码更加简洁。  缺点\n 影响程序的效率与性能，因此，复杂的程序一定不要使用递归。  ","title":"递归"},{"content":"什么是爱情 一 什么是爱情？你告诉我\n什么是喜欢？你告诉我\n什么是有趣的灵魂？\n什么才能让你爱上我独一无二的灵魂？\n是共性吗？是吸引吗？是魅力吗？\n是相处时的点点滴滴吗？\n是令人神魂颠倒的一见钟情吗？\n是怜悯吗？是欺骗吗？是欲望吗？\n一群没有爱人能力的巨婴，互相在说着爱与奉献一生一世？\n谁知道啊？谁能挖出他的心来看一看？\n一丝好感描述成喜欢\n一点喜欢描绘成爱情\n一点点荷尔蒙上头许下一生一世\n这就是令人迷恋痴缠割舍不掉的爱情吗？\n扪心自问你爱过谁？\n父母？兄妹？死党？朋友？男神女神？\n扪心自问你爱自己吗？\n见人没几面，跟人没说过几句话，\n看着人家阳光下明媚的微笑，晚风吹起鬓边的秀发，湿漉漉的眼睛装满了星辰大海，\n就以为爱上了人家？\n你知道 Ta 的梦想理想是什么吗？\n你知道 Ta 的爱好是什么吗？\n你知道 Ta 喜欢看什么书吗？\n你知道 Ta 的精神世界与你契合吗？\n你知道 Ta 抠脚放屁的时候吗？\n你知道 Ta 刚起床乱蓬蓬的头发吗？\n你知道 Ta 睡眼惺忪的眼屎吗？\n你知道 Ta 塞牙抠鼻屎拉屎的情景吗？\n或许在你的世界里，帅哥仙女是不会拉屎的吧。\n二 你知道尊重是什么吗？\n你能够不插嘴，听人家的高谈论阔吗？\n你能够不指手画脚，尊重人家的爱好吗？\n最起码的尊重有没有，还谈爱情？\n不过是一群不会尊重他人的思想上的巨婴罢了。\n三 看上了别人的肉体和颜值，\n却信誓旦旦的说着：好看的皮囊千篇一律，有趣的灵魂万里挑一\n爱情靠的是共性和吸引\n共性和吸引\n相同的三观\n不同的爱好\n否则当初那点吸引\n早就在时间长河中消磨殆尽了\n","permalink":"https://note.yxzi.xyz/note/view/bisexual/%E4%BB%80%E4%B9%88%E6%98%AF%E7%88%B1%E6%83%85/","summary":"什么是爱情 一 什么是爱情？你告诉我\n什么是喜欢？你告诉我\n什么是有趣的灵魂？\n什么才能让你爱上我独一无二的灵魂？\n是共性吗？是吸引吗？是魅力吗？\n是相处时的点点滴滴吗？\n是令人神魂颠倒的一见钟情吗？\n是怜悯吗？是欺骗吗？是欲望吗？\n一群没有爱人能力的巨婴，互相在说着爱与奉献一生一世？\n谁知道啊？谁能挖出他的心来看一看？\n一丝好感描述成喜欢\n一点喜欢描绘成爱情\n一点点荷尔蒙上头许下一生一世\n这就是令人迷恋痴缠割舍不掉的爱情吗？\n扪心自问你爱过谁？\n父母？兄妹？死党？朋友？男神女神？\n扪心自问你爱自己吗？\n见人没几面，跟人没说过几句话，\n看着人家阳光下明媚的微笑，晚风吹起鬓边的秀发，湿漉漉的眼睛装满了星辰大海，\n就以为爱上了人家？\n你知道 Ta 的梦想理想是什么吗？\n你知道 Ta 的爱好是什么吗？\n你知道 Ta 喜欢看什么书吗？\n你知道 Ta 的精神世界与你契合吗？\n你知道 Ta 抠脚放屁的时候吗？\n你知道 Ta 刚起床乱蓬蓬的头发吗？\n你知道 Ta 睡眼惺忪的眼屎吗？\n你知道 Ta 塞牙抠鼻屎拉屎的情景吗？\n或许在你的世界里，帅哥仙女是不会拉屎的吧。\n二 你知道尊重是什么吗？\n你能够不插嘴，听人家的高谈论阔吗？\n你能够不指手画脚，尊重人家的爱好吗？\n最起码的尊重有没有，还谈爱情？\n不过是一群不会尊重他人的思想上的巨婴罢了。\n三 看上了别人的肉体和颜值，\n却信誓旦旦的说着：好看的皮囊千篇一律，有趣的灵魂万里挑一\n爱情靠的是共性和吸引\n共性和吸引\n相同的三观\n不同的爱好\n否则当初那点吸引\n早就在时间长河中消磨殆尽了","title":"什么是爱情"},{"content":"杀一救百是否正义 不正义\n有一句话可以很好的回答这个问题：\n你每个器官都能救一条人命，请。\n杀一救百这种做法，表面上是维护了所谓更大的利益，但从更本质的层面，它摧毁了社会中每一个人的安全感。\n如果这种行为被允许甚至被提倡，那么所有人——至少是大部分没有选择权的人，都会陷入恐惧：\n你永远不知道自己什么时候会成为被牺牲的那个 1\n而你对此将毫无还手之力。\n这种恐惧，最终将不可避免地撕裂整个社会。\n","permalink":"https://note.yxzi.xyz/note/view/society/%E6%9D%80%E4%B8%80%E6%95%91%E7%99%BE%E6%98%AF%E5%90%A6%E6%AD%A3%E4%B9%89/","summary":"杀一救百是否正义 不正义\n有一句话可以很好的回答这个问题：\n你每个器官都能救一条人命，请。\n杀一救百这种做法，表面上是维护了所谓更大的利益，但从更本质的层面，它摧毁了社会中每一个人的安全感。\n如果这种行为被允许甚至被提倡，那么所有人——至少是大部分没有选择权的人，都会陷入恐惧：\n你永远不知道自己什么时候会成为被牺牲的那个 1\n而你对此将毫无还手之力。\n这种恐惧，最终将不可避免地撕裂整个社会。","title":"杀一救百是否正义"},{"content":"提倡禁止游戏 因为我不 xx，所以可以禁 xx 支持禁止游戏的人，都是不玩游戏的人。\n我支持禁止抽烟，因为我不抽烟。\n我支持禁止喝酒，因为我不喝酒\n\u0026hellip;.\n将教育的失败的责任推给游戏 孩子学习不好，父母没有和他一起找原因，而是骂你为什么不好好学习。\n孩子学习努力取得不错的成绩，父母会抛开孩子的努力，却说自己带孩子带得好。\n父母看别人家的孩子成绩优异，父母没有想自己孩子成绩不好是哪些因素导致的，而是骂自己的孩子：你为什么成绩不好。\n父母看见孩子玩游戏，不知道对孩子引导游戏和生活的关系，而是在那骂游戏。\n这种父母，真无能。\n如果被称作第九艺术的游戏被禁，那前八艺术还有不禁的天理？一个优秀的游戏，能真正让一个人理解到很多东西。\n降低犯罪率 大多数人，都活在生活的阳光面。\n哪怕你自己仅仅是个大专生，你的学历也超越了一半的同龄人，那么剩下的另一半呢？\n以前的学生，做的事情你根本想象不出来。\n闲得无聊就打架，打了架就想拉帮结派的，拉帮结派后胆子大了，就敢拿刀了，\n然后就有进派出所的，看场子的，放高利贷的。\n而现在呢？下课了躺在空调房打游戏，不香吗？\n我曾处理过一起约架事件，双方没打起来的原因是：\n一方的两个兄弟在打晋级赛，小孩子的矛盾来得快去的么快，等晋级赛打完以后，矛盾已经消除了。\n可笑却引人深思，这就是游戏即娱乐的作用。\n","permalink":"https://note.yxzi.xyz/note/view/society/%E6%8F%90%E5%80%A1%E7%A6%81%E6%AD%A2%E6%B8%B8%E6%88%8F/","summary":"提倡禁止游戏 因为我不 xx，所以可以禁 xx 支持禁止游戏的人，都是不玩游戏的人。\n我支持禁止抽烟，因为我不抽烟。\n我支持禁止喝酒，因为我不喝酒\n\u0026hellip;.\n将教育的失败的责任推给游戏 孩子学习不好，父母没有和他一起找原因，而是骂你为什么不好好学习。\n孩子学习努力取得不错的成绩，父母会抛开孩子的努力，却说自己带孩子带得好。\n父母看别人家的孩子成绩优异，父母没有想自己孩子成绩不好是哪些因素导致的，而是骂自己的孩子：你为什么成绩不好。\n父母看见孩子玩游戏，不知道对孩子引导游戏和生活的关系，而是在那骂游戏。\n这种父母，真无能。\n如果被称作第九艺术的游戏被禁，那前八艺术还有不禁的天理？一个优秀的游戏，能真正让一个人理解到很多东西。\n降低犯罪率 大多数人，都活在生活的阳光面。\n哪怕你自己仅仅是个大专生，你的学历也超越了一半的同龄人，那么剩下的另一半呢？\n以前的学生，做的事情你根本想象不出来。\n闲得无聊就打架，打了架就想拉帮结派的，拉帮结派后胆子大了，就敢拿刀了，\n然后就有进派出所的，看场子的，放高利贷的。\n而现在呢？下课了躺在空调房打游戏，不香吗？\n我曾处理过一起约架事件，双方没打起来的原因是：\n一方的两个兄弟在打晋级赛，小孩子的矛盾来得快去的么快，等晋级赛打完以后，矛盾已经消除了。\n可笑却引人深思，这就是游戏即娱乐的作用。","title":"提倡禁止游戏"},{"content":"环境的影响 对大多数人而言，环境对人的影响都很大\n环境影响的是人的三观，确切的说是影响人对于好、一般和坏的判断阈值。\n当你你周围的人都是早上 10 点才起床的时候，你就会觉得 9 点起床很早了，\n而如果你周围都是早上 7 点就起的，你就会觉得 8 点起就已经很晚了。\n你没有必要也没有能力说服所有人都和你观点一样，而且你的观点也并不一定就是正确的，\n所以你要接受有人观点和你不同这个客观事实\n只和那些愿意和你交流，你也愿意和他交流的人交流，否则就是浪费时间\n保持谦卑，注意反思，不断进步，\n保持谦卑——永远记得你不是最牛的，只是你不知道有人比你牛而已\n注意反思——时刻反问自己，你认为的就一定是对的么\n不断进步——不要为自己的停滞不前找借口，你只是不想进步了而已\n双标 为什么当别人抱怨一件事情的时候，我们总觉得问题出在他们自身？\n然而，为什么当我们自己遇到不如意的时候，我们却觉得错的是他人或是环境？\n这种现象叫做基本归因谬论，它普遍地存在于大多数人身上。\n我们倾向于用内因解释他人的行为，而忽略环境的影响。\n但是当我们尝试理解自身行为的时候，外因变得格外明显，\n因此我们会过分强调环境的影响而忽视自身的因素——这就是所谓的行动者—观察者偏误。\nJones and Harris 在 1967 年做了一个实验。他们找了一群学生，\n让学生们读一篇反对或是支持菲德尔卡斯特罗（古巴前领导人）的文章，然后评价文章作者对卡斯特罗的态度。\n第一组学生被告知文章的作者是自由选择文章的立场，\n这组学生很自然地认为支持卡斯特罗的文章作者对卡斯特罗的态度更正面。\n第二组学生被告知文章作者的立场是由抛硬币决定的，换而言之，文章的立场与作者本人的态度无关。\n遵循逻辑来说，这第二组的学生应该无法判断作者的态度，可是实验结果却显示，\n学生们依旧认为由抛硬币决定撰写支持卡斯特罗立场的文章作者对卡斯特罗抱有更加正面的态度。\n为什么会有这种现象？并不是因为我们都是自私爱推脱责任的坏人，只是我们的注意力有局限罢了。\n当我们观察和分析他人的时候，我们的注意力集中在那个人身上，很容易会忽视周围的环境。\n而当我们自己做一件事的时候，一定会有更多地注意力放在周围的环境上。\n因此我们在给行为归因的时候，就倾向于选择我们注意力关注到的一方。\n另外，我们在对待他人的事情上，是相当懒惰的。\n由于我们的认知系统会自动地用内因解释他人的行为，\n纵使我们意识到了他人行为受到环境的限制，我们的认知系统还需要清醒地商榷调整之前所做的解释。\n尤其是在认知系统非常繁忙的情况下，我们没有足够的认知资源去为他人的行为辩解。\n最后一个原因，或许有些人听说过——正义世界现象。\n我们更愿意相信自己生存的世界是正义的、是我们能够掌控的，只要我们努力就能得到我们想要的。\n如果我们把他人的失败归因于其自身，那么这个无法改变也无法控制的世界在我们眼中便还是好的、公正的。相信世界是好的，\n失败都是因为他人自己的过错，这样的想法满足了我们内心底的安全感。\n朋友抱怨的时候，请学会换位思考。\n即使无法提供帮助，至少不要妄下定论。\n","permalink":"https://note.yxzi.xyz/note/view/society/%E7%8E%AF%E5%A2%83%E7%9A%84%E5%BD%B1%E5%93%8D/","summary":"环境的影响 对大多数人而言，环境对人的影响都很大\n环境影响的是人的三观，确切的说是影响人对于好、一般和坏的判断阈值。\n当你你周围的人都是早上 10 点才起床的时候，你就会觉得 9 点起床很早了，\n而如果你周围都是早上 7 点就起的，你就会觉得 8 点起就已经很晚了。\n你没有必要也没有能力说服所有人都和你观点一样，而且你的观点也并不一定就是正确的，\n所以你要接受有人观点和你不同这个客观事实\n只和那些愿意和你交流，你也愿意和他交流的人交流，否则就是浪费时间\n保持谦卑，注意反思，不断进步，\n保持谦卑——永远记得你不是最牛的，只是你不知道有人比你牛而已\n注意反思——时刻反问自己，你认为的就一定是对的么\n不断进步——不要为自己的停滞不前找借口，你只是不想进步了而已\n双标 为什么当别人抱怨一件事情的时候，我们总觉得问题出在他们自身？\n然而，为什么当我们自己遇到不如意的时候，我们却觉得错的是他人或是环境？\n这种现象叫做基本归因谬论，它普遍地存在于大多数人身上。\n我们倾向于用内因解释他人的行为，而忽略环境的影响。\n但是当我们尝试理解自身行为的时候，外因变得格外明显，\n因此我们会过分强调环境的影响而忽视自身的因素——这就是所谓的行动者—观察者偏误。\nJones and Harris 在 1967 年做了一个实验。他们找了一群学生，\n让学生们读一篇反对或是支持菲德尔卡斯特罗（古巴前领导人）的文章，然后评价文章作者对卡斯特罗的态度。\n第一组学生被告知文章的作者是自由选择文章的立场，\n这组学生很自然地认为支持卡斯特罗的文章作者对卡斯特罗的态度更正面。\n第二组学生被告知文章作者的立场是由抛硬币决定的，换而言之，文章的立场与作者本人的态度无关。\n遵循逻辑来说，这第二组的学生应该无法判断作者的态度，可是实验结果却显示，\n学生们依旧认为由抛硬币决定撰写支持卡斯特罗立场的文章作者对卡斯特罗抱有更加正面的态度。\n为什么会有这种现象？并不是因为我们都是自私爱推脱责任的坏人，只是我们的注意力有局限罢了。\n当我们观察和分析他人的时候，我们的注意力集中在那个人身上，很容易会忽视周围的环境。\n而当我们自己做一件事的时候，一定会有更多地注意力放在周围的环境上。\n因此我们在给行为归因的时候，就倾向于选择我们注意力关注到的一方。\n另外，我们在对待他人的事情上，是相当懒惰的。\n由于我们的认知系统会自动地用内因解释他人的行为，\n纵使我们意识到了他人行为受到环境的限制，我们的认知系统还需要清醒地商榷调整之前所做的解释。\n尤其是在认知系统非常繁忙的情况下，我们没有足够的认知资源去为他人的行为辩解。\n最后一个原因，或许有些人听说过——正义世界现象。\n我们更愿意相信自己生存的世界是正义的、是我们能够掌控的，只要我们努力就能得到我们想要的。\n如果我们把他人的失败归因于其自身，那么这个无法改变也无法控制的世界在我们眼中便还是好的、公正的。相信世界是好的，\n失败都是因为他人自己的过错，这样的想法满足了我们内心底的安全感。\n朋友抱怨的时候，请学会换位思考。\n即使无法提供帮助，至少不要妄下定论。","title":"环境的影响"},{"content":"实现居中 绝对定位 兼容性不错的主流 css 绝对定位居中的用法：\nwidth: 600px; height: 400px; position: absolute; left: 50%; top: 50%; margin-top: -200px; /* 高度的一半 */ margin-left: -300px; /* 宽度的一半 */ 绝对定位 transform 中 translate 偏移的百分比值是相对于自身大小的，可以这样实现 css 绝对定位居中，给子元素应用以下样式，将子元素居于父元素正中间，注意：这个方法有 bug。\nposition: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); 弹性布局 给父元素应用以下样式，将子元素居于父元素正中间。\ndisplay: flex; flex-direction: row; justify-content: center; align-items: center; display: flex; flex-direction: column; justify-content: center; align-items: center; 文本实现垂直居中 display: flex; align-items: center; ","permalink":"https://note.yxzi.xyz/note/technology/language/css/%E5%AE%9E%E7%8E%B0%E5%B1%85%E4%B8%AD/","summary":"实现居中 绝对定位 兼容性不错的主流 css 绝对定位居中的用法：\nwidth: 600px; height: 400px; position: absolute; left: 50%; top: 50%; margin-top: -200px; /* 高度的一半 */ margin-left: -300px; /* 宽度的一半 */ 绝对定位 transform 中 translate 偏移的百分比值是相对于自身大小的，可以这样实现 css 绝对定位居中，给子元素应用以下样式，将子元素居于父元素正中间，注意：这个方法有 bug。\nposition: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); 弹性布局 给父元素应用以下样式，将子元素居于父元素正中间。\ndisplay: flex; flex-direction: row; justify-content: center; align-items: center; display: flex; flex-direction: column; justify-content: center; align-items: center; 文本实现垂直居中 display: flex; align-items: center; ","title":"Css 实现居中"},{"content":"盒子类型 行盒   display 属性为 inline 的元素是行盒，也叫行级元素；如 span、strong、button、em、a、img、video、audio。\n  文字一定是行盒（文字会产生匿名行盒将其包裹）。\n  内部产生参考线：一个元素中包含行盒，通常会给行盒设置 vertical-align:baseline，这会导致两个元素的参考线对齐。\n  同一个包含块中，连续多个行盒水平依次排列，剩余空间排列不下，才会换行。\n  行盒不能包含块盒（a 元素除外）。\n  设置 width 和 height 无效；调整行盒的 width 与 height 应使用字体大小、行高、字体类型等间接调整。\n  产生空白合并：代码中的连续空白字符，在页面显示时，会被合并为一个空格。\n  设置内外边距及边框，水平方向有效，垂直方向只会影响元素的背景，不会影响其他盒子。\n  内部包含行块盒或可替换元素，行盒的高度只和文字内容的字体大小有关系，和行块盒或可替换元素无关。\n  块盒  display 属性为 block 的元素，也叫块级元素；如 div、h1~h6、pre、ul、li、p。 同一个包含块中，每个块盒独占一行。 p 元素不能包含 div 元素。  行块盒  display 属性为 inline-block 的元素，也叫行块级元素；没有默认值为 inline-block 的元素。 同一个包含块中，连续的多个行块盒水平依次排列。 行块盒内部一定会产生参考线。 产生空白合并  ","permalink":"https://note.yxzi.xyz/note/technology/language/css/%E7%9B%92%E5%AD%90%E7%B1%BB%E5%9E%8B/","summary":"盒子类型 行盒   display 属性为 inline 的元素是行盒，也叫行级元素；如 span、strong、button、em、a、img、video、audio。\n  文字一定是行盒（文字会产生匿名行盒将其包裹）。\n  内部产生参考线：一个元素中包含行盒，通常会给行盒设置 vertical-align:baseline，这会导致两个元素的参考线对齐。\n  同一个包含块中，连续多个行盒水平依次排列，剩余空间排列不下，才会换行。\n  行盒不能包含块盒（a 元素除外）。\n  设置 width 和 height 无效；调整行盒的 width 与 height 应使用字体大小、行高、字体类型等间接调整。\n  产生空白合并：代码中的连续空白字符，在页面显示时，会被合并为一个空格。\n  设置内外边距及边框，水平方向有效，垂直方向只会影响元素的背景，不会影响其他盒子。\n  内部包含行块盒或可替换元素，行盒的高度只和文字内容的字体大小有关系，和行块盒或可替换元素无关。\n  块盒  display 属性为 block 的元素，也叫块级元素；如 div、h1~h6、pre、ul、li、p。 同一个包含块中，每个块盒独占一行。 p 元素不能包含 div 元素。  行块盒  display 属性为 inline-block 的元素，也叫行块级元素；没有默认值为 inline-block 的元素。 同一个包含块中，连续的多个行块盒水平依次排列。 行块盒内部一定会产生参考线。 产生空白合并  ","title":"Css 盒子类型"},{"content":"高斯模糊 backdrop-filter: blur(0.5rem); ","permalink":"https://note.yxzi.xyz/note/technology/language/css/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A/","summary":"高斯模糊 backdrop-filter: blur(0.5rem); ","title":"Css 高斯模糊"},{"content":"国内无法访问外网的原因 国内外网被屏蔽有很多种原因，比如政治因素、安全因经济因素等等。\n比如国外的信息有些是被中国法律不允许观看的（黄色，暴力、政治），\n但是这些信息在有些国家是可以合法存在的，因此中国就屏蔽了大部分国外知名网站。\n另外，虽然外网被屏蔽了，但并不是不能上，而是需要添加一些翻墙的软件（VPN），\n通过这些软件可以访问外网的信息，网上可以下载到这类软件，但大部分都需要付费（比如我现在使用的 Clash）\n不过目前这玩意是不合法的，无法在网上光明正大的传播或讨论，毕竟中国政治问题很大。\n","permalink":"https://note.yxzi.xyz/note/technology/internet/%E5%9B%BD%E5%86%85%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E5%A4%96%E7%BD%91%E7%9A%84%E5%8E%9F%E5%9B%A0/","summary":"国内无法访问外网的原因 国内外网被屏蔽有很多种原因，比如政治因素、安全因经济因素等等。\n比如国外的信息有些是被中国法律不允许观看的（黄色，暴力、政治），\n但是这些信息在有些国家是可以合法存在的，因此中国就屏蔽了大部分国外知名网站。\n另外，虽然外网被屏蔽了，但并不是不能上，而是需要添加一些翻墙的软件（VPN），\n通过这些软件可以访问外网的信息，网上可以下载到这类软件，但大部分都需要付费（比如我现在使用的 Clash）\n不过目前这玩意是不合法的，无法在网上光明正大的传播或讨论，毕竟中国政治问题很大。","title":"国内无法访问外网的原因"},{"content":"将孩子带大很辛苦，孩子本就该回报 这根本就是反自然的。基因延续是每个物种的义务，是物种最原始的追求和毕生唯一的意义，\n人类也不例外。做什么不辛苦？跳支广场舞也要出满身的汗呢。相比于世间其它的事情，\n传承是能够给人带来最大满足感的事情，这是大自然给予每个传承者的反馈。但是呢？\n为什么有些人感觉不到快乐？因为他们拒绝传承，所以不快乐。\n你辛苦的回报，早在你养育孩子的时候，大自然就给你回馈了，孩子给予你的快乐，是额外的。\n若还妄想孩子给予你回报，这就是索要，索要都是要付出代价的，那些向孩子索要的父母，迟早会感受到大自然和孩子的恶意。\n","permalink":"https://note.yxzi.xyz/note/view/society/%E5%AD%A9%E5%AD%90%E6%9C%AC%E5%B0%B1%E8%AF%A5%E5%9B%9E%E6%8A%A5/","summary":"将孩子带大很辛苦，孩子本就该回报 这根本就是反自然的。基因延续是每个物种的义务，是物种最原始的追求和毕生唯一的意义，\n人类也不例外。做什么不辛苦？跳支广场舞也要出满身的汗呢。相比于世间其它的事情，\n传承是能够给人带来最大满足感的事情，这是大自然给予每个传承者的反馈。但是呢？\n为什么有些人感觉不到快乐？因为他们拒绝传承，所以不快乐。\n你辛苦的回报，早在你养育孩子的时候，大自然就给你回馈了，孩子给予你的快乐，是额外的。\n若还妄想孩子给予你回报，这就是索要，索要都是要付出代价的，那些向孩子索要的父母，迟早会感受到大自然和孩子的恶意。","title":"孩子本就该回报"},{"content":"父母与子女 父母作为孩子在这个世界的引路人，本身对孩子就有着天然的义务——保护孩子避免过早暴露在危险中。\n如果父母不能做到这一点，就是父母的失职，违背自然规律是会受到最原始的反噬的。\n如果父母有能力做到这一点而拒绝去做，这就是父母的罪恶，必然会受到自然规律严重的惩罚。\n父母没能力让孩子啃老是父母的问题，父母应该意识到他们自身的问题，不过这我也不想过于苛责。\n我真正苛责的是那些有能力却只顾自己享乐，并且用“啃老可耻”绑架孩子的父母。\n而正是这样的父母，造就了一批自私自利不能共情的孩子。\n有的孩子一出生，就没很好的获得父母的资源，无论精神上还是物质上，\n父母懒惰自私，自己享乐苦了孩子，一直持续到孩子长大。\n等孩子长大，又用“辛苦把孩子拉扯大”来道徳绑架孩子来满足自己的私欲。\n这样的父母，压根就没想过给孩子提供保护，更没想过让孩子啃，\n往往也是这样的父母，才会将“啃老”二字挂在嘴上。\n这就是我所说的，穷人才会啃老，穷人的孩子，占一点父母的便宜，就会被懒惰自私的穷父母说啃老。\n","permalink":"https://note.yxzi.xyz/note/view/society/%E7%88%B6%E6%AF%8D%E4%B8%8E%E5%AD%90%E5%A5%B3/","summary":"父母与子女 父母作为孩子在这个世界的引路人，本身对孩子就有着天然的义务——保护孩子避免过早暴露在危险中。\n如果父母不能做到这一点，就是父母的失职，违背自然规律是会受到最原始的反噬的。\n如果父母有能力做到这一点而拒绝去做，这就是父母的罪恶，必然会受到自然规律严重的惩罚。\n父母没能力让孩子啃老是父母的问题，父母应该意识到他们自身的问题，不过这我也不想过于苛责。\n我真正苛责的是那些有能力却只顾自己享乐，并且用“啃老可耻”绑架孩子的父母。\n而正是这样的父母，造就了一批自私自利不能共情的孩子。\n有的孩子一出生，就没很好的获得父母的资源，无论精神上还是物质上，\n父母懒惰自私，自己享乐苦了孩子，一直持续到孩子长大。\n等孩子长大，又用“辛苦把孩子拉扯大”来道徳绑架孩子来满足自己的私欲。\n这样的父母，压根就没想过给孩子提供保护，更没想过让孩子啃，\n往往也是这样的父母，才会将“啃老”二字挂在嘴上。\n这就是我所说的，穷人才会啃老，穷人的孩子，占一点父母的便宜，就会被懒惰自私的穷父母说啃老。","title":"父母与子女"},{"content":"字体 参考线 当制作文字时，会出现几根参考线。不同的文字类型，参考线位置、距离都不一样，同一种文字类型，参考线一致。\n组成\n text_top ascent，顶线 super，上基线 baseline，基线 sub，下基线 text_bottom descent，底线  决定因素\n font-family：定义参考线的相对距离。 font-size：定义参考线之间的距离。 line-height：定义参考线的顶部空隙与底部空隙。  元素的基线 img：基线位置位于 img 的下外边距的最底边。\nfrom：基线位于其内容的底边。\n行块盒：父元素内部包含行块盒（高度自适应） ，会因为行块盒最后一行有 line-box，则会导致行块盒用最后一行的基线作为整个父元素的基线。若父元素中没有行盒，则使用父元素的下外边距作为基线。\nfont-size 用该属性设置字体大小时，改变的是文字的相对大小，也叫字体框大小。\n制作文字时，文字外面会有一个字体框，不同的文字的字体框，大小也不一样；即设置文字的小大，本质改变的是文字的相对大小。\n相对大小\n若一个文字的相对大小（字体框大小）为 2048 时，那么它顶线到基线的距离为 1884，底线到基线的距离为 514，则顶线到底线的距离为 1884 + 514 = 2398。（可以拙见为一个字体的高为 2048，那么该字体占的实际区域是 2390，因此某些字体会有默认边距）\n文字顶线到底线的距离，叫做文字的实际大小（content-area），也叫内容区。即行盒的背景，填充的是文字的实际大小。因此当我们给行盒设置背景时，会导致行盒上下有留白。即上部分留白 + 行盒背景 + 下部分留白 = 文字的相对大小。\nline-height 用于设置多行元素的空间量。\ntop：文字顶线向上延申的空间。\nbottom：文字底线向下延申的空间。\n空隙  这两个空间（top 与 bottom）的空间量一定相等，这两个空间叫做空隙（line gap）。 通常，空隙是字体设计者决定的，因此有些字体没有空隙，但有的字体有空隙，有的字体空隙是负数。  虚拟区  top 到 botoom 的距离，叫做虚拟区（virtual-area），有的虚拟区和内容区相等，有的虚拟区比内容区小，但大部分虚拟区都比内容区大；因此设置行高大小就等于设置虚假区的大小。 因为虚拟区上下两边都相等，所以字体的实际大小在虚拟区之间。  line-box  line-box（行框）是承载文字内容的必要条件，如果没有行框，文字将无法显示。 当有多行行盒排列时，每一行的区域就叫做 line-box，line-box 的顶边是该行所有行盒的最顶边，底边是该行行盒的最低底边。即一个行盒的实际占用高度是通过 line-box 计算的。  不生成 line-box 的情况\n 元素内部没有行盒。 元素的字体大小为 0。  ","permalink":"https://note.yxzi.xyz/note/technology/language/css/%E5%AD%97%E4%BD%93/","summary":"字体 参考线 当制作文字时，会出现几根参考线。不同的文字类型，参考线位置、距离都不一样，同一种文字类型，参考线一致。\n组成\n text_top ascent，顶线 super，上基线 baseline，基线 sub，下基线 text_bottom descent，底线  决定因素\n font-family：定义参考线的相对距离。 font-size：定义参考线之间的距离。 line-height：定义参考线的顶部空隙与底部空隙。  元素的基线 img：基线位置位于 img 的下外边距的最底边。\nfrom：基线位于其内容的底边。\n行块盒：父元素内部包含行块盒（高度自适应） ，会因为行块盒最后一行有 line-box，则会导致行块盒用最后一行的基线作为整个父元素的基线。若父元素中没有行盒，则使用父元素的下外边距作为基线。\nfont-size 用该属性设置字体大小时，改变的是文字的相对大小，也叫字体框大小。\n制作文字时，文字外面会有一个字体框，不同的文字的字体框，大小也不一样；即设置文字的小大，本质改变的是文字的相对大小。\n相对大小\n若一个文字的相对大小（字体框大小）为 2048 时，那么它顶线到基线的距离为 1884，底线到基线的距离为 514，则顶线到底线的距离为 1884 + 514 = 2398。（可以拙见为一个字体的高为 2048，那么该字体占的实际区域是 2390，因此某些字体会有默认边距）\n文字顶线到底线的距离，叫做文字的实际大小（content-area），也叫内容区。即行盒的背景，填充的是文字的实际大小。因此当我们给行盒设置背景时，会导致行盒上下有留白。即上部分留白 + 行盒背景 + 下部分留白 = 文字的相对大小。\nline-height 用于设置多行元素的空间量。\ntop：文字顶线向上延申的空间。\nbottom：文字底线向下延申的空间。\n空隙  这两个空间（top 与 bottom）的空间量一定相等，这两个空间叫做空隙（line gap）。 通常，空隙是字体设计者决定的，因此有些字体没有空隙，但有的字体有空隙，有的字体空隙是负数。  虚拟区  top 到 botoom 的距离，叫做虚拟区（virtual-area），有的虚拟区和内容区相等，有的虚拟区比内容区小，但大部分虚拟区都比内容区大；因此设置行高大小就等于设置虚假区的大小。 因为虚拟区上下两边都相等，所以字体的实际大小在虚拟区之间。  line-box  line-box（行框）是承载文字内容的必要条件，如果没有行框，文字将无法显示。 当有多行行盒排列时，每一行的区域就叫做 line-box，line-box 的顶边是该行所有行盒的最顶边，底边是该行行盒的最低底边。即一个行盒的实际占用高度是通过 line-box 计算的。  不生成 line-box 的情况","title":"Css 字体"},{"content":"删除文件 git rm FileName 命令git rm用于删除一个文件。\n如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容\n删错文件怎么办 有时候，你误删了一个文件 FileName，但因为版本库里还有，所以可以使用git checkout -- FileName把误删的文件恢复到最新版本\ngit checkout -- FileName ","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/","summary":"删除文件 git rm FileName 命令git rm用于删除一个文件。\n如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容\n删错文件怎么办 有时候，你误删了一个文件 FileName，但因为版本库里还有，所以可以使用git checkout -- FileName把误删的文件恢复到最新版本\ngit checkout -- FileName ","title":"Git 删除文件"},{"content":"文本溢出处理 实现单行文本的溢出显示省略号可以直接用 text-overflow:ellipsis 属性来实现，当然还需要加宽度width属来兼容部分浏览。\noverflow: hidden; text-overflow: ellipsis; white-space: nowrap; ","permalink":"https://note.yxzi.xyz/note/technology/language/css/%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86/","summary":"文本溢出处理 实现单行文本的溢出显示省略号可以直接用 text-overflow:ellipsis 属性来实现，当然还需要加宽度width属来兼容部分浏览。\noverflow: hidden; text-overflow: ellipsis; white-space: nowrap; ","title":"Css 文本溢出处理"},{"content":"渐变 background-image: linear-gradient(rgb(48, 47, 47), rgb(177, 177, 175)); ","permalink":"https://note.yxzi.xyz/note/technology/language/css/%E6%B8%90%E5%8F%98/","summary":"渐变 background-image: linear-gradient(rgb(48, 47, 47), rgb(177, 177, 175)); ","title":"Css 渐变"},{"content":"自适应布局 @media screen and (min-width: 720px) { \t/* 当浏览器宽度大于 value 时所应用的样式 */ }  @media screen and (max-width: value) { \t/* 当浏览器宽度小于 value 时所应用的样式*/ } ","permalink":"https://note.yxzi.xyz/note/technology/language/css/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/","summary":"自适应布局 @media screen and (min-width: 720px) { \t/* 当浏览器宽度大于 value 时所应用的样式 */ }  @media screen and (max-width: value) { \t/* 当浏览器宽度小于 value 时所应用的样式*/ } ","title":"Css 自适应布局"},{"content":"git status 查看当前 git 的状态，即查看工作区代码相对于暂存区的差别。比如哪些文件还在工作区（还没git add）、哪些文件还在暂存区（还没git commit）等等，及时了解当前的 git 状态可以避免一些误操作。\n但git status并不能让我们知道这些文件具体修改了什么内容。\n","permalink":"https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-status/","summary":"git status 查看当前 git 的状态，即查看工作区代码相对于暂存区的差别。比如哪些文件还在工作区（还没git add）、哪些文件还在暂存区（还没git commit）等等，及时了解当前的 git 状态可以避免一些误操作。\n但git status并不能让我们知道这些文件具体修改了什么内容。","title":"Git git status"},{"content":"每个人眼中的世界都不一样 说一个你们正常人一辈子不会有的体验，让你们感受下什么叫世界观崩塌。\n我天生左眼失明，但我居然在 7 岁才发现这一点。\n而之前无论我还是其他人都没意识到我有什么不正常。\n你们知道这意味着多恐怖的事情吗？这件事彻底刷新了我的世界观！\n因为\u0026quot;所有人没有意识到有什么不正常\u0026quot;本身就是最大的不正常。\n这意味着我们各自认知到的世界有可能根本就是完全不同的，而我们却没有察觉到这一点。\n我们虽然能“感觉”到同一个东西，但是这个东西在我们的认知中可能并不相同。\n普通人可能以为这种认知差别最多也就是红绿色盲和普通人的差别。\n而事实是这个差别可能大到人类无法想象的程度，而我们却意识不到。\n比如我左眼什么都看不到，但因为天生就如此，所以就把这种设定当作理所当然的事情接受了，而没有感到任何不妥！\n更进一步的说。\n如果这种个体世界观的差异不影响这个世界逻辑自洽性。\n那我们可能一辈子都生活在“人生而平等”的错觉中而没法发现，就像很多红绿色盲一辈子没意识到自己的认知有问题。\n我们以为其他人认知中的世界和自己认知中的世界是一样的，然而事实是，如果我们不一样你也不一定意识得到。\n而且即便我们意识到了我们各自的脑内世界不同，我们也没法沟通到底有哪里不同。\n我在知乎上提问过“两只眼睛看世界是什么体验？”，然而你们的回答我都看不太懂。\n我 7 岁以前一直以为我看到的世界就是你们看到的世界。\n直到我 7 岁第一次测视力，别人突然告诉我：\n你一直看到的认为理所当然的世界和别人看到的世界根本不是一回事。\n还有比这更细思恐极的吗？\n","permalink":"https://note.yxzi.xyz/note/view/thinking/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E7%9C%BC%E4%B8%AD%E7%9A%84%E4%B8%96%E7%95%8C%E9%83%BD%E4%B8%8D%E4%B8%80%E6%A0%B7/","summary":"每个人眼中的世界都不一样 说一个你们正常人一辈子不会有的体验，让你们感受下什么叫世界观崩塌。\n我天生左眼失明，但我居然在 7 岁才发现这一点。\n而之前无论我还是其他人都没意识到我有什么不正常。\n你们知道这意味着多恐怖的事情吗？这件事彻底刷新了我的世界观！\n因为\u0026quot;所有人没有意识到有什么不正常\u0026quot;本身就是最大的不正常。\n这意味着我们各自认知到的世界有可能根本就是完全不同的，而我们却没有察觉到这一点。\n我们虽然能“感觉”到同一个东西，但是这个东西在我们的认知中可能并不相同。\n普通人可能以为这种认知差别最多也就是红绿色盲和普通人的差别。\n而事实是这个差别可能大到人类无法想象的程度，而我们却意识不到。\n比如我左眼什么都看不到，但因为天生就如此，所以就把这种设定当作理所当然的事情接受了，而没有感到任何不妥！\n更进一步的说。\n如果这种个体世界观的差异不影响这个世界逻辑自洽性。\n那我们可能一辈子都生活在“人生而平等”的错觉中而没法发现，就像很多红绿色盲一辈子没意识到自己的认知有问题。\n我们以为其他人认知中的世界和自己认知中的世界是一样的，然而事实是，如果我们不一样你也不一定意识得到。\n而且即便我们意识到了我们各自的脑内世界不同，我们也没法沟通到底有哪里不同。\n我在知乎上提问过“两只眼睛看世界是什么体验？”，然而你们的回答我都看不太懂。\n我 7 岁以前一直以为我看到的世界就是你们看到的世界。\n直到我 7 岁第一次测视力，别人突然告诉我：\n你一直看到的认为理所当然的世界和别人看到的世界根本不是一回事。\n还有比这更细思恐极的吗？","title":"每个人眼中的世界都不一样"},{"content":"table 空隙 如果可能，边框会合并为一个单一的边框。会忽略 border-spacing 和 empty-cells 属性。\nborder-collapse: collapse; ","permalink":"https://note.yxzi.xyz/note/technology/language/css/table-%E7%A9%BA%E9%9A%99/","summary":"table 空隙 如果可能，边框会合并为一个单一的边框。会忽略 border-spacing 和 empty-cells 属性。\nborder-collapse: collapse; ","title":"Css table 空隙"},{"content":"年纪轻轻思想深度就高于常人 我相信的确有这么一部分人，年纪轻轻却有着远超同龄人或者常人的思想跟经验，\n但我觉得这不只是可以靠饱读诗书而获得，读书可以得到丰富的知识跟培养文学素养，\n可如果真的说想让人变得成熟和获得思想深度，我更愿意相信的是：他们有着不同于同龄人或者常人的生活经历。\n我记得现在大热电视剧《猎场》里面，胡歌饰演的郑秋冬因为刚刚出狱想给自己简历洗白所以造假冒充高材生铤而走险去参加面试，\n虽然违背了职业道德甚至有违法嫌疑但是面试临场的应对自如，口才出色给面试官都营造了很好的第一印象。\n其中有一幕是一个面试官问他说他刚刚讲说中用了一个形容词：牢房的叮咬感，\n从而问他是不是有监狱生活，当时郑秋冬掩饰住了自己的紧张跟心虚，说没有体验过并问面试官为何这么问，\n面试官说因为自己曾经在看守所呆过一夜，所以能真切感受到他所表达的这种感触。\n当然，我们不能否认，有时候人们表达自己的看法并不一定要有同样的体验才有发言权，\n只能说是拥有真切的感受才会使得流露出的情感更加具有感染力与说服力。\n","permalink":"https://note.yxzi.xyz/note/view/thinking/%E5%B9%B4%E7%BA%AA%E8%BD%BB%E8%BD%BB%E6%80%9D%E6%83%B3%E6%B7%B1%E5%BA%A6%E5%B0%B1%E9%AB%98%E4%BA%8E%E5%B8%B8%E4%BA%BA/","summary":"年纪轻轻思想深度就高于常人 我相信的确有这么一部分人，年纪轻轻却有着远超同龄人或者常人的思想跟经验，\n但我觉得这不只是可以靠饱读诗书而获得，读书可以得到丰富的知识跟培养文学素养，\n可如果真的说想让人变得成熟和获得思想深度，我更愿意相信的是：他们有着不同于同龄人或者常人的生活经历。\n我记得现在大热电视剧《猎场》里面，胡歌饰演的郑秋冬因为刚刚出狱想给自己简历洗白所以造假冒充高材生铤而走险去参加面试，\n虽然违背了职业道德甚至有违法嫌疑但是面试临场的应对自如，口才出色给面试官都营造了很好的第一印象。\n其中有一幕是一个面试官问他说他刚刚讲说中用了一个形容词：牢房的叮咬感，\n从而问他是不是有监狱生活，当时郑秋冬掩饰住了自己的紧张跟心虚，说没有体验过并问面试官为何这么问，\n面试官说因为自己曾经在看守所呆过一夜，所以能真切感受到他所表达的这种感触。\n当然，我们不能否认，有时候人们表达自己的看法并不一定要有同样的体验才有发言权，\n只能说是拥有真切的感受才会使得流露出的情感更加具有感染力与说服力。","title":"年纪轻轻思想深度就高于常人"},{"content":"修改网页滚动条样式 属性描述 /* 整个滚动条*/ ::-webkit-scrollbar { }  /* 滚动条两端的按钮 */ ::-webkit-scrollbar-button { }  /* 滚动条的滚动轨道 */ ::-webkit-scrollbar-track { }  /* 内层轨道 */ ::-webkit-scrollbar-track-piece { }  /* 滑块 */ ::-webkit-scrollbar-thumb { }  /* 边角 */ ::-webkit-scrollbar-corner { }  /* 右下角拖动块的样式 */ ::-webkit-resizer { } 使用 一般我们这样设置这几个主要属性就 OK 了。\n/*定义整个滚动条高宽及背景：高宽分别对应横竖滚动条的尺寸*/ ::-webkit-scrollbar { \twidth: 10px; \tbackground-color: #f5f5f5; } /*定义滚动条轨道：内阴影 + 圆角*/ ::-webkit-scrollbar-track { \tbackground-color: #f5f5f5; } /*定义滑块：内阴影 + 圆角*/ ::-webkit-scrollbar-thumb { \tborder-radius: 10px; \tbackground-color: #555; } 更多相关属性 :horizontal //水平方向的滚动条 :vertical //垂直 方向的滚动条 :decrement //应用于按钮和内层轨道(track piece)。它用来指示按钮或者内层轨道是否会减小视窗的位置(比如，垂直滚动条的上面，水平滚动条的左边。) :increment //decrement类似，用来指示按钮或内层轨道是否会增大视窗的位置(比如，垂直滚动条的下面和水平滚动条的右边。) :start //伪类也应用于按钮和滑块。它用来定义对象是否放到滑块的前面。 :end //类似于start伪类，标识对象是否放到滑块的后面。 :double-button //该伪类以用于按钮和内层轨道。用于判断一个按钮是不是放在滚动条同一端的一对按钮中的一个。对于内层轨道来说，它表示内层轨道是否紧靠一对按钮。 :single-button //类似于double-button伪类。对按钮来说，它用于判断一个按钮是否自己独立的在滚动条的一段。对内层轨道来说，它表示内层轨道是否紧靠一个single-button。 :no-button //用于内层轨道，表示内层轨道是否要滚动到滚动条的终端，比如，滚动条两端没有按钮的时候。 :corner-present //用于所有滚动条轨道，指示滚动条圆角是否显示。 :window-inactive //用于所有的滚动条轨道，指示应用滚动条的某个页面容器(元素)是否当前被激活。 ","permalink":"https://note.yxzi.xyz/note/technology/language/css/%E4%BF%AE%E6%94%B9%E7%BD%91%E9%A1%B5%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F/","summary":"修改网页滚动条样式 属性描述 /* 整个滚动条*/ ::-webkit-scrollbar { }  /* 滚动条两端的按钮 */ ::-webkit-scrollbar-button { }  /* 滚动条的滚动轨道 */ ::-webkit-scrollbar-track { }  /* 内层轨道 */ ::-webkit-scrollbar-track-piece { }  /* 滑块 */ ::-webkit-scrollbar-thumb { }  /* 边角 */ ::-webkit-scrollbar-corner { }  /* 右下角拖动块的样式 */ ::-webkit-resizer { } 使用 一般我们这样设置这几个主要属性就 OK 了。\n/*定义整个滚动条高宽及背景：高宽分别对应横竖滚动条的尺寸*/ ::-webkit-scrollbar { \twidth: 10px; \tbackground-color: #f5f5f5; } /*定义滚动条轨道：内阴影 + 圆角*/ ::-webkit-scrollbar-track { \tbackground-color: #f5f5f5; } /*定义滑块：内阴影 + 圆角*/ ::-webkit-scrollbar-thumb { \tborder-radius: 10px; \tbackground-color: #555; } 更多相关属性 :horizontal //水平方向的滚动条 :vertical //垂直 方向的滚动条 :decrement //应用于按钮和内层轨道(track piece)。它用来指示按钮或者内层轨道是否会减小视窗的位置(比如，垂直滚动条的上面，水平滚动条的左边。) :increment //decrement类似，用来指示按钮或内层轨道是否会增大视窗的位置(比如，垂直滚动条的下面和水平滚动条的右边。) :start //伪类也应用于按钮和滑块。它用来定义对象是否放到滑块的前面。 :end //类似于start伪类，标识对象是否放到滑块的后面。 :double-button //该伪类以用于按钮和内层轨道。用于判断一个按钮是不是放在滚动条同一端的一对按钮中的一个。对于内层轨道来说，它表示内层轨道是否紧靠一对按钮。 :single-button //类似于double-button伪类。对按钮来说，它用于判断一个按钮是否自己独立的在滚动条的一段。对内层轨道来说，它表示内层轨道是否紧靠一个single-button。 :no-button //用于内层轨道，表示内层轨道是否要滚动到滚动条的终端，比如，滚动条两端没有按钮的时候。 :corner-present //用于所有滚动条轨道，指示滚动条圆角是否显示。 :window-inactive //用于所有的滚动条轨道，指示应用滚动条的某个页面容器(元素)是否当前被激活。 ","title":"Css 修改网页滚动条样式"},{"content":"Body 背景图 画布 它是一块区域，也叫视口（可视窗口）。\n它的最小宽度为视口宽度，最小高度为视口高度。\nHtml 的背景图 该元素的背景覆盖画布。即给该元素设置背景，相当于设置画布的背景。\nBody 的背景图 若根元素有背景，body 元素的背景正常显示。\n若根元素没有设置背景，则 body 元素的背景覆盖画布，则会出现不正常的现象，原因为若没有这个规则，就无法给整个网页设置背景。\n背景图覆盖画布时 高度：纵向位置百分比、预设值，相对于根元素高度。\n宽度：横向位置百分比、预设值，相对于视口。\n","permalink":"https://note.yxzi.xyz/note/technology/language/css/body-%E8%83%8C%E6%99%AF%E5%9B%BE/","summary":"Body 背景图 画布 它是一块区域，也叫视口（可视窗口）。\n它的最小宽度为视口宽度，最小高度为视口高度。\nHtml 的背景图 该元素的背景覆盖画布。即给该元素设置背景，相当于设置画布的背景。\nBody 的背景图 若根元素有背景，body 元素的背景正常显示。\n若根元素没有设置背景，则 body 元素的背景覆盖画布，则会出现不正常的现象，原因为若没有这个规则，就无法给整个网页设置背景。\n背景图覆盖画布时 高度：纵向位置百分比、预设值，相对于根元素高度。\n宽度：横向位置百分比、预设值，相对于视口。","title":"Css Body 背景图"},{"content":"Css keyframes 持续旋转 选中文档中的元素。\n.map2 { \twidth: 8.0375rem; \theight: 8.0375rem; \tbackground-image: url(../images/lbx.png); \topacity: 0.6; \tanimation: rotate 15s linear infinite; \tz-index: 2; } keyframes @keyframes rotate { \t/* 从 0° 开始旋转 */ \tfrom { \ttransform: translate(-50%, -50%) rotate(0deg); \t} \t/* 旋转到 360 ° */ \tto { \ttransform: translate(-50%, -50%) rotate(360deg); \t} } ","permalink":"https://note.yxzi.xyz/note/technology/language/css/keyframes/","summary":"Css keyframes 持续旋转 选中文档中的元素。\n.map2 { \twidth: 8.0375rem; \theight: 8.0375rem; \tbackground-image: url(../images/lbx.png); \topacity: 0.6; \tanimation: rotate 15s linear infinite; \tz-index: 2; } keyframes @keyframes rotate { \t/* 从 0° 开始旋转 */ \tfrom { \ttransform: translate(-50%, -50%) rotate(0deg); \t} \t/* 旋转到 360 ° */ \tto { \ttransform: translate(-50%, -50%) rotate(360deg); \t} } ","title":"Css keyframes"},{"content":"italic 和 oblique italic：浏览器会显示一个斜体的字体样式。\noblique：浏览器会显示一个倾斜的字体样式。\n可以发现关键之处为斜体和倾斜。\nItalic 是使用了文字本身的斜体属性，\noblique 是让没有斜体属性的文字做倾斜处理。\n因为有少量的不常用字体没有斜体的属性，\n如果我们使用 Italic 就会没有效果，只能 Oblique 使用才能使文字倾斜。\n","permalink":"https://note.yxzi.xyz/note/technology/language/css/italic-%E5%92%8C-oblique/","summary":"italic 和 oblique italic：浏览器会显示一个斜体的字体样式。\noblique：浏览器会显示一个倾斜的字体样式。\n可以发现关键之处为斜体和倾斜。\nItalic 是使用了文字本身的斜体属性，\noblique 是让没有斜体属性的文字做倾斜处理。\n因为有少量的不常用字体没有斜体的属性，\n如果我们使用 Italic 就会没有效果，只能 Oblique 使用才能使文字倾斜。","title":"italic 和 oblique"},{"content":"语法 CSS 的语法通常是一个选择器，用于选择 HTML 文档中的元素。\n选择器：位于语法开始，用于选中 HTML 文档中的元素。\n声明：以 { 开始，以 } 结束。{ 与 } 必须成对出现。\n声明块：由属性与属性值组成。\n.selector { \tcolor: #000; } 使用 内联式：将 CSS 语法书写到元素的 style 属性中，仅对当前元素生效，也叫行内式。\n内嵌式：首先将 style 元素书写到 head 元素中，然后将 CSS 语法书写到 style 元素中，也叫内部样式表。\n外链式：将 CSS 语法书写到独立的 CSS 文件中，并在 HTML 文档中使用 link 元素引入，也叫外部样式表。\n优先级：内联式 \u0026gt; 内嵌式 \u0026gt; 外链式。\n","permalink":"https://note.yxzi.xyz/note/technology/language/css/%E8%AF%AD%E6%B3%95/","summary":"语法 CSS 的语法通常是一个选择器，用于选择 HTML 文档中的元素。\n选择器：位于语法开始，用于选中 HTML 文档中的元素。\n声明：以 { 开始，以 } 结束。{ 与 } 必须成对出现。\n声明块：由属性与属性值组成。\n.selector { \tcolor: #000; } 使用 内联式：将 CSS 语法书写到元素的 style 属性中，仅对当前元素生效，也叫行内式。\n内嵌式：首先将 style 元素书写到 head 元素中，然后将 CSS 语法书写到 style 元素中，也叫内部样式表。\n外链式：将 CSS 语法书写到独立的 CSS 文件中，并在 HTML 文档中使用 link 元素引入，也叫外部样式表。\n优先级：内联式 \u0026gt; 内嵌式 \u0026gt; 外链式。","title":"Css 语法"},{"content":"块格式化上下文 格式化上下文（Block Formatting Context），它是一块 独立的渲染区域，它规定了在该区域中，普通流块盒的布局。\n触发 BFC 的元素  根元素 html，该元素创建的 BFC 覆盖了文档中的所有元素。 浮动元素，float 的值不为 none 的元素。 绝对定位元素，position 的值为 absolute 或 fixed 的元素。 overflow 的值不为 visible 的块盒。 行块盒，display 的值为 inline-block 的元素。 表格单元格，display 的值为 table-cell 的元素，表格单元格默认为该值。 表格标题，display 的值为 table-caption 的元素，表格标题默认为该值。  正常布局流块盒的渲染区域  每个块盒都会参与块格式化上下文的创建。 不同的 BFC，它们进行渲染时互不干扰。 创建 BFC 的元素，隔绝了它内部和外部的联系，内部的渲染不会影响到外部区域。 创建 BFC 的元素，它的所有内容都会被包含在它所创建的 BFC 中  BFC 的作用 解决高度塌陷\n创建 BFC 的元素，它的自动高度会计算浮动元素；若只是为了创建 BFC 一般使用副作用最小的方式：设置块盒的 overflow 的属性值为 hidden。仅仅是为了解决高度坍塌，建议使用伪元素 after。\n原理：因为它要隔绝内部与外部的关系，而高度坍塌会使元素不在其包含块内，所以它的自动高度必须计算浮动元素，因此创建 BFC 可以解决高度坍塌的问题。\n解决浮动流脱离文档流\n创建了 BFC 的元素，普通流元素不会与浮动元素合并。\n原理：在一个浮动元素后面放一个正常布局流元素，默认情况下浮动元素会覆盖正常布局流元素，因此可以给普通流创建 BFC，即可解决浮动元素脱离文档流。类似于给正常布局流元素设置了 margin，使普通流元素刚好避开浮动元素。这时候可能给正常布局流元素设置 margin 会无效，因此可以设置浮动元素的 margin，使浮动元素的 margin 将正常布局流元素挤开。\n解决 margin 合并\n创建 BFC 的元素，不会和它的子元素发生 margin 合并。\n当两个元素处于两个不同的父元素创建的 BFC 时，它们的渲染是互不干扰的，因此两个元素的 margin 不会合并。\n注意：当两个子元素处于同一个父元素所创建的 BFC 时，则两个子元素的 margin 会合并。\n","permalink":"https://note.yxzi.xyz/note/technology/language/css/%E5%9D%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/","summary":"块格式化上下文 格式化上下文（Block Formatting Context），它是一块 独立的渲染区域，它规定了在该区域中，普通流块盒的布局。\n触发 BFC 的元素  根元素 html，该元素创建的 BFC 覆盖了文档中的所有元素。 浮动元素，float 的值不为 none 的元素。 绝对定位元素，position 的值为 absolute 或 fixed 的元素。 overflow 的值不为 visible 的块盒。 行块盒，display 的值为 inline-block 的元素。 表格单元格，display 的值为 table-cell 的元素，表格单元格默认为该值。 表格标题，display 的值为 table-caption 的元素，表格标题默认为该值。  正常布局流块盒的渲染区域  每个块盒都会参与块格式化上下文的创建。 不同的 BFC，它们进行渲染时互不干扰。 创建 BFC 的元素，隔绝了它内部和外部的联系，内部的渲染不会影响到外部区域。 创建 BFC 的元素，它的所有内容都会被包含在它所创建的 BFC 中  BFC 的作用 解决高度塌陷\n创建 BFC 的元素，它的自动高度会计算浮动元素；若只是为了创建 BFC 一般使用副作用最小的方式：设置块盒的 overflow 的属性值为 hidden。仅仅是为了解决高度坍塌，建议使用伪元素 after。\n原理：因为它要隔绝内部与外部的关系，而高度坍塌会使元素不在其包含块内，所以它的自动高度必须计算浮动元素，因此创建 BFC 可以解决高度坍塌的问题。\n解决浮动流脱离文档流","title":"Css 块格式化上下文"},{"content":"画三角形 .triangle { \twidth: 0; \theight: 0; \tborder-width: 50px; \tborder-style: solid; \tdisplay: inline-block; \tborder-color: transparent transparent #008c8c transparent; } ","permalink":"https://note.yxzi.xyz/note/technology/language/css/%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/","summary":"画三角形 .triangle { \twidth: 0; \theight: 0; \tborder-width: 50px; \tborder-style: solid; \tdisplay: inline-block; \tborder-color: transparent transparent #008c8c transparent; } ","title":"Css 画三角形"},{"content":"盒子模型 前言 在 CSS 中，每一个元素都可以看作是一个盒子，这个盒子由以下几个方面组成。目前常用的有两种盒模型，分别是标准盒模型和怪异盒模型。\n一个盒子的组成  内容（content） 内边距（padding） 边框（border） 外边距（margin）  标准盒模型 box-sizing 的值为 content-box 的元素；且浏览器将采用标准模式解析。\n盒子总宽度 = width + padding（左右）+ border（左右）+ margin（左右）。\n盒子总高度 = height + padding（上下）+ border（上下）+ margin（上下。\n怪异盒模型 box-sizing 的值为 border-box 的元素；且浏览器将采用怪异模式（兼容模式）解析，也叫 IE 盒模型。\n盒子总宽度 = width + margin（左右），其 width 包含了 padding（左右）和 border（左右）的宽度。\n盒子总高度 = width + margin（上下），其 height 包含了 padding（上下）和 border（上下）的高度。\n","permalink":"https://note.yxzi.xyz/note/technology/language/css/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/","summary":"盒子模型 前言 在 CSS 中，每一个元素都可以看作是一个盒子，这个盒子由以下几个方面组成。目前常用的有两种盒模型，分别是标准盒模型和怪异盒模型。\n一个盒子的组成  内容（content） 内边距（padding） 边框（border） 外边距（margin）  标准盒模型 box-sizing 的值为 content-box 的元素；且浏览器将采用标准模式解析。\n盒子总宽度 = width + padding（左右）+ border（左右）+ margin（左右）。\n盒子总高度 = height + padding（上下）+ border（上下）+ margin（上下。\n怪异盒模型 box-sizing 的值为 border-box 的元素；且浏览器将采用怪异模式（兼容模式）解析，也叫 IE 盒模型。\n盒子总宽度 = width + margin（左右），其 width 包含了 padding（左右）和 border（左右）的宽度。\n盒子总高度 = width + margin（上下），其 height 包含了 padding（上下）和 border（上下）的高度。","title":"Css 盒子模型"},{"content":"层叠上下文 它是一块区域，它由某个元素创建，它规定了该区域中的内容在 Z 轴上排列的先后顺序。\n它是一种 三维概念。所有的 HTML 元素都根据其元素的属性按照优先级顺序占据这个空间。\n规则 只有定位元素设置 z-index 有效。\n设置 z-index 值为负数的元素，会被正常流、浮动流覆盖。\nz-index 的值，该值越大，则越靠近用户。\n所有元素都处于 html 元素的层叠上下文中。\n如遇到 z-index 一样的层叠上下文，则比较元素的书写顺序。\n层叠上下文的元素，它本身永远被父级包含内，哪怕该元素设置了 z-index:-9999，它也只能包含于自身父元素的层叠上下文中。\n每一个层叠上下文的元素，它们都完全独立于同级的元素，当处理层叠上下文时只会考虑自己的子元素。\n创建层叠上下文的元素  根元素（html）。 Position 值为 absolute 或 relative 且 z-index 值不为 auto 的元素。 Opacity 的值小于 1 的元素。  优先级  同一个层叠上下文中，元素从底部到顶部的优先级 创建层叠上下文元素的背景和边框。 z-index 的值为负的层叠上下文元素。 常规流非定位元素的块盒。 非定位的浮动流。 常规流非定位行盒。 任何 z-index 属性值为 auto 的定位子元素，以及 z-index 为 0 的元素。 z-index 的值为正的元素。  ","permalink":"https://note.yxzi.xyz/note/technology/language/css/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/","summary":"层叠上下文 它是一块区域，它由某个元素创建，它规定了该区域中的内容在 Z 轴上排列的先后顺序。\n它是一种 三维概念。所有的 HTML 元素都根据其元素的属性按照优先级顺序占据这个空间。\n规则 只有定位元素设置 z-index 有效。\n设置 z-index 值为负数的元素，会被正常流、浮动流覆盖。\nz-index 的值，该值越大，则越靠近用户。\n所有元素都处于 html 元素的层叠上下文中。\n如遇到 z-index 一样的层叠上下文，则比较元素的书写顺序。\n层叠上下文的元素，它本身永远被父级包含内，哪怕该元素设置了 z-index:-9999，它也只能包含于自身父元素的层叠上下文中。\n每一个层叠上下文的元素，它们都完全独立于同级的元素，当处理层叠上下文时只会考虑自己的子元素。\n创建层叠上下文的元素  根元素（html）。 Position 值为 absolute 或 relative 且 z-index 值不为 auto 的元素。 Opacity 的值小于 1 的元素。  优先级  同一个层叠上下文中，元素从底部到顶部的优先级 创建层叠上下文元素的背景和边框。 z-index 的值为负的层叠上下文元素。 常规流非定位元素的块盒。 非定位的浮动流。 常规流非定位行盒。 任何 z-index 属性值为 auto 的定位子元素，以及 z-index 为 0 的元素。 z-index 的值为正的元素。  ","title":"Css 层叠上下文"},{"content":"爽文的价值 一部爽文的套路，如果我们把它的背景换一下，那么完全可以构造出不同的观感。\n假如更加彻底的改动，但是保留套路呢？\n能不能摇身一变，变成严肃文学？\n","permalink":"https://note.yxzi.xyz/note/view/read/%E7%88%BD%E6%96%87%E7%9A%84%E4%BB%B7%E5%80%BC/","summary":"爽文的价值 一部爽文的套路，如果我们把它的背景换一下，那么完全可以构造出不同的观感。\n假如更加彻底的改动，但是保留套路呢？\n能不能摇身一变，变成严肃文学？","title":"爽文的价值"},{"content":"层叠 层叠是 CSS 的一个基本特征，浏览器通过 优先级 来判断哪些属性值对一个元素最为重要，从而在这个元素上应用这些属性值。\n确定声明值 找出样式表中没有冲突的声明，并应用到 CSS 属性，样式声明不冲突则不会发生层叠。\n层叠 对样式表中有冲突（同一个元素在样式表中设置了多个相同的属性）的声明使用层叠规则。\n比较重要性\n 重要性由高到低为 样式表中的 !imliortant 样式（尽量不使用）。 样式表中的普通样式（内联式 \u0026gt; 内嵌式 \u0026gt; 外链式）。 浏览器中的默认样式。  比较优先级\n 选择器选中的范围越窄，优先级越高。 通过选择器，计算出一个四位数（xxxx），该四位数越大越则优先级越高。这个四位数的进制为逢 256 进一。 :nth-child()选择器会覆盖:hover选择器  四位数的取值\n  千位：内联样式，记作 1，否则记为 0。\n  百位：所有 id 选择器的数量。\n  十位：所有类选择器、属性选择器、伪类选择器的数量。\n  个位：元素选择器、伪元素选择器的数量。\n  零：通配符选择器。\n  比较源次序\nCSS 样式书写靠后的属性最终会应用到元素。\n继承 使用继承，对仍然没有值的属性，若可以继承（部分属性是不能继承的，通常情况下，只有跟文字内容有关的属性可以被继承。），则继承其父元素的属性。\n当元素的属性有默认值时，该元素一般不会继承父元素的属性。\n使用默认值 每个 CSS 在属性都会有默认值，当继承结束后，对于仍然没有值的属性，会使用默认值。\n","permalink":"https://note.yxzi.xyz/note/technology/language/css/%E5%B1%82%E5%8F%A0/","summary":"层叠 层叠是 CSS 的一个基本特征，浏览器通过 优先级 来判断哪些属性值对一个元素最为重要，从而在这个元素上应用这些属性值。\n确定声明值 找出样式表中没有冲突的声明，并应用到 CSS 属性，样式声明不冲突则不会发生层叠。\n层叠 对样式表中有冲突（同一个元素在样式表中设置了多个相同的属性）的声明使用层叠规则。\n比较重要性\n 重要性由高到低为 样式表中的 !imliortant 样式（尽量不使用）。 样式表中的普通样式（内联式 \u0026gt; 内嵌式 \u0026gt; 外链式）。 浏览器中的默认样式。  比较优先级\n 选择器选中的范围越窄，优先级越高。 通过选择器，计算出一个四位数（xxxx），该四位数越大越则优先级越高。这个四位数的进制为逢 256 进一。 :nth-child()选择器会覆盖:hover选择器  四位数的取值\n  千位：内联样式，记作 1，否则记为 0。\n  百位：所有 id 选择器的数量。\n  十位：所有类选择器、属性选择器、伪类选择器的数量。\n  个位：元素选择器、伪元素选择器的数量。\n  零：通配符选择器。\n  比较源次序\nCSS 样式书写靠后的属性最终会应用到元素。\n继承 使用继承，对仍然没有值的属性，若可以继承（部分属性是不能继承的，通常情况下，只有跟文字内容有关的属性可以被继承。），则继承其父元素的属性。\n当元素的属性有默认值时，该元素一般不会继承父元素的属性。\n使用默认值 每个 CSS 在属性都会有默认值，当继承结束后，对于仍然没有值的属性，会使用默认值。","title":"Css 层叠"},{"content":"break 用于终止循环或退出 switch.\n不能直接用于 if，除非 if 是循环的一个子句。\n","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/break/","summary":"break 用于终止循环或退出 switch.\n不能直接用于 if，除非 if 是循环的一个子句。","title":"C break"},{"content":"自增与自减 前自增++i与后自增 i++.\n异同 相同\n最终都会使 i 的值加 1.\n不同\ni++返回原来的值，\n++i返回加 1 后的值。\n#include \u0026lt;stdio.h\u0026gt; int main() {  int a,b,c,d;  a = b = 3;  // return 3  c = a++;  // return 4  d = ++b;  printf(\u0026#34;c = %d\\nd = %d\u0026#34;,c,d);  return 0; } ","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E8%87%AA%E5%A2%9E%E4%B8%8E%E8%87%AA%E5%87%8F/","summary":"自增与自减 前自增++i与后自增 i++.\n异同 相同\n最终都会使 i 的值加 1.\n不同\ni++返回原来的值，\n++i返回加 1 后的值。\n#include \u0026lt;stdio.h\u0026gt; int main() {  int a,b,c,d;  a = b = 3;  // return 3  c = a++;  // return 4  d = ++b;  printf(\u0026#34;c = %d\\nd = %d\u0026#34;,c,d);  return 0; } ","title":"C 自增与自减"},{"content":"预备知识 六大硬件的关系 双击（操作系统给用户提供的一个操作）打开一个存放在硬盘中的视频。\n因为 CPU 并不能直接处理硬盘上的数据，所以会将硬盘上的视频数据拷贝到内存中。\nCPU 再对内存中的数据进行处理。\n因为 CPU、内存、显卡（控制显示器的正确显示）、硬盘都是安装在主板上的，因此主板是一个组织它们如何有效运行的硬件。\n程序是如何运行的 编译 —— 建立链接（生成一个格式为 exe 的可执行文件）—— 调用操作系统，操作系统再调用 CPU 并执行这个 exe 文件，最后会在显示器上看到这个软件的运行结果 。\n软件不能直接控制硬件。\n什么是变量 变量的本质是将一个空闲的内存空间与某个变量产生联系。\nint a; //调用操作系统在内存条中创建一个空的内存空间，并将变量 a 自动分配到该内存空间中，使得变量 a 与该内存空间的地址编号产生一个一一对应的关系 a = 3; //将 3 放入变量 a 的内存空间内。  软件运行与内存的关系 一个软件在运行前需要请求操作系统将硬盘中的数据拷贝到内存中，并使用 CPU 启动该软件。\n一个软件运行时，它所占的储存空间不会再分配给其他程序使用。\n当软件运行完毕后，操作系统将释放该储存空间，（但操作系统并不会清空该内存空间中软件残留下来的数据，所以下次使用该内存空间时，很可能该内存空间中存在着其他软件所残留的垃圾数据。），以便再次分配给其他软件使用。\n常量的表示 整数。 八进制：前面加 0 ，018。\n十进制：传统写法，18。\n十六进制：前面加 0x 或 0X，0x18。\n浮点数。 传统写法，1.8。\n科学计数法，1.8e2（1.8 * 10 的 2 次方）。\n字符 单个字符用单引号括起来，\u0026lsquo;Y\u0026rsquo;。\n多个字符或单个字符都可以用双引号括起来，所有的字符串都会在末尾添加 \\0（结束符），\u0026ldquo;Y\\0\u0026rdquo;。\n常量是怎么存储在计算机中的 整数是以补码的形式转换为二进制储存在计算机中。\n实数是以 IEEE754 标准转换为二进制储存在计算机中 。\n字符是先通过 ASCII 码转换为整数，再以补码的形式换为二进制储存在计算机中。\n字节 字节（Byte）是计算数据容量的一种计量单位，也是硬件（CPU）所能访问的最小单位。\n一个字节存储 8 位（位是硬件的最小存储单位）无符号数，储存的数值范围为 0-255。\nchar 常见问题 char 的整数值是 ASCII 码 ，因此字符的存储方式与整数相同。\n双引号中的字符可以有一个或多个。\n单引号中的字符只能有一个。\n双引号中的字符串，不能赋给单个 char 字符类型的变量。\nASCII 码 它不是某种值，它是一种规范标准，它规定了不同的 char 字符应该用哪个整数表示这个 char 字符。\n运算符优先级 算术 \u0026gt; 关系 \u0026gt; 逻辑 \u0026gt; 赋值。\n","permalink":"https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/","summary":"预备知识 六大硬件的关系 双击（操作系统给用户提供的一个操作）打开一个存放在硬盘中的视频。\n因为 CPU 并不能直接处理硬盘上的数据，所以会将硬盘上的视频数据拷贝到内存中。\nCPU 再对内存中的数据进行处理。\n因为 CPU、内存、显卡（控制显示器的正确显示）、硬盘都是安装在主板上的，因此主板是一个组织它们如何有效运行的硬件。\n程序是如何运行的 编译 —— 建立链接（生成一个格式为 exe 的可执行文件）—— 调用操作系统，操作系统再调用 CPU 并执行这个 exe 文件，最后会在显示器上看到这个软件的运行结果 。\n软件不能直接控制硬件。\n什么是变量 变量的本质是将一个空闲的内存空间与某个变量产生联系。\nint a; //调用操作系统在内存条中创建一个空的内存空间，并将变量 a 自动分配到该内存空间中，使得变量 a 与该内存空间的地址编号产生一个一一对应的关系 a = 3; //将 3 放入变量 a 的内存空间内。  软件运行与内存的关系 一个软件在运行前需要请求操作系统将硬盘中的数据拷贝到内存中，并使用 CPU 启动该软件。\n一个软件运行时，它所占的储存空间不会再分配给其他程序使用。\n当软件运行完毕后，操作系统将释放该储存空间，（但操作系统并不会清空该内存空间中软件残留下来的数据，所以下次使用该内存空间时，很可能该内存空间中存在着其他软件所残留的垃圾数据。），以便再次分配给其他软件使用。\n常量的表示 整数。 八进制：前面加 0 ，018。\n十进制：传统写法，18。\n十六进制：前面加 0x 或 0X，0x18。\n浮点数。 传统写法，1.8。\n科学计数法，1.8e2（1.8 * 10 的 2 次方）。\n字符 单个字符用单引号括起来，\u0026lsquo;Y\u0026rsquo;。\n多个字符或单个字符都可以用双引号括起来，所有的字符串都会在末尾添加 \\0（结束符），\u0026ldquo;Y\\0\u0026rdquo;。\n常量是怎么存储在计算机中的 整数是以补码的形式转换为二进制储存在计算机中。","title":"C 预备知识"},{"content":"布局 正常流布局  默认情况下，所有元素都属于正常流。 块盒独占一行。 行盒水平依次排列。 包含块：每个盒子都有它的包含块，包含块决定了该盒子的排列范围。 在正常布局流中，元素的包含块，都是该元素父元素的内容盒。  margin 合并 多个同级且相邻的正常布局流块盒，当它们的上下margin相邻，则会合并为一个margin。\n 两个外边距值都是正数，则取较大值； 两个值都是负数，则取较大值； 一正一负则取两个值的和，  该情况可以触发 BFC 解决。\nmargin 塌陷 正常布局流中的呈父子关系的块盒，如果父元素没有设置上下内边距或上下边框，则子元素的上下margin就会和父元素的上下margin重合，且这时如果设置子元素的上下margin，相当于设置父元素的margin。\n该情况可以触发 BFC 解决。\n浮动流布局  使元素向左上或向右上排列。 通常情况，浮动元素会无视正常布局元素，它会将正常布局元素覆盖。 在一行浮动元素中，若父元素装不下所有的浮动元素，则多余的浮动元素会自动向下移动，直到具备足够的空间能容纳这些多余的浮动元素，才向左或向右移动。 行盒在排列时，默认会避开浮动元素（单独的文字也是行盒，因为浏览器会自动生成一个行盒包裹单独的文字，该行盒为匿名行盒）。 浮动元素一定是块盒。 不会发生 margin 合并。 脱离正常布局流。  高度塌陷 正常布局流元素高度自适应，它的子元素浮动后，该元素在计算高度时，不会考虑浮动后的子元素的高度，则会导致该元素高度为 0，这种情况称为高度塌陷。\n解决：\n利用伪元素 after 清除浮动即可解决。\n定位流布局 使一个元素从它原本在正常布局流中应该在的位置移动到另一个位置。\n相对定位   使元素在原来位置上进行偏移；若没有设置偏移量，对元素本身没有任何影响。\n  提升元素层级（z-index）。\n  盒子的偏移不会对其他盒子造成任何影响。\n  脱离正常布局流。\n  尽管元素被偏移了，但它仍然占据着它没偏移前的空间。\n  绝对定位   它相对于 static 定位以外的第一个父元素进行定位；若没有，则它的包含块为整个网页（初始化包含块），原位置不会被保留。\n  一定是块盒且不是浮动元素。\n  提升元素层级。\n  宽高为 auto（自适应内容）。\n  使元素完全脱离正常布局流。\n  固定定位   生成绝对定位的元素，相对于浏览器视口进行定位，原位置不会被保留。\n  当向下滚动页面时固定定位元素不会随着页面滚动所移动。\n  ","permalink":"https://note.yxzi.xyz/note/technology/language/css/%E5%B8%83%E5%B1%80/","summary":"布局 正常流布局  默认情况下，所有元素都属于正常流。 块盒独占一行。 行盒水平依次排列。 包含块：每个盒子都有它的包含块，包含块决定了该盒子的排列范围。 在正常布局流中，元素的包含块，都是该元素父元素的内容盒。  margin 合并 多个同级且相邻的正常布局流块盒，当它们的上下margin相邻，则会合并为一个margin。\n 两个外边距值都是正数，则取较大值； 两个值都是负数，则取较大值； 一正一负则取两个值的和，  该情况可以触发 BFC 解决。\nmargin 塌陷 正常布局流中的呈父子关系的块盒，如果父元素没有设置上下内边距或上下边框，则子元素的上下margin就会和父元素的上下margin重合，且这时如果设置子元素的上下margin，相当于设置父元素的margin。\n该情况可以触发 BFC 解决。\n浮动流布局  使元素向左上或向右上排列。 通常情况，浮动元素会无视正常布局元素，它会将正常布局元素覆盖。 在一行浮动元素中，若父元素装不下所有的浮动元素，则多余的浮动元素会自动向下移动，直到具备足够的空间能容纳这些多余的浮动元素，才向左或向右移动。 行盒在排列时，默认会避开浮动元素（单独的文字也是行盒，因为浏览器会自动生成一个行盒包裹单独的文字，该行盒为匿名行盒）。 浮动元素一定是块盒。 不会发生 margin 合并。 脱离正常布局流。  高度塌陷 正常布局流元素高度自适应，它的子元素浮动后，该元素在计算高度时，不会考虑浮动后的子元素的高度，则会导致该元素高度为 0，这种情况称为高度塌陷。\n解决：\n利用伪元素 after 清除浮动即可解决。\n定位流布局 使一个元素从它原本在正常布局流中应该在的位置移动到另一个位置。\n相对定位   使元素在原来位置上进行偏移；若没有设置偏移量，对元素本身没有任何影响。\n  提升元素层级（z-index）。\n  盒子的偏移不会对其他盒子造成任何影响。\n  脱离正常布局流。\n  尽管元素被偏移了，但它仍然占据着它没偏移前的空间。\n  绝对定位   它相对于 static 定位以外的第一个父元素进行定位；若没有，则它的包含块为整个网页（初始化包含块），原位置不会被保留。","title":"Css 布局"},{"content":"Github Github 不但可以是一个个人的免费仓库，它还是一个开源协作社区，通过 GitHub ，既可以让别人参与你的开源项目，也可以参与别人的开源项目。\n参与一个的开源项目 克隆他人的开源项目 访问该项目的主页。\n点击Fork先克隆这个的项目到自己的远程仓库中。\n使用git clone将这个项目从自己的远程仓库中clone到本地。\ngit clone git@github.com:YxzRainy/YxzRainy.github.io.git 一定要从自己的账号下 clone 仓库，这样你才能推送修改。如果从别人的仓库地址克隆，你将不能推送修改，因为你没有权限。\n如果你想修复这个开源的一个 bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。\n","permalink":"https://note.yxzi.xyz/note/technology/git/github/github/","summary":"Github Github 不但可以是一个个人的免费仓库，它还是一个开源协作社区，通过 GitHub ，既可以让别人参与你的开源项目，也可以参与别人的开源项目。\n参与一个的开源项目 克隆他人的开源项目 访问该项目的主页。\n点击Fork先克隆这个的项目到自己的远程仓库中。\n使用git clone将这个项目从自己的远程仓库中clone到本地。\ngit clone git@github.com:YxzRainy/YxzRainy.github.io.git 一定要从自己的账号下 clone 仓库，这样你才能推送修改。如果从别人的仓库地址克隆，你将不能推送修改，因为你没有权限。\n如果你想修复这个开源的一个 bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。","title":"Github"},{"content":"Hexo 将博客作为站点子页面 前言 如果你想如何在 GitHub 的 repository 中上传自己写的网页作为首页，hexo 生成的博客页作为其子页？即自己写的页面作为 UserName.github.io 的页面，将 hexo 博客放在 UserName.github.io/blog 上，那么，这个教程也许可以帮到你。\n本教程的前提是你已经用 hexo 将博客搭建在 UserName.github.io 的仓库上了。\n新建仓库 在 github 上新建一个仓库，名字随意，我的是 Blog。\n然后本地初始化一个 master 分支，并且将原仓库 clone 到本地分支，并且 开启仓库的 GitHub Pages.，需要注意的是，这里的本地分支目前是没有 CNAME 文件 的。\n修改 Hexo 的配置文件 打开配置文件 _config.yml，找到 #URL 下的 url 和 root，将 url 修改为https:// UesrName.github.io/新建的仓库名（我这里是 Blog），然后将 root 修改为**/新建的仓库名/**。\n# URL ## Set your site url here. For example, if you use GitHub Page, set url as \u0026#39;https://username.github.io/project\u0026#39; url: https://YxzRainy.github.io/Blog root: /Blog/ 再下滑找到 deploy:下的 repo，将地址改为你新建的 Clone 地址。\ndeploy:  type: git  repo: git@github.com:YxzRainy/Space.git  branch: master 重新部署博客 在新建的本地分支依次输入命令\nhexo clean\rhexo g\rhexo d 这样你的博客就已经被部署到 https://UserName.github.io/Space/ 上了\n清空原来的仓库 现在可以将原来的仓库清空了，清空之后就可以用 Git 命令将主页面的布局文件上传到原来的仓库 https://UserName.github.io/ 上了。\n通过超链接跳转到博客页面 你现在就可以在主页面放一个超链接，比如 a 元素 ，通过它跳转到你的博客页面就完成了。\n\u0026lt;a href=\u0026#34;Blog/\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; ","permalink":"https://note.yxzi.xyz/note/technology/frame/hexo/%E5%B0%86%E5%8D%9A%E5%AE%A2%E4%BD%9C%E4%B8%BA%E7%AB%99%E7%82%B9%E5%AD%90%E9%A1%B5%E9%9D%A2/","summary":"Hexo 将博客作为站点子页面 前言 如果你想如何在 GitHub 的 repository 中上传自己写的网页作为首页，hexo 生成的博客页作为其子页？即自己写的页面作为 UserName.github.io 的页面，将 hexo 博客放在 UserName.github.io/blog 上，那么，这个教程也许可以帮到你。\n本教程的前提是你已经用 hexo 将博客搭建在 UserName.github.io 的仓库上了。\n新建仓库 在 github 上新建一个仓库，名字随意，我的是 Blog。\n然后本地初始化一个 master 分支，并且将原仓库 clone 到本地分支，并且 开启仓库的 GitHub Pages.，需要注意的是，这里的本地分支目前是没有 CNAME 文件 的。\n修改 Hexo 的配置文件 打开配置文件 _config.yml，找到 #URL 下的 url 和 root，将 url 修改为https:// UesrName.github.io/新建的仓库名（我这里是 Blog），然后将 root 修改为**/新建的仓库名/**。\n# URL ## Set your site url here. For example, if you use GitHub Page, set url as \u0026#39;https://username.","title":"Hexo 将博客作为站点子页面"},{"content":"Hexo 搭建博客 创建 Github 仓库 注册一个Github账号 创建 Github Repository 在 Github 上创建一个仓库，仓库名必须为 UserName.github.io，注意，这是固定的写法 。\n将 Git 与 Github 关联 下载并安装Git 配置个人信息 git config --global user.name \u0026#34;Your UserName\u0026#34; git config --global user.email \u0026#34;YourEmail@qq.com\u0026#34; 生成 ssh 密钥文件 hexo d 到远程仓库，因为每一台电脑中的私钥只有只有一个，因此当你想给另一个 github 账号配置博客时，必须重新生成公钥和私钥\nssh-keygen -t rsa -C \u0026#34;Your GitHub 的邮箱\u0026#34; 复制 id_rsa pub 文件中的密钥 三个回车，默认不需要设置密码，之后到所显示的路径中找到生成的 ssh 的文件夹中的 id_rsa pub 密钥，将其中内容全部复制\nnew SSH Key 打开你的 Github 的主页，点击头像，选择 Settings，再选择 SSH and GPG keys，找到 SSH keys，点击 New SSH Key，Title 为标题，任意填写，将刚刚复制的 id_rsa pub 文件中的密钥文本粘贴进去，最后 Add SSH key。\n检测 GitHub 公钥设置是否成功 ssh git@github com\r 设置 GitHub 密钥原因 因为 GitHub 需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而 Git 支持 SSH 协议，所以，GitHub 只要知道了你电脑上的私钥，就可以确认只有你自己才能推送。\n当然，GitHub 允许你添加多个 公钥。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的公钥都添加到 GitHub，就可以在每台电脑上往 GitHub 推送了。\n当你推送的时候，git 就会匹电脑上的私钥跟 GitHub 上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。\n安装 Node js 和 Hexo 安装 Node js 检测 Node.js 和 nmp 是否安装成功 noed -v\rnmp - v\r 到这一步，说明你已经将安装 Hexo 的环境搭建完成了\n使用 nmp 命令安装 Hexo npm install -g hexo-cli\r Hexo 安装完成后，初始化我们的博客\nhexo init [folder name]\r 这时候你会得到一个文件夹，这个文件夹是你刚刚初始化博客时指定的文件夹名\n本地预览网页 执行以下命令后，在浏览器地址栏中输入 localhost:4000 即可在本地查看你的网站\nhexo new my blog\rhexo g\rhexo s\r hexo new my blog，新建一篇文章，文章标题为 my blog.\nhexo g 生成静态文件。\nhexo s启动本地预览网页，\n配置 GitHub 将 Hexo 生成的博客上传到 Github 仓库 打开站点的配置文件``_config yml```，将 deploy 下的内容编辑为以下内容后保存，编辑配置文件的目其实就是给 hexo d 这个命令做相应的配置，让 hexo 知道你要把你的本地博客文件部署在哪个位置，很显然，我们要将我们的博客部署在我们 GitHub 的仓库里。\n开启仓库的 GitHub Pages 在仓库 主页选择 Settings，然后选择 pages，在 Source 选项下，选择一个分支，比如 master，最后点击 save 即可，这样你就可以通过 Your site is published at 后面的域名来访问你的博客\n将本地网站部署到 Github 服务器 安装 Git 部署插件 npm install hexo-deployer-git --save\r 将本地博客部署到远程仓库 清除缓存文件 (db json) 和已生成的静态文件 (public)，再重新生成的静态文件并将静态文件推送到远程仓库\nHexo clean\rhexo g\rhexo d\r 到这一步，你就可以再浏览器地址栏输入 UserName github io 即可访问你的博客，但因为网址是 GitHub 提供的 xxxx github io，显然不太能突出咱们网站的个性，这时候就需要绑定我们自己的域名。\n个性化域名 绑定域名 来到你的域名管理界面，选择解析，再选择添加记录 这里需要注意的是记录值为你的 GitHub 仓库名 UserName github io，比如我这里是 yxzrainy github io.\n之后到你的 Github 上，进入放博客文件的仓库，选择 Settings，再选择左侧菜单栏中的 Pages，找到 GitHub Pages 下的 Custom domain（自定义域名），输入你的域名，然后点击 Save 即可\n接下来进入本地博客文件夹 ，进入 blog/source 目录下，创建一个记事本文件，输入你的域名，只要写进你自己的域名即可。如果带有 www，那么以后访问的时候必须带有 www 完整的域名才可以访问，但如果不带有 www，以后访问的时候带不带 www 都可以访问，所以建议，不要带有 www，最后保存，命名为 CNAME ，注意保存成所有文件而不是带后缀的 txt 文件或其他文件。 最后再次依次执行清空缓存文件，生成静态文件，将静态博客文件部署到远程仓库\nhexo clean\rhexo g\rhexo d\r 现在你就可以通过你的域名访问到你的博客页了！\n","permalink":"https://note.yxzi.xyz/note/technology/frame/hexo/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","summary":"Hexo 搭建博客 创建 Github 仓库 注册一个Github账号 创建 Github Repository 在 Github 上创建一个仓库，仓库名必须为 UserName.github.io，注意，这是固定的写法 。\n将 Git 与 Github 关联 下载并安装Git 配置个人信息 git config --global user.name \u0026#34;Your UserName\u0026#34; git config --global user.email \u0026#34;YourEmail@qq.com\u0026#34; 生成 ssh 密钥文件 hexo d 到远程仓库，因为每一台电脑中的私钥只有只有一个，因此当你想给另一个 github 账号配置博客时，必须重新生成公钥和私钥\nssh-keygen -t rsa -C \u0026#34;Your GitHub 的邮箱\u0026#34; 复制 id_rsa pub 文件中的密钥 三个回车，默认不需要设置密码，之后到所显示的路径中找到生成的 ssh 的文件夹中的 id_rsa pub 密钥，将其中内容全部复制\nnew SSH Key 打开你的 Github 的主页，点击头像，选择 Settings，再选择 SSH and GPG keys，找到 SSH keys，点击 New SSH Key，Title 为标题，任意填写，将刚刚复制的 id_rsa pub 文件中的密钥文本粘贴进去，最后 Add SSH key。","title":"Hexo 搭建博客"},{"content":"Hexo 更改博客主题 前言 配置完了 Hexo，你是否对自带的主题不满意呢？本篇文章将教你如何更改及美化 Hexo 主题。\n下载主题 去 Hexo 的Hexo Themes下载一个你认为不错的主题。这里推荐 Next主题\n更改基本站点信息 在你的博客根目录下打开**_config.yml**，将 Site 下的信息改为你自己的\n# Site title: Rainy 的梦呓 subtitle: \u0026#39;至简\u0026#39; description: \u0026#39;My Blog And Note to sum up\u0026#39; keywords: Blog note author: Yxz language: zh-CN timezone: \u0026#39;Asia/Shanghai\u0026#39; 同时 记得将 URL 下的 url 改为你自己的站点地址\n# URL ## Set your site url here. For example, if you use GitHub Page, set url as \u0026#39;https://username.github.io/project\u0026#39; url: https://YxzRainy.github.io/Blog 切换到 Next 主题 在你的博客根目录下打开**_config.yml**，将 Extensions，下的 theme 改为 next。\n# Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next 安装主题 在博客根目录新建一个 themes/next 文件夹。\n将刚才下载好的主题文件夹中的配置文件复制到新建的 themes/next 中，并将 themes/next/config.yml 复制到你的博客根目录，最后重命名为config.next.yml即可。\n配置 Next 主题 选择 Schemes 打开 _config.next.yml，首先可以看到 Scheme Settings，里面提供了四种模式，对应上面介绍 next 的图片的四种，可以根据自己的喜好更改。\n# Schemes scheme: Muse #scheme: Mist #scheme: Pisces #scheme: Gemini 设置 icon 在 _config.next.yml 中，在 favicon 下，可以设置侧边栏头像以及站点 icon。需要把你的 icon 放在 source/img/目录\nfavicon:  small: /img/avatar.jfif  medium: /img/avatar.jfif  apple_touch_icon: /img/avatar.jfif  safari_pinned_tab: /images/logo.svg 设置菜单栏 在 menu 下，可以设置菜单显示内容，此版本 next 支持 font awesome 图标，可以去Font Awesome寻找你喜欢的图标进行替换。注：相应的菜单栏需要有对应的页面才能打开，不然会 404 哦！\nmenu:  home: / || fa fa-home  #about: /about/ || fa fa-user  tags: /tags/ || fa fa-tags  categories: /categories/ || fa fa-th  archives: /archives/ || fa fa-archive  guestbook: /guestbook/ || fa fa-book  #schedule: /schedule/ || fa fa-calendar  #sitemap: /sitemap.xml || fa fa-sitemap  #commonweal: /404/ || fa fa-heartbeat 侧边栏设置 #调整边栏左右 #position: left position: right  # Sidebar Display (only for Muse | Mist), available values: # - post expand on posts automatically. Default. # - always expand for all pages automatically. # - hide expand only when click on the sidebar toggle icon. # - remove totally remove sidebar including sidebar toggle. display: post  # Sidebar padding in pixels. padding: 18 # Sidebar offset from top menubar in pixels (only for Pisces | Gemini). offset: 12 设置已读进度条 将 reading_progress 的 enable 设置为 true 即可，位置颜色和高度都可以调整。\n# Reading progress bar\rreading_progress:\renable: true\r# Available values: top | bottom\rposition: bottom\rcolor: \u0026#34;#37c6c0\u0026#34;\rheight: 3px ","permalink":"https://note.yxzi.xyz/note/technology/frame/hexo/%E6%9B%B4%E6%94%B9%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/","summary":"Hexo 更改博客主题 前言 配置完了 Hexo，你是否对自带的主题不满意呢？本篇文章将教你如何更改及美化 Hexo 主题。\n下载主题 去 Hexo 的Hexo Themes下载一个你认为不错的主题。这里推荐 Next主题\n更改基本站点信息 在你的博客根目录下打开**_config.yml**，将 Site 下的信息改为你自己的\n# Site title: Rainy 的梦呓 subtitle: \u0026#39;至简\u0026#39; description: \u0026#39;My Blog And Note to sum up\u0026#39; keywords: Blog note author: Yxz language: zh-CN timezone: \u0026#39;Asia/Shanghai\u0026#39; 同时 记得将 URL 下的 url 改为你自己的站点地址\n# URL ## Set your site url here. For example, if you use GitHub Page, set url as \u0026#39;https://username.github.io/project\u0026#39; url: https://YxzRainy.github.io/Blog 切换到 Next 主题 在你的博客根目录下打开**_config.","title":"Hexo 更改博客主题"},{"content":"img 的常见问题 关于无法设置宽高 如果该元素的图像链接失效，则该元素的特性会与行盒一样，无法设置宽高；如果想要图像链接失效后仍具有宽高，可以将该元素设置为块盒或者行块盒。\n关于图像底部的留白 当任何一个元素（例如 div）内包含行盒（例如 img）时，该 img 行盒就会在这个 div 元素的内部创建参考线，即这个 div 元素在没有设置下外边距的情况下，img 元素的基线（下外边距的底部）会与父元素的基线对齐（即留白部分就是 img 元素的下外边距），因此导致图像底部有留白。\n解决方法：\n 第一种是将父元素的字体大小设置为零，则父元素的内部就不会产生参考线。 第二种是将 img 元素设置为块盒，因此其父元素的内部就没有包含行盒，因此不会在其父元素内部产生参考线。  ","permalink":"https://note.yxzi.xyz/note/technology/language/html/img-%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","summary":"img 的常见问题 关于无法设置宽高 如果该元素的图像链接失效，则该元素的特性会与行盒一样，无法设置宽高；如果想要图像链接失效后仍具有宽高，可以将该元素设置为块盒或者行块盒。\n关于图像底部的留白 当任何一个元素（例如 div）内包含行盒（例如 img）时，该 img 行盒就会在这个 div 元素的内部创建参考线，即这个 div 元素在没有设置下外边距的情况下，img 元素的基线（下外边距的底部）会与父元素的基线对齐（即留白部分就是 img 元素的下外边距），因此导致图像底部有留白。\n解决方法：\n 第一种是将父元素的字体大小设置为零，则父元素的内部就不会产生参考线。 第二种是将 img 元素设置为块盒，因此其父元素的内部就没有包含行盒，因此不会在其父元素内部产生参考线。  ","title":"HTML img 的常见问题"},{"content":"元素语义化 前言 在 HTML 5 中，新增了许多元素，这些不同的元素都有不同的含义，因此语义化指的是用最合理、最恰当的元素来标记网页内容，使得机器也可以知道页面中有哪些元素，比如，文章、标题、或是段落。\n语义化的优点  使文档在没有 CSS 样式的条件下，也能很好地呈现出内容结构。 使文档结构变的清晰，更具可读性，且利于后期的代码维护。 方便其他设备解析（屏幕阅读器、盲人阅读器、移动设备等）。 有利于 SEO。  ","permalink":"https://note.yxzi.xyz/note/technology/language/html/%E5%85%83%E7%B4%A0%E8%AF%AD%E4%B9%89%E5%8C%96/","summary":"元素语义化 前言 在 HTML 5 中，新增了许多元素，这些不同的元素都有不同的含义，因此语义化指的是用最合理、最恰当的元素来标记网页内容，使得机器也可以知道页面中有哪些元素，比如，文章、标题、或是段落。\n语义化的优点  使文档在没有 CSS 样式的条件下，也能很好地呈现出内容结构。 使文档结构变的清晰，更具可读性，且利于后期的代码维护。 方便其他设备解析（屏幕阅读器、盲人阅读器、移动设备等）。 有利于 SEO。  ","title":"HTML 元素语义化"},{"content":"htm、html、shtml 后缀的区别 首先 htm、html、shtml 都是静态网页的后缀，三者也可以说都是只是扩展名不同，其他一样，都是静态的网页。\nHtm 和 html 是完全静态的网页不通过服务器编译解释直接送出给浏览器读取的静态网页，以 htm 和 html 伪静态 Request 除外。\nhtml、htm、shtml、shtm 均是静态 html 网页，都是网页文件后缀名不同的 html 网页扩展名。\nhtm html 与 htm 均是静态网页后缀名，网页文件没有区别与区分，html 与 htm 后缀网页后缀可以互换，对网页完全没有影响同时也没有区别。可以认为 html 与 htm 没有本质区别，只是两者适用于不同的运行环境（DOS 和 UNIX）之下。\nshtml shtml 命名的网页文件里，使用了 ssi 的一些指令，就像 asp 中的指令，你可以在 SHTML 文件中写入 SSI 指令，当客户端访问这些 shtml 文件时，服务器端会把这些 SHTML 文件进行读取和解释，把 SHTML 文件中包含的 SSI 指令解释出来。\n","permalink":"https://note.yxzi.xyz/note/technology/language/html/htmhtmlshtml-%E5%90%8E%E7%BC%80%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"htm、html、shtml 后缀的区别 首先 htm、html、shtml 都是静态网页的后缀，三者也可以说都是只是扩展名不同，其他一样，都是静态的网页。\nHtm 和 html 是完全静态的网页不通过服务器编译解释直接送出给浏览器读取的静态网页，以 htm 和 html 伪静态 Request 除外。\nhtml、htm、shtml、shtm 均是静态 html 网页，都是网页文件后缀名不同的 html 网页扩展名。\nhtm html 与 htm 均是静态网页后缀名，网页文件没有区别与区分，html 与 htm 后缀网页后缀可以互换，对网页完全没有影响同时也没有区别。可以认为 html 与 htm 没有本质区别，只是两者适用于不同的运行环境（DOS 和 UNIX）之下。\nshtml shtml 命名的网页文件里，使用了 ssi 的一些指令，就像 asp 中的指令，你可以在 SHTML 文件中写入 SSI 指令，当客户端访问这些 shtml 文件时，服务器端会把这些 SHTML 文件进行读取和解释，把 SHTML 文件中包含的 SSI 指令解释出来。","title":"htm、html、shtml 后缀的区别"},{"content":"Issus 你可以提出 issue，供看到这个问题的任何人参与解决、讨论这个 issue，当 issue 得到解决时，仓库的所有者与 issue 的所有者就可以将这个 issue 关闭了。\n","permalink":"https://note.yxzi.xyz/note/technology/git/github/issus/","summary":"Issus 你可以提出 issue，供看到这个问题的任何人参与解决、讨论这个 issue，当 issue 得到解决时，仓库的所有者与 issue 的所有者就可以将这个 issue 关闭了。","title":"Issus"},{"content":"基础 类、对象 、属性、封装 类可以理解成对象的集合。比如 class person，定义一个人物类，这是一个抽象的概念。\n对象可以理解为类中的一个元素，比如利用 person 这个人物类 new 一个“小明”，这个小明，就是一个具体的东西。\n赋予这个小明一些属性，比如眼睛，鼻子，身高，这就是这个对象的属性。\n赋予小明会编程、会跳舞唱歌的能力，这些就是这个对象的方法，你可以利用（调用）这些方法，让小明这个对象帮你写代码、唱首歌或跳支舞。\n至于封装，我的理解是将内部的代码封装起来，然后提供一个接口供我们访问。比如电脑主机的开机键就是一个接口，我们点击开机键，就是调用这个电脑的一个接口，至于开机的内部过程或操作细节由电脑自行完成，我们无法干涉。\n至于继承，还不知道。\nvoid 的作用 void 表示一个方法中没有 return 任何数据类型，如果方法中 return 了某种数据类型，那么 void 会被替换为这种数据类型。\nvoid Show1() {  int a = 123; }  int Show2() {  int a = 123;  return a; } public、protected、default（什么都不写）、private，表示访问控制的权限\nprivate void Show1() {  int a = 123; }  // 相当于 default int Show2() int Show2() {  int a = 123;  return a; } ","permalink":"https://note.yxzi.xyz/note/technology/language/java/java-%E5%9F%BA%E7%A1%80/","summary":"基础 类、对象 、属性、封装 类可以理解成对象的集合。比如 class person，定义一个人物类，这是一个抽象的概念。\n对象可以理解为类中的一个元素，比如利用 person 这个人物类 new 一个“小明”，这个小明，就是一个具体的东西。\n赋予这个小明一些属性，比如眼睛，鼻子，身高，这就是这个对象的属性。\n赋予小明会编程、会跳舞唱歌的能力，这些就是这个对象的方法，你可以利用（调用）这些方法，让小明这个对象帮你写代码、唱首歌或跳支舞。\n至于封装，我的理解是将内部的代码封装起来，然后提供一个接口供我们访问。比如电脑主机的开机键就是一个接口，我们点击开机键，就是调用这个电脑的一个接口，至于开机的内部过程或操作细节由电脑自行完成，我们无法干涉。\n至于继承，还不知道。\nvoid 的作用 void 表示一个方法中没有 return 任何数据类型，如果方法中 return 了某种数据类型，那么 void 会被替换为这种数据类型。\nvoid Show1() {  int a = 123; }  int Show2() {  int a = 123;  return a; } public、protected、default（什么都不写）、private，表示访问控制的权限\nprivate void Show1() {  int a = 123; }  // 相当于 default int Show2() int Show2() {  int a = 123;  return a; } ","title":"Java 基础"},{"content":"Pull Requests 简单来说就是：我改进了你的代码，你拉回去看看吧\n当你想改进一个别人的项目 ，或想为别人的项目做贡献时，你将要走以下几个流程\n Fork 别人的仓库，相当于拷贝一份，毕竟不可能有人让你直接修改他的原仓库的。 将拷贝过来的仓库clone到本地分支，做一些修复，比如git clone git@github.com:YxzRainy/YxzRainy.github.io.git。 改进完成后，你希望仓库所有者接受你的修改，那么你需要在 Github 上创建一个Pull Request给原仓库所有者，意思是请求原仓库所有者合并你的分支。 原仓库所有者审查你做的这些修复后，如果它同意的话，就会将你做的修改合并到他自己的项目中，这样你就为他的这个项目做了贡献。 到这一步，整个Pull Request的过程就结束了。  ","permalink":"https://note.yxzi.xyz/note/technology/git/github/pull-requests/","summary":"Pull Requests 简单来说就是：我改进了你的代码，你拉回去看看吧\n当你想改进一个别人的项目 ，或想为别人的项目做贡献时，你将要走以下几个流程\n Fork 别人的仓库，相当于拷贝一份，毕竟不可能有人让你直接修改他的原仓库的。 将拷贝过来的仓库clone到本地分支，做一些修复，比如git clone git@github.com:YxzRainy/YxzRainy.github.io.git。 改进完成后，你希望仓库所有者接受你的修改，那么你需要在 Github 上创建一个Pull Request给原仓库所有者，意思是请求原仓库所有者合并你的分支。 原仓库所有者审查你做的这些修复后，如果它同意的话，就会将你做的修改合并到他自己的项目中，这样你就为他的这个项目做了贡献。 到这一步，整个Pull Request的过程就结束了。  ","title":"Pull Requests"},{"content":"Repository 一个在 GitHub 的 repository 的地址路径一般由 **GitHub 的域名 + 仓库主人 + 仓库本身的名字 **组成，并且你可以通过这个地址访问一个已存在的公开库 。比如 https://github.com/YxzRainy/YxzRainy.github.io\n在这个仓库中，你可以上传文件或添加文件，并且可以直接编辑部分文档文件，比如 html、txt 等等，当你每次对这个仓库中的内容进行修改时，你都可以提交修改信息，比如你这次对文件做了哪些修改等等，这类似与备注。\n","permalink":"https://note.yxzi.xyz/note/technology/git/github/repository/","summary":"Repository 一个在 GitHub 的 repository 的地址路径一般由 **GitHub 的域名 + 仓库主人 + 仓库本身的名字 **组成，并且你可以通过这个地址访问一个已存在的公开库 。比如 https://github.com/YxzRainy/YxzRainy.github.io\n在这个仓库中，你可以上传文件或添加文件，并且可以直接编辑部分文档文件，比如 html、txt 等等，当你每次对这个仓库中的内容进行修改时，你都可以提交修改信息，比如你这次对文件做了哪些修改等等，这类似与备注。","title":"Repository"},{"content":"Vs Code 配置 Java 安装 vscode 安装 JDK 配置系统环境变量 打开系统系统环境变量配置界面   右击此电脑\n  属性\n  高级系统设置\n  高级选项卡\n  环境变量\n  系统变量\n  新建 JAVA_HOME 变量  变量名：JAVA_HOME。 值为：Java JDK 的安装路径。 确定  找到已存在的名为 Path 的变量  编辑 新建 输入：%JAVA_HOME%\\jre\\bin，确定 再新建，输入：%JAVA_HOME%\\bin，确定 保存即可  新建 Classpath 变量   变量名：Classpath，\n  值为：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n  测试环境配置是否成功 快捷键 Win + R，搜索 cmd 并 Enter，然后在命令行输入java以及javac.\n安装 vs code 扩展 java extension pack。\n以下是自动安装的 Test Runner for Java。\nDebugger for Java，调试 Java 代码。\nExtension Pack for Java。\nMaven for Java\n创建一个 java 项目并运行  接下来打开 Vs Code，快捷键 Ctrl + shift + p，然后输入create，选择No build tools. 选择项目位置 在顶部对话框输入项目名称  ","permalink":"https://note.yxzi.xyz/note/technology/language/java/vs-code-%E9%85%8D%E7%BD%AE-java/","summary":"Vs Code 配置 Java 安装 vscode 安装 JDK 配置系统环境变量 打开系统系统环境变量配置界面   右击此电脑\n  属性\n  高级系统设置\n  高级选项卡\n  环境变量\n  系统变量\n  新建 JAVA_HOME 变量  变量名：JAVA_HOME。 值为：Java JDK 的安装路径。 确定  找到已存在的名为 Path 的变量  编辑 新建 输入：%JAVA_HOME%\\jre\\bin，确定 再新建，输入：%JAVA_HOME%\\bin，确定 保存即可  新建 Classpath 变量   变量名：Classpath，\n  值为：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n  测试环境配置是否成功 快捷键 Win + R，搜索 cmd 并 Enter，然后在命令行输入java以及javac.\n安装 vs code 扩展 java extension pack。","title":"Vs Code 配置 Java"},{"content":"安装 Hyper V 安装 hyper v\n在第一台上链接第二台虚拟计算机\n启动 nat 模式 8\n关闭两台计算机的防火墙，更改高级设置，启用网络网络发现，关闭密码共享\n第一太 ping 第二台计算机的 ip 地址，成功即可\n查询\n开远程权限\n新建虚拟机\n位置和名称\n指定代数，32 位系统选第一代 64 位系统选第二代\n分配内存，1024\n网络连接，intel 8257\n大小，25gb\n以后安装操作系统\n最后链接虚拟机\n右击虚拟机\n检查点\n将虚拟机导出到文件夹，到处后就可以在操作界面进行导入虚拟机，创建新标识符\n安装操作系统\n文件，设置 ，固件，dvd 放到第一个，安装完成后，关机再将硬盘放到第一个。\n关机，添加新硬盘，开机，计算机管理，磁盘管理，新建一个本地磁盘。\nhyper v 设置，实时迁移，启用迁移\n移动虚拟机，将虚拟机移动到新建的磁盘上即可\n允许链接共享\n在 hyper v 上新建磁盘，固定大小动态扩展，下一步，完成\n","permalink":"https://note.yxzi.xyz/note/technology/windows-server/%E5%AE%89%E8%A3%85-hyper-v/","summary":"安装 Hyper V 安装 hyper v\n在第一台上链接第二台虚拟计算机\n启动 nat 模式 8\n关闭两台计算机的防火墙，更改高级设置，启用网络网络发现，关闭密码共享\n第一太 ping 第二台计算机的 ip 地址，成功即可\n查询\n开远程权限\n新建虚拟机\n位置和名称\n指定代数，32 位系统选第一代 64 位系统选第二代\n分配内存，1024\n网络连接，intel 8257\n大小，25gb\n以后安装操作系统\n最后链接虚拟机\n右击虚拟机\n检查点\n将虚拟机导出到文件夹，到处后就可以在操作界面进行导入虚拟机，创建新标识符\n安装操作系统\n文件，设置 ，固件，dvd 放到第一个，安装完成后，关机再将硬盘放到第一个。\n关机，添加新硬盘，开机，计算机管理，磁盘管理，新建一个本地磁盘。\nhyper v 设置，实时迁移，启用迁移\n移动虚拟机，将虚拟机移动到新建的磁盘上即可\n允许链接共享\n在 hyper v 上新建磁盘，固定大小动态扩展，下一步，完成","title":"安装 Hyper V"},{"content":"Vlan 重命名 Vlan enable configure terminal vlan 10 name MyVlan 删除 Vlan 分配 enable configure terminal interface f 0/18 no switchport access vlan 删除 Vlan no vlan 20 配置 Vlan 的 IP enable configure terminal interface vlan 1 ip address 192.168.10.1 255.255.255.0 ","permalink":"https://note.yxzi.xyz/note/technology/internet/cisco/vlan/","summary":"Vlan 重命名 Vlan enable configure terminal vlan 10 name MyVlan 删除 Vlan 分配 enable configure terminal interface f 0/18 no switchport access vlan 删除 Vlan no vlan 20 配置 Vlan 的 IP enable configure terminal interface vlan 1 ip address 192.168.10.1 255.255.255.0 ","title":"Cisco Vlan"},{"content":"如何提高文笔 经常阅读\n随时记录灵感。\n写文章第一天先把想写的写下来，连系段落随意写下。\n第二天把文章大体全部梳理写一遍。\n第三天重复精简修词。隔一天再审一遍\n画面感 1） 静画面中突出具体特质，如颜色、形状、质感、味道等等。\n2） 动静反衬。即静画面中突出动的，或动画面中突出伫立不动的。\n尽可能少用“的”\n视觉美感 是带有情绪的想象，用最少的文字，传递出最多元的信息\n词汇本身就极具美感和意境\n建立素材库，随机搭配\n情感落点 越想表达什么感情，越不说。欲言又止、欲走还留。\n","permalink":"https://note.yxzi.xyz/note/technology/writing/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%96%87%E7%AC%94/","summary":"如何提高文笔 经常阅读\n随时记录灵感。\n写文章第一天先把想写的写下来，连系段落随意写下。\n第二天把文章大体全部梳理写一遍。\n第三天重复精简修词。隔一天再审一遍\n画面感 1） 静画面中突出具体特质，如颜色、形状、质感、味道等等。\n2） 动静反衬。即静画面中突出动的，或动画面中突出伫立不动的。\n尽可能少用“的”\n视觉美感 是带有情绪的想象，用最少的文字，传递出最多元的信息\n词汇本身就极具美感和意境\n建立素材库，随机搭配\n情感落点 越想表达什么感情，越不说。欲言又止、欲走还留。","title":"如何提高文笔"},{"content":"PHP PHP 是一种运行在服务器端的脚本语言。\nPHP Hyper text Pxeprosessor, php. 超文本预处理器，底层使用 C 语言。\n所支持的数据库有：Sqlservex、Mysql、Oracle、Access\n","permalink":"https://note.yxzi.xyz/note/technology/language/php/php/","summary":"PHP PHP 是一种运行在服务器端的脚本语言。\nPHP Hyper text Pxeprosessor, php. 超文本预处理器，底层使用 C 语言。\n所支持的数据库有：Sqlservex、Mysql、Oracle、Access","title":"PHP"},{"content":"安装 Apache 官方下载地址Apache 进不去的话，就挂个 VPN，下载好后解压，我们会得到一个名为 Apache24 的文件夹，我们先将这个文件夹放到你想要放置的目录，我这里是D:\\AppInstallPath\\Apache24.\n目录文件解析 bin 和 cgi -bin 文件夹是 windows 下的一些可执行文件。\nconf 文件夹是 Apache 的配置文件目录。\nerror 文件夹是 Apache 的错误日志。\nhtdoce 文件夹是 Apache 的默认主机地址（网站的根目录文件，默认为 index）。\nmodules 文件夹是 Apache 的模块，Apache 的所有功能都是模块化的，你想要什么功能，就可以在配置文件中去加载对应功能的模块（so 后缀的文件）\nbin 文件夹解析 ab.exe 是提供压力测试（当很多人访问你的网站时，你的网站是否能承载）的一个程序。\nApacheMonitor.exe 是管理右下角最小化的图标的。\nhttpd.exe 很重要。\nconf 文件夹解析 httpd.conf 是主配置文件。\nextra 文件夹中都是子配置文件（比如 httpd-vhosts.conf），当我们需要用这些子配置文件的时候，我们需要到主配置中文件中去加载这些子配置文件。\nHttpd.exe 代表着服务器的进程，它运行之后，服务器才能运行。\n","permalink":"https://note.yxzi.xyz/note/technology/language/php/%E5%AE%89%E8%A3%85-apache/","summary":"安装 Apache 官方下载地址Apache 进不去的话，就挂个 VPN，下载好后解压，我们会得到一个名为 Apache24 的文件夹，我们先将这个文件夹放到你想要放置的目录，我这里是D:\\AppInstallPath\\Apache24.\n目录文件解析 bin 和 cgi -bin 文件夹是 windows 下的一些可执行文件。\nconf 文件夹是 Apache 的配置文件目录。\nerror 文件夹是 Apache 的错误日志。\nhtdoce 文件夹是 Apache 的默认主机地址（网站的根目录文件，默认为 index）。\nmodules 文件夹是 Apache 的模块，Apache 的所有功能都是模块化的，你想要什么功能，就可以在配置文件中去加载对应功能的模块（so 后缀的文件）\nbin 文件夹解析 ab.exe 是提供压力测试（当很多人访问你的网站时，你的网站是否能承载）的一个程序。\nApacheMonitor.exe 是管理右下角最小化的图标的。\nhttpd.exe 很重要。\nconf 文件夹解析 httpd.conf 是主配置文件。\nextra 文件夹中都是子配置文件（比如 httpd-vhosts.conf），当我们需要用这些子配置文件的时候，我们需要到主配置中文件中去加载这些子配置文件。\nHttpd.exe 代表着服务器的进程，它运行之后，服务器才能运行。","title":"安装 Apache"},{"content":"网站访问流程 静态网站  通过电脑打开浏览器输入 URL（资源的绝对路径），比如https://yxzi.xyz/:80/index.html DNS 服务器，先找本地 DNS（本地 hosts 文件），再找网络 DNS ，然后将域名（https://yxzi.xyz/）解析为 IP（192.168.1.0:80/index.html），最后将解析出来的 IP 返回给浏览器。 浏览器通过 IP（192.168.1.0:80/index.html）找到服务器， 再通过端口（80）找到服务器上的服务软件 Apache。 通过 Apache，就可以得到 一个 URI（资源都相对路径），Apache 根据这个 URI（/index.html），即可获取到服务器上文件名为 index.html 的文件。 Apache 会读取这个文件中的数据，并将最终结果返回给浏览器，反之，如果服务器上的文件不存在，那么浏览器会返回给浏览器一个错误，比如 404（链接所指向的网页不存在） 错误。 浏览器得到 Apache 返回的数据之后，它会解析这些数据，并将这些数据以某种方式呈现给用户。  动态网站  通过电脑打开浏览器输入 URL（资源的绝对路径），比如https://yxzi.xyz/:80/index.pnh DNS 服务器，先找本地 DNS（本地 hosts 文件），再找网络 DNS ，然后将域名（https://yxzi.xyz/）解析为 IP（192.168.1.0:80/index.php），最后将解析出来的 IP 返回给浏览器。 浏览器通过 IP（192.168.1.0:80/index.php）找到服务器， 再通过端口（80）找到服务器上的服务软件 Apache Apache 就可以得到 一个 URI（资源都相对路径），Apache 根据这个 URI（/index.php），即可获取到服务器上文件名为 index.php 的文件。 但又因为网站是动态的，所以 Apache 是无法识别后缀为 PHP 的文件的，因此在这里需要一个叫 PHP 引擎的东西，Apache 将 这个 PHP 文件交给 PHP 引擎，PHP 引擎读取 PHP 文件之后，需要将这个文件解析为 html 文件 ，注意，这时的 PHP 引擎可能会去寻找数据库，并对数据库进行一些操作（读取、放入、修改数据库等等）。最后，PHP 引擎会将解析后的 HTML 数据（PHP 文件中的数据和数据库中的数据），全部返回给 Apache。 Apache 会读取 PHP 引擎返回的内容，并将最终结果返回给浏览器，反之，如果服务器上的文件不存在，那么浏览器会返回给浏览器一个错误，比如 404（链接所指向的网页不存在） 错误。 浏览器得到 Apache 返回的数据之后，它会解析这些数据，并将这些数据以某种方式呈现给用户。  ","permalink":"https://note.yxzi.xyz/note/technology/internet/%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B/","summary":"网站访问流程 静态网站  通过电脑打开浏览器输入 URL（资源的绝对路径），比如https://yxzi.xyz/:80/index.html DNS 服务器，先找本地 DNS（本地 hosts 文件），再找网络 DNS ，然后将域名（https://yxzi.xyz/）解析为 IP（192.168.1.0:80/index.html），最后将解析出来的 IP 返回给浏览器。 浏览器通过 IP（192.168.1.0:80/index.html）找到服务器， 再通过端口（80）找到服务器上的服务软件 Apache。 通过 Apache，就可以得到 一个 URI（资源都相对路径），Apache 根据这个 URI（/index.html），即可获取到服务器上文件名为 index.html 的文件。 Apache 会读取这个文件中的数据，并将最终结果返回给浏览器，反之，如果服务器上的文件不存在，那么浏览器会返回给浏览器一个错误，比如 404（链接所指向的网页不存在） 错误。 浏览器得到 Apache 返回的数据之后，它会解析这些数据，并将这些数据以某种方式呈现给用户。  动态网站  通过电脑打开浏览器输入 URL（资源的绝对路径），比如https://yxzi.xyz/:80/index.pnh DNS 服务器，先找本地 DNS（本地 hosts 文件），再找网络 DNS ，然后将域名（https://yxzi.xyz/）解析为 IP（192.168.1.0:80/index.php），最后将解析出来的 IP 返回给浏览器。 浏览器通过 IP（192.168.1.0:80/index.php）找到服务器， 再通过端口（80）找到服务器上的服务软件 Apache Apache 就可以得到 一个 URI（资源都相对路径），Apache 根据这个 URI（/index.php），即可获取到服务器上文件名为 index.php 的文件。 但又因为网站是动态的，所以 Apache 是无法识别后缀为 PHP 的文件的，因此在这里需要一个叫 PHP 引擎的东西，Apache 将 这个 PHP 文件交给 PHP 引擎，PHP 引擎读取 PHP 文件之后，需要将这个文件解析为 html 文件 ，注意，这时的 PHP 引擎可能会去寻找数据库，并对数据库进行一些操作（读取、放入、修改数据库等等）。最后，PHP 引擎会将解析后的 HTML 数据（PHP 文件中的数据和数据库中的数据），全部返回给 Apache。 Apache 会读取 PHP 引擎返回的内容，并将最终结果返回给浏览器，反之，如果服务器上的文件不存在，那么浏览器会返回给浏览器一个错误，比如 404（链接所指向的网页不存在） 错误。 浏览器得到 Apache 返回的数据之后，它会解析这些数据，并将这些数据以某种方式呈现给用户。  ","title":"网站访问流程"},{"content":"DNS 和端口 DNS DNS 是互联网的一项服务，它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。\n简单的讲 DNS 就是翻译官，比如它会将http://www.baidu.com翻译成220.181.111.188让机器理解。\nDNS 有什么用 DNS 是用来做域名解析的，它会在你上网输入网址后，把它转换成 IP，然后去访问这个 IP 所指定的服务器，没有它，你想上百度就要记住百度的 IP，上 163 就要记住 163 的 IP，有了 DNS 的处理，你只需要记住对应网站的域名（网址），比如https://yxzi.xyz/。\nDNS 是一个按层次结构排列的分布式系统，由许多 DNS 服务器组成。DNS 服务器是注册加入 DNS 的任何计算机。它具有域名和 IP 地址的索引，并且在请求时，它可以告诉你与域名关联的当前 IP 地址。\n如果它不知道，那么它将尝试从其他 DNS 服务器中找出。\n因此，当您在浏览器中键入域名时，浏览器会询问 DNS 服务器该域的 IP 地址是什么，DNS 服务器会尝试告诉你。\n端口 简单来说：\n 在一台计算机上，端口用来指定你想要访问这台物理设备上的哪个程序。\n IP 能锁定一台物理机器，对应着一张网卡，网卡会接收外界发来的数据包。但是问题来了，网卡给程序提供了接口，你监听一下我，要是有消息来了，我就转发给你，这样应用程序就能收到数据了。\n但是问题来了，程序 A 和程序 B 都需要监听网卡接发数据，网卡说那我把接到的数据都发给你两，你们自己看着办吧。\n好，小 A 小 B 都接收了。\n但是又来了 CDEF\u0026hellip;\u0026hellip;，不行了，每个包都被发到了所有应用程序，每个应用程序都累得不行，最终垮了。\n好，那网卡说我给你们加个表示吧，我们之间可以用一个号码来作为标识，我和小 A 之间就用 1 来标识，\n如果外界发给 1 号标识的数据我就转发给你，你监听我的时候得告诉我你监听的是 1，我就转发 1 的数据包给你。\n好了其他的 BCD\u0026hellip;都自己弄一个标识号，只要不重复就行。\n这样大家都省事了。\n最后涉及到安全，一个标识号只能被一个应用程序监听，因为如果小 A 程序和小 B 同时监听一个标识号，那就坏了，\n我传的数据都被 AB 接到，这样数据的安全性就没办法保证了。\n这个标识号就是端口，最初设计网络数据交换的设计者不知道是怎么想的。\n其实网卡都是被系统层封装了，端口和进程之间的关系也是系统封装好的。我们只需要用 socket 就行，给定一个端口号就行了。\n其他的事都交给操作系统去做。\n","permalink":"https://note.yxzi.xyz/note/technology/internet/dns-%E5%92%8C%E7%AB%AF%E5%8F%A3/","summary":"DNS 和端口 DNS DNS 是互联网的一项服务，它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。\n简单的讲 DNS 就是翻译官，比如它会将http://www.baidu.com翻译成220.181.111.188让机器理解。\nDNS 有什么用 DNS 是用来做域名解析的，它会在你上网输入网址后，把它转换成 IP，然后去访问这个 IP 所指定的服务器，没有它，你想上百度就要记住百度的 IP，上 163 就要记住 163 的 IP，有了 DNS 的处理，你只需要记住对应网站的域名（网址），比如https://yxzi.xyz/。\nDNS 是一个按层次结构排列的分布式系统，由许多 DNS 服务器组成。DNS 服务器是注册加入 DNS 的任何计算机。它具有域名和 IP 地址的索引，并且在请求时，它可以告诉你与域名关联的当前 IP 地址。\n如果它不知道，那么它将尝试从其他 DNS 服务器中找出。\n因此，当您在浏览器中键入域名时，浏览器会询问 DNS 服务器该域的 IP 地址是什么，DNS 服务器会尝试告诉你。\n端口 简单来说：\n 在一台计算机上，端口用来指定你想要访问这台物理设备上的哪个程序。\n IP 能锁定一台物理机器，对应着一张网卡，网卡会接收外界发来的数据包。但是问题来了，网卡给程序提供了接口，你监听一下我，要是有消息来了，我就转发给你，这样应用程序就能收到数据了。\n但是问题来了，程序 A 和程序 B 都需要监听网卡接发数据，网卡说那我把接到的数据都发给你两，你们自己看着办吧。\n好，小 A 小 B 都接收了。\n但是又来了 CDEF\u0026hellip;\u0026hellip;，不行了，每个包都被发到了所有应用程序，每个应用程序都累得不行，最终垮了。\n好，那网卡说我给你们加个表示吧，我们之间可以用一个号码来作为标识，我和小 A 之间就用 1 来标识，\n如果外界发给 1 号标识的数据我就转发给你，你监听我的时候得告诉我你监听的是 1，我就转发 1 的数据包给你。","title":"DNS 和端口"},{"content":"IP 和域名 IP IP 具有唯一性，像人的身份证一样，是唯一的。\n通俗地讲就是互联网世界的门牌号，通过 IP 地址就可以准确无误的找到某台计算机的位置，它具有唯一性，所以当我们访问某个 IP 的时候才不会出现错误，他就像我们的身份证号码那样独一无二，我们可以和别人同名，但是绝不可能和别人有同样的身份证号码。\n首先要确定你的 IP 地址是否是以 192.168 开头，如果是这个地址的话，不需要担心。这是内网的 IP 地址，在外网是无法直接访问的。如果不是内网的地址，有可能会遭到黑客的攻击。这需要一定的专业技术，普通人很难进行攻击，而且你的电脑应该需要有很强的利用价值，才会让人费时费力对你发起攻击之心，所以知道你 IP 对于大多数人来说不能对你做什么。\n域名 IP 不方便我们记忆，而域名，则是为了我们更好的记忆某一个网站的地址。\n域名（Domain Name）是由一串字符组成的，它指向某一个具体的 IP 地址。\n","permalink":"https://note.yxzi.xyz/note/technology/internet/ip-%E5%92%8C%E5%9F%9F%E5%90%8D/","summary":"IP 和域名 IP IP 具有唯一性，像人的身份证一样，是唯一的。\n通俗地讲就是互联网世界的门牌号，通过 IP 地址就可以准确无误的找到某台计算机的位置，它具有唯一性，所以当我们访问某个 IP 的时候才不会出现错误，他就像我们的身份证号码那样独一无二，我们可以和别人同名，但是绝不可能和别人有同样的身份证号码。\n首先要确定你的 IP 地址是否是以 192.168 开头，如果是这个地址的话，不需要担心。这是内网的 IP 地址，在外网是无法直接访问的。如果不是内网的地址，有可能会遭到黑客的攻击。这需要一定的专业技术，普通人很难进行攻击，而且你的电脑应该需要有很强的利用价值，才会让人费时费力对你发起攻击之心，所以知道你 IP 对于大多数人来说不能对你做什么。\n域名 IP 不方便我们记忆，而域名，则是为了我们更好的记忆某一个网站的地址。\n域名（Domain Name）是由一串字符组成的，它指向某一个具体的 IP 地址。","title":"IP 和域名"},{"content":"服务器 在网络环境下，根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应 用程序服务器，WEB 服务器等。\n一台个人计算机也可以成为一台服务器，只要这台计算机可以提供服务，那么，如何让这台计算机提供服务呢？\n只需要在这台计算机上安装可以提供服务的软件（服务软件）。\n比如一台 Web 服务器，它如果要提供 Web 服务（网站访问），就需要安装 Web 服务软件，Apache，Tomcat， Iis 等等\n服务器是网站的灵魂，是打开网站的必要载体，没有服务器的网站用户无法浏览。服务器就像一块敲门砖，就算网站在搜索引擎里的排名再好，网站打不开，用户无法浏览，网站就没有用户体验可言，网站能被打开是第一个重点。\n提到服务器对于电脑爱好者来说一定不陌生，一般我们很难看到真正的服务器，因为服务器一般均放置在机房重点，闲人一般均是免进的，所以说起服务器，好多未接触的朋友都觉的很陌生，介于此，斯百德就为不明白服务器是什么的小伙伴们，揭开服务器神秘的面纱。\n其实服务器的模样就和电脑的主机很相似，但是服务器是网站的灵魂，是打开网站的必要载体，没有服务器的网站用户无法浏览。服务器就像一块敲门砖，就算网站在搜索引擎里的排名再好，网站打不开，用户无法浏览，网站就没有用户体验可言，网站能被打开是第一个重点。比如我们每天浏览的网站，其实数据均在服务器，服务器一般都在一些 IDC 数据中心机房以及电信等网络大厦里面。\n服务器，也称伺服器。服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，为此，服务器必须具有承担服务并且保障服务的能力。我们这里提到的服务器，主要是指的 Web 服务器，我们也称之为专用服务器，是专为网站业务应用的服务器，这种服务器可以向发出请求的浏览器提供文档的程序。Web 服务器也是一种被动的程序，只有当服务器接收到浏览器发出的请求时，服务器才会响应。\n由于Web 服务器是一种被动的程序，所以不同类型的网站对 Web 服务器的要求差别很大。企业网站和个人网站一般都是展示型网站，所以他们对服务器的性能要求一般都不高。电子商务型网站以及门户型等网站一般访问量用户比较大，这些大型网站对服务器的需要则较高。\n目前，用户使用最多的 web 服务器软件有两个：微软的信息服务器（iis）和 Apache。而架设 Web 服务器比较常见的操作系统有 Windows，Linux 和 Unix。Linux 的安全性在这三个系统中最高，同时可以支持多个硬件平台，而且其是开源软件，市场价格更低，甚至用户可以下载免费的代码来搭建 Web 服务器。Web 服务器的操作更简单，性能更优越，目前使用率非常的高，Unix 则比较小众！\n","permalink":"https://note.yxzi.xyz/note/technology/internet/%E6%9C%8D%E5%8A%A1%E5%99%A8/","summary":"服务器 在网络环境下，根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应 用程序服务器，WEB 服务器等。\n一台个人计算机也可以成为一台服务器，只要这台计算机可以提供服务，那么，如何让这台计算机提供服务呢？\n只需要在这台计算机上安装可以提供服务的软件（服务软件）。\n比如一台 Web 服务器，它如果要提供 Web 服务（网站访问），就需要安装 Web 服务软件，Apache，Tomcat， Iis 等等\n服务器是网站的灵魂，是打开网站的必要载体，没有服务器的网站用户无法浏览。服务器就像一块敲门砖，就算网站在搜索引擎里的排名再好，网站打不开，用户无法浏览，网站就没有用户体验可言，网站能被打开是第一个重点。\n提到服务器对于电脑爱好者来说一定不陌生，一般我们很难看到真正的服务器，因为服务器一般均放置在机房重点，闲人一般均是免进的，所以说起服务器，好多未接触的朋友都觉的很陌生，介于此，斯百德就为不明白服务器是什么的小伙伴们，揭开服务器神秘的面纱。\n其实服务器的模样就和电脑的主机很相似，但是服务器是网站的灵魂，是打开网站的必要载体，没有服务器的网站用户无法浏览。服务器就像一块敲门砖，就算网站在搜索引擎里的排名再好，网站打不开，用户无法浏览，网站就没有用户体验可言，网站能被打开是第一个重点。比如我们每天浏览的网站，其实数据均在服务器，服务器一般都在一些 IDC 数据中心机房以及电信等网络大厦里面。\n服务器，也称伺服器。服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，为此，服务器必须具有承担服务并且保障服务的能力。我们这里提到的服务器，主要是指的 Web 服务器，我们也称之为专用服务器，是专为网站业务应用的服务器，这种服务器可以向发出请求的浏览器提供文档的程序。Web 服务器也是一种被动的程序，只有当服务器接收到浏览器发出的请求时，服务器才会响应。\n由于Web 服务器是一种被动的程序，所以不同类型的网站对 Web 服务器的要求差别很大。企业网站和个人网站一般都是展示型网站，所以他们对服务器的性能要求一般都不高。电子商务型网站以及门户型等网站一般访问量用户比较大，这些大型网站对服务器的需要则较高。\n目前，用户使用最多的 web 服务器软件有两个：微软的信息服务器（iis）和 Apache。而架设 Web 服务器比较常见的操作系统有 Windows，Linux 和 Unix。Linux 的安全性在这三个系统中最高，同时可以支持多个硬件平台，而且其是开源软件，市场价格更低，甚至用户可以下载免费的代码来搭建 Web 服务器。Web 服务器的操作更简单，性能更优越，目前使用率非常的高，Unix 则比较小众！","title":"服务器"},{"content":"静态网站和动态网站 静态网站的特点  网页内容一经发布到网站服务器上，无论是否有用户访问，每个静态网页的内容都是保存在网站服务器上的,也就是说,静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件。 静态网页的内容相对稳定，因此容易被搜索引擎检索。 静态网页没有数据库的支持，在网站制作和维护方面工作量较大，因此当网站信息量很大时完全依靠静态网页制作方式比较困难。 静态网页的交互性较差，在功能方面有较大的限制，当我们要修改网页上文件时，需要将修改后的文件覆盖服务器上的源文件。  动态网站的特点  交互性强，网页会根据用户的要求和选择而动态地改变和响应，网页上的数据都是从数据库中获取的，并且用户的操作，也可以对网页上的数据进行实时的更新。 自动更新，即无须手动更新 HTmL 文档,便会自动生成新页面，可以大大节省工作量。 因时因人而变，在不同时间、不同用户访问用一个网址时，会出现不同页面。 在动态网页的网址中有一个标志性的符号“?”。  ","permalink":"https://note.yxzi.xyz/note/technology/language/php/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E5%92%8C%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99/","summary":"静态网站和动态网站 静态网站的特点  网页内容一经发布到网站服务器上，无论是否有用户访问，每个静态网页的内容都是保存在网站服务器上的,也就是说,静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件。 静态网页的内容相对稳定，因此容易被搜索引擎检索。 静态网页没有数据库的支持，在网站制作和维护方面工作量较大，因此当网站信息量很大时完全依靠静态网页制作方式比较困难。 静态网页的交互性较差，在功能方面有较大的限制，当我们要修改网页上文件时，需要将修改后的文件覆盖服务器上的源文件。  动态网站的特点  交互性强，网页会根据用户的要求和选择而动态地改变和响应，网页上的数据都是从数据库中获取的，并且用户的操作，也可以对网页上的数据进行实时的更新。 自动更新，即无须手动更新 HTmL 文档,便会自动生成新页面，可以大大节省工作量。 因时因人而变，在不同时间、不同用户访问用一个网址时，会出现不同页面。 在动态网页的网址中有一个标志性的符号“?”。  ","title":"静态网站和动态网站"},{"content":"let 变量无法重复声明，避免变量污染。\n块级作用域，变量只在当前代码块{}的作用域中有效，一个{}就是一个作用域。\n{ \tlet b = 1; } console.log(b); 但不影响作用域链。\na = 3; function fun() { \tconsole.log(a); } fun(); 不进行变量声明提升\nconsole.log(a);\rlet a = 1; ","permalink":"https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/let/","summary":"let 变量无法重复声明，避免变量污染。\n块级作用域，变量只在当前代码块{}的作用域中有效，一个{}就是一个作用域。\n{ \tlet b = 1; } console.log(b); 但不影响作用域链。\na = 3; function fun() { \tconsole.log(a); } fun(); 不进行变量声明提升\nconsole.log(a);\rlet a = 1; ","title":""},{"content":"函数 形参默认值 定义函数时，指定形参的默认值。这个默认值会在调用该函数且并未传入实参的时候，当作该函数的默认实参传入。\nfunction fun($a = 1) {  echo $a; } fun(); 可变函数 将定义好的函数名赋值给一个变量，然后通过这个变量来调用。\nfunction sysFun($fun, $num) {  $num = $num + 10;  // 函数调用  return $fun($num); }  function userFun($num) {  return $num * $num * $num * $num; } echo sysFun(\u0026#39;userFun\u0026#39;, 10); ","permalink":"https://note.yxzi.xyz/note/technology/language/php/%E5%87%BD%E6%95%B0/","summary":"函数 形参默认值 定义函数时，指定形参的默认值。这个默认值会在调用该函数且并未传入实参的时候，当作该函数的默认实参传入。\nfunction fun($a = 1) {  echo $a; } fun(); 可变函数 将定义好的函数名赋值给一个变量，然后通过这个变量来调用。\nfunction sysFun($fun, $num) {  $num = $num + 10;  // 函数调用  return $fun($num); }  function userFun($num) {  return $num * $num * $num * $num; } echo sysFun(\u0026#39;userFun\u0026#39;, 10); ","title":"PHP 函数"},{"content":"操作数据库 // 链接数据库 $link = mysqli_connect(\u0026#39;localhost\u0026#39;, \u0026#39;root\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;my_shop\u0026#39;, \u0026#39;3306\u0026#39;); if (!$link) {  exit(\u0026#39;数据库链接失败\u0026#39;); }  // 对数据库进行一次查询 $res = mysqli_query($link, \u0026#39;select * from hr_goods\u0026#39;);  // 获取查询结果中的所有字段，每个字段都是一个数组 while ($row = mysqli_fetch_array($res)) {  echo $row[1] . \u0026#39;、\u0026#39;; }  ","permalink":"https://note.yxzi.xyz/note/technology/language/php/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"操作数据库 // 链接数据库 $link = mysqli_connect(\u0026#39;localhost\u0026#39;, \u0026#39;root\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;my_shop\u0026#39;, \u0026#39;3306\u0026#39;); if (!$link) {  exit(\u0026#39;数据库链接失败\u0026#39;); }  // 对数据库进行一次查询 $res = mysqli_query($link, \u0026#39;select * from hr_goods\u0026#39;);  // 获取查询结果中的所有字段，每个字段都是一个数组 while ($row = mysqli_fetch_array($res)) {  echo $row[1] . \u0026#39;、\u0026#39;; }  ","title":"PHP 操作数据库"}]