<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>编程语言 on Rainy · Note</title>
    <link>https://note.yxzi.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link>
    <description>Recent content in 编程语言 on Rainy · Note</description>
    <image>
      <url>https://note.yxzi.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://note.yxzi.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 05 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://note.yxzi.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JavaScrip class</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/class/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/class/</guid>
      <description>class 创建一个基于原型继承类。
class Phone { 	// 调用构造方法 	constructor(height, width) { 	this.area = height * width; 	}  	fun() { 	console.log(&amp;#39;i am function&amp;#39;); 	} }  let apple = new Phone(4, 3); apple.fun(); </description>
    </item>
    
    <item>
      <title>JavaScrip constructor</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%B1%BB/constructor/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%B1%BB/constructor/</guid>
      <description>constructor() 用于创建和初始化class创建的对象的特殊方法。</description>
    </item>
    
    <item>
      <title>JavaScrip Object 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/object/object-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/object/object-%E5%B1%9E%E6%80%A7/</guid>
      <description>Object 属性 constructor 返回构造当前对象的构造函数。
var array = [];  // return ƒ Array() { [native code] } console.log(array.constructor); </description>
    </item>
    
    <item>
      <title>JavaScrip static</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%B1%BB/static/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%B1%BB/static/</guid>
      <description>static 定义静态方法。静态方法不能在类的实例上调用静态方法，而应该通过类本身调用。
class Phone { 	static name = &amp;#39;静态方法&amp;#39;; }  let apple = new Phone(4, 3); console.log(apple.name); console.log(Phone.name); </description>
    </item>
    
    <item>
      <title>Map</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/map/map/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/map/map/</guid>
      <description>Map 用于保存键值对，并且能够记住键的原始插入顺序。任何值都可以作为一个键或一个值。
const map1 = new Map();  map1.set(&amp;#39;a&amp;#39;, 1); map1.set(&amp;#39;b&amp;#39;, 2); map1.set(&amp;#39;c&amp;#39;, 3);  console.log(map1.get(&amp;#39;a&amp;#39;)); // return 1  map1.set(&amp;#39;a&amp;#39;, 97);  console.log(map1.get(&amp;#39;a&amp;#39;)); // return 97  console.log(map1.size); // return 3  map1.delete(&amp;#39;b&amp;#39;);  console.log(map1.size); // return 2 </description>
    </item>
    
    <item>
      <title>Map 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/map/map-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/map/map-%E6%96%B9%E6%B3%95/</guid>
      <description>Map 方法 set() 添加或更新指定的键值。
delete() 移除指定元素
get() 返回一个指定元素。
clear() 清空所有元素</description>
    </item>
    
    <item>
      <title>Promise 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/promise/promise-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/promise/promise-%E6%96%B9%E6%B3%95/</guid>
      <description>Promise 方法 than() then() 返回一个 Promise 对象。它有两个参数：Promise 调用resolve() 和调用 rejecte() 情况的回调函数。
返回 Promise 对象 than()的返回值如果是 Promise 对象，那么该 Promise 对象的执行结果会作为当前 than() 的返回值。
let p = new Promise((resolve, reject) =&amp;gt; { 	setTimeout(() =&amp;gt; { 	resolve(&amp;#39;success&amp;#39;); 	}, 1000); });  let result = p.then( 	(value) =&amp;gt; { 	console.log(value); 	return new Promise((resolve, reject) =&amp;gt; { 	reject(&amp;#39;fail&amp;#39;); 	}); 	}, 	(reason) =&amp;gt; { 	console.error(reason); 	} );  // rejected // &amp;#34;fail&amp;#34; console.</description>
    </item>
    
    <item>
      <title>Set</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/set/set/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/set/set/</guid>
      <description>Set 用于存储任何类型的唯一值。
数组去重 const arr = [2, 3, 4, 4, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 5, 32, 3, 4, 5]; console.log([...new Set(arr)]); 交集 并集 let arr = [1, 4, 3, 8]; let arr2 = [5, 1, 7, 2];  let union = [...new Set([...arr, ...arr2])]; console.log(union); 差集 </description>
    </item>
    
    <item>
      <title>Set 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/set/set-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/set/set-%E6%96%B9%E6%B3%95/</guid>
      <description>Set 方法 add() 向末尾添加一个指定的元素。
delete() 删除指定元素。
has() 检测 set 中是否存在指定元素。
clear() 清空所有元素。</description>
    </item>
    
    <item>
      <title>Promise</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/promise/promise/</link>
      <pubDate>Fri, 03 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/promise/promise/</guid>
      <description>Promise Promise 说得通俗一点就是一种写代码的方式，并且是用来写 JavaScript 编程中的异步代码。
可以封装 ajax.
基本使用 let p = new Promise((resolve, reject) =&amp;gt; { 	if (0) { 	// 成功 	resolve(&amp;#39;success&amp;#39;); 	} else { 	// 失败 	reject(&amp;#39;fail&amp;#39;); 	} });  p.then( 	// 如果 p 调用了 resolve() 	(value) =&amp;gt; { 	console.log(value); 	}, 	// 如果 p 调用了 reject() 	(reason) =&amp;gt; { 	console.error(reason); 	} ); 读取文件 let fs = require(&amp;#39;fs&amp;#39;); let p = new Promise((resolve, reject) =&amp;gt; { 	fs.</description>
    </item>
    
    <item>
      <title>JavaScrip Symbol</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/symbol/</link>
      <pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/symbol/</guid>
      <description>Symbol 一般用于给对象添加一个独一无二的属性或方法。
使用Symbol()定义一个Symbol类型的数据。
// 添加方式一 var game = { 	house() {}, }; let methods = { 	fun: Symbol(), };  // 给对象中的属性添加方法 game[methods.fun] = function () { 	console.log(&amp;#39;方法1&amp;#39;); }; // 添加方式二 var game = { 	[Symbol(&amp;#39;fun&amp;#39;)]: function () { 	console.log(&amp;#39;methods one &amp;#39;); 	}, }; console.log(game);  Symbol 是原始类型，不是引用类型，不能使用 new。
Symbol()可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。
Symbol 类型的值时唯一的，用来解决命名冲突的问题。
Symbol 类型的值不能于其他数据进行运算
Symbol 定义的对象属性不能被遍历</description>
    </item>
    
    <item>
      <title>HTML 理想视口</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/%E7%90%86%E6%83%B3%E8%A7%86%E5%8F%A3/</link>
      <pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/%E7%90%86%E6%83%B3%E8%A7%86%E5%8F%A3/</guid>
      <description>理想视口 开启移动端的理想视口。
&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width,initial-scale=1.0&amp;#34; /&amp;gt; </description>
    </item>
    
    <item>
      <title>PHP 指针函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E7%BB%84/%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 26 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E7%BB%84/%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0/</guid>
      <description>指针函数 next()和prex()会移动指针，有可能导致指针移出数组，导致
数组不能使用，此时，无法通过next() 和prex()使指针回到数组，只能通过end()或reset()重置指针。</description>
    </item>
    
    <item>
      <title>PHP closure</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/closure/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/closure/</guid>
      <description>closure php 的 Closure，v 也就是匿名函数。
匿名函数中，默认无法访问外部函数中的变量。
function demo() {  $a = 1;  function fun()  {  // 无法使用 demo() 中的 $a  echo $a;  };  fun(); }; demo(); 通过 use()将外部变量传入到内部函数的作用域内：
function demo() {  $a = 1;  $fun = function () use ($a) {   echo $a;  };  $fun(); };  demo(); 闭包 匿名函数中的use()，其作用就是从父作用域继承变量，继承之后，就会形成一个闭包。
function demo() {  $a = 1;  $fun = function () use ($a) {   echo $a;  };  return $fun; };  $closure = demo();  $closure(); </description>
    </item>
    
    <item>
      <title>PHP echo() 、print()、var_dump()的区别</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/echo-printvar_dump%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/echo-printvar_dump%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>echo() 、print()、var_dump()的区别 echo() 输出一个或多个字符串。
echo() 实际不是一个函数（而是语言结构），因此可以不使用()。
print() 输出一个或多个字符串。
print() 实际不是一个函数（而是语言结构），因此可以不使用()。
var_dump() 返回变量的类型与值。
区别  echo()能接受多个字符串类型的参数，能同时输出多个字符串。当echo()接受多个参数时，不能使用括号。 print()只能接收 1 个字符串类型的参数；只能同时输出一个字符串； print()打印的值能直接赋值给一个变量：`$a = print “123” echo()输出的速度比 print() 快。 echo()没有返回值，而print()有返回值，其返回值永远为int类型的 1。  </description>
    </item>
    
    <item>
      <title>PHP static</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/static/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/static/</guid>
      <description>static 静态全局变量与普通全局变量的区别 非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态全局变量在各个源文件中都是有效的。
静态全局变量的作用域只在当前源文件内， 在同一源程序的其它源文件中不能使用它，因此可以避免变量污染。
静态局部变量与普通局部变量 静态局部变量只被初始化一次，变量下一次的值依据的是上次的结果值。
静态函数与普通函数 静态函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。
作用 拥挤函数的执行次数。
统计函数多次调用的不同结果。</description>
    </item>
    
    <item>
      <title>PHP 伪类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E4%BC%AA%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E4%BC%AA%E7%B1%BB%E5%9E%8B/</guid>
      <description>伪类型 用于在 PHP 文档里指示参数可以使用的类型和值，但实际上伪类型在 PHP 中不存在。
mixed mixed 说明一个参数可以接受多种不同的(但不一定是所有的)类型。
例如：gettype()可以接受所有的 PHP 类型，str_replace()可以接受字符串和数组，
number number 说明一个参数可以是 integer 或者 float。
callback 本文档中在 PHP5.4 引入 callable 类型之前使用了 callback 伪类型，二者涵义完全相同，
array|object array|object 意思是参数既可以是 array 也可以是 object，
void void 作为返回类型意味着函数的返回值是无用的，
void 作为参数列表意味着函数不接受任何参数，</description>
    </item>
    
    <item>
      <title>PHP 变量</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/%E5%8F%98%E9%87%8F/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/%E5%8F%98%E9%87%8F/</guid>
      <description>变量 预定义变量 指的是系统提前定义的变量，存储许多需要用到的数据，并且，预定义变量都 是数组。
$_GET：获取所有表单以 get 方式提交的数据。
$_POST：获取所有表单以 post 方式提交的 value。
$_REQUEST：GET 和 POST 提交的都会保存。
$_GLOBALS：PHP 中所有的全局变量。
$_SERVER：服务器信息。
$_SESSION：获取 session 会话数据。
$_COOKIE：获取 cookie 的会话数据。
$_ENV：环境信息。
$_FILES：用户上传的文件信息。
可变变量 可变变量就是变量的变量。
$a = &amp;#39;b&amp;#39;; $b = &amp;#39;bb&amp;#39;; // $$a = $ + $a = $ + b = $b = bb echo $$a;  </description>
    </item>
    
    <item>
      <title>JavaScrip debugger</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E/</guid>
      <description>debugger debugger 被调用时, 浏览器执行 JavaScrip 代码时会暂停在 debugger 语句的位置，并调用 (如果有) 浏览器的调试器进行调试。例如设置断点。</description>
    </item>
    
    <item>
      <title>JavaScript HTMLElement 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/htmlelement/htmlelement/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/htmlelement/htmlelement/</guid>
      <description>HTMLElement 方法 focus() 如果可以，将焦点聚焦在指定的元素上。
如果是创建的新元素，则必须先将创建的新元素插入到页面中，然后再执行focus()，焦点才能成功聚焦到这个新元素上。如果是先聚焦，再插入，焦点则不会聚焦到新元素上。</description>
    </item>
    
    <item>
      <title>JavaScript Math 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/math/math-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/math/math-%E6%96%B9%E6%B3%95/</guid>
      <description>Math 方法 random() 返回一个 0（= 0）到 1（&amp;lt; 1）的随机数。
floor() 向下取整，返回一个小于或等于指定数字的最大整数。
ceil() 向上取整，返回一个大于或等于指定数字的最小整数。</description>
    </item>
    
    <item>
      <title>JavaScript 匿名函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</guid>
      <description>匿名函数 指没有名称的函数。如果单独只写一个匿名函数，此时是不符合语法要求的会报错。
function () { 	console.log(&amp;#39;该函数会报错&amp;#39;); }; 需要给匿名函数包裹一个括号，使之成为函数表达式。
(function (a, b) { 	console.log(&amp;#39;匿名函数表达式&amp;#39;); })(); 也可以将一个匿名函数赋给一个变量，再通过变量来调用这个匿名函数。
var demo = function () { 	console.log(&amp;#39;匿名函数表达式&amp;#39;); }; demo(); </description>
    </item>
    
    <item>
      <title>JavaScript 回调函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid>
      <description>回调函数 将 A 函数当作 B 函数的参数，并被 B 函数调用，则 A 函数是 B 函数的回调函数。
一般的函数调用，可以称作是调用，然而执行时才将某个函数传入再调用的调用方式，被称为回调。</description>
    </item>
    
    <item>
      <title>HTML input</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/input/</link>
      <pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/input/</guid>
      <description>input 输入框。
为input 设置不同的 type 属性，可以变化为多种形态。
radio 单选框。
需要为多个单选按钮设置相同的 name 值。
性别： &amp;lt;input type=&amp;#34;radio&amp;#34; name=&amp;#34;sex&amp;#34; id=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;input type=&amp;#34;radio&amp;#34; name=&amp;#34;sex&amp;#34; id=&amp;#34;&amp;#34; /&amp;gt; </description>
    </item>
    
    <item>
      <title>PHP 转换数据类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E8%BD%AC%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E8%BD%AC%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>转换数据类型 在很多的条件下，需要将指定的数据类型，转换成目标数据类型。
自动转换 系统根据需求判定并转换（用的比较多，效率偏低）。
$a = &amp;#39;abc1.1.1&amp;#39;; $b = &amp;#39;1.1.1abc&amp;#39;;  // 0 + 1.1 echo $a + $b; 强制转换 它会先复制一份需要被转换的数据，然后在对这份被复制的数据进行处理（不会处理实际的数据，它处理的是自己拷贝的）。
() 在变量之前增加一个 ()，括号中的参数为目标数据类型。
$a = &amp;#39;我是字符串呀&amp;#39;; $b = 123;  // 强制转换，使 a 中的数据变为浮点型 // 但 a 本身的数据并没有变为 float echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;, (float)$a; echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; // 0 echo &amp;#39;a = &amp;#39; . $a; //string echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;;  echo &amp;#39;此时 a 的数据类型依旧为：&amp;#39; . gettype($a); echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; echo &amp;#39;&amp;lt;hr/&amp;gt;&amp;#39;; settype() 设定数据类型，但与前面的强制转换()不同，它会直接改变数据本身。
&amp;lt;?php $a = &amp;#39;我是字符串呀&amp;#39;; $b = 123;  // 强制设置数据类型 //true var_dump(settype($a, &amp;#39;int&amp;#39;)); echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; // a 的数据类型直接被设置成了 integer，和强制转换大不一样 echo &amp;#39;a 的数据类型为：&amp;#39; .</description>
    </item>
    
    <item>
      <title>JavaScrip AMD</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/amd/amd/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/amd/amd/</guid>
      <description>AMD 专门用于浏览器端，实现异步加载模块，该规范依赖于 require.js。
不是所有模块都支持 AMD 规范，比如 angular.js，但也可以通过 shim配置来使用angular.js
定义模块 定义没有依赖的模块：
define(function () { 	// 暴露模块 	return module; }); 定义有依赖的模块：
// 显式声明依赖注入 define([&amp;#39;module1&amp;#39;, &amp;#39;module2&amp;#39;, &amp;#39;module2&amp;#39;], function (m1Obj, m2Obj, m3Obj) { 	// 暴露模块 	return module; }); 导入模块 require([ 	&amp;#39;module1&amp;#39;, 	&amp;#39;module2&amp;#39;, 	&amp;#39;module3&amp;#39;, 	function (m1Obj, m2Obj, m3Obj) { 	// 使用 m1Obj, m2Obj, m3Obj 	}, ]); 实现 使用require.js。</description>
    </item>
    
    <item>
      <title>JavaScrip AMD 实现模块化</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/amd/amd-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/amd/amd-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>AMD 实现模块化 将require.js导入到项目目录./libs/require.js
创建项目结构 ./libs/：第三方模块目录。
./modules/：自定义模块目录。
./libs/jquery.js：第三方模块。
./libs/require.js：第三方模块。
./modules/alerter.js：有依赖的自定义模块。
./modules/dataService.js无依赖的自定义模块。
./main.js：主模块。
./index.html：入口文件。
模块化编码 alerter.js
// 定义无依赖的模块 define(function () { 	var name = &amp;#39;no have dependencies&amp;#39;; 	function fun() { 	return name; 	} 	// 暴露模块的 fun() 	return { fun }; }); dataService.js
// 定义有依赖的模块，该模块依赖 dataService、jquery define([&amp;#39;dataService&amp;#39;, &amp;#39;jquery&amp;#39;], function (dataService, $) { 	var msg = &amp;#39;have dependencies&amp;#39;; 	function showMsg() { 	console.log(msg, dataService.fun()); 	} 	$(&amp;#39;body&amp;#39;).</description>
    </item>
    
    <item>
      <title>JavaScrip Browserify 实现模块化</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/browserify-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/browserify-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>Browserify 实现模块化 基于本地浏览器端实现模块化，需要用 Browserify来打包。
创建项目结构 ./dist：打包生成的文件目录。
./src：模块目录。
./src/module1.js：自定义模块一。
./src/module2.js：自定义模块二。
./src/module3.js：自定义模块三。
./app.js：主模块。
./index.html：入口文件。
模块化编码 module1.js
// 暴露对象 module.exports = { 	msg: &amp;#39;module one&amp;#39;, 	fun() { 	console.log(this.msg); 	}, }; module2.js
// 暴露函数 module.exports = function () { 	console.log(&amp;#39;module two&amp;#39;); }; module3.js
// 向暴露 2 个函数，1 个数组  exports.f = function () { 	console.log(&amp;#39;modul three f1&amp;#39;); };  exports.f2 = function () { 	console.log(&amp;#39;module three f2&amp;#39;); };  exports.</description>
    </item>
    
    <item>
      <title>JavaScrip CMD</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/cmd/cmd/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/cmd/cmd/</guid>
      <description>CMD 专用于浏览器端，异步加载模块。
惰性加载模块，即使用模块时才会加载。
实现该规范使用Sea.js
定义模块 注意，回调函数中的三个参数require, exports, module必须加上，否则会报错。
定义没有依赖的模块：
define(function (require, exports, module) { 	// 暴露模块，通常用后者 	exports.xxx = value; 	module.exports = value; }); 定义有依赖的模块：
define(function (require, exports, module) { 	// 同步导入模块 	var module2 = require(&amp;#39;./module2&amp;#39;); 	// 异步导入依赖模块 	require.async(&amp;#39;./module3&amp;#39;, function (m3Obj) { 	// 使用 m3Obj 	}); 	// 暴露模块 	exports.xxx = value; }); 导入模块 define(function (require) { 	var m1 = require(&amp;#39;.</description>
    </item>
    
    <item>
      <title>JavaScrip CMD 实现模块化</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/cmd/cmd-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/cmd/cmd-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>CMD 实现模块化 创建项目结构 ./libs：第三方模块目录。
./libs/sea.js：第三方模块。
./modules：自定义模块目录。
./modules/module1.js：自定义模块一。
./modules/module2.js：自定义模块二。
./modules/module3.js：自定义模块三。
./modules/module4.js：自定义模块四。
modules/main.js：主模块。
./index.html：入口文件
模块化编码 module1.js
// 定义没有依赖的模块 define(function (require, exports, module) { 	var msg = &amp;#39;module1&amp;#39;; 	function fun() { 	return msg; 	} 	// 暴露模块 	module.exports = { fun }; }); module2.js
// 定义没有依赖的模块 define(function (require, exports, module) { 	var msg = &amp;#39;module2&amp;#39;; 	function fun2() { 	console.log(msg); 	} 	// 暴露模块 	module.</description>
    </item>
    
    <item>
      <title>JavaScrip CommonJS</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/commonjs/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/commonjs/</guid>
      <description>CommonJS 一种为 JS 的表现指定的规范，它希望 JavaScrip 可以运行在任何地方，Node.js采用了这个规范。
一个单独文件就是一个模块，通过require()来同步加载要依赖的模块，然后通过extports或则module.exports来暴露模块的接口。
定义模块 两种方式所暴露的模块都是一个对象。
module.expots 将需要暴露的属性或方法保存到exports对象中。
// ExposedObjects() 将会保存到 exports 对象中，并暴露出去 module.expots = ExposedObjects(){ }; exports.xxx 给exports定义不同的xxx 对象，可以暴露不同属性或方法。
// 不同的对象暴露不同的方法或属性 expots.obj = ExposedObjects(){ }; expots.obj2 = ExposedObjects2(){ } expots.obj3 = ExposedObjects3(){ } 导入模块 // 导入第三方模块 require(&amp;#39;jquery&amp;#39;); // 导入自定义模块 require(&amp;#39;modules.js&amp;#39;); 实现 服务器端 直接使用 Node.js，加载模块时是同步加载，这会导致阻塞（等待），但因为是在服务器端，影响也不是很大，无非是加载的时间比较长。
浏览器端 加载模块时是同步加载，也会导致阻塞，且因为是在浏览器端，加载的时间非常长，用户体验不好（页面白屏），因此，我们需要将模块进行编译打包，以此来缩短加载时间。
打包工具：Browserify.</description>
    </item>
    
    <item>
      <title>JavaScrip ES6 Module</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/es6-module/es6-module/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/es6-module/es6-module/</guid>
      <description>ES6 Module 配置 package.json 项目或模块的描述文件。
{ 	&amp;#34;name&amp;#34;: &amp;#34;es6-module&amp;#34;, 	&amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34;, 	&amp;#34;dependencies&amp;#34;: { 	&amp;#34;jquery&amp;#34;: &amp;#34;^3.6.0&amp;#34;, 	&amp;#34;uniq&amp;#34;: &amp;#34;^1.0.1&amp;#34; 	}, 	&amp;#34;devDependencies&amp;#34;: { 	&amp;#34;@babel/cli&amp;#34;: &amp;#34;^7.17.10&amp;#34;, 	&amp;#34;@babel/core&amp;#34;: &amp;#34;^7.17.12&amp;#34;, 	&amp;#34;@babel/preset-env&amp;#34;: &amp;#34;^7.17.12&amp;#34;, 	&amp;#34;browserify&amp;#34;: &amp;#34;^17.0.0&amp;#34; 	} } 安装 babel/cli Babel 自带的一个内置的 CLI 命令行工具，可通过命令行编译文件。
npm install --save-dev @babel/core @babel/cli 其中@babel/core是 babel 的核心库。
babel/preset-env 一个智能预设，允许您使用最新的 JavaScript，而无需微观管理目标环境需要哪些语法转换（以及可选的浏览器 polyfills）
npm install --save-dev @babel/preset-env 安装 Browserify 用来打包编译模块。
npm install -g browserify 配置 babel.</description>
    </item>
    
    <item>
      <title>JavaScrip ES6 模块化规范</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/es6-module/es6-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/es6-module/es6-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/</guid>
      <description>ES6 模块化规范 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。
ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。
依赖模块需要借助 Browserify来打包。
暴露模块 使用export来暴露模块，它用于规定模块的对外接口。
分别暴露 export function fun1() { 	console.log(&amp;#39;fun1 module1&amp;#39;); } export function fun11() { 	console.log(&amp;#39;fun11 module1&amp;#39;); } export var arr = [9999, 34, 5, 6, 7565, 757, 6]; 统一暴露 function fun2() { 	console.log(&amp;#39;fun2 module2&amp;#39;); } function fun22() { 	console.log(&amp;#39;fun2 module2&amp;#39;); } export { fun2, fun22 }; 默认暴露 使用默认暴露，可以暴露任意数据类型；且暴露的是什么数据类型，接收到的就是什么数据类型；可以使用任意的变量来接收。
在同一个模块中，只允许用export default 暴露一次。</description>
    </item>
    
    <item>
      <title>JavaScrip NodeJs 实现模块化</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/nodejs-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/nodejs-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>NodeJs 实现模块化 基于node.js服务器端实现模块化。
创建项目结构 ./modules：模块目录。
./modules/module1.js：自定义模块一。
./modules/module2.js：自定义模块二。
./modules/module3.js：自定义模块三。
./app.js：主模块。
安装模块 安装 uniq
npm install uniq 模块化编码 module1.js
// 暴露对象 module.exports = { 	msg: &amp;#39;module one&amp;#39;, 	fun() { 	console.log(this.msg); 	}, }; module2.js
// 暴露函数 module.exports = function () { 	console.log(&amp;#39;module two&amp;#39;); }; module3.js
// 暴露 2 个函数，1 个数组 exports.f = function () { 	console.log(&amp;#39;modul three f1&amp;#39;); };  exports.f2 = function () { 	console.log(&amp;#39;module three f2&amp;#39;); };  exports.</description>
    </item>
    
    <item>
      <title>JavaScrip 模块</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97/</guid>
      <description>模块 向外提供特定功能的 JavaScrip 文件，一个 JavaScrip 文件就是一个模块。</description>
    </item>
    
    <item>
      <title>JavaScrip 模块化</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>模块化 将一个复杂的 JavaScrip 程序依据一定的规范封装成几个块（文件），并组合在一起的过程就是模块化。块的内部数据是私有的，只向外部暴露了一些接口与外部其他模块通信。
作用  降低复杂度。 提高解耦性，降低耦合度。 部署方便，功能点明确。  优点  避免变量污染。 更好的分离，按需加载。 更高的复用性。 更高的可维护性。  常见的模块化标准 CommonJS.
ES6 Module.
AMD.
CMD.</description>
    </item>
    
    <item>
      <title>JavaScrip 模块化的发展史</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/</guid>
      <description>模块化的发展史 全局函数模式 将不同的函数封装成不同的全局函数。
缺点
变量非常不安全，会直接污染全局中的变量。
JavaScrip One
// msg 变量并不安全，会被其他文件中的 js 代码修改。 var msg = &amp;#39;全局函数模式&amp;#39;; function fun() { 	console.log(msg); } JavaScrip Two
fun(); msg = &amp;#39;全局中的 msg 被其他文件中的 js 代码修改了&amp;#39;; fun(); 命名空间 将全局中的变量定义到一个对象中，以减少 Global 上的变量。
缺点
本质是对象，依旧可以通过对象去修改该对象中的变量，变量依旧不安全。
JavaScrip One
var obj = { 	// 将全局中的变量定义为对象的属性，以减少全局中的变量 	msg: &amp;#39;命名空间模式&amp;#39;, 	fun() { 	console.log(this.msg); 	}, }; JavaScrip Two
obj.fun(); obj.msg = &amp;#39;对象中的 msg 被其他文件中的 js 代码修改了&amp;#39;; obj.fun(); IIFE 模式 将变量和函数定义到立即执行函数内部，并将方法暴露给 window，以一个匿名闭包（将一个模块暴露给 window 对象，然后在其其他模块中用 window 对象来访问这个这个模块）的方式实现了模块化。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/%E5%9F%BA%E7%A1%80/</guid>
      <description>基础 注释 // 开头的注释，less 不会将其编译到 css 文件中。
/**/ 包裹的注释，less 才会将其编译到 css 文件中
// 该注释不可见/* 该注释可见 */ 变量 使用@来申明一个变量: @color: #008c8c。
作为普通属性值只来使用：使用@color
作为选择器和属性名或 URL：@{attr}、@{class}、@{ur1}的形式。
// 属性值变量@color2: #2775e0;@color: #198484;// 选择器变量@class: .indiv;// 属性名变量@attr:width;div {// 使用属性名变量@{attr}: 100px;height: 100px;// 使用属性值变量background-color: @color2;// 使用选择器变量@{class}{width: 40px;height: 50px;background-color: @color;}} 被编译为：
div { 	width: 100px; 	height: 100px; 	background-color: #2775e0; } div .</description>
    </item>
    
    <item>
      <title>Less</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/less/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/less/</guid>
      <description>Less Less 一门向后兼容的 CSS 扩展语言。它扩展了 CSS，使 CSS 更易于维护和扩展。
Less 官方文档
安装 Node.js：
npm install -g less 引入：
&amp;lt;script src=&amp;#34;//cdnjs.cloudflare.com/ajax/libs/less.js/3.11.1/less.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 将 less 编译为 css 在 less 文件的目录引入执行，就会得到一个 编译后的 css 文件。
lessc styles.less &amp;gt; styles.css 当然，如果你使用的是 Vs Code，那么直接安装Easy Less扩展即可，每当你保存 less 文件的时候，它会自动将 less 文件编译为 css 文件，方便的很。</description>
    </item>
    
    <item>
      <title>Less 继承</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/%E7%BB%A7%E6%89%BF/</guid>
      <description>继承 使用 :extend()将混合规则集继承给指定的选择器。extend 是一个 Less 伪类
继承规则集不能带()。
// 定义一个继承，它不能有().center {position: absolute;left: 50%;top: 50%;transform: translate(-50%, -50%);}.wrap {width: 300px;height: 300px;background-color: aqua;.inner {// 将 .center 中的规则集继承到 .wrap .inner{} 中// 使用 all&amp;amp;:extend(.center);&amp;amp;:nth-child(1) {width: 500px;height: 100px;background-color: pink;}&amp;amp;:nth-child(2) {width: 80px;height: 80px;background-color: rgb(210, 29, 59);}}} </description>
    </item>
    
    <item>
      <title>JavaScript Object 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/object/objet-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/object/objet-%E6%96%B9%E6%B3%95/</guid>
      <description>Object 方法 defineProperty() 用于在一个对象上定义一个新属性，或者修改一个对象的已有属性，并返回此对象。
使用 defineProperty() 定义的属性无法被枚举。
value 该属性对应的值。默认值为undefined。
enumerable 控制属性是否可以被枚举。
可枚举属性是指那些内部enumerable设置为 true 的属性，对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true，对于通过Object.defineProperty() 等定义的属性，该标识值默认为 false。
writable 控制属性是否可以被修改，默认值为false
configurable 控制属性是否可以被删除，默认值为false
get() 当访问当前属性时，会调用此函数。该函数的返回值会被用作当前属性的值。
set() 当前属性值被修改时，会调用此函数。该方法接受一个参数（当前属性被赋予的新值），会传入赋值时的 this 对象。
var number = 20; var person = { 	Name: &amp;#39;张三&amp;#39;, 	sex: &amp;#39;男&amp;#39;, 	// age: 25, }; Object.defineProperty(person, &amp;#39;age&amp;#39;, { 	// 每当我们读取 person 的 age 属性时，get() 就会被调用，且返回值是 age 的值 	get() { 	console.log(&amp;#39;读取 age 的值&amp;#39;); 	return number; 	}, 	// 每当我们修改 person 的 age 属性时，set() 就会被调用，且会收到被修改后的的值 	set(value) { 	console.</description>
    </item>
    
    <item>
      <title>JavaScript 箭头函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</guid>
      <description>箭头函数 任何可以使用匿名函数的位置均可以使用箭头函数。
箭头函数适合与 this 无关的回调，不适合与 this 有关的回调。
// 普通匿名函数 var sum = function (a, b) { 	return a + b; }; console.log(sum(1, 2)); // 箭头函数 var sumES6 = (a, b) =&amp;gt; { 	return a + b; }; console.log(sumES6(4, 3)); 可以看出，定义箭头函在数语法上要比普通函数简洁得多。
参数 没有参数，直接写一个空括号()即可。
只有一个参数，可以省去包裹参数的括号。
多个参数，将参数依次用逗号(,)分隔。
// 无参数 var fun1 = () =&amp;gt; { 	console.log(&amp;#39;无参数&amp;#39;); };  // 只有一个参数 var fun2 = (name) =&amp;gt; { 	console.log(name); };  // 多个参数 var fun3 = (val1, val2, val3) =&amp;gt; { 	return [val1, val2, val3]; }; 函数体 如果箭头函数的函数体中只有一句代码，可以省去函数体的大括号{ }，此时rturn 必须省略。</description>
    </item>
    
    <item>
      <title>JavaScript 语法糖</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E6%B3%95%E7%B3%96/</link>
      <pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E6%B3%95%E7%B3%96/</guid>
      <description>语法糖 对象属性简写 简写对象的属性以及方法。
var name = &amp;#39;月色&amp;#39;; var age = 20; var sex = &amp;#39;男&amp;#39;; // 传统对象的属性 var person = { 	name: name, 	age: age, 	Fun: function () { 	console.log(sex); 	}, }; // 语法糖对象的属性 var personES6 = { 	name, 	age, 	Fun() { 	console.log(sex); 	}, }; console.log(person); console.log(personES6); 模板字符串 用反引号``声明（传统字符串是双引号或单引号）。
通过模板字符串，你可以以${表达式}的形式在模板中插入任何 JavaScript 表达式、变量。
默认支持多行，无需使用\n来换行。
var person = { 	name: &amp;#39;Rainy&amp;#39;, 	age: &amp;#39;20&amp;#39;, }; // 传统字符串拼接 var str = &amp;#39;my name is &amp;#39; + person.</description>
    </item>
    
    <item>
      <title>PHP 判断数据类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>判断变量类型 is_XX() 判断一个变量是否为指定数据类型，最终返回这个变量所保存数据的数据类型。
Bool 类型不能用 echo 来查看，需要使用 var_dump() 查看。
// true var_dump(is_int($a)); echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;;  // false var_dump(is_int($b)); echo &amp;#39;&amp;lt;hr/&amp;gt;&amp;#39;; gettype() 获取变量的类型，得到的是该类型对应的字符串。
// string echo &amp;#39;a 的数据类型为：&amp;#39; . gettype($a); echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; // integer echo &amp;#39;b 的数据类型为：&amp;#39; . gettype($b);  echo &amp;#39;&amp;lt;hr/&amp;gt;&amp;#39;; </description>
    </item>
    
    <item>
      <title>PHP 数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/</guid>
      <description>数组 索引数组 用数字作为键名的数组一般叫做索引数组。用字符串表示键的数组就是下面要介绍的关联数组。索引数组的键是整数，而且从 0 开始以此类推。
关联数组 数组的key是字符串。
特点   可以使用整数或字符串作为下标。
  下标为整数则为索引数组。
  下标都为字符串，则为关联数组。
    不同的下标（字符串、整数）可以混合存在，则为混合数组。
  数组中元素的顺序以放入顺序为准，与指定的下标无关。
  特殊的下标自动转换：false、true、null。
  </description>
    </item>
    
    <item>
      <title>PHP 文件包含</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</guid>
      <description>文件包含 在一个 PHP 脚本中，将另一个文件的代码插入到当前文件，并使用另一个文件中的方法、变量等等。
用于实现代码模块化。
被包含的文件是单独进行编译的
包含方式 include() 一般放在程序的流程控制中，当程序执行时碰到才会引用，简化程序的执行流程。
include()引入的文件有错误时，会继续执行，并返回一个警告。
include once() 检查当前文件是否已经在前面被引入过了，如果已经引入过，则不在引入。
可以避免某写代码重新执行而报错，比如重复引入导致常量重复定义。
require() 一般放在 PHP 文件的最前面，程序在执行前就会先导入要引用的文件。
require()引入的文件有错误时，执行会中断，并返回一个致命错误。
require onec() 检查当前文件是否已经在前面被引入过了，如果已经引入过，则不在引入。
可以避免某写代码重新执行而报错，比如重复引入导致常量重复定义。</description>
    </item>
    
    <item>
      <title>PHP 流程控制代替语法</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%BB%A3%E6%9B%BF%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%BB%A3%E6%9B%BF%E8%AF%AD%E6%B3%95/</guid>
      <description>流程控制代替语法 代替 for PHP 本身是嵌入到 HTML 中的脚本语言，因此，我们可以这样书写：
// 生成了九个一级标题元素。 &amp;lt;?php for ($i = 1; $i &amp;lt; 10; $i++) { ?&amp;gt;&amp;lt;h1&amp;gt;一级标题&amp;lt;/h1&amp;gt; &amp;lt;?php } ?&amp;gt; 但是，如果我们以上面这种方式将 PHP 代码嵌入到 HTML 中，那么{}给我们所带来的观感是非常不好的。
因此， PHP 提供了一种代替{}的机制：
&amp;lt;?php for ($i = 1; $i &amp;lt; 10; $i++) : ?&amp;gt;&amp;lt;h1&amp;gt;一级标题&amp;lt;/h1&amp;gt; &amp;lt;?php endfor; ?&amp;gt; 同样的，除了for，PHP 还支持 if、switch、while、foreach：
&amp;lt;?php if (1 &amp;lt; 2) : ?&amp;gt;&amp;lt;h1&amp;gt;一级标题&amp;lt;/h1&amp;gt; &amp;lt;?php endif; ?&amp;gt; </description>
    </item>
    
    <item>
      <title>PHP 运算符</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>运算符 错误抑制符 在 PHP 中 有一些错误可以提前预知，但是这些错误可能无法避免，但又不希望报错给用户看，可以使用错误抑制符@()处理。
&amp;lt;?php $a = 10; $b = 0; @($c = $a / $b);  echo $c; 错误抑制符通常在生产环境（上线）会用到，在开发的时候不会用系统本身最好没有任何。</description>
    </item>
    
    <item>
      <title>RegExp 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/regexp-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/regexp-%E5%B1%9E%E6%80%A7/</guid>
      <description>RegExp 属性 lastIndex 从 0 开始，表示字符在进行下一次匹配时的起始位置，这个属性会被exec()和test()用到。
该属性可以被手动修改。
var reg = /ab/g;  var str = &amp;#39;abababab&amp;#39;;  // 第一次匹配，lastIndex 变为 2 console.log(reg.exec(str)); // lastIndex = 2 console.log(reg.lastIndex); //手动修改 lastIndex reg.lastIndex = 0; // 修改成功，lastIndex = 2 console.log(reg.exec(str)); </description>
    </item>
    
    <item>
      <title>RegExp 量词</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E9%87%8F%E8%AF%8D/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E9%87%8F%E8%AF%8D/</guid>
      <description>量词 表示数量。
n+ 匹配 n 一次或多次，等价于 {1,}。
var reg = /a+/g;  var str = &amp;#39;aavva&amp;#39;;  var result = str.match(reg); console.log(result); n* 匹配 n 零次或多次。等价于{0,}。
var reg = /a*/g;  var str = &amp;#39;aavva&amp;#39;;  var result = str.match(reg); console.log(result); n? 匹配 n 零次或一次。等价于 {0,1}。
var reg = /a?/g;  var str = &amp;#39;aavva&amp;#39;;  var result = str.match(reg); console.log(result); n{x} 匹配 n 表达式 x 次。x 是一个非负整数。
var reg = /o{2}/g;  var str = &amp;#39;boooody&amp;#39;;  var result = str.</description>
    </item>
    
    <item>
      <title>JavaScrip 时间线</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%97%B6%E9%97%B4%E7%BA%BF/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%97%B6%E9%97%B4%E7%BA%BF/</guid>
      <description>时间线 浏览器加载一个页面时，当开始执行 JavaScrip 的那一刻，浏览器会有一个特定的加载顺序，按照这个加载顺序一步步的执行的过程，就会形成一个时间线。
顺序 大致就三步：创建 Document ——&amp;gt; DOMTree 解析完毕，文档加载完毕并执行完毕。
 创建 Document 对象，开始解析 Web 页面。 解析 HTML 元素和它们的文本内容后添加 Element 对象和 Text 节点到文档中。此时的document.readyState = &#39;loading&#39;。 如遇到 link 引入的外部 CSS，那么创建线程加载这个 CSS，并继续解析文档。 遇到 script 引入的外部 JS，并且没有设置异步 async、defer 等，浏览器则同步加载这个 JS 文件，并阻塞，等待 JS 加载完成并执行该脚本，然后继续解析文档。 遇到 script 引入的外部 JS，井且设置有异步 async、defer 等，浏览器创建异步线程加载，井继续解析文档。对于 async 属性的脚本，脚本加载完成后立即执行。(异步加载的 JS 文件，其中禁止使用 document.write()) 遇到 img 等有 src 属性的元素，先正常解析 DOM 结构，然后浏览器异步加载 src，并继续解析文档。 当文档（DOMTree）解析完成，此时的document.readyState = &#39;interactive&#39;。 文档解析完成后，所有设置有 defer 的脚本会按照顺序执行。（注意与 async 的不同,但同样禁止使用 document.write()） document 对象触发 DOMContentLoaded 事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。 当所有 async 的脚本加载完成并执行完毕后、img 等加载完成后，document.</description>
    </item>
    
    <item>
      <title>RegExp</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>RegExp 一种查找以及字符串替换的操作。
直接量（推荐使用） var reg = /abcde/i;  var str = &amp;#39;abCDE&amp;#39;;  var result = reg.test(str); console.log(result); new RegExp var str = &amp;#39;abCDE&amp;#39;; var reg = new RegExp(&amp;#39;abc&amp;#39;, &amp;#39;i&amp;#39;); var result = reg.test(str); console.log(result); 贪婪匹配 匹配时，能多匹配，就不会少匹配。
正则表达式默认的匹配模式就是贪婪匹配。
非贪婪匹配 匹配时，能少匹配，就不会多匹配。
+? 重复 1 次或更多次，但尽可能少重复。
var str = &amp;#39;aaaa&amp;#39;; var reg = /a+?/g; var result = str.match(reg); console.log(result); 除了+?，还有：
*? 重复任意次，但尽可能少重复。
?? 重复 0 次或 1 次，但尽可能少重复。
{n,m}? 重复 n 到 m 次，但尽可能少重复。</description>
    </item>
    
    <item>
      <title>RegExp 修饰符</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid>
      <description>修饰符 i 不区分大小写，即 A 和 a 没有区别。
var reg = /abcde/i;  var str = &amp;#39;abCDE&amp;#39;;  var result = reg.test(str); console.log(result); g 全局匹配。查找字符串中所有的匹配项。
即匹配到一个匹配项后，还会继续匹配后续的字符串，它找出字符串中所有的匹配项。
var reg = /ab/g; var str = &amp;#39;abababababab&amp;#39;;  var result = str.match(reg); console.log(result); 如果不加该修饰符，则只匹配一个匹配项：
var reg = /ab/; var str = &amp;#39;abababababab&amp;#39;;  var result = str.match(reg); console.log(result); m 多行匹配，通常需要配合g来用。用边界字符^表示只匹配每一行的开头，用$匹配每一行的结尾，注意时是多行匹配，而不是整个字符串的开头和结尾。
var reg = /^a/gm;  var str = &amp;#39;abcababa\nabab&amp;#39;;  var result = str.match(reg); console.</description>
    </item>
    
    <item>
      <title>RegExp 元字符</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E5%85%83%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E5%85%83%E5%AD%97%E7%AC%A6/</guid>
      <description>元字符 \n 将 n 标记为一个特殊字符（将特殊字符进行转义）、或一个原义字符、或一个向后引用、或一个八进制转义符。
\w 匹配字母、数字、下划线。等价于[A-Za-z0-9_]。
var reg = /\wcd2/g;  var str = &amp;#39;bcd2&amp;#39;;  var result = str.match(reg); console.log(result); \W 匹配非字母、数字、下划线。等价于 [^A-Za-z0-9_]。
var reg = /\Wcd2/g;  var str = &amp;#39;b*cd2&amp;#39;;  var result = str.match(reg); console.log(result); \d 匹配一个数字字符。等价于 [0-9]。
\D 匹配一个非数字字符。等价于 [^0-9]。
\s 匹配任何空白字符，包括空格符、制表符\t、回车符\r、换行符\n、垂直制表符\v、换页符\f。
等价于 [ \f\n\r\t\v]。
\S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\b 匹配一个单词边界，也就是指单词和空格间的位置。
例如， er\b可以匹配 never 中的 &amp;rsquo;er&amp;rsquo;，但不能匹配 verb 中的 er。
var reg = /\bname/g;  var str = &amp;#39;my name is rainy&amp;#39;;  var result = str.</description>
    </item>
    
    <item>
      <title>RegExp 实例</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E5%AE%9E%E4%BE%8B/</guid>
      <description>实例 匹配字符串首或尾是数字的字符串 var reg = /^\d|\d$/g;  var str = &amp;#39;2dfds&amp;#39;;  var result = str.match(reg); console.log(result); 匹配字符串首尾都是数字的字符串 var reg = /^\d[\s\S]*\d$/g;  var str = &amp;#39;2dfds2&amp;#39;;  var result = str.match(reg); console.log(result); 将以 - 分割的字符串变为小驼峰式的字符串 var str = &amp;#39;the-first-name&amp;#39;; var reg = /-(\w)/g; var result = str.replace(reg, function ($, $1) { 	return $1.toUpperCase(); }); console.log(result); 字符串去重 var str = &amp;#39;aaaabbbbccccddddd&amp;#39;; var reg = /(\w)\1+/g; var result = str.replace(reg, &amp;#39;$1&amp;#39;); console.</description>
    </item>
    
    <item>
      <title>RegExp 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/regexp-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/regexp-%E6%96%B9%E6%B3%95/</guid>
      <description>RegExp 方法 exec() 如果匹配模式带有g修饰符，则每匹配一次，匹配结束的位置就是下一次匹配的起始位置。
如果匹配模式不带g修饰符，则不管匹配多少次，匹配的起始位置始终都只从lastIndex = 0开始。即不管匹配多少次，lastIndex 都只为 0。
加 g 修饰符 // 加 g 修饰符 var reg = /ab/g;  var str = &amp;#39;abababab&amp;#39;;  // 第一次匹配，lastIndex 从 0 开始匹配，匹配完后 lastIndex = 2 console.log(reg.exec(str));  // 第二次匹配，lastIndex 从 2 开始匹配，匹配完后 lastIndex = 4 console.log(reg.exec(str));  // 第三次匹配，lastIndex 从 4 开始匹配，匹配完后 lastIndex = 6 console.log(reg.exec(str));  // 第四次匹配，lastIndex 从 6 开始匹配，匹配后 lastIndex = 8 console.log(reg.exec(str));  // 第五次匹配，lastIndex 从 8 开始匹配， // 因为从 8 开始匹配，无法匹配到任何值，因此此处返回 null // 返回 null 之后，lastIndex 从起始位置 0 开始，即现在的 lastIndex = 0， console.</description>
    </item>
    
    <item>
      <title>RegExp 普通字符</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</guid>
      <description>普通字符 () 匹配与()中的字表达式相同的字符。可以用()来标记一个子表达式的开始和结束位置，后面我们可以用\1（反向引用）来引用第一个()中的字表达式。
// 表示匹配与 \w 相同的四个连续的字符 var reg = /(\w)\1\1\1/g;  var str = &amp;#39;aaaabbbbccccc&amp;#39;;  var result = str.match(reg);  console.log(result); 也可以使用\2来引用第二个子表达式：
var reg = /(\w)\1(\w)\2/g;  var str = &amp;#39;ccddvvffff&amp;#39;;  var result = str.match(reg);  console.log(result); 普通字符 () 标记一个子表达式的开始和结束位置，即匹配与()中的字表达式相同的字符，之后我们可以用\1（反向引用）来引用第一个()中的字表达式。
// 表示匹配与 \w 相同的四个连续的字符 var reg = /(\w)\1\1\1/g;  var str = &amp;#39;aaaabbbbccccc&amp;#39;;  var result = str.match(reg);  console.log(result); 也可以使用\2来引用第二个子表达式：
var reg = /(\w)\1(\w)\2/g;  var str = &amp;#39;ccddvvffff&amp;#39;;  var result = str.</description>
    </item>
    
    <item>
      <title>JavaScript Document</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document/</link>
      <pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document/</guid>
      <description>Document Document 是文档的根，表示整个文档，它包含所有元素，包括 html 元素。</description>
    </item>
    
    <item>
      <title>JavaScript Document 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document-%E5%B1%9E%E6%80%A7/</guid>
      <description>Document 属性 head 和 body 表示文档中的 head 和 body 元素。
document.head; document.body; documentElement 表示文档中的 html 元素。
document.documentElement; </description>
    </item>
    
    <item>
      <title>JavaScript Document 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document-%E6%96%B9%E6%B3%95/</guid>
      <description>Document 方法 查找节点 使用 querySelectorAll 和 querySelector 方法选择的元素不是实时的，而使用 getElements 方法选择的元素是实时的。
比如，使用 querySelecto 选择 div 元素，并存放到 ele 变量中，如果后面我们在文档中删除或增加一个 div 元素，ele 中的 div 元素依旧不变。
getElementById() 选择文档中指定 id 的元素，id 是唯一的，所以是 getElement，不是 getElements
var ele = document.getElementById(&amp;#39;only&amp;#39;); getElementsByTagName() 选择文档中指定标签名的元素，返回结果是一个类数组
var ele = document.getElementsByTagName(&amp;#39;span&amp;#39;); getElementsByTagName(&amp;rsquo;*&#39;) 选择文档中的所有元素。
var ele = document.getElementsByTagName(&amp;#39;*&amp;#39;); getElementsByName() 选择文档中指定 name 的元素，ele 是一个类数组，需要注意，该元素只有部分元素才能生效
var ele = document.getElementsByName(&amp;#39;span&amp;#39;); getElementsByClassName() 选择文档中指定 class 的元素
var ele = document.getElementsByClassName(&amp;#39;build&amp;#39;); querySelector() 选择匹配指定选择器的第一个元素。不实时
var ele = document.querySelector(&amp;#39;div &amp;gt; span a .</description>
    </item>
    
    <item>
      <title>HTML 伪元素和伪类</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB/</link>
      <pubDate>Fri, 06 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB/</guid>
      <description>伪元素和伪类 伪类选择器和伪元素选择器都是 CSS 选择器的一种。
伪类选择器使用:开头。
伪元素选择器使用::开头
伪类 用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态根据用户行为而动态变化。
比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的 css 类相似，可以为已有的元素添加样式，但是它只有处于 DOM 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。
伪元素 伪元素用于创建一些不在 DOM 树中的元素（虚拟元素），并为其添加其 CSS 样式。伪元素开头为双冒号::。
比如说，我们可以用::before或::after在一个元素的前面或后面增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在 DOM 树中，因为他们都是虚拟的元素。
 </description>
    </item>
    
    <item>
      <title>HTML DOCTYPE</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/doctype/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/doctype/</guid>
      <description>DOCTYPE 用来告知浏览器该使用了哪种渲染方式来渲染当前文档。
文档首行是&amp;lt;!DOCTYPE html&amp;gt;，则浏览器渲染模式为标准模式；首行不是或没有&amp;lt;!DOCTYPE html&amp;gt;则浏览器的渲染模式为怪异模式。
目前浏览器的渲染引擎使用三种模式：怪异模式、接近标准模式、以及标准模式。
历史问题 在很久以前的网络上，页面通常有两种版本：为网景的 Navigator 准备的版本，以及为微软的 Internet Explorer 准备的版本。
当 W3C 创立网络标准后，为了不破坏当时既有的网站，浏览器不能直接弃用这些标准。因此，浏览器采用了两种模式，用以把能符合新规范的网站和老旧网站区分开。
标准模式 在标准模式下，行为即由 HTML 与 CSS 的规范描述的行为。
在接近标准模式下，只有少数的怪异行为被实现。
怪异模式 在怪异模式下，文档会兼容之前的网页。也叫混杂模式。
compatMode 返回当前浏览器采用的渲染方式。
BackCompat 标准兼容模式关闭，当 document.compatMode 等于 BackCompat 时，浏览器客户区宽度为 document.body.clientWidth;
CSS1Compat 标准兼容模式开启,当 document.compatMode 等于 CSS1Compat 时浏览器客户区宽度为 document.documentElement.clientWidth;</description>
    </item>
    
    <item>
      <title>HTML 表单元素</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/</guid>
      <description>表单元素 label 关联指定的表单元素。
for 为需要关联的元素 id，关联之后，当点击label 时，也可以聚焦到label所关联的元素。
&amp;lt;label for=&amp;#34;account&amp;#34;&amp;gt;账号：&amp;lt;/label&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;&amp;#34; id=&amp;#34;account&amp;#34; /&amp;gt; select 下拉列表。
option 定义下拉列表中可选择的选项。
通过添加 selected 属性来定义默认选项。
&amp;lt;select name=&amp;#34;cars&amp;#34;&amp;gt; 	&amp;lt;option value=&amp;#34;volvo&amp;#34; selected&amp;gt;Volvo&amp;lt;/option&amp;gt; 	&amp;lt;option value=&amp;#34;saab&amp;#34;&amp;gt;Saab&amp;lt;/option&amp;gt; 	&amp;lt;option value=&amp;#34;fiat&amp;#34;&amp;gt;Fiat&amp;lt;/option&amp;gt; 	&amp;lt;option value=&amp;#34;audi&amp;#34;&amp;gt;Audi&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; textarea 文本域（多行输入框）。
&amp;lt;textarea name=&amp;#34;message&amp;#34; rows=&amp;#34;10&amp;#34; cols=&amp;#34;30&amp;#34;&amp;gt; The cat was playing in the garden. &amp;lt;/textarea&amp;gt; button 按钮。
&amp;lt;button type=&amp;#34;button&amp;#34; onclick=&amp;#34;alert(&amp;#39;Hello World!&amp;#39;)&amp;#34;&amp;gt;Click Me!&amp;lt;/button&amp;gt; datalist datalist为 input 设置预定义的下拉列表。
input 获取焦点时，可以看到预定义的下拉列表。
input 的 list 属性必须为 datalist的 id。</description>
    </item>
    
    <item>
      <title>JavaScript Date</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/date/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/date/</guid>
      <description>Date 创建一个 Date 实例，该实例呈现时间中的某个时刻。
Date 对象基于格林威治 Unix Time Stamp，即自 1970 年 1 月 1 日（UTC）起经过的毫秒数。
Date 对象有大量的设置、获取和操作日期的方法。 但它并不含有任何属性。
Date 对象中存放的都是被构造出来的那一刻的时间，而不是随着系统时间改变而改变。</description>
    </item>
    
    <item>
      <title>JavaScript Element</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element/</guid>
      <description>Element 用来遍历元素节点。</description>
    </item>
    
    <item>
      <title>JavaScript Event</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event-%E6%96%B9%E6%B3%95/</guid>
      <description>Event stopPropagation() 用于取消事件的捕获和冒泡，W3C 推荐的方法。
cancelBubble() 功能与stopPropagation()相同， IE 独有，但在 Chrome 中也可以用。
var wrapper = document.getElementsByClassName(&amp;#39;wrapper&amp;#39;)[0];  document.addEventListener( 	&amp;#39;click&amp;#39;, 	function () { 	console.log(&amp;#39;document&amp;#39;); 	}, 	false );  wrapper.addEventListener( 	&amp;#39;click&amp;#39;, 	function (event) { 	console.log(&amp;#39;点击了子元素&amp;#39;);  	event.stopPropagation(); 	// IE 独有，但 Chrome 也可以使用 	event.cancelBubble = true; 	}, 	false ); </description>
    </item>
    
    <item>
      <title>JavaScript Event</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event/</guid>
      <description>Event 表示在 DOM 中出现的事件。</description>
    </item>
    
    <item>
      <title>JavaScript Event 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event-%E5%B1%9E%E6%80%A7/</guid>
      <description>Event 属性 target 返回触发当前事件的事件源对象。
document.onclick = function (event) { 	console.log(event.target); }; </description>
    </item>
    
    <item>
      <title>JavaScript EventTarget</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/eventtarget/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/eventtarget/</guid>
      <description>EventTarget addEventListener() 监听一个对象，并给这个对象绑定指定的事件处理函数。
第一个参数是事件类型，第二个参数是事件的回调回函数。
this 的指向是 DOM 元素本身，第三个参数是一个布尔值，用于定义该对象应该使用哪一种事件处理模型（冒泡、捕获）进行触发。
优点 可以给同一个对象同一类型事件绑定多个事件处理函数，并且会按绑定事件的先后顺序去执行。
// 旧事件 div.addEventListener( 	&amp;#39;click&amp;#39;, 	function () { 	console.log(&amp;#39;第一个事件&amp;#39;); 	}, 	false ); // 新事件，不会fu div.addEventListener( 	&amp;#39;click&amp;#39;, 	function () { 	console.log(&amp;#39;第二个事件&amp;#39;); 	}, 	false ); attachEvent() IE 独有事件，它与 addEventListener() 差不多。
this 指向 window。
for 绑定 addEventListener() 事件 var li = document.getElementsByTagName(&amp;#39;li&amp;#39;);  var len = li.length; for (var i = 0; i &amp;lt; len; i++) { 	// 用立即执行函数解决闭包内存泄漏的问题 	(function (i) { 	li[i].</description>
    </item>
    
    <item>
      <title>JavaScript get 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/get-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/get-%E6%96%B9%E6%B3%95/</guid>
      <description>get 方法 getDate() 返回一个月中的某天 1 — 31
getDay() 返回一周中的某天 0 — 6。
注意，0 表示周一，6 表示周日。
getMonth() 返回一年终的某月 0 — 11。
注意，0 表示一月，11 表示 12 月
getFullYear() 获取四位数的年份 XXXX。
以前是用的 getYear() 方法，因为以前表示日期用的六位制 YY.MM.DD，直到 1999 年 12 月 31 日之后，变成了 2000 年，这个时候的日期用六位制已经无法表示了，因此，现在改用八位制 YYYY.MM.DD。
getHours() 获取小时 0 — 23
getMinutes() 获取分 0 — 59
getSeconds() 获取秒 0 — 59
getMilliseconds() 获取毫秒 0 — 999
getTime() 获取毫秒（从格林威治时间 1970 年 1 月 1 日至今的毫秒数），也叫获取时间戳。
时间戳 用于验证执行某个程序所花费的毫秒数。</description>
    </item>
    
    <item>
      <title>JavaScript GlobalEventHandlers</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/globaleventhandlers/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/globaleventhandlers/</guid>
      <description>GlobalEventHandlers 全局事件句柄，在 JavaScrip 中，为了将属性和事件区分开，所有事件的命名都是小写的，而不是像属性那样用小驼峰式命名。
onclick 当指定元素被点击时，所触发的事件。它的兼容性非常好。
基本等于将事件写到 HTML 元素的onclick内联属性上。
this 的指向是 DOM 元素本身。
只能监听鼠标左键，无法监听右键和滚轮。
onmousedown + onmouseup = onclick
缺点 一个元素只能绑定一个事件，如果给这个元素定义新的事件，那么新的事件会覆盖旧的事件。
var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0];  // 旧事件 div.onclick = function () { 	console.log(&amp;#39;旧事件&amp;#39;); }; // 新事件，会覆盖旧事件 div.onclick = function () { 	console.log(&amp;#39;新s&amp;#39;); }; 点击事件只触发一次 div.onclick = function () { 	console.log(4555); 	// 使 onclick 事件只能被触发一次 	div.onclick = null; }; oncontextmenu 鼠标右键单击指定对象时，所触发的事件。
onmousemove 鼠标移动到指定对象上时，所触发的事件。
onmousedown 鼠标按下指定对象时，所触发的事件。</description>
    </item>
    
    <item>
      <title>JavaScript HTMLElement 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/htmlelement/htmlelement-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/htmlelement/htmlelement-%E5%B1%9E%E6%80%A7/</guid>
      <description>HTMLElement 属性 innerText/textContent 设置或获取指定元素所包含的文本信息，只返文本信息，不返回所包含的元素。
另外，设置元素内容的时候，如果元素内容中有子元素，则这些子元素也会被覆盖。
innerText 很容易 与 textContent 混淆, 但这两个属性间实际上有很重要的区别. 大体来说, innerText 可操作已被渲染的内容， 而 textContent 则不会。
var body = document.getElementsByTagName(&amp;#39;body&amp;#39;)[0]; var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0]; // 设置内容 div.innerText = &amp;#39;123&amp;#39;; /textContent div.textContent = &amp;#39;456&amp;#39;; offsetHeight 它返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。
offsetWidth 它返回该元素的像素宽度，宽度包含该元素的水平内边距和边框，且是一个整数。
offsetLeft 返回当前元素左边界相对于最近的定位父元素的左边界的像素值。该值包含 border
如果当前元素的父元素中没有定位元素，则返回相对文档左边界的像素值。
offsetTop 它返回当前元素顶边界相对于最近的定位父元素的顶边界的像素值。该值包含 border
如果当前元素的父元素中没有定位元素，则返回相对文档左边界的像素值。
offsetParent 返回距离当前元素最近的定位父元素。
如果当前元素的父元素中没有定位元素，则返回 body。
style 设置或返回 ele 的内联样式表中的 attr，并不会返回内嵌样式表和外链样式表中的 CSS 属性。
设置的值必须为字符串格式。
如果是设置 float 这样的保留字属性，则尽量使用 cssFloat ，虽然也可以使用 float 设置，但是 W3C 并不建议使用 float，因为 float 是一个保留字，未来可能会成为关键字，避免未来的命名冲突。</description>
    </item>
    
    <item>
      <title>JavaScript set 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/set-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/set-%E6%96%B9%E6%B3%95/</guid>
      <description>set 方法 setDate() 以数值 1-31 设置日
var date = new Date(); // 设置日期中的第 18 天 var d = date.setDate(18); console.log(d); // 输出被更改后的时间戳，因为日变了，所以日对应的周也会跟着变。 console.log(date); 定时执行某个代码
用 set 方法设置一个未来的时间点，然后判断当 getTime() 的毫秒数与 set 的毫秒数相差小于 1000 的时候，相当于此刻的时间点已经和设置的时间点重合，可以执行一些需要在这个时间点所执行的操作。
用它可以实现倒计时抢漏、闹钟等功能。
setTime() 设置从 1970 年 1 月 1 日至今的毫秒数。
var date = new Date(); // 将 date 设置为从格林威治时间至今的毫秒数（毫秒数会转换为日期） date.setTime(12343546557501); // 返回设置的日期 console.log(date); 闹钟 var date = new Date(); // 设置未来的某个时间点的分和秒，当格林威治时间到达我们设置的时间戳，会执行某个操作 date.setMinutes(10); date.setSeconds(5);  // 定时器，每隔 1000 毫秒会执行一次回调函数 setInterval(function () { 	// 判断格林威治时间是否和设置的时间点相差小于 1000 毫秒（小于 1000 毫秒则表示格林威治时间已经到大我们设置的时间戳） 	if (new Date().</description>
    </item>
    
    <item>
      <title>JavaScript String 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/string/string-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/string/string-%E6%96%B9%E6%B3%95/</guid>
      <description>String 方法 fromCharCode() 将 UTF-16 组成的值转换为一个字符串。
match() 检索并返回字符串匹配正则表达式的结果。
参数通常是一个正则表达式，
var reg = /ab/g;  var str = &amp;#39;abababababab&amp;#39;;  var result = str.match(reg); console.log(result); slice() 从字符串的第 n 位字符开始截取，一直截取到字符串最末。并返回一个新的字符串，且不会改动原字符串。
search() 返回子字符串在字符串中的起始位置（索引值）这个字符串也可以使正则表达式。
匹配失败返回 -1。
var str = &amp;#39;eedsddvv&amp;#39;;  var reg = /(\w)\1(\w)\2/g;  var result = str.search(reg);  console.log(result); split() 使用指定的分隔符字符串将一个字符串对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。
除了会返回匹配结果，还会返回()中第一次匹配的子表达式的值，并且这些值是类数组的数据位，它们存在于类数组的索引位中。
var str = &amp;#39;dfjajfdsssajfiovvdsafjttidjf&amp;#39;;  var reg = /(\w)\1/g;  var result = str.split(reg);  console.log(result); 用数之来分割字符串 var str = &amp;#39;dfjajfdss0sajfiovvds0afjttidjf&amp;#39;;  var reg = /\d/g;  var result = str.</description>
    </item>
    
    <item>
      <title>JavaScript Window 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/window/window-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/window/window-%E5%B1%9E%E6%80%A7/</guid>
      <description>Window 属性 innerWidth 和 innerHeight 返回视口的宽度和高度。
视口就是浏览器中能看到网页的部分。
// 视口宽度 var WViewport = window.innerWidth; // 视口高度 var HViewport = window.innerHeight; console.log(&amp;#39;视口宽度：&amp;#39; + WViewport); console.log(&amp;#39;视口高度：&amp;#39; + HViewport); pageYOffset 和 pageXOffset 返回滚动条当前的纵向滚动距离和横向滚动距离。
// 纵向滚动条的滚动距离 var Ydistance = window.pageYOffset; // 横向滚动条的滚动距离 var Xdistance = window.pageXOffset; console.log(Ydistance); console.log(Xdistance); IE 8 及 IE 8 以下的浏览器 document.body.scrollLeft/Top 和 document.documentElement.scorllLeft/Top这个两个属性的兼容性机器混乱，Top 代表纵向，Left 代表横向
在 IE 8 及 IE 8 以下的浏览器中，这两个属性中只要其中一个有值，则另一个属性的值一定为 0。因此， 如果我们要考虑兼容性的问题，都会将这两个属性相加，以兼容 IE 8 及其 IE 8 以下的浏览器。
DOMContentLoaded 文档解析完成后执行的事件。</description>
    </item>
    
    <item>
      <title>JavaScript Window 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/window/window-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/window/window-%E6%96%B9%E6%B3%95/</guid>
      <description>Window 方法 scroll() 和 scrollTo() 使文档的滚动条滚动至文档中的特定位置。
//让水平的滚动条滚动到 100 像素的位置，再让垂直滚动条滚动到 200 像素的位置 scrollTo(100, 200); scrollBy() 使文档的滚动条按指定的偏移量滚动。
//　让垂直滚动条滚动 10px， scrollTo(0, 10); // 重复执行的话，滚动条会再滚动 10px scrollTo(0, 10); getComputedStyle() 返回指定元素经过计算后的 CSS 样式,，且返回的值都是绝对值，它是一个只读属性。
返回的样式是元素在浏览器中最终渲染效果的样式。
第一个参数是元素，第二个参数是伪元素。
getComputedStyle() 的第二个参数可以获取第一个参数（元素）的伪元素（::before、::after等）的 CSS 样式。
第二个参数不是必须的，当不查询元素的伪元素的时候可以忽略或者传入 null。
currentStyle 只读属性，返回的 CSS 属性的值没有经过计算。IE 独有属性。
获取指定元素的指定 CSS 属性 var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0];  function GetStyle(elem, name) { 	if (window.getComputedStyle) { 	return window.getComputedStyle(elem, null)[name]; 	} else { 	return elem.currentStyle[name]; 	} } setInterval() 用于每隔一段时间调用一个函数或一个代码片段。</description>
    </item>
    
    <item>
      <title>JavaScript 事件句柄</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%8F%A5%E6%9F%84/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%8F%A5%E6%9F%84/</guid>
      <description>事件句柄 事件发生时进行的操作。
事件句柄就是一个将元素的特定事件与某个函数关联起来，比如 onclick、onmouseover 等都是事件句柄，它们会指向一个给定的函数，如果事件发生，那么就会执行此函数。
document.oncontextmenu = function () { 	console.log(&amp;#39;鼠标右击事件句柄&amp;#39;); }; document.onclick = function () { 	console.log(&amp;#39;点击事件句柄&amp;#39;); }; </description>
    </item>
    
    <item>
      <title>JavaScript 事件处理模型</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B/</guid>
      <description>事件处理模型 一个对象的一个事件类型，只能触发一种事件处理模型，也就是要么触发事件冒泡，要么触发事件捕获。
另外，并不是所有事件都存冒泡，比如 focus、blur、change、submit、reset、select 等事件。
事件冒泡 结构上（非视觉上）为嵌套关系的元素，会存在事件冒泡的情况。即同一类型的事件，触发事件源，事件会以由内（事件源）至外的顺序被触发。
HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt;   &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt;  &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt;  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;  &amp;lt;style&amp;gt;  * {  margin: 0;  padding: 0;  }   .wrapper {  width: 300px;  height: 300px;  background-color: rgb(183, 43, 43);  }   .content {  width: 200px;  height: 200px;  background-color: rgb(12, 175, 200);  }   .</description>
    </item>
    
    <item>
      <title>JavaScript 事件对象</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/</guid>
      <description>事件对象 在 DOM 中发生事件时，所有相关信息都会被收集并存储在一个名为**event **的对象中。这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型、可能与特定事件相关的任何其他数据等。
每个事件处理函数都有一个形参 event，这个 **event **就可以在函数中被当做 event 对象来使用。
// event 是一个参数，系统会自动将事件对象传给他。 document.onclick = function (event) { 	console.log(event); }; srcElement 表示触发当前事件的事件源对象。
可以用event.target来获取事件的 srcElement。
Button 表示触发当前事件是鼠标的左键还是右键，又或者是滚轮。
0 表示鼠标左键，1 表示鼠标滚轮，2 表示鼠标右键。
div.onmousedown = function (event) { 	if (event.button == 0) { 	console.log(&amp;#39;Left Click&amp;#39;); 	} else if (event.button == 1) { 	console.log(&amp;#39;Roller&amp;#39;); 	} else if (event.button == 2) { 	console.log(&amp;#39;Right Click&amp;#39;); 	} }; charCode 键盘事件的事件对象上的属性，返回按下的键的 ASCII 码 。</description>
    </item>
    
    <item>
      <title>JavaScript 区分点击事件与长按事件</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E5%8C%BA%E5%88%86%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E4%B8%8E%E9%95%BF%E6%8C%89%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E5%8C%BA%E5%88%86%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E4%B8%8E%E9%95%BF%E6%8C%89%E4%BA%8B%E4%BB%B6/</guid>
      <description>区分点击事件与长按事件 HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; 	&amp;lt;title&amp;gt;区分点击事件与长按事件.m&amp;lt;/title&amp;gt; 	&amp;lt;style&amp;gt; 	div { 	width: 100px; 	height: 100px; 	background-color: rgb(15, 190, 131); 	} 	&amp;lt;/style&amp;gt; 	&amp;lt;/head&amp;gt;  	&amp;lt;body&amp;gt; 	&amp;lt;div style=&amp;#34;position:absolute;left:0;top:0;&amp;#34;&amp;gt;该拖曳只对内联样式有效&amp;lt;/div&amp;gt; 	&amp;lt;/body&amp;gt; 	&amp;lt;script src=&amp;#34;./js/main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt; JavaScrip var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0];  var firstTime = new Date(); var lastTime = new Date(); var key = false; // 元素按下时的时间 document.</description>
    </item>
    
    <item>
      <title>JavaScript 定时器</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/window/%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/window/%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <description>定时器 定时操作的方法全是 Window 对象的方法，这些方法中的 this 都指向 Window
setIntereval() 每隔多少毫秒再循环执行一次回调函数中的代码。
需要注意，这个间隔时间一旦定义就无法被修改。
非常不准确，可以用时间戳来证明。
返回值是一个 id 数值，这个 id 作为当前定时器的唯一标识符。
// 定时器 var time = 1000; setInterval(function () { 	console.log(&amp;#39;定时器&amp;#39;); }, time); // 修改 time，虽然 time 被修改了，但定时器中的 time 依旧也是 1000 time = 10; console.log(time); clearIntereval() 清除由 setInterval() 设置的定时操作。
参数是一个数值。
var i = 0; var time = setInterval(function () { 	console.log(i++); 	if (i &amp;gt; 10) { 	clearInterval(time); 	console.log(&amp;#39;定时器已暂停&amp;#39;); 	} }, 100); setTimeout() 在指定毫秒数之后执行回调函数中的代码。回调函数中的代码只会执行因此。</description>
    </item>
    
    <item>
      <title>JavaScript 拖拽元素</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E6%8B%96%E6%8B%BD%E5%85%83%E7%B4%A0/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E6%8B%96%E6%8B%BD%E5%85%83%E7%B4%A0/</guid>
      <description>拖拽元素 HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; 	&amp;lt;title&amp;gt;拖拽元素&amp;lt;/title&amp;gt; 	&amp;lt;style&amp;gt; 	div { 	width: 100px; 	height: 100px; 	background-color: rgb(15, 190, 131); 	} 	&amp;lt;/style&amp;gt; 	&amp;lt;/head&amp;gt;  	&amp;lt;body&amp;gt; 	&amp;lt;div style=&amp;#34;position:absolute;left:0;top:0;&amp;#34;&amp;gt;该拖曳只对内联样式有效&amp;lt;/div&amp;gt; 	&amp;lt;/body&amp;gt; 	&amp;lt;script src=&amp;#34;./js/main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt; JavaScrip function drag(elem) { 	var disX, disY; 	// 鼠标 	elem.</description>
    </item>
    
    <item>
      <title>JavaScript 脚本化 CSS</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%84%9A%E6%9C%AC%E5%8C%96-css/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%84%9A%E6%9C%AC%E5%8C%96-css/</guid>
      <description>脚本化 CSS 用 JavaScrip 间接操作 CSS，它是通过内联样式表去间接控制 CSS。
间接操作 CSS 时，只有ele.style.attr是读写操作，除此之外的任何操作都是只读操作。</description>
    </item>
    
    <item>
      <title>JavaScript 自动阅读</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E8%87%AA%E5%8A%A8%E9%98%85%E8%AF%BB/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E8%87%AA%E5%8A%A8%E9%98%85%E8%AF%BB/</guid>
      <description>自动阅读 JavaScrip var start = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0];var stop = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0];var time;// 定义一个 key，用来判断自动阅读是否暂停// 如果不加判断，setInterval() 就会被重复执行多个（导致自动阅读的速度增加），而 clearInterval() 则只能暂停第一个 setInterval()（导致自动阅读无法被暂停）var key = &amp;#39;自动阅读已暂停&amp;#39;;start.onclick = function () {// 判断自动阅读的状态if (key == &amp;#39;自动阅读已暂停&amp;#39;) {// 用 setInterval() 反复执行 scrollBy() 实现页面自动向下滚动time = setInterval(function () {window.scrollBy(0, 10);}, 100);// 自动阅读已开始key = &amp;#39;自动阅读已开始&amp;#39;;}};// 自动阅读已暂停stop.onclick = function () {clearInterval(time);key = &amp;#39;自动阅读已暂停&amp;#39;;}; </description>
    </item>
    
    <item>
      <title>JavaScript 返回父元素节点.</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E8%BF%94%E5%9B%9E%E7%88%B6%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E8%BF%94%E5%9B%9E%E7%88%B6%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9/</guid>
      <description>返回父元素节点. JavaScrip function re(e, n) { 	// 如果 e 不为 null 并且 n 不为 0 	while (e &amp;amp;&amp;amp; n) { 	// 获取当前节点的父元素 	e = e.parentElement; 	// 每次循环一次，则想上找一层的父元素，直到 n 为 0 	n--; 	} 	return e; }  var i = document.getElementsByTagName(&amp;#39;i&amp;#39;)[0];  var result = re(i, 3); console.log(result); </description>
    </item>
    
    <item>
      <title>JavaScript 阻止默认事件</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6/</guid>
      <description>阻止默认事件 默认事件：表单提交、a 元素跳转、右键菜单等。
reture false 阻止某个对象的默认事件，只支持阻止事件句柄 onclick，不支持addEventListener()。
document.oncontextmenu = function () { 	console.log(&amp;#39;鼠标右击事件&amp;#39;); 	return false; };  document.onclick = function () { 	console.log(&amp;#39;文档被点击&amp;#39;); 	return false; }; preventDefault() 阻止某个对象的默认事件，支持事件句柄，以及addEventListener()。
document.addEventListener( 	&amp;#39;contextmenu&amp;#39;, 	function (event) { 	console.log(&amp;#39;鼠标右击事件&amp;#39;); 	event.preventDefault(); 	}, 	false ); document.onconte; xtmenu = function (event) { 	console.log(&amp;#39;鼠标右击事件&amp;#39;); 	event.preventDefault(); }; returnValue() 兼容 IE，与preventDefault()一样，支持阻止事件句柄、以及addEventListener()。
document.oncontextmenu = function (event) { 	console.log(&amp;#39;鼠标右击事件&amp;#39;); 	event.</description>
    </item>
    
    <item>
      <title>JavaScrip</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/javascrip/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/javascrip/</guid>
      <description>JavaScript JavaScrip 是单线程的语言的原因是因为 JavaScrip 需要对 HTML 页面进行操作，无法一边操作 HTML 文档，一边又加载 HTML 文档。</description>
    </item>
    
    <item>
      <title>JavaScrip 异步加载 JS</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD-js/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD-js/</guid>
      <description>异步加载 JS 有时候，我们需要加载一些工具包，这些工具包与加载 HTML 文档无关，因此，我们就需要异步加载 JavaScrip，即实现 JavaScrip 的多线程。
aysnc=&amp;ldquo;aysnc&amp;rdquo; 异步加载，加载 JavaScrip 文件完就执行，aysnc 只能加载外部 JavaScrip，并不能将 JavaScrip 代码写到 script 元素中。
defer = &amp;ldquo;defer&amp;rdquo; 异步加载，即一边加载 JavaScrip 文件，一边加载 HTML 文档，但是，它需要等 DOM 文档解析完毕后，才会执行其中的 JavaScrip 代码，相当于window.onload，IE 独有。
可以将 JavaScrip 代码写到 script 元素中。
&amp;lt;script src=&amp;#34;vue.js&amp;#34; defer=&amp;#34;defer&amp;#34;&amp;gt; 	console.log(&amp;#39;IE 异步加载&amp;#39;) &amp;lt;/script&amp;gt; 按需异步加载 JS 当我们用创建一个 script 元素，那么需要将它插入到页面中，才会执行这个 JavaScrip 文件。如果不插入的话，仅仅只执行加载这个 JavaScrip 文件，这样，我们就实现了一个异步加载 JavaScrip 的过程。
因为加载 JavaScrip 文件需要一个过程，而程序执行代码的时候，并不会等 main.js 文件下载完毕才继续执行后续代码，因此，这时候如果立即执行 main.js 中的某个方法，会报错。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description>
    </item>
    
    <item>
      <title>JavaScrip 异步和同步</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5/</guid>
      <description>异步和同步 同步 异步 异步是目的，多线程是手段。
异步是和同步相对的。同步即阻塞，也即在做 A 的时候做不了 B，AB 可以同时做互不干扰就叫异步。为了实现异步，可以利用多线程。</description>
    </item>
    
    <item>
      <title>JavaScrip 浏览器渲染页面</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2/</guid>
      <description>浏览器渲染页面 构建 DOM 树 解析 DOM 节点，将 HTML 元素以树形结构（二叉树）的方式添加到 DOM 树上，解析的时候只解析节点本身，不解析节点的属性或其包含的文本。
此时还未加载 DOM 树，仅仅只是解析 DOM 节点。
构建 CSS 树 构建 Render 树 DOMTree + CSSTree = RenderTree
RenderTree 构建完成之后，浏览器渲染引擎才正式开始绘制页面
reFlow 该过程需要重新构建整个文档，非常浪费性能。
指的是网络浏览器为了重新渲染部分或全部的文档而重新计算文档中元素的位置和几何结构的过程。例如 dom 节点的删除与添加、dom 节点的宽高发生变化、节点的位置变变化等。
repaint 该过程只重新绘制部分元素。
一个元素的外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。例如改变 vidibility、outline、背景色等属性。
节点布局 页面渲染 </description>
    </item>
    
    <item>
      <title>JavaScrip 生成器</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>生成器 用function*定义一个生成器函数，该函数通过next()来调用。
生成器函数在执行时能暂停，后面又能从暂停处继续执行。
生成器函数可以被当作一个迭代器来使用。
function* fun() { 	console.log(&amp;#39;我是生成器函数&amp;#39;); }  let iterator = fun(); iterator.next(); yield yield关键字使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。
function* fun() { 	yield console.log(&amp;#39;第一段代码&amp;#39;); 	yield console.log(&amp;#39;第二段代码&amp;#39;); 	yield console.log(&amp;#39;第三段代码&amp;#39;); 	yield console.log(&amp;#39;第四段代码&amp;#39;); }  let iterator = fun(); iterator.next(); iterator.next(); iterator.next(); iterator.next(); iterator.next(); 调用 next()时，如果传入了参数，那么这个参数会传给上一条执行的 yield 左边的变量：
function* fun(val) { 	let result = yield console.log(&amp;#39;第一段代码&amp;#39;); 	console.log(result); 	// 将 str 传给 result 	yield console.log(&amp;#39;第二段代码&amp;#39;); 	yield console.</description>
    </item>
    
    <item>
      <title>JavaScrip 表达式</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>表达式 表达式是一组代码的集合，它会返回一个值。
JavaScript 有以下表达式类型：
 算数：得出一个数字，例如 3.14159. 字符串：得出一个字符串, 例如 &amp;ldquo;Fred&amp;rdquo; 或 &amp;ldquo;234&amp;rdquo;. 逻辑值：得出 true 或者 false。 基本表达式：javascript 中基本的关键字和一般表达式。 左值表达式：分配给左值。  </description>
    </item>
    
    <item>
      <title>JavaScrip 迭代器</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>迭代器 它是一个对象。
for 用于创建一个循环，由三个表达式和一个用于在循环中执行的代码块组成。
while 当指定表达式为 true，则循环执行代码体，直到表达式为 false 时结束循环。
在一个循环语句中，应当有使表达式为 false 的条件，否则会造成死循环。
do while 不管指定条件是否为 true，其代码块都会被执行一次，直到开始第二次循环时，才开始判断指定条件，直到指定条件为 false 时结束循环。
for in 用于以任意顺序遍历一个对象（除 Symbol 以外）的属性。
因为 for...in 是为遍历对象的属性而构建的，所以并不建议与数组一起使用。
通常与 Object.hasOwnPropert() 一起使用。
var obj = { 	name: &amp;#39;zhu&amp;#39;, 	age: &amp;#39;18&amp;#39;, 	gander: &amp;#39;man&amp;#39;, 	height: 174, 	__proto__: { 	lastName: &amp;#39;不属于 obj 自身的属性&amp;#39;, 	}, }; Object.prototype.zxy = &amp;#39;我是 obj 原型上的属性&amp;#39;; for (var key in obj) { 	// 判断 obj 是否含有自身所没有的属性。 	if (!</description>
    </item>
    
    <item>
      <title>JavaScript Array 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/array/array-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/array/array-%E6%96%B9%E6%B3%95/</guid>
      <description>Array 方法 splice(start,deleteCount,item&amp;hellip;) 从数组的索引 start 开始删除 deleteCount 个元素，并在索引为 start 的地方添加若干个 item 元素，并返回一个新数组。
此方法会改变原数组。
shift() 删除数组的第一个元素，并返回该元素的值。
此方法会改变原数组。
unshift() 将一个或多个元素添加到数组的开头，并返回该数组的新长度，该方法会修改原有数组。
filter() 用于对数组进行过滤，它返回一个过滤后的数组，如果没有任何数组元素通过测试，则返回空数组。
filter()不会对空数组进行检测，不会改变原始数组。
sort() 用原地算法对数组的元素进行排序，并返回数组。
此方法会改变原数组。
它的参数为一个回调函数compareFunction，该回调函数有a、b两个参数，它们分别代表数组中当前进行比较的两个元素：
a 表示在后的那个元素。
b 表示在前的那个元素
数字升序：
var arr = [5, 3, 9, 2, 5, 1, 7]; var result = arr.sort(function (a, b) { 	return a - b; });  console.log(arr); 数字降序：
var arr = [5, 3, 9, 2, 5, 1, 7]; var result = arr.sort(function (a, b) { 	return b - a; });  console.</description>
    </item>
    
    <item>
      <title>JavaScript Element 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element-%E5%B1%9E%E6%80%A7/</guid>
      <description>Element 属性 innerHTML 设置或返回指定元素的内容。返回的内容包含这个元素所包含的子元素以及文本信息。
它会解析 HTML 结构。
设置元素内容的时候，如果元素内容中有子元素，则这些子元素也会被覆盖。
可以在元素内容的后面追加新内容。
var body = document.getElementsByTagName(&amp;#39;body&amp;#39;)[0]; var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0]; // 设置内容 div.innerHTML = &amp;#39;123&amp;#39;; // 追加内容 div.innerHTML += &amp;#39;456&amp;#39;; // 写入 html 元素 div.innerHTML += &amp;#39;&amp;lt;span&amp;gt;写入的元素&amp;lt;/span&amp;gt;&amp;#39;; childElementCount 返回指定元素节点的子元素节点的个数，不包含子元素节点的子元素节点。
firstElementChild 返回指定元素节点的第一个元素节点。
lastElementChild 返回指定元素节点的最后一个元素节点。
children 返回当前元素节点的所有子元素节点，不包含子元素节点的子元素节点。</description>
    </item>
    
    <item>
      <title>JavaScript Element 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element-%E6%96%B9%E6%B3%95/</guid>
      <description>Element 方法 setAttribute() 设置指定元素的属性和属性的值。设置的属性名可以是自定义的属性。
如果这个指定的属性已存在，则仅更改值。
getAttribute() 返回指定属性名的属性值。
getBoundingClientRect() 返回元素的尺寸，以及相对于视口的位置。
如果是标准盒子模型，元素的宽高等于width/height + padding + border-width 的总和。如果box-sizing: border-box，元素的宽高等于 width/height。
返回的结果不是事实的，是静态的。
var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0]; var ele = div.getBoundingClientRect(); </description>
    </item>
    
    <item>
      <title>JavaScript Node 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/node/node-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/node/node-%E5%B1%9E%E6%80%A7/</guid>
      <description>Node 属性 用来遍历节点树。
parentElement 返回当前元素节点的父元素节点。
parentNode 返回指定节点的父节点，一个节点的父节点只有一个。
childNodes 返回指定节点所包含的所有子节点。
firstChild 返回指定节点所包含的最后一个节点
lastChild 返回指定节点所包含的第一个节点
nextSibling 返回在指定节点后面的兄弟节点，如果指定节点为最后一个节点，则返回 null。
previousSibling 返回在指定节点前面的兄弟节点，如果指定节点为第一个节点，则返回 null。</description>
    </item>
    
    <item>
      <title>JavaScript 操作节点</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E6%93%8D%E4%BD%9C%E8%8A%82%E7%82%B9/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E6%93%8D%E4%BD%9C%E8%8A%82%E7%82%B9/</guid>
      <description>操作节点 增加节点 createElement() 创建一个元素节点，但还没有插入到文档中，需要用 appendChild() 将元素插入到文档中。
var div = document.createElement(&amp;#39;div&amp;#39;); createTextNod() 创建一个文本节点，但还没有插入到文档中，需要用 appendChild() 将元素插入到文档中。
var text = document.createTextNode(&amp;#39;我是文本节点&amp;#39;); createComment() 创建一个文本节点，但还没有插入到文档中，需要用 appendChild() 将元素插入到文档中。
var comment = document.createComment(&amp;#39;我是一个注释&amp;#39;); createDocumentFragment(&amp;rsquo;&#39;) 创建了一虚拟的节点对象，也可以说是创建一个文档碎片
var fragment = document.createDocumentFragment(&amp;#39;&amp;#39;); 插入节点 ele.appendChild(subEle) 在 ele 节点的最后一个子节点之后添加 subEle 节点。
如果 subEle 节点已经在文档中存在，那么会将 subEle 节点移动到 ele 节点中。
var body = document.getElementsByTagName(&amp;#39;body&amp;#39;)[0]; var div = document.createElement(&amp;#39;div&amp;#39;); var text = document.createTextNode(&amp;#39;插入的文本&amp;#39;); body.appendChild(div); div.appendChild(text); ele.insertBefore(subEleOne,subEleTwo) 在 ele 节点的子节点 subEleTwo 之前插入一个 subEleOne 节点。
var body = document.</description>
    </item>
    
    <item>
      <title>JavaScript 类数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/array/%E7%B1%BB%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/array/%E7%B1%BB%E6%95%B0%E7%BB%84/</guid>
      <description>类数组 类数组是可以当作数组来使用的对象
类数组虽然在写法上跟数组一样，但它实际上是 object，且数组能调用的方法它都不能调用的数组。
比如 arguments，函数的第一个参数是 argument[0]，写法上跟数组一样，但是不是数组，它的原型是 Object，它也不能调用数组的一些方法。
特点 具有对象和数组的特性，既可以当作对象来用，也可以当作数组来用（并不是所有的数组方法都能使用，可以自己手动添加）
数据位 存在于数组索引位上的数据。</description>
    </item>
    
    <item>
      <title>JavaScrip JSON</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/json/json/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/json/json/</guid>
      <description>JOSN 一种轻量级的数据传输格式。本质上就是对象，用来传输的对象。
它在与后端的数据交互中有较为广泛的应用。
优点 JSON 比 XML 更小、更快，更易解析。
语法 客户端与服务端的交互数据无非就是两种：
 数组 对象  于是乎，JSON 所表示的数据要么就是对象，要么就是数组。
JSON 数组 var employees = [ 	{ firstName: &amp;#39;Bill&amp;#39;, lastName: &amp;#39;Gates&amp;#39; }, 	{ firstName: &amp;#39;George&amp;#39;, lastName: &amp;#39;Bush&amp;#39; }, 	{ firstName: &amp;#39;Thomas&amp;#39;, lastName: &amp;#39;Carter&amp;#39; }, ]; JSON 对象 var obj = { 	age: 20, 	str: &amp;#39;zhongfucheng&amp;#39;, 	method: function () { 	alert(&amp;#39;我爱学习&amp;#39;); 	}, }; </description>
    </item>
    
    <item>
      <title>JavaScrip JSON 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/json/json-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/json/json-%E6%96%B9%E6%B3%95/</guid>
      <description>JSON 方法 stringify() 将一个对象或值转换为 JSON 字符串。
var obj = { 	name: &amp;#39;rainy&amp;#39;, 	age: &amp;#39;20&amp;#39;, }; var result = JSON.stringify(obj); // 对象 console.log(obj);  // 字符串 console.log(result); parse() 将 JSON 字符串转换为对象。
var json = &amp;#39;{&amp;#34;name&amp;#34;:&amp;#34;rainy&amp;#34;, &amp;#34;age:&amp;#34;:20}&amp;#39;;var obj = JSON.parse(json);// 字符串console.log(json);// 对象console.log(obj); </description>
    </item>
    
    <item>
      <title>C Null</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/null/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/null/</guid>
      <description>Null 二进制全部为零时有几种含义，为什么会有几种含义呢，这是因为解码的方式不同：
 数值零。（数值解码） 字符串结束标记符&#39;\0&#39;（字母解码） 空指针Null，此时的Null本质也是零，但这个零不代表数字 0：int i = 0，而表示某个内存单元的地址为零（地址解码）  另外，我们计算机规定，以零（Null）为地址的储存单元的内容不可读，也不可写。</description>
    </item>
    
    <item>
      <title>C 分配内存和释放内存</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E5%92%8C%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E5%92%8C%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98/</guid>
      <description>分配内存和释放内存 分配内存 操作系统会将某一块内存空间的控制权限，交给程序。
释放内存 释放内存，可以用 C 语言中的free();函数来实现。
程序会将某一块内存空间的控制权限，交还给操作系统，使得这个程序无法对这块区域进行操作。而不是将这一块内存空间中的数据清空。</description>
    </item>
    
    <item>
      <title>C 变量为什么要初始化</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>变量为什么要初始化 初始化，也叫赋值，变量不进行初始化，那么这个变量中所存放的数据就是垃圾值。
垃圾值 垃圾值（随机值）指的是其他程序使用某个内存空间所遗留下来的值。
VC++ 若发现某个变量的内存空间内有垃圾值（即该变量没进行初化），那么它会将该垃圾值替换为填充值。目的是为了避免开发者将垃圾值当做一个正常值来使用，也就是提醒开发者这个变量没有进行初始化。因此，变量若未进行初始化，该变量的内存空间内存放的是一个垃圾值。</description>
    </item>
    
    <item>
      <title>C 变量的定义和赋值</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B5%8B%E5%80%BC/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B5%8B%E5%80%BC/</guid>
      <description>变量的定义和赋值 系统是如何执行 int i = 5; 这个语句的  程序请求操作系统为 i 分配存储空间。 操作系统会在内存中寻找一块空闲的内存空间，将这个内存空间当作 i 来使用。 程序会将 i 和这块内存空间关联起来，也就是将 i 当作这块内存空间的名字，使得以后对 i 这个字母进行操作，就相当于对这块内存空间进行，操作。 最后将 5 存储到 i 中，也就是存储到这块空闲的区域中。  </description>
    </item>
    
    <item>
      <title>C 三目运算符</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E8%BF%90%E7%AE%97%E7%AC%A6/%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Tue, 19 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E8%BF%90%E7%AE%97%E7%AC%A6/%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>三目运算符 a ? b : c 相当于 if 语句
if (a);  b; else  c; return 0; </description>
    </item>
    
    <item>
      <title>C 逗号表达式</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E8%BF%90%E7%AE%97%E7%AC%A6/%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 19 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E8%BF%90%E7%AE%97%E7%AC%A6/%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>逗号表达式 (a,b,c,d) 从左向右执行，表达式最终的值是 d 的值。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt; int main() {  int i;  int c = 2;  i = (c++, ++c, c + 2, c - 3);  // 执行了 c++ 与 ++c 后，c 变为了 4，然后执行 c + 2，  // 但此时并没有将 c + 2 的结果赋给 c，因此此时的 c 依旧为 4，  // 再 c - 3，则 i = 1.  printf(&amp;#34;%d&amp;#34;, i);  // return 1  return 0; } </description>
    </item>
    
    <item>
      <title>C 反转</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>反转链表 // * pHead 头指针 struct ListNode* ReverseList(struct ListNode* pHead ) { 	// pHead 头结点 	// 当为空、或者 只有一个元素时直接退出  if(pHead == NULL)  return NULL;  if(pHead-&amp;gt;next == NULL)  return pHead;   //至少两个元素时  //定义两个空指针  struct ListNode *p = NULL;  struct ListNode *temp = NULL;  // p ：首结点，断开头结点指向空  p = pHead-&amp;gt;next;  pHead-&amp;gt;next = NULL;  // 首结点的下一个结点不为空  while(p-&amp;gt;next != NULL)  {  // 记录首结点的下一个结点  temp = p-&amp;gt;next;   // 头删  p-&amp;gt;next = pHead;   // 将首结点设置为头结点  pHead = p;   // 将当前节点的下一个结点  p = temp;  } 	//退出时 p 是最后一个结点 也是最终目标链表头结点   //p 指向头结点  p-&amp;gt;next = pHead; 	//p设置为头结点  pHead = p;  //返回 pHead  return pHead; } </description>
    </item>
    
    <item>
      <title>C 链表</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8/</guid>
      <description>链表 链表主要是便于管理长度或数量不确定的数据，相对于数组，链表处理这种数据时比较节省内存。
链表靠节点的指针域中存放的指针地址来寻找下一个元素。
确定一个链表，只需要知道头指针即可。
优点 存取数据效率高。
不需要一个太大的内存。
缺点 查找某个位置的元素时，效率很低。
结点 链表由一个个的结点组成，每个节点左侧是数据域，右侧是指针域，数据域用来存放当前节点的有效数据，指针域用来存放下一个节点的指针地址。
链表中一个个的元素，被称之为结点，每个结点都有数据域和指针域。
首结点 链表中存放第一个有效数据的节点。
尾结点 链表中存放最后一个有效数据的节点，尾节点的指针域为 Null。
头结点 头结点的数据类型和首节点的类型一模一样。
头结点是首节点前面的那个节点。
头结点的数据域通常不存放任何有效数据，但头结点的指针域存放的是首节点的地址。
设置头结点的目的是为了方便对链表的操作。
任何一个链表都有一个头结点
空链表，指的是头结点的指针域为 Null 的链表，非空链表，指的是头结点的指针域有指向的链表。
头指针 它不是链表的节点，只是一个指针变量，用于存放头结点的指针地址。
链表实例 # include &amp;lt;stdio.h&amp;gt; # include &amp;lt;malloc.h&amp;gt; # include &amp;lt;stdlib.h&amp;gt;  // 定义一个链表 struct Node {  // 定义链表中节点的数据域  int data;  // 定义链表中节点的指针域。  // 指针域是一个 struct Node *类型的 pNext，其中 pNext 中存放的是 struct Node 变量的地址  struct Node * pNext; };  struct Node * CreateList(void); void TraverseList(struct Node *);  int main(void) {  // 定义头指针 pHead，用来存放链表的头结点的地址，  // 也就是我们可以通过 pHead 中存放中的地址，找到链表的头结点.</description>
    </item>
    
    <item>
      <title>C 枚举</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%9E%9A%E4%B8%BE/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%9E%9A%E4%B8%BE/</guid>
      <description>枚举 将一个事物所有可能的取值给一一列举出来。
优点 使代码更加安全。
使代码更加直观。
缺点 书写麻烦。
# include &amp;lt;stdio.h&amp;gt; # include &amp;lt;malloc.h&amp;gt; // 定义一个数据类型，并没有定义变量，该数据类型的名字为 enum WeekDay enum WeekDay{  // 每一个元素，实际上都是数字，并且第一个元素默认是从 0 开始的，  // 当然，也可以指定首个元素是多少：MonDay = 1;那么此时的 Monday 就是 1，不再是 0 了  // 那么第二个元素就是 2，不再是 1 了，  // 这样写的好处是，WeekDay 的取值只能是下面的这些枚举常量，也就是将 WeekDay 的取值范围给限制了。  // 这样会让代码更加安全，也更加直观。  MonDay, TuesDay,WednesDay,ThursDay,FriDay,SaturDay,SunDay };  int main(void) {  // 因为一个周实际上只能有 7 天，因此这个 int week 只能取1 - 7，且不能是负数或则大于7 的数  // 但默认情况下，int week 的取值大概率会超出这个范围，但我们又不能强制要求 int 的 week 的取值范围是多少  // 所以，我们就需要用到枚举  int week;  // 虽然 WednesDay = 2，但是不能写成：  // enum WeekDay newWeek = 2;  // newWeek 的值只能是枚举常量  enum WeekDay newWeek = WednesDay;  // 实际上返回的是 2  printf(&amp;#34;%d&amp;#34;,newWeek); } </description>
    </item>
    
    <item>
      <title>C 结构体</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E7%BB%93%E6%9E%84%E4%BD%93/%E7%BB%93%E6%9E%84%E4%BD%93/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E7%BB%93%E6%9E%84%E4%BD%93/%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
      <description>结构体 将一些基本类型数据组合在一起，形成一个新的复合数据类型，这个复合数据类型，就是结构体。
为什么需要结构体 为了表示一些复杂的事物，而普通的基本类型无法满足我们的实际需求
结构体的定义 结构体有三种定义方式，但最常用的定义方式是第一种，第二种和第三种都不常用，相较于第一种定义方式，第一种和第二种方式也不是特别好。
需要注意的是，结构体最后的分号不能省去。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt;// 第一种定义结构体的方式 // 只定义变量类型， 但不定义变量名， // 变量名由我们使用这个变量类型的时候定义。 struct Student{  int age;  float score;  char sex; }; // 第二种定义结构体的方式 // 定义的同时，也将变量名（Sts）定义了（变量名写死了）。 struct Students{  int age;  float score;  char sex; } Sts; // 第三种定义结构体的方式 // 没有定义变量类型，只定义了变量名。 struct{  int age;  float score;  char sex; }St;  int main(void) { } </description>
    </item>
    
    <item>
      <title>C 结构体的使用</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E7%BB%93%E6%9E%84%E4%BD%93/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E7%BB%93%E6%9E%84%E4%BD%93/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>结构体的使用 初始化和赋值   初始化一个结构体的时候，可以同时进行赋值。
  先初始化一个结构体，后续再一个变量一个变量的进行赋值。
  #include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt; struct Student{  int age;  float score;  char sex; };  int main(void) {  // 初始化结构体，同时进行赋值  struct Student Rainy = {18,98.3,&amp;#39;N&amp;#39;};  // 初始化结构体，后续再一个变量一个变量的进行赋值  struct Student Rainys;  Rainys.age = 21;  Rainys.score = 95.6;  Rainys.sex = &amp;#39;V&amp;#39;;  printf(&amp;#34;%d %f %c\n&amp;#34;,Rainy.age,Rainy.score,Rainy.sex);  printf(&amp;#34;%d %f %c&amp;#34;,Rainys.age,Rainys.score,Rainys.sex);  } 访问结构体中的变量  通过结构体变量名.成员变量名的方式去访问结构体中的变量 通过指针变量名-&amp;gt;成员变量名 = (*指针变量名).</description>
    </item>
    
    <item>
      <title>C 多级指针</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88/</link>
      <pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88/</guid>
      <description>多级指针 其实就是指针的指针int**，或指针的指针的指针int***，或者指针的指针的指针的指针int****。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt; int main() {  // i 存放的是 int 类型  int i = 10;  // p 存放 i 的地址，且这个地址只能是 int 类型的地址，因为 p 是 int 类型的指针变量。  int * p = &amp;amp;i;  // q 存放 p 的地址，且这个地址只能是 int * 类型的地址，不能存放 int 类型的地址，因为 q 是 int* 类型的指针变量。  int ** q = &amp;amp;p;  // r 存放 q 的地址,且这个地址只能int**的地址，不能存放 int * 类型的地址，因为 r 是 int **类型的指针变量。  int *** r = &amp;amp;q;  printf(&amp;#34;%d&amp;#34;,***r); } #include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.</description>
    </item>
    
    <item>
      <title>C 跨函数使用内存</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E8%B7%A8%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98/</link>
      <pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E8%B7%A8%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98/</guid>
      <description>跨函数使用变量 静态内存不能跨函数使用 当静态函数终止之后，这个静态函数中的数据就不能被其他函数访问，因为这个静态函数的内存空间已经被释放了。就算可以使用，也是非法访问，这样是不对的。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt;// q 是指针变量，无论 q 是什么类型的指针变量，都只占 4 个字节 // 将实参 *p 传入 fun 函数的形参，则**q = *p, 则*q = p，q 存放的是 p 的地址， void fun(int **q){  int i = 5;  // ** q = i  // *q = p  //q = p 的地址  // **q = *p  // 因为 *q = p，所以这里相当于 p = &amp;amp;1，  *q = &amp;amp;i; } int main(void) {  int *p;  // 取 p（*p） 的地址，传入函数 fun，实际传入的是 *p，则 **q = *p  fun(&amp;amp;p);  // 下面代码语法没问题，但是逻辑上有问题。  // 这是因为当 fun 函数执行完毕后，fun 函数中的 i 变量已经被释放，  // 因此，p 虽然可以存放 i 的地址， 但是却不能访问 i 。  // 就算能够访问 i ，这也是非法的访问，没 error 是因为编译器的问题。  printf(&amp;#34;%d\n&amp;#34;,*p); } 动态内存可以跨函数使用 因为当一个函数执行完毕，动态内存分配的变量不会随着fun()的自动释放而释放，所以，当fun()被系统自动释放后，我们依旧可以访问变量*p</description>
    </item>
    
    <item>
      <title>C 动态一维数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E5%8A%A8%E6%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E5%8A%A8%E6%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</guid>
      <description>动态一维数组 动态一维数组可以被当作静态一维数组来来用，换言之，静态数组可以实现的，动态数组都可以实现，不同的是，动态一维数组可以被我们使用free()函数助动释放掉，而且可以用realloc()动态的缩小或扩充。
而静态一维数组只能等当前函数执行完毕后，才会被系统自动释放。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt; int main() {  // 静态创建一维数组，数组大小为 20个字节  // 静态数组只能等它自己所在的函数 main 执行完毕后，才会被系统助动释放。  int a[5];   // 动态创建一维数组  // 数组长度  int len;  // 数组名  int * pArr;  //自定义数组长度  printf(&amp;#34;请输入你要存放的元素个数：&amp;#34;);  scanf(&amp;#34;%d&amp;#34;,&amp;amp;len);// 5  // 动态创建一维数组，数组大小为 20个字节，类似于 int pArr[len];  pArr = (int *)malloc(4 * len);   // 向动态数组里面添加元素  for(int i = 0; i &amp;lt; len; i++)  {  scanf(&amp;#34;%d&amp;#34;,&amp;amp;pArr[i]);  printf(&amp;#34;你向数组中添加了：%d\n&amp;#34;,pArr[i]);  }   // 输出动态数组中所有的元素  printf(&amp;#34;pArr 数组中的元素有：&amp;#34;);  for(int i = 0; i &amp;lt; len; i++)  {  printf(&amp;#34;%d、&amp;#34;,pArr[i]);  } } </description>
    </item>
    
    <item>
      <title>C 静态变量和动态变量</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F/</guid>
      <description>静态变量和动态变量 如果一个变量所对应的内存空间是静态分配的，那么这个变量就是静态变量。
如果一个变量所对应的内存空间是动态分配的，那么这个变量就是动态变量。
静态变量 静态变量在栈内存中分配。由程序自动分配，也由程序自动释放。在函数运行的过程中，无法被使用者手动释放，必须等函数执行完毕。
动态变量 动态变量在堆内存中分配。由使用者手动分配，也由使用者手动释放。在函数的运行的过程中，可以被使用者手动释放，不需要等待函数执行完毕。</description>
    </item>
    
    <item>
      <title>JavaScript DOM</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/dom/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/dom/</guid>
      <description>DOM DOM （文档对象模型）中提供了一系列的方法，DOM 是这一些列方法的统称。这些方法使得我们可以操作 HTML 和 XML。
DOM 就像一棵节点树一样，从文档的根（document），依次分支展开，每一个元素，都可以看作是树的一个节点，每一个元素都是一个对象。
使用 DOM 操作文档中的元素时，必须先加载整个 HTML 文档（body 之前的代码 ），再加载 JS 文件；因为没有完整的 DOM 模型，DOM 的一些操作就无法完成，会导致报错。
graph TD;Node --&amp;gt; Document;Node --&amp;gt; CharacterData;Node --&amp;gt; Element;Node --&amp;gt; Atrr;Document --&amp;gt; HTMLDocument;Document --&amp;gt; XMLDocument;CharacterData --&amp;gt; TextCharacterData --&amp;gt; CommentElement --&amp;gt; HTMLElementAttrHTMLElement --&amp;gt; HTMLHeadElementHTMLElement --&amp;gt; HTMLBodyElementHTMLElement --&amp;gt; HTMLTitleElementHTMLElement --&amp;gt; HTMLParagraphlement Node 最终指向 Object.prototype。
getElementById() getElementById() 定义在了 Document.prototype 上，这说明 XMLDocument 和 HTMLDocument 都能使用 getElementById()，但 Element 不能使用 getElementById()。</description>
    </item>
    
    <item>
      <title>JavaScript ES5 严格模式</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/es5-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/es5-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</guid>
      <description>ES5 严格模式 ECMAScript 是 JavaScript 的一个标准。
ES5 严格模式指的是：我们应该对 ES3 和 ES5 产生冲突的部分使用哪个版本的规则？
当我们开启 ES5 严格模式后，那么 ES3 和 ES5 产生冲突的部分会遵循 ES5 的规则，否则会使用 ES3（浏览器默认遵循 ES3 的规则）
&amp;ldquo;use strict&amp;rdquo; 使某一作用域内的代码不在兼容 ES3 中的一些不规则的语法，使用全新的 ES5 的语法。
如何启用 ES5 严格模式 在作用域顶端添加语句&amp;quot;use strict&amp;quot;即可，启用之后，ES3 中的一些方法就无法使用了。比如arguments的callee属性：
&amp;#39;use strict&amp;#39;; function test() { 	console.log(arguments.callee); } test(); 浏览器会出现以下错误：
Uncaught TypeError: &amp;#39;caller&amp;#39;, &amp;#39;callee&amp;#39;, and &amp;#39;arguments&amp;#39; properties may not be accessed on strict mode functions or the arguments objects for calls to them 同样，也可以使某一局部作用域支持 ES5，而其他作用域支持 ES3：</description>
    </item>
    
    <item>
      <title>JavaScript Try Catch</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%8E%A7%E5%88%B6%E6%B5%81/try-catch/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%8E%A7%E5%88%B6%E6%B5%81/try-catch/</guid>
      <description>Try Catch 为了容错，防止程序报错后引起整个程序的终止运行
try 中有错误信息 就会执行 catch 中的代码，没有这不会执行 catch 之中的代码
catch 有一个参数，参数名自定义 比如 e
那么这个 e 就会有两个参数 e.name 和 e.message
Error.name EvalError：eval()的使用与定义不一致
RangeError：数值越界
ReferenceError：非法或不能识别的引用数值，比如当一个变量未经声明就使用或者一个函数未定义就调用的时候，会出现 ReferenceError。
SyntaxError：语法解析错误
TypeError：操作数类型错误
URlError：URI 处理函数使用不当</description>
    </item>
    
    <item>
      <title>JavaScript with</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/other/with/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/other/with/</guid>
      <description>with with(ogj)函数可以改变自身代码块中的代码的作用域链，它会将 obj 放到它自己代码块中的代码的作用域链的最顶端，也就是会先去 obj 的作用域中去寻找变量。
ES5 中不支持 with 函数。
 var obj = {  age: &amp;#34;456&amp;#34;,  name: &amp;#34;your&amp;#34;, }  function test() {  var age = &amp;#39;123&amp;#39;;  var name = &amp;#39;my&amp;#39;;  with (obj) {  // 下面的输出不会返回自身作用域（test 函数的作用域）下的 age 和 name。  // 只会返回全局作用域下的 obj 对象的 age 和 name，因为作用域被 with 函数改变了。  console.log(age);  console.log(name);  } } test(); 替代链式调用 with (document) {  write(&amp;#34;with 调用&amp;#34; + &amp;#34;&amp;lt;br/&amp;gt;&amp;#34;) }  //等同于 document.</description>
    </item>
    
    <item>
      <title>C for</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/for/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/for/</guid>
      <description>for 执行 1，判断 2，当 2 为 true 时则执行 A，之后再执行 3，此后一直判断 2，直到 2 为 false 时并结束循环；如果 2 为 false，则直接结束循环。
for(1; 2; 3) {  A; } 其中：
1 只执行一次。
3 执行完后才意味着一次 for 循环执行完毕。
3 执行完后一定会再执行一次 2，且不管表达式 2 的结果为 true 或 false 都会执行一次 2。
#include &amp;lt;stdio.h&amp;gt;int main(void) { 	int sum = 0; 	for (int i = 1;i &amp;lt; 10;i++) 	printf(&amp;#34;%d\n&amp;#34;, i); 	//0 - 10 的自然数。 } 1 - 10 所有奇数之和 #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>C if</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/if/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/if/</guid>
      <description>if 在程序当中,并不是所有的语句都是自上而下依次的执行，有时候会依据条件来选择性的执行某段代码，这个时候就需要用到 if 语句。
如果 1 为真，则执行 A；如果 1 为假，则不执行 A。
#include &amp;lt;stdio.h&amp;gt;int main(void) { 	if (1) 	A； } #include &amp;lt;stdio.h&amp;gt;int main(void) { 	if (2 &amp;gt; 1) 	printf(&amp;#34;if 语句为 true\n&amp;#34;); } if 语句默认只能控制 A，不能控制 B（即无论 1 为 true 还是 false， B 都会执行）。
#include &amp;lt;stdio.h&amp;gt;int main(void) { 	if (1) 	A; 	B; } #include &amp;lt;stdio.h&amp;gt;int main(void) { 	if (2 &amp;gt; 1) 	printf(&amp;#34;被 if 语句控制\n&amp;#34;); 	printf(&amp;#34;不被 if 语句控制\n&amp;#34;); } if 语句默认只能控制一个 A，如果想控制多个语句（A 和 B），就必须将 A 和 B 用 {} 括起来。</description>
    </item>
    
    <item>
      <title>C malloc</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/malloc/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/malloc/</guid>
      <description>malloc malloc 是 memory（内存）allocate（分配）的缩写。
可以让一个变量动态分配内存。
malloc 函数的使用 #include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt; int main() {  int a = 5; // a 是一个 int 变量，它是静态分配的  int * p = (int *)malloc(4); // 动态分配  *p = 5;// *p 也是一个 int 变量，但它是动态分配的  free(p); // 手动释放动态分配的内存  printf(&amp;#34;%d\n&amp;#34;,*p);  printf(&amp;#34;%d\n&amp;#34;,p); }  使用 malloc 函数，需要添加头文件 malloc.h malloc 函数只有一个形参，并且形参是整型。 malloc(4)表示请求系统为我们分配 4 个字节 malloc 函数只能返回第一个字节的地址，即 p 只保存了第一个字节的整型地址 int * 是为了让系统知道我们分配这个 4 个字节的地址是整型地址。 int * p = (int *)malloc(4)这行代码总共分配了 8 个字节，int * p分配了 4 个字节，(int *)malloc(4)分配了 84 个字节一共 8 个字节。 p（int * p）本身所占的内存是静态分配的，但 p 所指向的内存(int *)malloc(4)是动态分配的。 free(p)表示将 p 所指向的内存给释放掉，使得 p 指向的内存无法被读写。但是，p 本身的内存是静态的，不能被我们用free()函数手动释放，p 本身的内存只能在 p 变量所在的函数运行结束后，被系统自动释放。 *p = 5和int a = 5的区别在于前者的内存分配方式是动态分配的，后者的内存分配方式是静态分配的。 *p = 5 中，其中*p指的是用(int *)malloc(4)动态分配了 4 个字节的内存空间，而*p = 5，则是将 5 这个 int 数值放入这动态分配的 4 个字节的内存中。而 p 则只保存了其中第 1 个字节的地址。  </description>
    </item>
    
    <item>
      <title>C 流程控制</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>流程控制 流程控制也叫控制结构，控制程序应该如何执行代码。
顺序控制 从上到下的执行代码，中间没有任何判断或跳转。
选择控制 某些代码可能执行，也可能不执行，有选择的执行某些代码。
循环控制 某些代码被重复执行。</description>
    </item>
    
    <item>
      <title>C 一个指针变量占几个字节</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%8D%A0%E5%87%A0%E4%B8%AA%E5%AD%97%E8%8A%82/</link>
      <pubDate>Wed, 30 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%8D%A0%E5%87%A0%E4%B8%AA%E5%AD%97%E8%8A%82/</guid>
      <description>一个指针变量占几个字节 在 64 位系统中，一个指针变量占 4 个字节，不管这个指针指向的是什么类型的变量。
在 64 位系统中，一个指针变量占 8 个字节，不管这个指针指向的是什么类型的变量。
sizeof() 此函数可以返回指定数据类型所占的字节。
#include &amp;lt;stdio.h&amp;gt; int main () {  int a = 666;  char ch = &amp;#39;A&amp;#39;;  double dou = 99.9;  int*p = &amp;amp;a;  char *c = &amp;amp;ch;  double *x = &amp;amp;dou;  // 不过什么数据类型的指针变量，  // 所占字节都是 8 个（32 位系统占 4 个字节）  printf(&amp;#34;%d\n&amp;#34;,sizeof(p));  printf(&amp;#34;%d\n&amp;#34;,sizeof(c));  printf(&amp;#34;%d\n&amp;#34;,sizeof(x)); } 虽然在 64 位系统中的指针变量占 8 个字节，但是一个变量的地址（指针变量）只会存放该变量首字节的地址。这样，指针变量通过首字节的地址，就能知道自己所指向的变量类型，也就知道了该指针变量所指向的变量到底占多少个字节。</description>
    </item>
    
    <item>
      <title>C 动态分配内存</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98/</link>
      <pubDate>Wed, 30 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98/</guid>
      <description>动态内存分配 传统数组的缺点 传统数组也叫静态数组，也属于静态内存
  数组长度必须事先指定，且只能是长整数，不能是变量。
  传统形式定义的数组，该数组的内存无法被我们手动释放。因为系统为该数组分配的储存空间就会一直存在，除非数组所在的函数运行完毕，数组的空间才会被系统释放。
#include &amp;lt;stdio.h&amp;gt;void fun(void){  // 这 20 个字节（4 个 int ）的储存空间无法被我们手动的释放，  // 只能在本函数（fun 函数）运行完毕后由系统自动释放  int a[5] = {1,2,3,4,5}; } int main () {  }   数组的长度一旦定义，其长度就不能再被更改。也就是数组的长度不能在函数运行的过程中动态的扩充或缩小。
  Ａ 函数中定义的数组，在 Ａ 函数运行期间可以被其他函数使用，但 A 函数运行完毕之后，A 函数中的数组将无法在被其他函数使用（A 函数在运行完毕后，就会被系统释放）。
  动态数组（动态内存） 动态数组很好的解决了传统数组的 4 个缺点，传统数组也叫静态数组，</description>
    </item>
    
    <item>
      <title>C 一维数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</guid>
      <description>一维数组 定义一个一维数组时：
为 n 个变量连续分配储存空间。
数组中的所有元素，数据类型必须一致。
数组中所有变量所占的字节必须一样。
定义一维数组 #include &amp;lt;iostream&amp;gt;int main(){  // 完全初始化  int arr[5] ={1,2,3,4,5};  // 不完全初始化，未初始化的元素的值为 0  int arr2[5] ={1,2,3};  // 打印索引为 4 的值，但 arr2 中没有索引为 3 的值，因此这里返回 0  printf(&amp;#34;%d\n&amp;#34;,arr2[3]);  // 不初始化，所有元素都是垃圾值  int arr3[5];  printf(&amp;#34;%d\n&amp;#34;,arr3[5]);  // 清零，将数组中的每个元素的值都变成 0  int arr4[5] = {0}; } 错误的定义 只有在定义数组的同时，才可以整体赋值，
其他情况下整体复制都是错误的。
#include &amp;lt;iostream&amp;gt;int main(){  int a[5];  // a[5] 表示 a 数组中索引为 5 的值。  a[5] = {1,2,3,4,5}; } 将数组 a 中的值全部复制到数组 b #include &amp;lt;iostream&amp;gt; int main() { // 错误的写法，因为一维数组名，d该数组中第一个元素的地址  b = a; // 正确的写法  for(int i = 0; i &amp;lt; 5; i++ )  {  b[i] = a[i];  } } </description>
    </item>
    
    <item>
      <title>C 二维数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</guid>
      <description>二维数组 一个二维数组，在本质上，是一个一维数组的列表。它声明了一个 x 行 y 列的二维整型数组。
#include &amp;lt;iostream&amp;gt; int main(){  // 该数组中总共有12个元素，可以当作 3 行(一)5 列（丨）来看  int arr[3][4];  // 这个二位数组以此为：  arr[0][0] arr[0][1] arr[0][2] arr[0][3]  arr[1][0] arr[1][1] arr[1][2] arr[1][3]  arr[2][0] arr[2][1] arr[2][2] arr[2][3] } 声明一个二维数组 #include &amp;lt;iostream&amp;gt; int main() {  int arr[3][4] = {1,2,3,4,6,7,8,9,10,11,12};   int arr2[3][4] =  {  {1, 2, 3, 4},  {5, 6, 7, 8},  {9,10,11,12}  }; } 输出二维数组的内容 #include &amp;lt;iostream&amp;gt; int main() {  int arr[3][4] =  {  {1, 2, 3, 4},  {5, 6, 7, 8},  {9,10,11,12}  };  int i,j;  for(i = 0; i &amp;lt; 3; ++i)  {  for(j = 0; j &amp;lt; 4; ++j)  { // 负号表示将输出的内容对其， // 3表示每个元素间隔3个光标到位置  printf(&amp;#34;%-3d &amp;#34;,arr[i][j]);  }  printf(&amp;#34;\n&amp;#34;);  } } 关于多维数组 不存在多维数组，因为内存是线性的</description>
    </item>
    
    <item>
      <title>C 指针和一维数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E5%92%8C%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E5%92%8C%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</guid>
      <description>指针和一维数组 一维数组名 一维数组的名字是一个指针常量，它存放的是数组一个元素的地址。
#include &amp;lt;iostream&amp;gt; int main() {  int a[5];  // 打印一维数组 a 中，第一个元素的地址  printf(&amp;#34;%#x\n&amp;#34;,&amp;amp;a[0]);  // 打印一维数组 a 的名字  printf(&amp;#34;%#x\n&amp;#34;,a); } 下标和指针的关系 如果 p 是一个指针变量，则 p[n] 永远等价于 *（p + n）
void DeterminesArray(int *arr, int lenght) {  for(int i = 0; i &amp;lt; lenght; i++)  {  printf(&amp;#34;%d\n&amp;#34;,*(arr + i));  // *(arr + i) 等价于 arr[i]  printf(&amp;#34;%d\n&amp;#34;,arr[i]);  } } 确定一个一维数组需要哪些参数 当一个函数要处理一个或多个一维数组时，我们需要接收该数组的那些信息。也就是如何让一个函数知道我们将要处理的是一个数组，而不是其他数据类型。</description>
    </item>
    
    <item>
      <title>C 指针的运算</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97/</guid>
      <description>指针的运算 指针变量不能相加不能相乘也不能相除。 如果两个指针变量指向的是同一块连续空间中的不同存储单元（比如数组），则这两个指针变量才可以相减（表示两个元素相隔多少个元素/字节）</description>
    </item>
    
    <item>
      <title>PHP 数据类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>数据类型 在 PHP 中，指的是一个变量所存储的数据本身的类型，而不是变量的类型，即变量本身是没有数据类型的。
基本数据类型 int/integer 占 4 个字节，表示整数类型，前提是存的下，当整型存不下的时候，将会变为 double 类型。
PHP 中提供了四种整型的定义方式：十进制定义、二进制定义、八进制定义和十六进制定义。
// 十进制 $decimal = 20;  // 二进制 $Binary = 10100;  // 八进制 $Octal = 1747;  // 十六进制 $HexaDecimal = 0x3E7;  echo $decimal . &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; echo $Binary . &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; echo $Octal . &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; echo $HexaDecimal . &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; float/double 占 8 个字节，表示小数或者是整型所存不下的整数。
string 所占字节根据长度分配，表示字符串。
bool/boolean 表示 true 或 false.
复合数据类型 object 存放对象。
array 次性存放多个数据。
特殊数据类型 resource 存放资源数据，比如 PHP 外部数据（数据库、文件等）</description>
    </item>
    
    <item>
      <title>PHP 常量</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/%E5%B8%B8%E9%87%8F/</link>
      <pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/%E5%B8%B8%E9%87%8F/</guid>
      <description>常量 顾名思义，指的是不能被改变的变量。
在 PHP 中，常量有两种定义方式（5.3 之后才有两种）
定义 define() define(&amp;#39;PI&amp;#39;, 3.14); echo PI, &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; const() const PII = 18; echo PII; 定义特殊常量
define(&amp;#39;-_-&amp;#39;, &amp;#39;smile&amp;#39;); // 输出失败 // echo -_-; // 输出成功 echo constant(&amp;#39;-_-&amp;#39;); 这种特殊符号的常量无法用 一般的方式来输出，必须使用 constant() 来输出。
命名规则  常量不需要使用 $ 符号，因为一旦使用 $，系统就会认为这是变量。 常量的名字组成由字母、 数字和下划线组成，不能以数字开头。 常量的名字通常是以大写字母为主（主要是与变量以示区别）。 常量命名的规则比变量要松散， 可以使用一些特殊字符，但该方式只能使用 define 定义。  常量和变量的使用  数据可能变化的， 那么肯定是用变量。 数据不一定会变的，可以使用常量或者变量（变量居多） 数据不允许被修改的， 务必用常量。  系统常量 PHP_ VERSION：PHP 版本号。 PHP INT SIZE**：整型数据所占的字节数。 PHP_ INT_MAX：整型能表示的最大值（PHP 中整型是允许出现负数的）
系统魔术常量 在 PHP 中，还有一些特殊的系统常量，他们由 __ 开始 + 常量名 + __，这种常量称之为系统魔术常量。</description>
    </item>
    
    <item>
      <title>PHP 环境配置</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 02 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description>环境配置 下载 PHPStudy PHPStudy 是一个 windows 下的 Apache/Ngnix+PHP+MySQL 的集成开发环境
 解压运行 选择安装目录，通常时 D 盘，我这里是D:\AppInstallPath\PhpStudy  安装完成后，打开 PHPStudy，会出现以下界面：
![下载 PHPStudy](.assets/下载 PHPStudy.png)
另外，PHPStudy 会在安装目录下的 phpstudy_pro\Extensions 路径形成目录结构：
![image-20220303002959290](E:\Github\MyBlog\content\mynote\4 Specialty\Language\PHP\PHP 环境配置.assets\image-20220303002959290.png)
在这里我们只需要注意 MySql 和 php 的路径，因为之后我们会用到这两个路径来配置环境变量。
配置 MySQL 环境变量  此电脑 — 系统属性 — 高级系统设置 — 高级 — 环境变量 。 找到系统变量中名为 Path 的变量， 新建，将 MySql 目录下的 bin 文件的路径粘贴到这里，确定。 win + R 打开 cmd，输入 mysql，如果提示ERROR 2003 (HY000): Can&#39;t connect to MySQL server on &#39;localhost&#39; (10061)就说明 MySQL 的环境变量配置完成。  !</description>
    </item>
    
    <item>
      <title>C 递归</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%87%BD%E6%95%B0/%E9%80%92%E5%BD%92/</link>
      <pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%87%BD%E6%95%B0/%E9%80%92%E5%BD%92/</guid>
      <description>递归 函数自身调用自身。</description>
    </item>
    
    <item>
      <title>C 函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</guid>
      <description>函数 每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。
函数还有很多叫法，比如方法、子例程或程序，等等。
#include &amp;lt;iostream&amp;gt; // void 表示这个 max 函数没有返回值（但可以有 reture，但不能 reture 表达式） void max(int i,int j) {  if(i &amp;gt; j)  {  printf(&amp;#34;%d\n&amp;#34;,i);  }  else  {  printf(&amp;#34;%d\n&amp;#34;,j);  } }  // int 表示 main 函数返回一个整型的值 // 程序从 main 函数进入 void 表示该函数不能接收参数。 int main(void) {  int a = 1;  int b = 5;  max(a,b); } 优点  避免了重复性的操作。 有利于程序的模块化。  特点 能够接受参数，（但也可以不接收）</description>
    </item>
    
    <item>
      <title>C 数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 21 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/</guid>
      <description>数组 数组是用于储存多个相同类型数据的集合。
在 C 语言中，与数组相关的方法很少，大部分操作，都只能自己去实现，比如排序，查找等等。
#include &amp;lt;iostream&amp;gt; int main(void){ // arr 是数组的名字，5 表示数组中，元素的个数，  int arr[5] = {1,2,3,4,5};  printf(&amp;#34;%d\n&amp;#34;,arr[4]); } 在 C 语言中，一个数组的名字是这个数组第一个元素的指针地址。
特点 数组是连续的、线性的，在内存中亦是如此。
数组的数量，一旦定义，无法修改。
数组的类型取决于该数组存储的元素的类型。
优点 存取速度快。
缺点 需要一个连续的、很大的内存。
插入和删除元素的效率很低。</description>
    </item>
    
    <item>
      <title>C 指针的使用</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 19 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>指针的使用 互换两个数字 #include &amp;lt;stdio.h&amp;gt;//*p = 1 *q = 5 void interchange(int * p,int * q) { // 将 t 作为两个值的互换媒介。  int t; // t = 1  t = *p; // *p = 5  *p = *q; // *q = 1  *q = t; } // 因为 *p 和 *q 分别指向于 a 和 b，所以，修改 *p 和 *q，就相当于修改 a 和 b， // 尽管 *p 和 *q 在函数指向完毕后已经被释放，但程序依旧通过 *p 和 *q，分别修改了 a 和b。 // 而 p 和 q，两者和 a 、b，并不一样，因为 p、q 中，存放的是指向 a、b 的地址。 // 由此可得出一个结论，函数的形参和实参， 永远不是一个 int main () {  int a = 1;  int b = 5; // 取 a、b 的地址  interchange(&amp;amp;a,&amp;amp;b);  printf(&amp;#34;a = %d,b = %d&amp;#34;,a,b); } 通过被调函数修改主调函数普通变量的值 函数的实参必须为该普通变量的地址。</description>
    </item>
    
    <item>
      <title>CodeBlocks 的使用</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B1%89%E5%8C%96-codeblocks/</link>
      <pubDate>Sat, 19 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B1%89%E5%8C%96-codeblocks/</guid>
      <description>CodeBlocks 的使用 codebooks 快捷键 注释 使用Ctrl + Shift + C快速注释。
使用Ctrl + Shift + X取消注释。
汉化 CodeBlocks 将汉化文件zh_CN.mo放置到路径D:\AppInstallPath\CodeBlocks\share\CodeBlocks\locale\zh_CN（没有文件夹就自行创建）
打开 CodeBlocks，Settings — Environment — View — Internationalization(勾选)，选择Chinese(Simplified)</description>
    </item>
    
    <item>
      <title>C CPU 如何对内存条进行处理</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/cpu-%E5%A6%82%E4%BD%95%E5%AF%B9%E5%86%85%E5%AD%98%E6%9D%A1%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/cpu-%E5%A6%82%E4%BD%95%E5%AF%B9%E5%86%85%E5%AD%98%E6%9D%A1%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86/</guid>
      <description>CPU 如何对内存条进行处理 CUP 处理内存条中的数据时，需要通过控制线（只读或只写）、数据线（数据传输）和地址线（确定将要处理的是哪一个内存单元）处理内存条中的数据。
32 位系统最大支持 4G 内存。
64 位 系统最大支持 192G 内存。</description>
    </item>
    
    <item>
      <title>C 基本类型指针</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88/</guid>
      <description>基本类型指针 #include &amp;lt;stdio.h&amp;gt; int main () { 	int * p; // 定义一个指针变量 p，且这个 p 只能存放 int 类型的地址， 	int i = 20; 	p = &amp;amp;i; // &amp;amp;i 表示获取变量 i 的内存地址 //这时候 p 中，存放的就是指向变量 i 的内存地址，则 p 完全等同于 i.  	int j = * p; 	printf(&amp;#34;i = %d ,j = %d \n&amp;#34;,i,j);  	return 0; } 详解 *p #include &amp;lt;iostream&amp;gt;int main() {  int * p;  int i = 5;  p = &amp;amp;i; // p 保存了 i 的地址 // 修改 p 不会影响 i；修改 i 也不会影响 p，因为他们是不同的变量。 // *p = i，此时，修改 *p 就是修改 i，修改 i 就是修改 *p // 更准确的说，*p 是以 p 的内容为地址的变量。  *p = 99;  printf(&amp;#34;i = %d,p = %d \n&amp;#34;,i,*p);  i = 88;  printf(&amp;#34;i = %d,p = %d \n&amp;#34;,i,*p); } </description>
    </item>
    
    <item>
      <title>C 指针</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88/</guid>
      <description>指针 指针是 C 语言的灵魂。
指针是一个地址，地址是内存单元的编号，它是一个从零开始的非负整数；比如在 32 位系统中，地址的取值范围是 0 — 4 G（4095）。
指针本质就是一个操作受限的非负整数。
指针只能进行减法运算，不能进行加乘除等运算。
指针变量是存放编号的变量。
八位（Bit）是一个字节，一个字节就是一个内存单元。
int* 是 指向整型变量的指针，
作用   表示一些复杂的数据结构（树、图）。
  快速的传递数据，并且减少了内存的耗费。
  使函数返回一个以上的值。
  可以直接访问硬件。
  更方便的处理字符串（&amp;rsquo;\0&amp;rsquo;）。
  </description>
    </item>
    
    <item>
      <title>C 星号的含义</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%98%9F%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%98%9F%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/</guid>
      <description>星号的含义 </description>
    </item>
    
    <item>
      <title>C printf</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/printf/</link>
      <pubDate>Tue, 04 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/printf/</guid>
      <description>printf 用于将变量的内容输出到显示器。
直接输出 printf(&amp;#34;字符串&amp;#34;); print(&amp;ldquo;输出控制符&amp;rdquo;,参数) int i = 10;//将数值 10 的二进制代码储存到变量 i 中 。 printf(&amp;#34;%o&amp;#34;, a);//将变量 i（数值 10） 的二进制代码以八进制输出，a 为参数。 printf(&amp;ldquo;输出控制符 1 输出控制符 2&amp;rdquo;,参数 1,参数 2)  int a = 10;  int i = 15;  printf(&amp;#34;%d %d\n&amp;#34;, a, i);//控制符和参数必须一一对应。 printf(&amp;ldquo;输出控制符 非输出控制符&amp;rdquo;,参数) int a = 10;//将数值 10 的二进制代码储存到变量 i 中 。 printf(&amp;#34;%o\n&amp;#34;,a);//将变量 i（数值 10 的二进制代码以八进制输出；\n 为非输出控制符。 C 语言中的所有基本类型以及对应的输出符  int，用%d输出。 long int，用%ld输出。 shot int， char，用%c输出。 float，用%f输出，另外，%.2f表示输出的数保留两位小数。 double，用%lf输出。  </description>
    </item>
    
    <item>
      <title>C scanf</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/scanf/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/scanf/</guid>
      <description>scanf 通过键盘将数据输入到变量中。
将从键盘输入的字符转化为输入控制符所规定类型的数据，然后存入以输入参数的值为地址的变量中。
使用 scanf 之前先使用 printf 提示用户以什么样的方式输入内容。
scanf 中使用非输入控制符时，尽量使用空格，不建议使用其他的符号。
scanf(&amp;ldquo;输入控制符&amp;rdquo;,输入参数) int i; scanf(&amp;#34;%d&amp;#34;,&amp;amp;i);//i&amp;amp; 表示变量 i 的地址，&amp;amp; 是一个取地址符，也就是将输入的整数类型的值放入到变量 i 中。 printf(&amp;#34;%d\n&amp;#34;,i); scanf(&amp;ldquo;非输入控制符 输入控制符&amp;rdquo;,输入参数) int i; scanf(&amp;#34;z%d&amp;#34;,&amp;amp;i);//非输入控制符 z （z 可以是任意值）必须同输入控制符一起输入 。 printf(&amp;#34;i = %d\n&amp;#34;,i); </description>
    </item>
    
    <item>
      <title>C switch</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/switch/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/switch/</guid>
      <description>switch 它是一种选择控制语句。
switch 是选择控制语句，而不是循环控制语句，如果在 switch 中出现了 berak 语句，该语句的功
能只是退出 switch 语句并转去执行这个 switch 下面的语句。
在 switch 中，出现 continue 是错误的，除非当前 switch 在 for 或 while 之中。
当我们使用它时，它会去寻找与表达式结果所匹
的子表达式（case），并执行子表达式后面的所有
语句，直到遇到 break 停止执行。
#include &amp;lt;stdio.h&amp;gt; int main () {  char fraction ; 	printf(&amp;#34;请输入您的等级：&amp;#34;); 	scanf(&amp;#34;%c&amp;#34;, &amp;amp;fraction); 	// 测试请键入 A 	switch(fraction) { 	case &amp;#39;A&amp;#39; : 	printf(&amp;#34;很棒！\n&amp;#34; ); 	case &amp;#39;B&amp;#39; : 	printf(&amp;#34;还不错哦\n&amp;#34; ); 	case &amp;#39;C&amp;#39; : 	printf(&amp;#34;做得好\n&amp;#34; ); 	break; 	case &amp;#39;D&amp;#39; : 	printf(&amp;#34;您通过了\n&amp;#34; ); 	break; 	case &amp;#39;F&amp;#39; : 	printf(&amp;#34;最好再试一下\n&amp;#34; ); 	break; 	default : 	printf(&amp;#34;无效的成绩\n&amp;#34; ); 	} 	printf(&amp;#34;您的等级是 %c\n&amp;#34;, fraction);  	return 0;  } 当我们键入 A 时，会发现程序不仅仅执行了与主</description>
    </item>
    
    <item>
      <title>Java IO 流</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/io-%E6%B5%81/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/io-%E6%B5%81/</guid>
      <description>IO 流 import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream;  public class ShuRuShuChu {  public static void main(String[]args) throws Exception { //写入  String str=&amp;#34;写入成功！&amp;#34;;  File xieru=new File(&amp;#34;C:\\Users\\admin\\Desktop\\期末考试\\李白.txt&amp;#34;);  FileOutputStream fos=new FileOutputStream(xieru,true);  byte[] words=str.getBytes();  fos.write(words,0,words.length);  //读取  File file2 = new File(&amp;#34;C:\\Users\\admin\\Desktop\\期末考试\\李白.txt&amp;#34;);  FileInputStream fis = new FileInputStream(file2);  byte[] b = new byte[1024];  int len = fis.read(b);  while (len != -1) {  String data = new String(b);  System.</description>
    </item>
    
    <item>
      <title>Java 卖票问题</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/%E5%8D%96%E7%A5%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/%E5%8D%96%E7%A5%A8%E9%97%AE%E9%A2%98/</guid>
      <description>卖票 Ticket Class public class Ticket {  public static int chepiao = 1000;  public String name;  public String a = new String(&amp;#34;222&amp;#34;);   public Ticket(String name) {  this.name = name;  }   public void run() {  while (true) {  synchronized (a) {  if (chepiao &amp;gt; 0) {  System.out.println(this.name + &amp;#34;正在卖第&amp;#34; + (1001 - chepiao) + &amp;#34;张票&amp;#34;);  chepiao--;  } else {  break;  }  }   }  } } ThreadOne Class public class ThreadOne implements Runnable {  public static int chepiao = 1000;  public String name;  public static String aa = new String(&amp;#34;111&amp;#34;);   public ThreadOne(String name) {  this.</description>
    </item>
    
    <item>
      <title>Java 生产者消费者模式</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>生产者消费者模式 工厂类 public class Factory {  int num=0;   //库存 // 开始生产  public synchronized void addProduct() throws InterruptedException {  if(num &amp;gt;= 10){  System.out.println(&amp;#34;库存已满，不能再生产了!&amp;#34;);  //强制当前线程等待，知道其他线程在同一个对象调用notify()方法后释放  this.wait();  }else {  Thread.sleep(1000);  num++; //生产出商品  System.out.println(&amp;#34;生产者生产了一个商品，当前库存为: &amp;#34; + num);  //唤醒消费商品的线程  this.notify();  }  }  //开始消费  public synchronized void subProduct() throws InterruptedException {  if(num == 0){  System.out.println(&amp;#34;商品已经被抢光了！请等待补货...&amp;#34;);  this.</description>
    </item>
    
    <item>
      <title>Java 继承</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/%E7%BB%A7%E6%89%BF/</guid>
      <description>继承 Phone Class public class Phone extends Dianhua implements Mp3 {  public void playmusic(){  System.out.println(&amp;#34;播放音乐&amp;#34;);  }  public void call(){  System.out.println(&amp;#34;可以打电话&amp;#34;);  }  public void dh(){  System.out.println(&amp;#34;可以高得地图导航&amp;#34;);  } } Telephone Class public abstract class Telephone {  public abstract void call();  public abstract void dh(); } Mp3 Interface public interface Mp3 {  abstract void playmusic(); } Test Class public class Test {  public static void main(String[] args) {  Phone c=new Phone();  c.</description>
    </item>
    
    <item>
      <title>Css 选择器</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E9%80%89%E6%8B%A9%E5%99%A8/</link>
      <pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E9%80%89%E6%8B%A9%E5%99%A8/</guid>
      <description>选择器 ID 选择器，尽量少用，</description>
    </item>
    
    <item>
      <title>Java 字符流和字节流</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81/</guid>
      <description>字节流 package yxzi.xyz;  import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileReader;  public class Rainy {  public static void main(String[] args) throws Exception {  File file = new File(&amp;#34;C:\\Users\\admin\\Desktop\\java\\File.txt&amp;#34;); // 字节输入流  FileInputStream wj = new FileInputStream(file);  // 字节输出流  FileOutputStream outinput = new FileOutputStream(&amp;#34;C:\\Users\\admin\\Desktop\\java\\副本.txt&amp;#34;);  // 创建一个字符数组---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  byte arr[] = new byte[1024];  int len = wj.read(arr);  while (len != -1) { // String data = new String(arr); //// System.</description>
    </item>
    
    <item>
      <title>Java 遍历集合</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88/</guid>
      <description>遍历集合 package Yxzi;  import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator;  public class Test {  public static void main(String[] args) throws Exception {  ArrayList &amp;lt;Student&amp;gt; arr = new ArrayList();   Student obj1 = new Student(&amp;#34;小明&amp;#34;, 23);  Student obj2 = new Student(&amp;#34;小红&amp;#34;, 18);  Student obj3 = new Student(&amp;#34;小花&amp;#34;, 13);  Student obj4 = new Student(&amp;#34;小黑&amp;#34;, 11);  Student obj5 = new Student(&amp;#34;小白&amp;#34;, 23);   arr.add(obj1);  arr.</description>
    </item>
    
    <item>
      <title>Less &amp; 使用</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/-%E7%AC%A6%E5%8F%B7/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/-%E7%AC%A6%E5%8F%B7/</guid>
      <description>Less &amp;amp; 使用 在类前面添加了&amp;amp;之后，编译之后的 css 变为且的关系，而没有使用&amp;amp;的 css 是父子的关系
&amp;amp; 符号可以表示对父选择器的引用。 在一个内层选择器的前面，如果没有 &amp;amp; 符号，则这个内层选择器会被解析为父选择器的后代。
如果内层选择器前面有一个 &amp;amp; 符号，则内层选择器会被解析为父选择器自身或父选择器的伪类。
Less 代码 .mainbox {display: flex;min-width: 1024px;max-width: 1920px;margin: 0 auto;padding: 0.125rem 0 0.125rem 0;.column {background-color: yellowgreen;flex: 3;&amp;amp;:nth-child(2) {flex: 5;}}} 解析后的 Css 代码 .mainbox .column:nth-child(2) { 	flex: 5; } 去掉 &amp;amp; 后的 Css 代码 .mainbox .column :nth-child(2) { 	flex: 5; } </description>
    </item>
    
    <item>
      <title>Less 嵌套</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/%E5%B5%8C%E5%A5%97/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/%E5%B5%8C%E5%A5%97/</guid>
      <description>嵌套 #header { 	color: black; } #header .navigation { 	font-size: 12px; } #header .logo { 	width: 300px; } 用 less 可以这样书写：
#header {color: black;.navigation {font-size: 12px;}.logo {width: 300px;}} &amp;amp; 在选择器前面添加了 &amp;amp; ，表示与父元素是并且关系，而没有使用&amp;amp;的 css 是父子的关系。
&amp;amp; 符号可以表示对父选择器的引用。 在一个内层选择器的前面，如果没有&amp;amp;符号，则这个内层选择器会被编译为父选择器的后代。
如果内层选择器到前面有一个&amp;amp;符号，则内层选择器会被编译为父选择器自身或父选择器的伪类、伪元素等。
div {width: 100px;height: 100px;background-color: firebrick;.indiv {width: 50px;height: 50px;background-color: salmon;&amp;amp;:hover {background-color: aquamarine;}}} 被编译为：</description>
    </item>
    
    <item>
      <title>Less 混合</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/%E6%B7%B7%E5%90%88/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/%E6%B7%B7%E5%90%88/</guid>
      <description>混合 将一个包含一组属性的规则集引入到另一个规则集的方式。
普通混合 当 less 编译成 css，混合规则集也会被编译到 css 中。这会导致 css 文件过大。
// .MixColor 会被编译到 css 文件中.MixColor {width: 100px;height: 100px;background-color: #008c8c;}.wrap {width: 200px;height: 200px;background-color: firebrick;.indiv {.MixColor;}.indiv2 {.MixColor;}} 为混合规则集加上()，则混合规则集不会被编译到 css 中。
//.MixColor 会被编译到 css 文件中.MixColor() {width: 100px;height: 100px;background-color: #008c8c;}.wrap {width: 200px;height: 200px;background-color: firebrick;.indiv {.MixColor;}.</description>
    </item>
    
    <item>
      <title>JavaScrip const</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/const/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/const/</guid>
      <description>const 声明一个常量（一旦声明就无法被修改的量）。
声明时必须赋初始值，声明时使用大写。
常量无法被修改。
块级作用域。
使用const声明的对象和数组，可以修改其属性或元素，因为常量所指向的引用地址并没有改变。</description>
    </item>
    
    <item>
      <title>JavaScrip var、let、count</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/varletcount/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/varletcount/</guid>
      <description>var、let、count 使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象；
使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；
使用const声明的是常量，在后面出现的代码中不能再修改该常量的值。</description>
    </item>
    
    <item>
      <title>JavaScrip 结构赋值</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</guid>
      <description>结构赋值 结构赋值就是从数组和对象中提取自己想要的变量，然后进行赋值。
数组 将数组中的元素，依次赋给变量。
const arr = [&amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;]; let [a, b, c, d] = arr; console.log(a); console.log(b); console.log(c); console.log(d); 对象 将对象中的属性或方法依次赋给变量。
const obj = { 	name: &amp;#39;rainy&amp;#39;, 	age: 21, 	fun() { 	console.log(&amp;#39;method called&amp;#39;); 	}, };  let { name, age, fun } = obj; console.log(name); console.log(age); fun(); </description>
    </item>
    
    <item>
      <title>JavaScrip var</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/var/</link>
      <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/var/</guid>
      <description>var 变量会进行函数声明提升，即预编译处理。</description>
    </item>
    
    <item>
      <title>JavaScript arguments</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/arguments/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/arguments/</guid>
      <description>arguments 它是一个与函数的实参有映射关系的类数组。
若函数的实参和形参数量一致，那么函数的形参与函数的 argments 之间为映射关系，即形参改变后，与之映射的 arguments[x] 也会改变。
若传入的实参比形参少，多余的形参和 argments 没有映射关系。
function demo(a, b) { 	// return 20 	console.log(b); 	b = 200;  	// return 200 	console.log(b); 	arguments[1] = 2000; 	// return 2000 	console.log(b); } demo(1, 20); 属性 Callee 该属性包含当前正在执行的函数。在哪个函数中调用的方法 arguments.calle，该 calle 中就包含这个函数的函数体。
注意 arguments 对象是所有（非箭头）函数中都可用的局部变量。你可以使用 arguments 对象在函数中引用函数的实参；此对象包含传递给函数的每个实参，第一个实参的索引为 0。
arguments 对象不是一个 Array ；但它类似于 Array，但除了有 length 属性和索引的特性之外没有任何其他 Array 属性。</description>
    </item>
    
    <item>
      <title>JavaScript eval()</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/eval/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/eval/</guid>
      <description>eval() 它会将传入的字符串当做 JavaScript 代码来执行。
在 JavaScript 中，有一句话叫：
eval 是魔鬼。
console.log(eval(&amp;#39;2 + 2&amp;#39;)); </description>
    </item>
    
    <item>
      <title>JavaScript Function</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/function/function/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/function/function/</guid>
      <description>Function 每个 JavaScript 函数实际上都是一个 Function 对象。
Function 构造函数创建一个新的 Function 对象。
全局的 Function 对象没有自己的属性和方法，但是，因为它本身也是一个函数，所以它也会通过原型链从自己的原型链 Function.prototype 上继承一些属性和方法。</description>
    </item>
    
    <item>
      <title>JavaScript function</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E4%B8%BB%E8%A6%81%E8%A1%A8%E8%BE%BE%E5%BC%8F/function/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E4%B8%BB%E8%A6%81%E8%A1%A8%E8%BE%BE%E5%BC%8F/function/</guid>
      <description>function 它可以用来在一个表达式中定义一个函数。
function Fun(parameter) { 	console.log(&amp;#39;我是一个函数&amp;#39;); } </description>
    </item>
    
    <item>
      <title>JavaScript Function 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/function/function-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/function/function-%E6%96%B9%E6%B3%95/</guid>
      <description>Function 方法 call() 改变调用它的构造函数的 this 指向。并指定构造函数的采纳书
function Demo(name, age) { 	this.name = name; 	this.age = age; } var huge = new Demo(&amp;#39;Su&amp;#39;, 100); console.log(huge);  var test = {};  // 改变 Demo() 中 this 的指向为对象 test， Demo.call(test, &amp;#39;Rainy&amp;#39;, 100);  console.log(test); 实现继承 function Tyre(size, style) { 	this.size = size; 	this.style = style; }  function Interior(color, texture) { 	this.color = color; 	this.texture = texture; }  function Model(height, width, length, type) { 	this.</description>
    </item>
    
    <item>
      <title>JavaScript IIFE</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/iife/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/iife/</guid>
      <description>IIFE 立即执行函数，是一种在被定义后就会立即执行的函数，不需要被调用，执行完毕后就会被立即释放。
用于创建一个独立的作用域，主要用于初始化功能。这个作用域中的变量，外面的任何位置访问不到，用于避免变量污染和命名冲突。
它具有普通的函数一样的功能（参数、返回值、执行期上下文等）。
只有函数表达式可以被执行符 () 执行，被执行符所执行的函数表达式的函数名会被自动忽略，即该函数表达式变为了 IIFE。
多个 IIFE 之间要加分号。
var demo = (function (a, b) { 	// 用变量 demo 接收 IIFE 的返回值 	a = Number(a); 	b = Number(b); 	var c = (a + b) * 10; 	// 将变量 a 与 b 的和乘 10 的结果赋给变量 c 	return c; 	// 将变量 c 作为该 IIFE 的返回值 })(10, 20); // 10 与 20 为实参 console.log(demo); 立即释放的特性 var a = (function demo() { 	// 用变量 a 接收函数 demo，因函数 demo 执行一次后就会被释放，则会导致变量 a 的值变为 undefined 	// 因此再次调用变量 a 会返回 undefined 	console.</description>
    </item>
    
    <item>
      <title>JavaScript isNaN()</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/isnan/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/isnan/</guid>
      <description>isNaN() isNaN(value) 用于判定 value 是否为 NaN，是则返回 true，否则返回 false。
如果 value 不是 Number 类型，那么该函数会用 Number() 方法将 value 隐式转换，然后再判断转换后的结果是否为 NaN。因此，被测试的值在被强制转换成数值时会不会返回 IEEE-754 中所谓的不是数值，隐式转换调用的都是显式转换方法。
返回 false 的值  0 除以 0 NaN undefined {}（空对象）  </description>
    </item>
    
    <item>
      <title>JavaScript Math</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/math/math/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/math/math/</guid>
      <description>Math 它是一个内置对象，它拥有一些数字常数属性和数学函数方法，它不是一个函数对象。
引用圆周率的写法是 Math.PI，调用正余弦函数的写法是 Math.sin(x)，x 是要传入的参。
计算时精度不准 0.14 * 100 = 14.000000000000002；0.1 + 0.2 = 0.30000000000000004；这些运算后的值都是因为 js 计算精度不准的导致。
在 js 中整数和浮点数都属于 Number 数据类型，所有数字都是以 64 位浮点数形式储存。JavaScript 里的数字是采用 IEEE 754 标准的 64 位双精度浮点数，计算机进行计算的时候，会把数字转换为二进制，进行运算之后再转换为十进制，但是运算过程中小数部分最多支持 52 位，就会出现运算精度不准的问题。
1000000000000001 + 1000000000000001 = 2000000000000002，即在 JavaScript 中，可正常计算范围在小数点前 16 位与后 16 位。
function One() { 	for (var c = 0; c &amp;lt; 18; c++) { 	var d = Math.random().toFixed(2) * 100; 	// 首先取 0-1 的随机数，然后取这个数小数点后的两位数，最后乘 100，并赋给变量 d 	var e = Math.</description>
    </item>
    
    <item>
      <title>JavaScript new</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%B7%A6%E4%BE%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F/new/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%B7%A6%E4%BE%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F/new/</guid>
      <description>new 用于创建一个对象类型的实例或一个具有构造函数的内置对象的实例。
new 实例 创建或返回一个新的对象实例，并将构造函数的作用域赋给新的对象实例（因此构造函数中的 this 的指向就变为了这个新的对象实例）。</description>
    </item>
    
    <item>
      <title>JavaScript Number()</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/number/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/number/</guid>
      <description>Number 该对象是经过封装的能被处理数字值的对象；该对象由 Number() 构造器创建。
Number 的方法 toString() NumObj.toString(radix)
 将 NumObj 转为为 radix 进制的数，若 NumObj 无法被转换为 radix 进制的数，则返回 string 类型的 NaN；rRadix 的取值范围为 2 - 36，如果未指定 radix 参数，则默认值为 10。 当在 NumObj 中，遇到不在 radix 中的字符，则将忽略该字符以及所有后续字符，并返回在这之前已解析的整数值。 因为 Number 对象覆盖了 Object 对象上的 toString() 方法（系统将 Number 对象的 toString 方法重写了），因此它并不继承自 Object.prototype.toString()。  十进制转十六进制 var a = 1971; var b = 10; var c = 16; var d = parseInt(a, b); // 将变量 a 当做 b 进制的数，并将 b 转换为十进制的数。 var e = d.</description>
    </item>
    
    <item>
      <title>JavaScript Object</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/object/object/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/object/object/</guid>
      <description>Object 创建一个对象包装器；它的每个值都是对象的属性，且每个属性必须要有属性值，属性值的类型可以是任何数据类型。
创建方式 对象字面量 var n = &amp;#39;世雨&amp;#39;; var a = &amp;#39;&amp;#39;; var object = { 	//var obj ={} 相当于 var obj = new Object()，一般情况都使用前者。 	b: &amp;#39;臣&amp;#39;, 	// b 为属性名，臣为属性值 	c: n, }; a = object.b + object.c; // 用变量 a 接收对象 object 的属性 b 与 c 的值。 console.log(a); // 返回臣世雨 工厂模式 function ThreeOne(color) { 	this.color = color; 	// color为可选参数 	this.name = &amp;#39;bird&amp;#39;; 	this.</description>
    </item>
    
    <item>
      <title>JavaScript parseFloat()</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/parsefloat/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/parsefloat/</guid>
      <description>parseFloat() parseFloat(string)，将 string 显式转换为 number 类型浮点数（小数）。若 string 无法被转换为浮点数，则返回 number 类型的 NaN。</description>
    </item>
    
    <item>
      <title>JavaScript parselnt()</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/parselnt/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/parselnt/</guid>
      <description>parseInt() parseInt(string, radix) 函数解析一个字符串并返回指定基数的十进制整数。
将 string 看作 radix 进制的数，并将 string 显式转换为十进制且为 number 的整数（radix 为介于 2-36 之间的数，它是可选值，表示被解析字符串的基数），若 string 无法被转换为整数，则返回 number 类型的 NaN。
当在 string 中，遇到不在 radix 进制中的字符，则将忽略该字符以及所有后续字符，并返回在这之前已解析的整数值。
若 radix 为 0 时，部分浏览器（比如 IE）会报错，部分浏览器会将 0 当做 10 进行转换。
N 进制转十进制 var n = 10010; var c = 2; // 变量 n 可为 8，16，32。 var a = parseInt(n, c); // 将 n 当作 c 进制的数，并将 n 显式转换为十进制的整数。 console.log(a); </description>
    </item>
    
    <item>
      <title>JavaScript return</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/return/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/return/</guid>
      <description>return 用于终止函数的执行，并指定函数的返回值。若没有指定返回值，则返回 undefined。
字符串转数字 var n = &amp;#39;18&amp;#39;; function demo(n) { 	return +n; 	// 用加号 + 隐式调用 Number() 方法，将字符串 n 转换为数字并作为返回值 } var a = demo(n); console.log(typeof a + &amp;#39;:&amp;#39; + a); </description>
    </item>
    
    <item>
      <title>JavaScript this</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E4%B8%BB%E8%A6%81%E8%A1%A8%E8%BE%BE%E5%BC%8F/this/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E4%B8%BB%E8%A6%81%E8%A1%A8%E8%BE%BE%E5%BC%8F/this/</guid>
      <description>this 在全局中，无论是否在严格模式下，this 指的都是全局对象（window）。
通常情况，函数的调用方式决定了 this 的值；严格模式下， this 一般指向一个调用它的对象（即 this 的调用者，哪个对象的方法调用了 this，那么这个 this 就指向调用这个方法的对象 ），即第一人称我，
严格模式下可以指向任意值。</description>
    </item>
    
    <item>
      <title>JavaScript Window</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/window/window/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/window/window/</guid>
      <description>Window Window 对象表示一个包含 DOM 文档的窗口，其 document 属性指向窗口中载入的 DOM 文档 。
如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。</description>
    </item>
    
    <item>
      <title>JavaScript 作用域</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>作用域 作用域（scope）定义了代码在运行时的某些特定的变量、函数、对象的可调用范围。
每个函数都会创建 scope（作用域对象），scope 中储存是一个个的全局作用域与局部作用域），即 scope 中存储的是作用域的集合（作用域链）。
父函数不能调用子函数的变量 当调用一个变量时，调用者会去作用域链（scope）的顶端依次向下寻找这个变量；又因为子函数的 AO 中含有父函数 AO 的引用地址，所以子函数可以调用父函数的变量；反之，因为父函数的 AO 不能含有子函数 AO 的引用，所以父函数不能调用子函数的变量。
作用域都是独立的 声明多个同级函数时，这些函数的作用域链都是独立的，即每个同级函数中的局部变量不可以公用，但它们都可以使用全局中的变量；这些作用域链会随着对应函数的执行完毕而依次释放。
全局作用域 在全局作用域（GO 对象）中的变量为全局变量，全局变量的的作用域为整个脚本，这类变量在脚本中的任何地方（包括函数内部）能被调用。
它们通常指在全局中定义的变量或没有使用 var 声明的暗示全局变量。
这些变量都在全局作用域中：  函数外声明的变量。 函数中没有使用 var 声明的变量。  局部作用域 局部作用域（AO 对象）中的变量为局部变量，局部变量的作用域仅限于某个特定的函数，这类变量可以在特定的函数中调用。
每个函数内部都会创建一个局部作用域，当一个函数（父函数）中包含另一个函数（子函数），则父函数不能调用子函数的变量，但子函数可以调用父函数的变量；并且两个独立且同级的函数中的局部变量不能公用，只能各用各的局部变量。
这些变量都在局部作用域中：  它们通常指在函数中定义的变量或函数的形式参数。 函数中使用 var 声明的变量。 函数中的形式参数。  累加器 function One() { 	var b = 0; 	function Two() { 	b++; 	console.log(b); 	} 	a = Two; 	// 变量 a 是一个暗示全局变量，用变量 a 接收函数 Two } One(); //调用函数 One，使暗示全局变量 a 可以执行 a(); // 执行变量 a，相当于执行函数 Two，每执行一次变量 a，就会使 b 在原来的的结果上自增一次。 a(); a(); 作用域链 function One() { 	// 声明函数 One 时，系统会隐式创建 One.</description>
    </item>
    
    <item>
      <title>JavaScript 函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</guid>
      <description>函数 函数又叫方法，它是用来执行某些特定功能的代码；且允许我们在程序中随时进行调用。
每一个函数其实都是一个 Function 类型的对象。
函数中若没有使用 return 语句，则它默认返回 undefined；要想返回一个指定的值，则需使用 return 语句来指定一个返回值（使用 new 关键字调用一个构造函数除外）。
基本方式 直接通过 function 关键字进行声明。
function demo(a, b) { 	// 声明一个函数，demo 为函数名，a 与 b为形式参数（形参）。 	console.log(a + b); 	// 返回形参 a 与 b 的和 3。 } demo(1, 2); // 使用执行符 () 调用函数 demo，1 与 2 为实际参数（实参） var c = demo.name; // 函数 demo 的属性 name 为指定函数的（这里为 demo）名字， // 该属性的值永远等于跟在 function 关键字后面的标识符（变量名），匿名函数的属性 name 为空。 console.log(c); // 返回函数 demo 的函数名  //匿名函数方式-------------------------------------------------- var demo = function () { 	console.</description>
    </item>
    
    <item>
      <title>JavaScript 函数参数</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</guid>
      <description>函数参数 形参 指在定义函数时使用的参数，用于接收调用该函数时传入的实参。
在调用函数时，实参将赋值给形参；因而，必须使实参的个数与类型应与形参一一的对应，且传入的实参必须要有确定的值。若为给形参传入对应的实参，那么该形参默认为undefined。
实参 调用函数时传递给函数的参数，一般与实参一一对应。
变量传值 指的是将一个变量的值赋给另外一个变量。
值传递 将一个变量的值复制一份， 然后将新的值赋给另外一个变量（两个变量没有关系）。
引用传递 将一个变量的值的内存地址，传递给另外一个变量，两个变量的内存地址所指向的是同一块内存空间（两个变量所指向的都是同一个值，他们互相影响，其中一个变量被改变，另一个也会跟着被改变）。
形参默认值 定义函数的同时可以给形参赋默认值，当我们调用该函数时，若未给形参传入对应的实参，那么这个默认值会被当作该函数的实参。
形参默认值一般设置在形参末尾。
function fun(a = 1, b = 2, c = 3) { 	console.log(a, b, c); }  fun(10, 20); rest rest 中包含了没有对应形参的实参，或者说多余的实参。
rest 只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。
rest 是一个真数组，而不是一个类数组。
rest 必须放到形参末尾。</description>
    </item>
    
    <item>
      <title>JavaScript 分支与循环</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF/</guid>
      <description>分支与循环 为什么 if 语句中不能进行函数声明 因为程序执行时，程序会在本页代码之内寻找函数声明，并进行函数声明提升，而不会去查找需要条件的 if 之内的内容，
另外，可以用函数表达式定义函数？</description>
    </item>
    
    <item>
      <title>JavaScript 包装类</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%8C%85%E8%A3%85%E7%B1%BB/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%8C%85%E8%A3%85%E7%B1%BB/</guid>
      <description>包装类 在 JavaScript 中，因为原始值不能有属性和方法，所以当给原始值添加属性与方法时，系统会自动且隐式的将原始类型的数据转换为对象，然后再调用这个对象的属性和方法，调用完以后，在将其转换为原始值，这个过程叫做包装类。
因为 undefined 与 null 不能有属性，所以它们不能进行包装类。
Number 将原始类型的数值，转换为 Number 对象，它的原型是 Number.prototyp。
数字类型的对象可以进行学运算，但运算的结果，这个对象会变回原始类型的数值。
String 将原始类型的字符串，转换为 String 对象，它的原型是 String.prototyp。
当原始值字符串直接调用属性 length 时，系统会对这个原始值字符串进行包装类，使之变为对象字符串，又因为字符串对象自带属性 length，因此系统不会将这个属性 delete 删掉，所以最终将属性 length 的值返回。
Boolean 将原始类型的布尔值，转换为 boolean 对象，它的原型是 Boolean.prototyp。
注意 因为 Number、String、boolean 它们本身重写了（用一个同名不同功能的方法覆盖系统自带的方法）一个 xxx.prototype.toString 方法，所以它们不会用原型上 Object.prototype 的 toString 方法。
var a = new Number(123); var b = new String(&amp;#39;yxz&amp;#39;); var c = new Boolean(&amp;#39;true&amp;#39;); console.log(typeof a); console.log(typeof b); console.log(typeof c); // 返回三个 object 数值包装类运算 var num = new Number(123); //原始值 num 被进行包装类，因此它变成了 对象 123。 console.</description>
    </item>
    
    <item>
      <title>JavaScript 区分对象与数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%8C%BA%E5%88%86%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%8C%BA%E5%88%86%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%95%B0%E7%BB%84/</guid>
      <description>区分对象与数组 Constructor var arr = []; var obj = {}; var a = arr.constructor; console.log(a); // 返回数组。 var b = obj.constructor; console.log(b); // 返回对象。 Instanceof var arr = [];  var obj = {};  var a = arr instanceof Array; console.log(a); // 返回 true，因为变量 arr 是一个数组。 var a = arr instanceof Object; console.log(a); // 返回 true，因为变量 arr 是一个数组类对象。 var b = obj instanceof Array; console.log(b); // 返回 flase，因为变量 obj 不是一个数组。 var b = obj instanceof Object; console.</description>
    </item>
    
    <item>
      <title>JavaScript 原型</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B/</guid>
      <description>原型 原型对象，它是只有函数才拥有的隐式属性（使用 null 作为构造函数的原型的情况下，原型不能通过自定义进行添加）
通过原型对象这种机制，可以使一个对象从其他的对象那里继承一属性或方法。
prototype 显式原型属性，每一个对象都有一个 prototype，这个属性指向该对象的原型对象。
它和proto指向的都是同一个原型对象。
我们一般通过prototype去操作一个对象的原型对象。而系统调用的时候，会通过proto去调用。
__proto__  隐式原型属性，每一个对象都有一个proto，这个属性指向该对象的原型对象。 proto 的指向（值）可以修改，即一个用构造函数创建出的对象实例的原型是可以通过该属性修改的。 当调用一个对象的属性时，如果这个对象没有这个属性，那么就会到构造该对象的构造函数的原型所指向的对象（可以称之为父对象）中去寻找这个属性，如果父对象也没有这个属性，则到该父对象的构造函数的原型所指向的对象（可以称之为为爷爷对象）里去寻找这个属性，如果还没找到，则继续往上找…，直到原型链终端为 Object.prototype；Object.prototype 中有一个 null，相当于到 null 中去取值，即调用一个对象所没有的值，会返回 undefined；这种通过属性 proto 连接原型对象直到 Object.prototype（null）的一条链为原型链。 通常情况，大部分对象最终都会继承自 Object.prototype，因为 Object.create() 方法中可以将 null 放进去当做原型。 在 JavaScript 中，null 与 undefined 没有原型且不是对象。  作用 可以让一个构造函数所创建的多个对象都可以使用公用的属性和方法。
声明一个构造函数之后，该构造函数中会有一个属性 prototype，这个属性指向的就是该构造函数对应的原型对象。
原型对象中有一个属性 constructor，该属性用于指向这个对象的构造函数。
// Demo.prototype = {} 是构造函数 Demo 的原型，它默认是一个空对象（原型对象） // 当构造函数 Demo 被定义完成时，同时该函的原型对象 Demo.prototype = {} 也被定义完成； // Demo.prototype.name = &amp;#34;原型的名字&amp;#34;; // Demo.prototype.size = &amp;#34;500&amp;#34;; // Demo.prototype.height = &amp;#34;1400&amp;#34;; // Demo.</description>
    </item>
    
    <item>
      <title>JavaScript 原型链</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE/</guid>
      <description>原型链 每个实例对象（ object ）都有一个私有属性（ proto ），用于指向它的构造函数的原型对象（prototype）；该原型对象也有一个自己的私有属性（proto ），层层向上直到原型对象 Object.prototype 为 null；而 null 没有原型，它作为这个原型链的终端，它的值为 undefined。
几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。
可以使用对象的属性 proto 实现继承。</description>
    </item>
    
    <item>
      <title>JavaScript 命名空间</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</guid>
      <description>命名空间 命名空间（package），它可以帮助我们更好地整理代码，并可避免变量命名冲突。
简单地说，我们可以创建一个简单对象字面量来打包所有的相关函数和变量。这个简单对象字面量模拟了命名空间的作用。
作用 私有化变量 function Demo() { 	var healthy = 0; 	// 该变量为私有化变量，这个变量只能通过构造函数的指定方法进行调用， 	// 不能直接作为对象的属性或变量进行调用。 	this.cure = function () { 	healthy++; 	};  	this.injured = function () { 	healthy--; 	};  	this.view = function () { 	console.log(healthy); 	}; }  var demo = new Demo();  demo.view(); // 返回 0，调用构造函数的属性 view。 demo.cure(); // 调用构造函数的属性 cure。，使变量 healthy 自增 1。 demo.</description>
    </item>
    
    <item>
      <title>JavaScript 属性调用</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%B1%9E%E6%80%A7%E8%B0%83%E7%94%A8/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%B1%9E%E6%80%A7%E8%B0%83%E7%94%A8/</guid>
      <description>属性调用 通常调用属性的格式一般为 fun.arr，实际上系统会隐式将 fun.arr 变为 fun[&amp;ldquo;arr&amp;rdquo;]，因为前者调用更加灵活且简洁。
var demo = { 	wife1: { name: &amp;#39;lei&amp;#39; }, 	wife2: { name: &amp;#39;zheng&amp;#39; }, 	wife3: { name: &amp;#39;xing&amp;#39; }, 	wife4: { name: &amp;#39;zhu&amp;#39; }, 	fun: function (num) { 	var a = [&amp;#39;wife&amp;#39; + num]; 	console.log(a); 	return this[&amp;#39;wife&amp;#39; + num]; 	// 看不太懂 	}, };  demo.fun(1); demo.fun(2); demo.fun(3); demo.fun(4); </description>
    </item>
    
    <item>
      <title>JavaScript 开发原则</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</guid>
      <description>开发原则 渐进增强 不要使用 JavaScript 代码添加网页的核心内容，应该先保证核心内容脱离与 CSS 与 JavaScript 代码之外。
平稳退化 确保网页在没有 JavaScript 与 CSS 的情况下也能使用核心功能，而且渐进增强的实现必然支持平稳退化。
向后兼容 使用对象检测的方式来检测浏览器对 JavaScript 的支持程度，确保老版本的浏览器不会因为不支持某些 JavaScript 代码而报错。
性能考虑 减少访问 DOM 的和文档中标记的元素；过多的页面元素只会增大 DOM 树的规模。
将多个 JavaScript 文件合并为一个；减少加载页面时发送的请求数量。
压缩已完成的 JavaScript 脚本；将文件中的不必要的字节（空格、注释、回车符）统统删除，从而减少整体文件大小。</description>
    </item>
    
    <item>
      <title>JavaScript 数据类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>原始值和引用值 在 ECMAScript 中，数据类型有两种，即原始类型和引用类型。
原始类型 一种非对象也没有方法和属性的数据类型，也叫基本类型（基本数值或基本数据类型）。所有的原始值都是不可改变的。
Number 数值，用整数或浮点数表示，它允许任意位的小数。
String 字符串，由零个或多个字符构成，它必须被包含在双引号或双引号内。
与数组一样的是，字符串中的每个字符都有一个下标，这些下标从 0 开始。因此，它有属性 length。
Boolean 布尔，表示一个逻辑值，只有 true 或 false 两个值。
BigInt 任何精度格式的整数，是一种比 Number 数据类型支持的范围更大的整数值。用于安全地存储和操作大整数。
Symbol 符号，它是唯一的并且是不可修改的。
undefined 未定义，它只有一个值 undefined，指一个声明未描述的变量的初始值或一个变量直接赋值为 undefined，或没有实际参数的形式参数
Null 空指针，它也只有一个值 null，表示一个不存在的或无效 object 和地址引用。因为历史遗留性问题，它是的数据类型为 Object。
原始值的储存原理 a = 10; // 在栈内存第一层创建一个变量 a ，然后将数值 10 放进变量 a 中。 // 栈内存： // a ： 10 var b = a; // 在栈内存第二层创建一个变量 b，然后将变量 a 中的数值 10 拷贝到变量 b 中。 // 栈内存： // a ：10 // 拷贝变量 10 // b ：10 a = 20; // 在栈内存第三层重新创建一个变量 a，然后将数值 10 放入这个第三层的变量 a 中，之后关闭在第一层的变量 a。 // 栈内存： // a ：10（已关闭） // b ：10 // a ：20 （新的变量 a） 引用类型 引用类型都是对象，每个对象都有属性和方法。它指的是存储在堆内存中的实际对象。每一个引用变量中都存放着指针，这个指针指向其堆内存中的实际对象。</description>
    </item>
    
    <item>
      <title>JavaScript 继承方式</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</guid>
      <description>继承方式 原型链继承 缺点
会使一个对象过多继承一些没用或不需要的属性，则会导致代码的执行效率大大降低。反对反对反对法大幅度发反对发的
Grand.prototype.blue = &amp;#39;blue&amp;#39;;  function Grand() {}  var grandfather = new Grand();  Father.prototype = grandfather;  function Father() { 	this.red = &amp;#39;red&amp;#39;; 	this.money = { 	card: &amp;#39;pencil&amp;#39;, 	}; 	this.value = &amp;#39;100&amp;#39;; }  var father = new Father();  Son.prototype = father;  function Son() { 	this.orange = &amp;#39;orange&amp;#39;; } var son = new Son();  console.log(son.orange);  // 返回 son 的原型 father 上的 red。 console.</description>
    </item>
    
    <item>
      <title>JavaScript 节点</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E8%8A%82%E7%82%B9/</guid>
      <description>节点 在文档中，几乎每一样东西都是一个节点（Node），包括空格和换行符都会被解释为节点。
文档的根节点不是 html，而是 document。
分类 元素节点 文档中的元素，nodeType 的值为 1。
属性节点 文档中元素节点的属性，属性节点都被包含在元素节点中。
nodeType 的值为 2。
文本节点 文档中元素所包含的文本。 nodeType 的值为 3。
注释节点 文档中的注释。
nodeType 的值为 8.
document 节点 nodeType 的值为 9。
属性 每一个节点都有四个基本属性。
nodeValue 返回或设置指定点的值。
只用文本节点或注释节点才有 nodeValue。
而其他节点的 nodeValue 是 null 。
nodeName 返回指定节点的大写字母形式的节点名，它是一个只读属性。
nodeType 返回指定节点的类型，只读属性。
元素节点返回 1。
属性节点返回 2。
文本节点返回 3。
注释节点返回 8。
document 节点返回 9。
attributes 返回指定节点的所有属性节点。
方法 hasChildNodes() 判断一个元素是否包含子节点，返回一个布尔值。</description>
    </item>
    
    <item>
      <title>JavaScript 运算符</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>运算符 算数运算符 算术运算符都会将操作数用 Number() 隐式转换，然后再进行运算；若遇到无法转换的值，则会返回 number 类型的 NaN。
++ a++ 或 ++a，自增（递增）。使操作数加 1，并返回自增后的值。
操作数前置或后置
若位于数值的之后（a++），则会自增之前返回数值。
若位于数值的之前（++a），则会自增之后返回数值。
&amp;ndash; a&amp;ndash; 或 &amp;ndash;a， 递减（自减）。使操作数减 1，并返回自减后的值。
操作数前置或后置
若位于数值的之后（a&amp;ndash;），则会递减之前返回数值。
若位于数值的之前（&amp;ndash;a），则会递减之后返回数值。
比较运算符 JavaScript 有两种比较方式：严格比较和转换类型比较。
对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为 true。
对于比较运算符（==）来说，会先将将两个操作数转换成相同的类型，再进行值的比较运算。
对于关系运算符（ &amp;lt;=）来说，会先将操作数转为原始值，使它们类型相同，再进行值的比较运算。
字符串比较则是使用基于标准字典的 Unicode 值来进行比较的。
原始值比较的是值，引用值比较的是引用地址。
In 用于判断一个对象的指定的属性是否在该对象或其原型链中，在则 in 运算符返回 true，不在则返回 false。
Instanceof 用于判断一个对象是否是由指定构造函数构造出来的。
// 如果 mycar 不是 vue 的实例对象 if (!(mycar instanceof Car)) { 	console.log(&amp;#39;No&amp;#39;); } 也可以用于判断一个实例对象的原型链中有没有另一个变量的原型。
function Car(make, model, year) { 	this.make = make; 	this.</description>
    </item>
    
    <item>
      <title>JavaScript 链式调用</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/</guid>
      <description>链式调用 模仿一个 jQuery 链式调用的方式。
var demo = { 	a: function () { 	console.log(123); 	return this; 	// 将函数自身返回。 	},  	b: function () { 	console.log(456); 	return this; 	// 将函数自身返回。 	},  	c: function () { 	console.log(789); 	return this; 	//将函数自身返回。 	}, }; demo.a().b().c(); // 呈链式(连续)的调用对象 demo 的属性。 </description>
    </item>
    
    <item>
      <title>JavaScript 闭包</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E9%97%AD%E5%8C%85/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E9%97%AD%E5%8C%85/</guid>
      <description>闭包 在函数（父函数）中创建另一个函数（子函数）时；当子函数被父函数 return 到了外部时，会生成闭包。
生成了闭包后，虽然父函数的 AO 已经被释放了，但子函数却保存了父函数的 AO，且这个 AO 不会因为父函数的执行完毕而被释放，因为父函数的 AO 已经被子函数给保存了起来，且可以随意调用。
闭包的优缺点 优点 避免全局变量的污染。
使变量长期储存在内存中。
缺点 使用不当会导致原有的作用域链不释放，造成内存泄露（过多占用内存的剩余空间，导致可用空间越来越少）。
function demo() { 	function test() { 	var d = 345; 	console.log(c); 	// 虽然函数 test 中没有变量 c，但因为函数 test 可以使用函数 demo 的 AO， 	// 所以它会到函数 demo 的作用域中去寻找变量 c，然后返回 123 	} 	var c = 123; 	return test; 	// 将函数 test 返回，即将函数 test 与它的作用域一起保存到了外部， 	// 使的函数 demo 可以使用函数 test 的 AO } var e = demo(); // 用变量 e 接收函数 demo 的返回值，也就是接收函数 test 以及它的 AO e(); // 调用变量 e，即相当于执行函数 demo 的返回值 // 父函数 demo 执行完毕后，释放了自己的 AO，但子函数 test 在这之前已经将父函数 demo 的 AO 保存了起来， // 所以它会到函数 demo 的作用域中去寻找变量 c，然后返回 123 function demo() { 	var b = &amp;#39;apple&amp;#39;; 	var obj = { 	c: function () { 	// 给对象 obj 添加一个属性 c ，属性值为一个函数 	if (b !</description>
    </item>
    
    <item>
      <title>JavaScript 预编译</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E9%A2%84%E7%BC%96%E8%AF%91/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E9%A2%84%E7%BC%96%E8%AF%91/</guid>
      <description>预编译 JavaScript 是脚本语言，因此不会进行传统的预编译，但它会经过一个特殊的预编译过程，这个预编译过程发生在代码执行前的极短时间内。
预编译发生在代码执行之前的一瞬间，用于在内存中创建一些空间来存储一些变量与函数；预编译时，会无视 if 语句中的条件，会直接将 if 语句中的代码块内的变量的声明与函数声明进行提升。
函数声明提升 定义一个函数时，该函数会被提升到当前作用域链的顶端，即调用该函数时，不管在哪调用该函数，都可以调用成功；但函数表达式并不会。
变量声明提升 使用 var 声明的变量，不管在这之前还是之后调用该变量，并不会报错，会返回 undefined。
暗示全局变量 暗示全局变量（imply global），一个变量未声明就赋值，那么此变量就是 window（全局对象）的属性； 任何全局变量，都是 window 的属性，即可以通过 window 对象调用全局变量。window 就是全局的域，它包括了全局变量和全局函数。
暗示全局变量不会进行变量声明提升。
a = 10; // 一个变量未声明就赋值，那么此变量就是 window（全局对象）的属性，也叫暗示全局变量 // 相当于 window.a = 10; // 相当于 window = { 	a: 10, };  //一切声明了的全局变量，都是 window 的属性 var b = 20; // 相当于 window.b = 20; // 相当于 window = { 	b: 20, }; // 调用变量 b，相当于调用全局对象 window 的属性 b，即 console.</description>
    </item>
    
    <item>
      <title>Css 实现居中</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%AE%9E%E7%8E%B0%E5%B1%85%E4%B8%AD/</link>
      <pubDate>Sat, 16 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%AE%9E%E7%8E%B0%E5%B1%85%E4%B8%AD/</guid>
      <description>实现居中 绝对定位 兼容性不错的主流 css 绝对定位居中的用法：
width: 600px; height: 400px; position: absolute; left: 50%; top: 50%; margin-top: -200px; /* 高度的一半 */ margin-left: -300px; /* 宽度的一半 */ 绝对定位 transform 中 translate 偏移的百分比值是相对于自身大小的，可以这样实现 css 绝对定位居中，给子元素应用以下样式，将子元素居于父元素正中间，注意：这个方法有 bug。
position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); 弹性布局 给父元素应用以下样式，将子元素居于父元素正中间。
display: flex; flex-direction: row; justify-content: center; align-items: center; display: flex; flex-direction: column; justify-content: center; align-items: center; 文本实现垂直居中 display: flex; align-items: center; </description>
    </item>
    
    <item>
      <title>Css 盒子类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E7%9B%92%E5%AD%90%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 16 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E7%9B%92%E5%AD%90%E7%B1%BB%E5%9E%8B/</guid>
      <description>盒子类型 行盒   display 属性为 inline 的元素是行盒，也叫行级元素；如 span、strong、button、em、a、img、video、audio。
  文字一定是行盒（文字会产生匿名行盒将其包裹）。
  内部产生参考线：一个元素中包含行盒，通常会给行盒设置 vertical-align:baseline，这会导致两个元素的参考线对齐。
  同一个包含块中，连续多个行盒水平依次排列，剩余空间排列不下，才会换行。
  行盒不能包含块盒（a 元素除外）。
  设置 width 和 height 无效；调整行盒的 width 与 height 应使用字体大小、行高、字体类型等间接调整。
  产生空白合并：代码中的连续空白字符，在页面显示时，会被合并为一个空格。
  设置内外边距及边框，水平方向有效，垂直方向只会影响元素的背景，不会影响其他盒子。
  内部包含行块盒或可替换元素，行盒的高度只和文字内容的字体大小有关系，和行块盒或可替换元素无关。
  块盒  display 属性为 block 的元素，也叫块级元素；如 div、h1~h6、pre、ul、li、p。 同一个包含块中，每个块盒独占一行。 p 元素不能包含 div 元素。  行块盒  display 属性为 inline-block 的元素，也叫行块级元素；没有默认值为 inline-block 的元素。 同一个包含块中，连续的多个行块盒水平依次排列。 行块盒内部一定会产生参考线。 产生空白合并  </description>
    </item>
    
    <item>
      <title>Css 高斯模糊</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A/</link>
      <pubDate>Sat, 16 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A/</guid>
      <description>高斯模糊 backdrop-filter: blur(0.5rem); </description>
    </item>
    
    <item>
      <title>Css 字体</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%AD%97%E4%BD%93/</link>
      <pubDate>Thu, 14 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%AD%97%E4%BD%93/</guid>
      <description>字体 参考线 当制作文字时，会出现几根参考线。不同的文字类型，参考线位置、距离都不一样，同一种文字类型，参考线一致。
组成
 text_top ascent，顶线 super，上基线 baseline，基线 sub，下基线 text_bottom descent，底线  决定因素
 font-family：定义参考线的相对距离。 font-size：定义参考线之间的距离。 line-height：定义参考线的顶部空隙与底部空隙。  元素的基线 img：基线位置位于 img 的下外边距的最底边。
from：基线位于其内容的底边。
行块盒：父元素内部包含行块盒（高度自适应） ，会因为行块盒最后一行有 line-box，则会导致行块盒用最后一行的基线作为整个父元素的基线。若父元素中没有行盒，则使用父元素的下外边距作为基线。
font-size 用该属性设置字体大小时，改变的是文字的相对大小，也叫字体框大小。
制作文字时，文字外面会有一个字体框，不同的文字的字体框，大小也不一样；即设置文字的小大，本质改变的是文字的相对大小。
相对大小
若一个文字的相对大小（字体框大小）为 2048 时，那么它顶线到基线的距离为 1884，底线到基线的距离为 514，则顶线到底线的距离为 1884 + 514 = 2398。（可以拙见为一个字体的高为 2048，那么该字体占的实际区域是 2390，因此某些字体会有默认边距）
文字顶线到底线的距离，叫做文字的实际大小（content-area），也叫内容区。即行盒的背景，填充的是文字的实际大小。因此当我们给行盒设置背景时，会导致行盒上下有留白。即上部分留白 + 行盒背景 + 下部分留白 = 文字的相对大小。
line-height 用于设置多行元素的空间量。
top：文字顶线向上延申的空间。
bottom：文字底线向下延申的空间。
空隙  这两个空间（top 与 bottom）的空间量一定相等，这两个空间叫做空隙（line gap）。 通常，空隙是字体设计者决定的，因此有些字体没有空隙，但有的字体有空隙，有的字体空隙是负数。  虚拟区  top 到 botoom 的距离，叫做虚拟区（virtual-area），有的虚拟区和内容区相等，有的虚拟区比内容区小，但大部分虚拟区都比内容区大；因此设置行高大小就等于设置虚假区的大小。 因为虚拟区上下两边都相等，所以字体的实际大小在虚拟区之间。  line-box  line-box（行框）是承载文字内容的必要条件，如果没有行框，文字将无法显示。 当有多行行盒排列时，每一行的区域就叫做 line-box，line-box 的顶边是该行所有行盒的最顶边，底边是该行行盒的最低底边。即一个行盒的实际占用高度是通过 line-box 计算的。  不生成 line-box 的情况</description>
    </item>
    
    <item>
      <title>Css 文本溢出处理</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86/</link>
      <pubDate>Wed, 13 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86/</guid>
      <description>文本溢出处理 实现单行文本的溢出显示省略号可以直接用 text-overflow:ellipsis 属性来实现，当然还需要加宽度width属来兼容部分浏览。
overflow: hidden; text-overflow: ellipsis; white-space: nowrap; </description>
    </item>
    
    <item>
      <title>Css 渐变</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E6%B8%90%E5%8F%98/</link>
      <pubDate>Tue, 12 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E6%B8%90%E5%8F%98/</guid>
      <description>渐变 background-image: linear-gradient(rgb(48, 47, 47), rgb(177, 177, 175)); </description>
    </item>
    
    <item>
      <title>Css 自适应布局</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/</link>
      <pubDate>Tue, 12 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/</guid>
      <description>自适应布局 @media screen and (min-width: 720px) { 	/* 当浏览器宽度大于 value 时所应用的样式 */ }  @media screen and (max-width: value) { 	/* 当浏览器宽度小于 value 时所应用的样式*/ } </description>
    </item>
    
    <item>
      <title>Css table 空隙</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/table-%E7%A9%BA%E9%9A%99/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/table-%E7%A9%BA%E9%9A%99/</guid>
      <description>table 空隙 如果可能，边框会合并为一个单一的边框。会忽略 border-spacing 和 empty-cells 属性。
border-collapse: collapse; </description>
    </item>
    
    <item>
      <title>Css 修改网页滚动条样式</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E4%BF%AE%E6%94%B9%E7%BD%91%E9%A1%B5%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F/</link>
      <pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E4%BF%AE%E6%94%B9%E7%BD%91%E9%A1%B5%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F/</guid>
      <description>修改网页滚动条样式 属性描述 /* 整个滚动条*/ ::-webkit-scrollbar { }  /* 滚动条两端的按钮 */ ::-webkit-scrollbar-button { }  /* 滚动条的滚动轨道 */ ::-webkit-scrollbar-track { }  /* 内层轨道 */ ::-webkit-scrollbar-track-piece { }  /* 滑块 */ ::-webkit-scrollbar-thumb { }  /* 边角 */ ::-webkit-scrollbar-corner { }  /* 右下角拖动块的样式 */ ::-webkit-resizer { } 使用 一般我们这样设置这几个主要属性就 OK 了。
/*定义整个滚动条高宽及背景：高宽分别对应横竖滚动条的尺寸*/ ::-webkit-scrollbar { 	width: 10px; 	background-color: #f5f5f5; } /*定义滚动条轨道：内阴影 + 圆角*/ ::-webkit-scrollbar-track { 	background-color: #f5f5f5; } /*定义滑块：内阴影 + 圆角*/ ::-webkit-scrollbar-thumb { 	border-radius: 10px; 	background-color: #555; } 更多相关属性 :horizontal //水平方向的滚动条 :vertical //垂直 方向的滚动条 :decrement //应用于按钮和内层轨道(track piece)。它用来指示按钮或者内层轨道是否会减小视窗的位置(比如，垂直滚动条的上面，水平滚动条的左边。) :increment //decrement类似，用来指示按钮或内层轨道是否会增大视窗的位置(比如，垂直滚动条的下面和水平滚动条的右边。) :start //伪类也应用于按钮和滑块。它用来定义对象是否放到滑块的前面。 :end //类似于start伪类，标识对象是否放到滑块的后面。 :double-button //该伪类以用于按钮和内层轨道。用于判断一个按钮是不是放在滚动条同一端的一对按钮中的一个。对于内层轨道来说，它表示内层轨道是否紧靠一对按钮。 :single-button //类似于double-button伪类。对按钮来说，它用于判断一个按钮是否自己独立的在滚动条的一段。对内层轨道来说，它表示内层轨道是否紧靠一个single-button。 :no-button //用于内层轨道，表示内层轨道是否要滚动到滚动条的终端，比如，滚动条两端没有按钮的时候。 :corner-present //用于所有滚动条轨道，指示滚动条圆角是否显示。 :window-inactive //用于所有的滚动条轨道，指示应用滚动条的某个页面容器(元素)是否当前被激活。 </description>
    </item>
    
    <item>
      <title>Css Body 背景图</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/body-%E8%83%8C%E6%99%AF%E5%9B%BE/</link>
      <pubDate>Sat, 09 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/body-%E8%83%8C%E6%99%AF%E5%9B%BE/</guid>
      <description>Body 背景图 画布 它是一块区域，也叫视口（可视窗口）。
它的最小宽度为视口宽度，最小高度为视口高度。
Html 的背景图 该元素的背景覆盖画布。即给该元素设置背景，相当于设置画布的背景。
Body 的背景图 若根元素有背景，body 元素的背景正常显示。
若根元素没有设置背景，则 body 元素的背景覆盖画布，则会出现不正常的现象，原因为若没有这个规则，就无法给整个网页设置背景。
背景图覆盖画布时 高度：纵向位置百分比、预设值，相对于根元素高度。
宽度：横向位置百分比、预设值，相对于视口。</description>
    </item>
    
    <item>
      <title>Css keyframes</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/keyframes/</link>
      <pubDate>Sat, 09 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/keyframes/</guid>
      <description>Css keyframes 持续旋转 选中文档中的元素。
.map2 { 	width: 8.0375rem; 	height: 8.0375rem; 	background-image: url(../images/lbx.png); 	opacity: 0.6; 	animation: rotate 15s linear infinite; 	z-index: 2; } keyframes @keyframes rotate { 	/* 从 0° 开始旋转 */ 	from { 	transform: translate(-50%, -50%) rotate(0deg); 	} 	/* 旋转到 360 ° */ 	to { 	transform: translate(-50%, -50%) rotate(360deg); 	} } </description>
    </item>
    
    <item>
      <title>italic 和 oblique</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/italic-%E5%92%8C-oblique/</link>
      <pubDate>Sat, 09 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/italic-%E5%92%8C-oblique/</guid>
      <description>italic 和 oblique italic：浏览器会显示一个斜体的字体样式。
oblique：浏览器会显示一个倾斜的字体样式。
可以发现关键之处为斜体和倾斜。
Italic 是使用了文字本身的斜体属性，
oblique 是让没有斜体属性的文字做倾斜处理。
因为有少量的不常用字体没有斜体的属性，
如果我们使用 Italic 就会没有效果，只能 Oblique 使用才能使文字倾斜。</description>
    </item>
    
    <item>
      <title>Css 语法</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Fri, 08 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E8%AF%AD%E6%B3%95/</guid>
      <description>语法 CSS 的语法通常是一个选择器，用于选择 HTML 文档中的元素。
选择器：位于语法开始，用于选中 HTML 文档中的元素。
声明：以 { 开始，以 } 结束。{ 与 } 必须成对出现。
声明块：由属性与属性值组成。
.selector { 	color: #000; } 使用 内联式：将 CSS 语法书写到元素的 style 属性中，仅对当前元素生效，也叫行内式。
内嵌式：首先将 style 元素书写到 head 元素中，然后将 CSS 语法书写到 style 元素中，也叫内部样式表。
外链式：将 CSS 语法书写到独立的 CSS 文件中，并在 HTML 文档中使用 link 元素引入，也叫外部样式表。
优先级：内联式 &amp;gt; 内嵌式 &amp;gt; 外链式。</description>
    </item>
    
    <item>
      <title>Css 块格式化上下文</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%9D%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/</link>
      <pubDate>Thu, 07 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%9D%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/</guid>
      <description>块格式化上下文 格式化上下文（Block Formatting Context），它是一块 独立的渲染区域，它规定了在该区域中，普通流块盒的布局。
触发 BFC 的元素  根元素 html，该元素创建的 BFC 覆盖了文档中的所有元素。 浮动元素，float 的值不为 none 的元素。 绝对定位元素，position 的值为 absolute 或 fixed 的元素。 overflow 的值不为 visible 的块盒。 行块盒，display 的值为 inline-block 的元素。 表格单元格，display 的值为 table-cell 的元素，表格单元格默认为该值。 表格标题，display 的值为 table-caption 的元素，表格标题默认为该值。  正常布局流块盒的渲染区域  每个块盒都会参与块格式化上下文的创建。 不同的 BFC，它们进行渲染时互不干扰。 创建 BFC 的元素，隔绝了它内部和外部的联系，内部的渲染不会影响到外部区域。 创建 BFC 的元素，它的所有内容都会被包含在它所创建的 BFC 中  BFC 的作用 解决高度塌陷
创建 BFC 的元素，它的自动高度会计算浮动元素；若只是为了创建 BFC 一般使用副作用最小的方式：设置块盒的 overflow 的属性值为 hidden。仅仅是为了解决高度坍塌，建议使用伪元素 after。
原理：因为它要隔绝内部与外部的关系，而高度坍塌会使元素不在其包含块内，所以它的自动高度必须计算浮动元素，因此创建 BFC 可以解决高度坍塌的问题。
解决浮动流脱离文档流</description>
    </item>
    
    <item>
      <title>Css 画三角形</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/</link>
      <pubDate>Thu, 07 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/</guid>
      <description>画三角形 .triangle { 	width: 0; 	height: 0; 	border-width: 50px; 	border-style: solid; 	display: inline-block; 	border-color: transparent transparent #008c8c transparent; } </description>
    </item>
    
    <item>
      <title>Css 盒子模型</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</guid>
      <description>盒子模型 前言 在 CSS 中，每一个元素都可以看作是一个盒子，这个盒子由以下几个方面组成。目前常用的有两种盒模型，分别是标准盒模型和怪异盒模型。
一个盒子的组成  内容（content） 内边距（padding） 边框（border） 外边距（margin）  标准盒模型 box-sizing 的值为 content-box 的元素；且浏览器将采用标准模式解析。
盒子总宽度 = width + padding（左右）+ border（左右）+ margin（左右）。
盒子总高度 = height + padding（上下）+ border（上下）+ margin（上下。
怪异盒模型 box-sizing 的值为 border-box 的元素；且浏览器将采用怪异模式（兼容模式）解析，也叫 IE 盒模型。
盒子总宽度 = width + margin（左右），其 width 包含了 padding（左右）和 border（左右）的宽度。
盒子总高度 = width + margin（上下），其 height 包含了 padding（上下）和 border（上下）的高度。</description>
    </item>
    
    <item>
      <title>Css 层叠上下文</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</link>
      <pubDate>Tue, 05 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</guid>
      <description>层叠上下文 它是一块区域，它由某个元素创建，它规定了该区域中的内容在 Z 轴上排列的先后顺序。
它是一种 三维概念。所有的 HTML 元素都根据其元素的属性按照优先级顺序占据这个空间。
规则 只有定位元素设置 z-index 有效。
设置 z-index 值为负数的元素，会被正常流、浮动流覆盖。
z-index 的值，该值越大，则越靠近用户。
所有元素都处于 html 元素的层叠上下文中。
如遇到 z-index 一样的层叠上下文，则比较元素的书写顺序。
层叠上下文的元素，它本身永远被父级包含内，哪怕该元素设置了 z-index:-9999，它也只能包含于自身父元素的层叠上下文中。
每一个层叠上下文的元素，它们都完全独立于同级的元素，当处理层叠上下文时只会考虑自己的子元素。
创建层叠上下文的元素  根元素（html）。 Position 值为 absolute 或 relative 且 z-index 值不为 auto 的元素。 Opacity 的值小于 1 的元素。  优先级  同一个层叠上下文中，元素从底部到顶部的优先级 创建层叠上下文元素的背景和边框。 z-index 的值为负的层叠上下文元素。 常规流非定位元素的块盒。 非定位的浮动流。 常规流非定位行盒。 任何 z-index 属性值为 auto 的定位子元素，以及 z-index 为 0 的元素。 z-index 的值为正的元素。  </description>
    </item>
    
    <item>
      <title>Css 层叠</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%B1%82%E5%8F%A0/</link>
      <pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%B1%82%E5%8F%A0/</guid>
      <description>层叠 层叠是 CSS 的一个基本特征，浏览器通过 优先级 来判断哪些属性值对一个元素最为重要，从而在这个元素上应用这些属性值。
确定声明值 找出样式表中没有冲突的声明，并应用到 CSS 属性，样式声明不冲突则不会发生层叠。
层叠 对样式表中有冲突（同一个元素在样式表中设置了多个相同的属性）的声明使用层叠规则。
比较重要性
 重要性由高到低为 样式表中的 !imliortant 样式（尽量不使用）。 样式表中的普通样式（内联式 &amp;gt; 内嵌式 &amp;gt; 外链式）。 浏览器中的默认样式。  比较优先级
 选择器选中的范围越窄，优先级越高。 通过选择器，计算出一个四位数（xxxx），该四位数越大越则优先级越高。这个四位数的进制为逢 256 进一。 :nth-child()选择器会覆盖:hover选择器  四位数的取值
  千位：内联样式，记作 1，否则记为 0。
  百位：所有 id 选择器的数量。
  十位：所有类选择器、属性选择器、伪类选择器的数量。
  个位：元素选择器、伪元素选择器的数量。
  零：通配符选择器。
  比较源次序
CSS 样式书写靠后的属性最终会应用到元素。
继承 使用继承，对仍然没有值的属性，若可以继承（部分属性是不能继承的，通常情况下，只有跟文字内容有关的属性可以被继承。），则继承其父元素的属性。
当元素的属性有默认值时，该元素一般不会继承父元素的属性。
使用默认值 每个 CSS 在属性都会有默认值，当继承结束后，对于仍然没有值的属性，会使用默认值。</description>
    </item>
    
    <item>
      <title>C break</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/break/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/break/</guid>
      <description>break 用于终止循环或退出 switch.
不能直接用于 if，除非 if 是循环的一个子句。</description>
    </item>
    
    <item>
      <title>C 自增与自减</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E8%87%AA%E5%A2%9E%E4%B8%8E%E8%87%AA%E5%87%8F/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E8%87%AA%E5%A2%9E%E4%B8%8E%E8%87%AA%E5%87%8F/</guid>
      <description>自增与自减 前自增++i与后自增 i++.
异同 相同
最终都会使 i 的值加 1.
不同
i++返回原来的值，
++i返回加 1 后的值。
#include &amp;lt;stdio.h&amp;gt; int main() {  int a,b,c,d;  a = b = 3;  // return 3  c = a++;  // return 4  d = ++b;  printf(&amp;#34;c = %d\nd = %d&amp;#34;,c,d);  return 0; } </description>
    </item>
    
    <item>
      <title>C 预备知识</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</guid>
      <description>预备知识 六大硬件的关系 双击（操作系统给用户提供的一个操作）打开一个存放在硬盘中的视频。
因为 CPU 并不能直接处理硬盘上的数据，所以会将硬盘上的视频数据拷贝到内存中。
CPU 再对内存中的数据进行处理。
因为 CPU、内存、显卡（控制显示器的正确显示）、硬盘都是安装在主板上的，因此主板是一个组织它们如何有效运行的硬件。
程序是如何运行的 编译 —— 建立链接（生成一个格式为 exe 的可执行文件）—— 调用操作系统，操作系统再调用 CPU 并执行这个 exe 文件，最后会在显示器上看到这个软件的运行结果 。
软件不能直接控制硬件。
什么是变量 变量的本质是将一个空闲的内存空间与某个变量产生联系。
int a; //调用操作系统在内存条中创建一个空的内存空间，并将变量 a 自动分配到该内存空间中，使得变量 a 与该内存空间的地址编号产生一个一一对应的关系 a = 3; //将 3 放入变量 a 的内存空间内。  软件运行与内存的关系 一个软件在运行前需要请求操作系统将硬盘中的数据拷贝到内存中，并使用 CPU 启动该软件。
一个软件运行时，它所占的储存空间不会再分配给其他程序使用。
当软件运行完毕后，操作系统将释放该储存空间，（但操作系统并不会清空该内存空间中软件残留下来的数据，所以下次使用该内存空间时，很可能该内存空间中存在着其他软件所残留的垃圾数据。），以便再次分配给其他软件使用。
常量的表示 整数。 八进制：前面加 0 ，018。
十进制：传统写法，18。
十六进制：前面加 0x 或 0X，0x18。
浮点数。 传统写法，1.8。
科学计数法，1.8e2（1.8 * 10 的 2 次方）。
字符 单个字符用单引号括起来，&amp;lsquo;Y&amp;rsquo;。
多个字符或单个字符都可以用双引号括起来，所有的字符串都会在末尾添加 \0（结束符），&amp;ldquo;Y\0&amp;rdquo;。
常量是怎么存储在计算机中的 整数是以补码的形式转换为二进制储存在计算机中。</description>
    </item>
    
    <item>
      <title>Css 布局</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%B8%83%E5%B1%80/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%B8%83%E5%B1%80/</guid>
      <description>布局 正常流布局  默认情况下，所有元素都属于正常流。 块盒独占一行。 行盒水平依次排列。 包含块：每个盒子都有它的包含块，包含块决定了该盒子的排列范围。 在正常布局流中，元素的包含块，都是该元素父元素的内容盒。  margin 合并 多个同级且相邻的正常布局流块盒，当它们的上下margin相邻，则会合并为一个margin。
 两个外边距值都是正数，则取较大值； 两个值都是负数，则取较大值； 一正一负则取两个值的和，  该情况可以触发 BFC 解决。
margin 塌陷 正常布局流中的呈父子关系的块盒，如果父元素没有设置上下内边距或上下边框，则子元素的上下margin就会和父元素的上下margin重合，且这时如果设置子元素的上下margin，相当于设置父元素的margin。
该情况可以触发 BFC 解决。
浮动流布局  使元素向左上或向右上排列。 通常情况，浮动元素会无视正常布局元素，它会将正常布局元素覆盖。 在一行浮动元素中，若父元素装不下所有的浮动元素，则多余的浮动元素会自动向下移动，直到具备足够的空间能容纳这些多余的浮动元素，才向左或向右移动。 行盒在排列时，默认会避开浮动元素（单独的文字也是行盒，因为浏览器会自动生成一个行盒包裹单独的文字，该行盒为匿名行盒）。 浮动元素一定是块盒。 不会发生 margin 合并。 脱离正常布局流。  高度塌陷 正常布局流元素高度自适应，它的子元素浮动后，该元素在计算高度时，不会考虑浮动后的子元素的高度，则会导致该元素高度为 0，这种情况称为高度塌陷。
解决：
利用伪元素 after 清除浮动即可解决。
定位流布局 使一个元素从它原本在正常布局流中应该在的位置移动到另一个位置。
相对定位   使元素在原来位置上进行偏移；若没有设置偏移量，对元素本身没有任何影响。
  提升元素层级（z-index）。
  盒子的偏移不会对其他盒子造成任何影响。
  脱离正常布局流。
  尽管元素被偏移了，但它仍然占据着它没偏移前的空间。
  绝对定位   它相对于 static 定位以外的第一个父元素进行定位；若没有，则它的包含块为整个网页（初始化包含块），原位置不会被保留。</description>
    </item>
    
    <item>
      <title>HTML img 的常见问题</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/img-%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/img-%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</guid>
      <description>img 的常见问题 关于无法设置宽高 如果该元素的图像链接失效，则该元素的特性会与行盒一样，无法设置宽高；如果想要图像链接失效后仍具有宽高，可以将该元素设置为块盒或者行块盒。
关于图像底部的留白 当任何一个元素（例如 div）内包含行盒（例如 img）时，该 img 行盒就会在这个 div 元素的内部创建参考线，即这个 div 元素在没有设置下外边距的情况下，img 元素的基线（下外边距的底部）会与父元素的基线对齐（即留白部分就是 img 元素的下外边距），因此导致图像底部有留白。
解决方法：
 第一种是将父元素的字体大小设置为零，则父元素的内部就不会产生参考线。 第二种是将 img 元素设置为块盒，因此其父元素的内部就没有包含行盒，因此不会在其父元素内部产生参考线。  </description>
    </item>
    
    <item>
      <title>HTML 元素语义化</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/%E5%85%83%E7%B4%A0%E8%AF%AD%E4%B9%89%E5%8C%96/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/%E5%85%83%E7%B4%A0%E8%AF%AD%E4%B9%89%E5%8C%96/</guid>
      <description>元素语义化 前言 在 HTML 5 中，新增了许多元素，这些不同的元素都有不同的含义，因此语义化指的是用最合理、最恰当的元素来标记网页内容，使得机器也可以知道页面中有哪些元素，比如，文章、标题、或是段落。
语义化的优点  使文档在没有 CSS 样式的条件下，也能很好地呈现出内容结构。 使文档结构变的清晰，更具可读性，且利于后期的代码维护。 方便其他设备解析（屏幕阅读器、盲人阅读器、移动设备等）。 有利于 SEO。  </description>
    </item>
    
    <item>
      <title>htm、html、shtml 后缀的区别</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/htmhtmlshtml-%E5%90%8E%E7%BC%80%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/htmhtmlshtml-%E5%90%8E%E7%BC%80%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>htm、html、shtml 后缀的区别 首先 htm、html、shtml 都是静态网页的后缀，三者也可以说都是只是扩展名不同，其他一样，都是静态的网页。
Htm 和 html 是完全静态的网页不通过服务器编译解释直接送出给浏览器读取的静态网页，以 htm 和 html 伪静态 Request 除外。
html、htm、shtml、shtm 均是静态 html 网页，都是网页文件后缀名不同的 html 网页扩展名。
htm html 与 htm 均是静态网页后缀名，网页文件没有区别与区分，html 与 htm 后缀网页后缀可以互换，对网页完全没有影响同时也没有区别。可以认为 html 与 htm 没有本质区别，只是两者适用于不同的运行环境（DOS 和 UNIX）之下。
shtml shtml 命名的网页文件里，使用了 ssi 的一些指令，就像 asp 中的指令，你可以在 SHTML 文件中写入 SSI 指令，当客户端访问这些 shtml 文件时，服务器端会把这些 SHTML 文件进行读取和解释，把 SHTML 文件中包含的 SSI 指令解释出来。</description>
    </item>
    
    <item>
      <title>Java 基础</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/java-%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/java-%E5%9F%BA%E7%A1%80/</guid>
      <description>基础 类、对象 、属性、封装 类可以理解成对象的集合。比如 class person，定义一个人物类，这是一个抽象的概念。
对象可以理解为类中的一个元素，比如利用 person 这个人物类 new 一个“小明”，这个小明，就是一个具体的东西。
赋予这个小明一些属性，比如眼睛，鼻子，身高，这就是这个对象的属性。
赋予小明会编程、会跳舞唱歌的能力，这些就是这个对象的方法，你可以利用（调用）这些方法，让小明这个对象帮你写代码、唱首歌或跳支舞。
至于封装，我的理解是将内部的代码封装起来，然后提供一个接口供我们访问。比如电脑主机的开机键就是一个接口，我们点击开机键，就是调用这个电脑的一个接口，至于开机的内部过程或操作细节由电脑自行完成，我们无法干涉。
至于继承，还不知道。
void 的作用 void 表示一个方法中没有 return 任何数据类型，如果方法中 return 了某种数据类型，那么 void 会被替换为这种数据类型。
void Show1() {  int a = 123; }  int Show2() {  int a = 123;  return a; } public、protected、default（什么都不写）、private，表示访问控制的权限
private void Show1() {  int a = 123; }  // 相当于 default int Show2() int Show2() {  int a = 123;  return a; } </description>
    </item>
    
    <item>
      <title>Vs Code 配置 Java</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/vs-code-%E9%85%8D%E7%BD%AE-java/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/vs-code-%E9%85%8D%E7%BD%AE-java/</guid>
      <description>Vs Code 配置 Java 安装 vscode 安装 JDK 配置系统环境变量 打开系统系统环境变量配置界面   右击此电脑
  属性
  高级系统设置
  高级选项卡
  环境变量
  系统变量
  新建 JAVA_HOME 变量  变量名：JAVA_HOME。 值为：Java JDK 的安装路径。 确定  找到已存在的名为 Path 的变量  编辑 新建 输入：%JAVA_HOME%\jre\bin，确定 再新建，输入：%JAVA_HOME%\bin，确定 保存即可  新建 Classpath 变量   变量名：Classpath，
  值为：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
  测试环境配置是否成功 快捷键 Win + R，搜索 cmd 并 Enter，然后在命令行输入java以及javac.
安装 vs code 扩展 java extension pack。</description>
    </item>
    
    <item>
      <title>PHP</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/php/</link>
      <pubDate>Sat, 30 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/php/</guid>
      <description>PHP PHP 是一种运行在服务器端的脚本语言。
PHP Hyper text Pxeprosessor, php. 超文本预处理器，底层使用 C 语言。
所支持的数据库有：Sqlservex、Mysql、Oracle、Access</description>
    </item>
    
    <item>
      <title>安装 Apache</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E5%AE%89%E8%A3%85-apache/</link>
      <pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E5%AE%89%E8%A3%85-apache/</guid>
      <description>安装 Apache 官方下载地址Apache 进不去的话，就挂个 VPN，下载好后解压，我们会得到一个名为 Apache24 的文件夹，我们先将这个文件夹放到你想要放置的目录，我这里是D:\AppInstallPath\Apache24.
目录文件解析 bin 和 cgi -bin 文件夹是 windows 下的一些可执行文件。
conf 文件夹是 Apache 的配置文件目录。
error 文件夹是 Apache 的错误日志。
htdoce 文件夹是 Apache 的默认主机地址（网站的根目录文件，默认为 index）。
modules 文件夹是 Apache 的模块，Apache 的所有功能都是模块化的，你想要什么功能，就可以在配置文件中去加载对应功能的模块（so 后缀的文件）
bin 文件夹解析 ab.exe 是提供压力测试（当很多人访问你的网站时，你的网站是否能承载）的一个程序。
ApacheMonitor.exe 是管理右下角最小化的图标的。
httpd.exe 很重要。
conf 文件夹解析 httpd.conf 是主配置文件。
extra 文件夹中都是子配置文件（比如 httpd-vhosts.conf），当我们需要用这些子配置文件的时候，我们需要到主配置中文件中去加载这些子配置文件。
Httpd.exe 代表着服务器的进程，它运行之后，服务器才能运行。</description>
    </item>
    
    <item>
      <title>静态网站和动态网站</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E5%92%8C%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E5%92%8C%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99/</guid>
      <description>静态网站和动态网站 静态网站的特点  网页内容一经发布到网站服务器上，无论是否有用户访问，每个静态网页的内容都是保存在网站服务器上的,也就是说,静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件。 静态网页的内容相对稳定，因此容易被搜索引擎检索。 静态网页没有数据库的支持，在网站制作和维护方面工作量较大，因此当网站信息量很大时完全依靠静态网页制作方式比较困难。 静态网页的交互性较差，在功能方面有较大的限制，当我们要修改网页上文件时，需要将修改后的文件覆盖服务器上的源文件。  动态网站的特点  交互性强，网页会根据用户的要求和选择而动态地改变和响应，网页上的数据都是从数据库中获取的，并且用户的操作，也可以对网页上的数据进行实时的更新。 自动更新，即无须手动更新 HTmL 文档,便会自动生成新页面，可以大大节省工作量。 因时因人而变，在不同时间、不同用户访问用一个网址时，会出现不同页面。 在动态网页的网址中有一个标志性的符号“?”。  </description>
    </item>
    
    <item>
      <title>PHP 函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E5%87%BD%E6%95%B0/</guid>
      <description>函数 形参默认值 定义函数时，指定形参的默认值。这个默认值会在调用该函数且并未传入实参的时候，当作该函数的默认实参传入。
function fun($a = 1) {  echo $a; } fun(); 可变函数 将定义好的函数名赋值给一个变量，然后通过这个变量来调用。
function sysFun($fun, $num) {  $num = $num + 10;  // 函数调用  return $fun($num); }  function userFun($num) {  return $num * $num * $num * $num; } echo sysFun(&amp;#39;userFun&amp;#39;, 10); </description>
    </item>
    
    <item>
      <title>PHP 操作数据库</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>操作数据库 // 链接数据库 $link = mysqli_connect(&amp;#39;localhost&amp;#39;, &amp;#39;root&amp;#39;, &amp;#39;123456&amp;#39;, &amp;#39;my_shop&amp;#39;, &amp;#39;3306&amp;#39;); if (!$link) {  exit(&amp;#39;数据库链接失败&amp;#39;); }  // 对数据库进行一次查询 $res = mysqli_query($link, &amp;#39;select * from hr_goods&amp;#39;);  // 获取查询结果中的所有字段，每个字段都是一个数组 while ($row = mysqli_fetch_array($res)) {  echo $row[1] . &amp;#39;、&amp;#39;; }  </description>
    </item>
    
  </channel>
</rss>
