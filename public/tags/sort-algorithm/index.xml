<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Sort Algorithm on Rainy · Note</title>
    <link>https://note.yxzi.xyz/tags/sort-algorithm/</link>
    <description>Recent content in Sort Algorithm on Rainy · Note</description>
    <image>
      <url>https://note.yxzi.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://note.yxzi.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 17 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://note.yxzi.xyz/tags/sort-algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>二分查找</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
      <description>二分查找 #include &amp;lt;stdio.h&amp;gt;void main(){ 	int arr[] ={1,3,7,10,12,14,17,20,21,23}; 	int num = 50; 	int left = 0, right = 10; 	int flag = 0; 	while(left &amp;lt; right){ 	int middle = (left + right)/2; 	if(arr[middle] &amp;gt; num){ 	right = middle; 	} 	if(arr[middle] &amp;lt; num){ 	left = middle +1; 	} 	if(arr[middle] == num){ 	printf(&amp;#34;%d&amp;#34;,middle); 	flag = 1; 	break; 	} 	} 	if(flag == 0 ){ 	printf(&amp;#34;not found\n&amp;#34;); 	} } </description>
    </item>
    
    <item>
      <title>冒泡排序</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/sort/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/sort/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</guid>
      <description>冒泡排序 流程   比较相邻的两个元素，升序则交换两个数的位置，降序则位置不变。
  对每一对相邻元素作同样的操作，从开始第一对到结尾的最后一对。直到产生一个最大或者最小的数（这取决于你是升序还是降序）。升序是产生最大的数，降序是产生最小的数。
  重新开始下一轮遍历，但无需遍历上轮遍历时所产生的最大数。
  实现升序 # include &amp;lt;stdio.h&amp;gt;  // *arr 数组 // len 数组长度 void BubbleSort(int * arr, int len){   // 整体比较轮数  int i;   // 元素与元素的比较次数  int j;   // 媒介变量，用于交换两个元素的位置  int t;   // 整体比较轮数  // 需要b len-1 轮，每轮整体比较都需要进行元素与元素的比较。  for (i = 0; i &amp;lt; len-1;i ++){   // 元素与元素的比较次数  // 每进行一轮比较，都会在数组末尾产生一个最大元素。  // 下次比较时，这个最大元素将不再参与和其他元素的比较，因此，元素与元素的比较次数为 j &amp;lt; len - 1 - i。  for(j = 0;j &amp;lt; len - 1- i;j++){   // 元素与元素的比较 	// 从第一个元素 a[j] 与第二个元素 a[j+1] 开始依次比较。  if (arr[j] &amp;gt; arr[j+1]){   // 交换两个元素的位置。  t = arr[j];  arr[j] = arr[j+1];  arr[j + 1] = t;  }  }  } }  int main(void) {  int arr[] = {10,2,8,-8,11,0};  BubbleSort(arr,6);  for(int i = 0; i &amp;lt; 6;i++){  printf(&amp;#34;%d &amp;#34;,arr[i]);  }  printf(&amp;#34;\n&amp;#34;); </description>
    </item>
    
    <item>
      <title>冒泡排序</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</guid>
      <description>选择排序 流程  在未排序的元素中找到最小（或最大）元素，将其存放到该数组的起始位置， 跳过已排序数，从剩余未排序的元素中继续寻找最小（或最大）元素，放到已排序数组的末尾。 以此类推，直到所有元素均排序完毕。  实现升序 #include &amp;lt;stdio.h&amp;gt; void SelectionSort(int *arr,int len) {   // 已排序元素的末尾位置  int i;   // 未排序元素的起始位置  int j;   int k;   // 媒介变量，用于交换两个元素的位置  int t;   // 整体比较轮数  // 需要比较 len 轮  for(i = 0; i &amp;lt; len; i++)  {   // 跳过已排序的数  int k = i;   // 忽略已排序的数，直接从未排序的数开始比较，找出未排序数中的最小数  for(j = i; j &amp;lt; len; j++)  {  printf(&amp;#34;%d\n&amp;#34;,i);  if(arr[j] &amp;lt; arr[k])  {  // 将一对数中较小的数的索引赋给 k  k = j;  }  }   // 将最小的那个数移到数组最前面  t = arr[k];  arr[k] = arr[i];  arr[i] = t;  } }  int main() {  int arr[] = {5,7,1,3,8,12,2,9};  SelectionSort(arr,8);  for(int j = 0; j &amp;lt; 8; j++)  {  printf(&amp;#34;%d &amp;#34;,arr[j]);  } } </description>
    </item>
    
  </channel>
</rss>
