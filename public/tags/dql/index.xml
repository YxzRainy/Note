<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DQL on Rainy · Blog</title>
    <link>https://yxzi.xyz/Sub/Blog/tags/dql/</link>
    <description>Recent content in DQL on Rainy · Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 30 Apr 2022 06:00:00 +0000</lastBuildDate><atom:link href="https://yxzi.xyz/Sub/Blog/tags/dql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL 交叉链接</title>
      <link>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E4%BA%A4%E5%8F%89%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Sat, 30 Apr 2022 06:00:00 +0000</pubDate>
      
      <guid>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E4%BA%A4%E5%8F%89%E9%93%BE%E6%8E%A5/</guid>
      <description>交叉链接 </description>
    </item>
    
    <item>
      <title>MySQL 内链接</title>
      <link>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/sql-99/%E5%86%85%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Thu, 28 Apr 2022 06:00:00 +0000</pubDate>
      
      <guid>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/sql-99/%E5%86%85%E9%93%BE%E6%8E%A5/</guid>
      <description>内连接 该语法比 SQL 92 的链接查询语法的可读性要高。
SELECT 查询列表FROM 表一 别名 链接类型JOIN 表二 别名# SQL 92 用 WHERE，SQL99 用 ONON 链接条件WHERE </description>
    </item>
    
    <item>
      <title>MySQL 等值链接</title>
      <link>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/sql-92/%E5%86%85%E8%BF%9E%E6%8E%A5/%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Wed, 27 Apr 2022 06:00:00 +0000</pubDate>
      
      <guid>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/sql-92/%E5%86%85%E8%BF%9E%E6%8E%A5/%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</guid>
      <description>等值链接 判断不同表中都包含的字段是否相等，等于则显示，不等于则过滤。且一般都用的是等于符号来判断。
查询的是多张表的交集部分。
一般需要为表起别名。
注意 使用链接查询，很多时候容易出现Column &#39;字段名&#39; in ambiguousfield 错误，这种情况一般是因为不同的表中含有相同的字段名，导致系统无法知道我们到底要查询哪个表中的字段。这个时候只需要指定一下我们要查询的是哪个表中的字段即可。
查询女神名所对应的男神名 SELECTname,boyNameFROMbeauty,boysWHEREbeauty.boyfriend_id=boys.id;查询员工名所对应的部门名 SELECTlast_nameAS员工名,department_nameAS部门名FROMemployees,departmentsWHEREemployees.department_id=departments.department_id查询员工名、工种号、工种名 链接查询通常比较长，因此我们可以给表定义一个别名。
注意，如果我们为一些表起了别名之后，后续的语句当中如果需要用到这些表，则只能用我们定义的别名，不能用原本的表名。
#因为jobs表和employees表中都用job_id，#系统不知道我们到底要查询哪一个，#因此，这里需要指定一下我们要查询哪个表中的job_idSELECTlast_name,员工表.job_id,job_titleFROMemployeesAS员工表,jobsAS工种表WHERE员工表.job_id=工种表.job_id;查询城市名中第二个字符为o的部门和城市名 SELECTdepartment_name,cityFROMdepartmentsAS部门表,locationsAS位置表WHERE部门表.location_id=位置表.location_idAND位置表.cityLIKE&amp;#39;_o%&amp;#39;;查询每个城市的部门个数 SELECTCOUNT(*),cityFROMdepartmentsAS部门表,locationsAS位置表WHERE部门表.location_id=位置表.location_idGROUPBYcity查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资 SELECTdepartment_name,部门表.manager_id,MIN(salary)FROMdepartmentsAS部门表,employeesAS员工表WHERE部门表.department_id=员工表.department_idANDcommission_pctISNOTNULLGROUPBYdepartment_name,部门表.manager_id查询每个工种的工种名和员工的个数，并且按员工的个数降序 SELECTjob_titleAS工种名,COUNT(*)AS员工个数FROMemployeesAS员工表,jobsAS工种表WHERE员工表.job_id=工种表.job_idGROUPBY工种名ORDERBY员工个数DESC查询员工名、部门名和所在城市 SELECTlast_name,department_name,cityFROMemployeesAS员工表,departmentsAS部门表,locationsAS位置表WHERE员工表.</description>
    </item>
    
    <item>
      <title>MySQL 自链接</title>
      <link>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/sql-92/%E5%86%85%E8%BF%9E%E6%8E%A5/%E8%87%AA%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Wed, 27 Apr 2022 06:00:00 +0000</pubDate>
      
      <guid>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/sql-92/%E5%86%85%E8%BF%9E%E6%8E%A5/%E8%87%AA%E9%93%BE%E6%8E%A5/</guid>
      <description>自链接 判断同一张表中的不同字段是否相等，相等则显示，不相等则过滤。需要给同一张表取不同的别名，让系统分清同一张表中的不同字段。
查询员工名所对应的领导名称 SELECT员工表.</description>
    </item>
    
    <item>
      <title>MySQL 非等值链接</title>
      <link>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/sql-92/%E5%86%85%E8%BF%9E%E6%8E%A5/%E9%9D%9E%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Wed, 27 Apr 2022 06:00:00 +0000</pubDate>
      
      <guid>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/sql-92/%E5%86%85%E8%BF%9E%E6%8E%A5/%E9%9D%9E%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</guid>
      <description>非等值链接 新建查询并运行。
CREATETABLEjob_grades(grade_levelVARCHAR(3),lowest_salint,highest_salint);INSERTINTOjob_gradesVALUES(&amp;#39;A&amp;#39;,1000,2999);INSERTINTOjob_gradesVALUES(&amp;#39;B&amp;#39;,3000,5999);INSERTINTOjob_gradesVALUES(&amp;#39;C&amp;#39;,6000,9999);INSERTINTOjob_gradesVALUES(&amp;#39;D&amp;#39;,10000,14999);INSERTINTOjob_gradesVALUES(&amp;#39;E&amp;#39;,15000,24999);INSERTINTOjob_gradesVALUES(&amp;#39;F&amp;#39;,25000,40000);查询员工的工资和工资级别 SELECTsalary,grade_levelFROMemployeesAS员工表,job_grades工资等级表WHERE员工表.</description>
    </item>
    
    <item>
      <title>MySQL 分组查询</title>
      <link>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Mon, 25 Apr 2022 06:00:00 +0000</pubDate>
      
      <guid>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/</guid>
      <description>分组查询 通过一定的规则将一个数据集划分为若干个小组，然后对这些小组中的数据进行处理。
语法 SELECT字段名FROM表名WHERE分组前的筛选条件GROUPBY依照哪个字段进行分组ORDERBY排序列表HAVING分组后的筛选条件查询列表必须特殊，必须实分组函数和 GROUP BY后面出现的字段。
分组查询的筛选条件被分为分组前的筛选和分组后的筛选
WHERE 和 HAVING WHERE，分组之前的筛选条件，数据来源是原始表。
HAVING，分组之后的筛选条件，数据来源是经过 WHERE 筛选后的表。
用先用 WHERE 来进行筛选的，优先考虑先用 WHERE 来进行筛选。
按单个字段分组 查询每个工种的最高工资 SELECTMAX(salary),job_idFROMemployeesGROUPBYjob_id查询每个部门，邮箱中包含 a 字符的平均工资 SELECTAVG(salary),department_idFROMemployeesWHEREemailLIKE&amp;#39;%a%&amp;#39;GROUPBYdepartment_id查询每个领导手下有奖金的员工的最高工资 SELECTMAX(salary),manager_idFROMemployeesWHEREcommission_pctISNOTNULLGROUPBYmanager_id查询哪些部门的员工数 &amp;gt; 2 SELECTCOUNT(*)AS员工个数,department_idFROMemployeesGROUPBYdepartment_idHAVING员工个数&amp;gt;2;查询哪些工种编号的最高工资 &amp;gt; 12000 SELECTMAX(salary)AS最高工资,job_idFROMemployeesWHEREcommission_pctISNOTNULLGROUPBYjob_idHAVING最高工资&amp;gt;12000;查询哪些领导编号 &amp;gt;102 ，且最低工资 &amp;gt; 5000 SELECTMIN(salary)AS最低工资,manager_idFROMemployeesWHEREmanager_id&amp;gt;102GROUPBYmanager_idHAVING最低工资&amp;gt;5000;按表达式或函数分组 按员工姓的长度分组，查询每组员工个数 &amp;gt;5 的组 SELECTCOUNT(*)AS员工个数,LENGTH(last_name)AS这些员工的姓名长度FROMemployeesGROUPBYLENGTH(last_name)HAVING员工个数&amp;gt;5按多个字段分组 将GROUP BY后面的多个字段用,隔开即可。
查询每个部门和每个工种的员工的平均工资 SELECTAVG(salary)AS平均工资,department_id,job_idFROMemployeesGROUPBYdepartment_id,job_id;查询每个不为 NULL 的部门和每个工种的 &amp;gt; 10000 的平均工资，并且按平均工资的高低显示 SELECTAVG(salary)AS平均工资,department_id,job_idFROMemployeesWHEREdepartment_idISNOTNULLGROUPBYjob_id,department_idHAVING平均工资&amp;gt;10000ORDERBY平均工资DESC;</description>
    </item>
    
    <item>
      <title>MySQL 外连接</title>
      <link>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/sql-99/%E5%A4%96%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Mon, 25 Apr 2022 06:00:00 +0000</pubDate>
      
      <guid>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/sql-99/%E5%A4%96%E8%BF%9E%E6%8E%A5/</guid>
      <description>外连接 左外链接 右外链接 全外链接 </description>
    </item>
    
    <item>
      <title>MySQL 链接查询</title>
      <link>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Mon, 25 Apr 2022 06:00:00 +0000</pubDate>
      
      <guid>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/</guid>
      <description>链接查询 当需要从多张表中查询数据，而这些表之间有关联字段的时候，需要使用连接查询。
笛卡尔乘积错误 表 1 有 N 行，表 2 有 M 行，最终的查询结果就是 M * N 行。
SELECTname,boyNameFROMbeauty,boys导致的原因是因为没有添加有效的链接条件。
只需要添加有效的链接条件即可。
SELECTname,boyNameFROMbeauty,boysWHEREbeauty.boyfriend_id=boys.id;内连接 从结果表中删除与其他被连接表中没有匹配行的所有行。
SQL 92 只支持内链接。
SQL 99 支持内链接，外连接以及交叉链接。并且该版本的语法要比 SQL 92 的可读性要高。
外链接 交叉链接 </description>
    </item>
    
    <item>
      <title>MySQL 函数</title>
      <link>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 23 Apr 2022 06:00:00 +0000</pubDate>
      
      <guid>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</guid>
      <description>函数 函数之间可以嵌套
语法 SELECT函数名(实参列表,表名)单行函数 主要用于处理数据，传入一个参数，返回一个值。
 字符函数，传入的参数为字符串类型。 数学函数，传入的参数为数字类型。 日期函数，传入的参数为日期类型。 其他函数 流程控制函数，可以实现一些分支结构。  分组函数 主要用于统计数据，传入一组参数，并返回一个值，也叫统计函数、组函数、聚合函数。</description>
    </item>
    
    <item>
      <title>MySQL 模糊查询</title>
      <link>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Sat, 23 Apr 2022 06:00:00 +0000</pubDate>
      
      <guid>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</guid>
      <description>模糊查询 LIKE 查询某个字段中所有包含单个或多个字符的数据
查询员工名中第三个字符为n，第五个字符为 l 的员工名和工资 _通配符，表示匹配任意单个字符。
SELECTlast_name,salaryFROMemployeesWHERElast_nameLIKE#第三个字符为n，第五个字符为l的数据&amp;#39;__n_l%&amp;#39;;查询员工名中第二个字符为 _ 的员工名 \转义字符，表示特殊的控制意义，一般用于格式控制。
SELECTlast_name,salaryFROMemployeesWHERElast_nameLIKE&amp;#39;_\_%&amp;#39;;ESCAPE关键字可以让我们自定义转义字符。
SELECTlast_name,salaryFROMemployeesWHERElast_nameLIKE&amp;#39;_$_%&amp;#39;#自定义一个转义字符$ESCAPE&amp;#39;$&amp;#39;;查询员工名中包含字符 a 的员工信息 %通配符，表示匹配任意多个字符，且包含 0 个字符。
SELECT*FROMemployeesWHERElast_nameLIKE#%表示匹配任意内容的意思#这里的%表示匹配a字符前面和后面都有任意字符的数据&amp;#39;%a%&amp;#39;;BETWEEN AND 查询某个字段中所有在&amp;hellip;和&amp;hellip;之间的数据。
可以提高语句简洁度。
包含两个临界值。
查询员工编号在 100 - 120 之间的员工信息 方式一（推荐）
SELECT*FROMemployeesWHEREemployee_idBETWEEN100AND120;方式二
SELECT*FROMemployeesWHEREemployee_id&amp;gt;=100ANDemployee_id&amp;lt;=120;IN 查询某个字段中所有等于 in 列表中指定字符串的数据。
可以提高语句简洁的。
in 列表中的值的类型必须统一。
in 列表中的字符串不支持通配符。
查询员工的工种编号是 IT _PROG、AD_VP、AD_PRES 中的一个员工名和工种编号 方式一（推荐）
SELECTlast_name,job_idFROMemployeesWHEREjob_idin(&amp;#39;IT_PROT&amp;#39;,&amp;#39;AD_VP&amp;#39;,&amp;#39;AD_PRES&amp;#39;);方式二
SELECTlast_name,job_idFROMemployeesWHEREjob_id=&amp;#39;IT_PROT&amp;#39;ORjob_id=&amp;#39;AD_VP&amp;#39;ORjob_id=&amp;#39;AD_PRES&amp;#39;;IS NULL 查询某个字段中所有等于 Null 的数据。
因为在 MySQL 中， = 和&amp;lt;&amp;gt; 不能判断Null，也就是不能写成= Null或 &amp;lt;&amp;gt; Null，
所以只能用is Null来判断某个字段中的数据是否等于Null
查询没有奖金的员工名和奖金率 SELECTlast_name,commission_pctFROMemployeesWHEREcommission_pctISNULL# 安全等于 # commission_pct &amp;lt;=&amp;gt; NULL IS NOT NULL 查询某个字段中所有不等于 Null 的数据。</description>
    </item>
    
    <item>
      <title>MySQL 排序查询</title>
      <link>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Fri, 22 Apr 2022 06:00:00 +0000</pubDate>
      
      <guid>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/</guid>
      <description>排序查询 语法 SELECT查询列表FROM表名WHERE筛选条件ORDERBY排序列表ASCDESC升序/降序特点  ASC 代表升序，DESC 代表降序，如果不写，则默认是升序。 支持单个字段、多个字段、表达式、函数、别名等。 一般放在查询语句的最后面，limit 语句除外。  按字段排序 查询员工信息，并按工资从高至低排序 SELECT*FROMemployeesWHEREsalary# 降序 用 DESC ，升序用 ASC ORDERBYsalaryDESC;按多个字段排序 查询员工信息，并先按工资升序，再按员工编号降序 如果有两种排序规则，若第一种排序规则中有相同的数据，那么这两个数据应该哪个在前，哪个在后呢？这时候会按照第二种排序规则进行排序，决定第一种排序规则中的相同数据的先后顺序。
SELECT*,salaryAS工资,employee_idAS员工编号FROMemployeesORDERBYsalaryASC,employee_idDESC;按表达式排序 查询部门编号 &amp;gt;= 90 的员工信息，并按入职的先后顺序排序 SELECT*FROMemployeesWHEREdepartment_id&amp;gt;=90# 降序 用 DESC ，升序用 ASC ORDERBYsalaryASC;按表达式排序 SELECT*,# 因为表中没有年薪这个字段，所以我们需要用表达式来计算每个员工的年薪 salary*12*(1+IFNULL(commission_pct,0))AS年薪FROMemployeesORDERBYsalary*12*(1+IFNULL(commission_pct,0))DESC;按别名排序 查询员工的信息和年薪，并按年薪的高低排序 SELECT*,# 因为表中没有年薪这个字段，所以我们需要用表达式来计算每个员工的年薪 salary*12*(1+IFNULL(commission_pct,0))AS年薪FROMemployees# 用表达式所对应的别名来替代表达式，使得语句更好理解 ORDERBY年薪DESC;按函数排序 查询远东的姓名和工资，并按姓的字节长度从多到少排序 SELECTLENGTH(last_name)AS字节长度,last_name,salaryFROMemployeesORDERBYLENGTH(last_name)DESC; </description>
    </item>
    
    <item>
      <title>MySQL 基础查询</title>
      <link>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Wed, 06 Apr 2022 06:00:00 +0000</pubDate>
      
      <guid>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/</guid>
      <description>基础查询 我们用的是名为 MyEmployees.sql 和 Girls.sql 的 SQL 文件。
语法 select查询列表from表名特点  查询列表可以是表中的字段、常量、表达式、函数。 查询的结果是一个虚拟的表格。  查询表中的单个字段 SELECTlast_nameFROMemployees;查询表中的多个字段 会以特定的顺序显示我们查询的字段。
SELECTlast_name,first_name,emailFROMemployees;查询表中的所有字段 会以表原本的字段顺序显示我们查询的字段
SELECT*FROMemployees;区分关键字和字段名 MySQL 中，我们可以用一对着重号**``**来区 MySQL 中的分字段和关键字
SELECT`NAME`FROMrainy;查询常量 SELECT&amp;#39;john&amp;#39;;查询表达式 SELECT100*57;起别名 自定义字段名（列名），起别名可以使我们更好的理解表。
有时候，字段名可能会是一些表达式，会让输出的虚拟表达中的字段名难以理解，这时候，我们可以为其设置一个便于理解的字段名。
表达式可以用这个表达式的别名来代替该表达式 当我们为一个表达式定义了一个别名，如果后续我们需要用到这个表达式，那么我们可以不用再重复书写表达式，直接写别名即可。
SELECT*,# 因为表中没有年薪这个字段，所以我们需要用表达式来计算每个员工的年薪 salary*12*(1+IFNULL(commission_pct,0))AS年薪FROMemployees# 用表达式所对应的别名来替代表达式，使得语句更好理解 ORDERBY年薪DESC;如果要查询的字段中有重名的情况，也可以使用别名来区分。
AS 关键字 SELECT100-2AS计算结果;SELECTlast_nameAS姓,first_nameAS名FROMemployees;空格 SELECTlast_name姓,first_name名FROMemployees;去掉重复字段 查询员工表中涉及到的所有部门的编号 SELECTDISTINCTdepartment_idFROMemployees;+ 号的作用 两个操作数都为数值型，则做加法运算。
SELECT520+250;其中一方为字符型，试图将字符型数值转换成数值型。 如果转换成功，则继续做加法运算。 如果转换失败，则将字符型数值转换成 0。
SELECT&amp;#34;john&amp;#34;+90;只要其中一方为 Null，则结果肯定为 Null。</description>
    </item>
    
    <item>
      <title>MySQL 条件查询</title>
      <link>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Wed, 06 Apr 2022 06:00:00 +0000</pubDate>
      
      <guid>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</guid>
      <description>条件查询 语法 select# 3、查询 QueryListfrom# 1、寻找库中有无指定名 TableNameWHERE# 2、筛选满足条件的字段 ConditionalExpression;分类  按条件表达式查询，主要用条件运算符 按逻辑表达式查询，主要用逻辑运算符 模糊查询，主要用模糊关键字  &amp;gt; 大于。
查询工资大于 12000 的员工信息 SELECT*FROMemployeesWHEREsalary&amp;gt;12000;&amp;lt; 小于。
= 等于。
&amp;lt;&amp;gt; 不等于，也可以用 !=，但是在 MySQL 中 建议中 &amp;lt;&amp;gt;。
查询部门编号不等于 90 号的员工名和部门编号 SELECTlast_name,department_idFROMemployeesWHEREdepartment_id&amp;lt;&amp;gt;90;&amp;gt;= 大于等于。
&amp;lt;= 小于等于。</description>
    </item>
    
    <item>
      <title>MySQL 逻辑查询</title>
      <link>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E9%80%BB%E8%BE%91%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Wed, 06 Apr 2022 06:00:00 +0000</pubDate>
      
      <guid>https://yxzi.xyz/Sub/Blog/mynote/4-specialty/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E9%80%BB%E8%BE%91%E6%9F%A5%E8%AF%A2/</guid>
      <description>逻辑查询 AND 与运算符，也可以用 &amp;amp;&amp;amp;，但是在 MySQL 中，建议用 and。
当表达式都为 true 时，结果才为 true，否则结果为 false。
查询工资在 10000-20000 之间的员工名、工资以及奖金 SELECTlast_name,salary,commission_pctFROMemployeesWHEREsalary&amp;gt;=12000ANDsalary&amp;lt;=20000;OR 或运算符，但也可以用 ||，但是在 MySQL 中，建议用 or。
当表达式都为 false 时，结果才为 false，否则结果为 true。
查询部门编号不在 90 - 100 之间，或者工资高于 15000 的员工信息 SELECT*FROMemployeesWHERE#筛选部门id小于90或大于100ddepartment_id&amp;lt;90ORdepartment_id&amp;gt;110ORsalary&amp;gt;15000;NOT 非运算符，但也可以用 !，但是在 MySQL 中，建议用 not。
表达式的结果取反。
查询部门编号不在 90 - 100 之间，或者工资高于 15000 的员工信息 SELECT*FROMemployeesWHERE#筛选部门id不在90-110之间的数据NOT(department_id&amp;gt;=90ANDdepartment_id&amp;lt;=110)ORsalary&amp;gt;15000;</description>
    </item>
    
  </channel>
</rss>
