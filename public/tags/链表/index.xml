<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>链表 on Rainy · Note</title>
    <link>https://note.yxzi.xyz/tags/%E9%93%BE%E8%A1%A8/</link>
    <description>Recent content in 链表 on Rainy · Note</description>
    <image>
      <url>https://note.yxzi.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://note.yxzi.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 18 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://note.yxzi.xyz/tags/%E9%93%BE%E8%A1%A8/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C 反转</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>反转链表 // * pHead 头指针 struct ListNode* ReverseList(struct ListNode* pHead ) { 	// pHead 头结点 	// 当为空、或者 只有一个元素时直接退出  if(pHead == NULL)  return NULL;  if(pHead-&amp;gt;next == NULL)  return pHead;   //至少两个元素时  //定义两个空指针  struct ListNode *p = NULL;  struct ListNode *temp = NULL;  // p ：首结点，断开头结点指向空  p = pHead-&amp;gt;next;  pHead-&amp;gt;next = NULL;  // 首结点的下一个结点不为空  while(p-&amp;gt;next != NULL)  {  // 记录首结点的下一个结点  temp = p-&amp;gt;next;   // 头删  p-&amp;gt;next = pHead;   // 将首结点设置为头结点  pHead = p;   // 将当前节点的下一个结点  p = temp;  } 	//退出时 p 是最后一个结点 也是最终目标链表头结点   //p 指向头结点  p-&amp;gt;next = pHead; 	//p设置为头结点  pHead = p;  //返回 pHead  return pHead; } </description>
    </item>
    
    <item>
      <title>C 链表</title>
      <link>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://note.yxzi.xyz/note/technology/datastructure/algorithm/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8/</guid>
      <description>链表 链表主要是便于管理长度或数量不确定的数据，相对于数组，链表处理这种数据时比较节省内存。
链表靠节点的指针域中存放的指针地址来寻找下一个元素。
确定一个链表，只需要知道头指针即可。
优点 存取数据效率高。
不需要一个太大的内存。
缺点 查找某个位置的元素时，效率很低。
结点 链表由一个个的结点组成，每个节点左侧是数据域，右侧是指针域，数据域用来存放当前节点的有效数据，指针域用来存放下一个节点的指针地址。
链表中一个个的元素，被称之为结点，每个结点都有数据域和指针域。
首结点 链表中存放第一个有效数据的节点。
尾结点 链表中存放最后一个有效数据的节点，尾节点的指针域为 Null。
头结点 头结点的数据类型和首节点的类型一模一样。
头结点是首节点前面的那个节点。
头结点的数据域通常不存放任何有效数据，但头结点的指针域存放的是首节点的地址。
设置头结点的目的是为了方便对链表的操作。
任何一个链表都有一个头结点
空链表，指的是头结点的指针域为 Null 的链表，非空链表，指的是头结点的指针域有指向的链表。
头指针 它不是链表的节点，只是一个指针变量，用于存放头结点的指针地址。
链表实例 # include &amp;lt;stdio.h&amp;gt; # include &amp;lt;malloc.h&amp;gt; # include &amp;lt;stdlib.h&amp;gt;  // 定义一个链表 struct Node {  // 定义链表中节点的数据域  int data;  // 定义链表中节点的指针域。  // 指针域是一个 struct Node *类型的 pNext，其中 pNext 中存放的是 struct Node 变量的地址  struct Node * pNext; };  struct Node * CreateList(void); void TraverseList(struct Node *);  int main(void) {  // 定义头指针 pHead，用来存放链表的头结点的地址，  // 也就是我们可以通过 pHead 中存放中的地址，找到链表的头结点.</description>
    </item>
    
  </channel>
</rss>
